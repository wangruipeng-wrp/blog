<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Spring AOP 实现 | 知更</title><meta name="author" content="码小瑞"><meta name="copyright" content="码小瑞"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="《Spring揭秘》读书笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring AOP 实现">
<meta property="og:url" content="https://www.wrp.cool/posts/22032/index.html">
<meta property="og:site_name" content="知更">
<meta property="og:description" content="《Spring揭秘》读书笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/index_img.jpg">
<meta property="article:published_time" content="2022-12-04T03:46:38.000Z">
<meta property="article:modified_time" content="2022-12-09T16:54:35.450Z">
<meta property="article:author" content="码小瑞">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/index_img.jpg"><link rel="shortcut icon" href="/images/avatar.png"><link rel="canonical" href="https://www.wrp.cool/posts/22032/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 码小瑞","link":"链接: ","source":"来源: 知更","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring AOP 实现',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-10 00:54:35'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="知更" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-map-marker-alt"></i><span> 这里</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-user"></i><span> 我说我呀</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-book"></i><span> 喜欢看书</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 喜欢电影</span></a></li><li><a class="site-page child" href="/love/"><i class="fa-fw fa fa-heart red"></i><span> 还喜欢你</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-link"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">知更</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-map-marker-alt"></i><span> 这里</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-user"></i><span> 我说我呀</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-book"></i><span> 喜欢看书</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 喜欢电影</span></a></li><li><a class="site-page child" href="/love/"><i class="fa-fw fa fa-heart red"></i><span> 还喜欢你</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-link"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Spring AOP 实现</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-04T03:46:38.000Z" title="发表于 2022-12-04 11:46:38">2022-12-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-09T16:54:35.450Z" title="更新于 2022-12-10 00:54:35">2022-12-10</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>32分钟</span></span></div></div></div><article class="post-content" id="article-container"><h1 id="Joinpoint"><a href="#Joinpoint" class="headerlink" title="Joinpoint"></a>Joinpoint</h1><p>Spring AOP 中，仅支持方法执行类型的 Joinpoint。也就是仅能在方法内部执行开始时点进行横切逻辑织入。</p>
<h1 id="Pointcut"><a href="#Pointcut" class="headerlink" title="Pointcut"></a>Pointcut</h1><p>Spring 中以接口定义 <code>org,springframework.aop.Pintcut</code> 作为其 AOP 框架中所有 Pointcut 的最顶层抽象，该接口定义了两个方法用来帮助捕捉系统中的相应 Joinpoint，并提供了一个 TruePointcut 类型实例。如果 Pointcut 类型为 TruePointcut ，默认会对系统中的所有对象，以及对象上所有被支持的 Joinpoint 进行匹配。<code>org.springframeworkaop.Pointcut</code> 接口定义如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Pointcut</span> &#123;</span><br><span class="line">    ClassFilter <span class="title function_">getClassFilter</span><span class="params">()</span>;</span><br><span class="line">    MethodMatcher <span class="title function_">getMethodMatcher</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">Pointcut</span> <span class="variable">TRUE</span> <span class="operator">=</span> TruePointcut.INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ClassFilter"><a href="#ClassFilter" class="headerlink" title="ClassFilter"></a>ClassFilter</h2><p>ClassFilter 和 MethodMatcher 分别用于匹配将被执行织入操作的对象以及相应的方法。ClassFilter 接口的作用是对 Joinpoint 所处的对象进行 Class 级别的类型匹配，其定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ClassFilter</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(Class clazz)</span>;</span><br><span class="line">    <span class="type">ClassFilter</span> <span class="variable">TRUE</span> <span class="operator">=</span> TrueClassFilter.INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当织入的目标对象的 Class 类型与 Pointcut 所规定的类型相符时，matches 方法将会返回 true，否则，返回 false，即意味着不会对这个类型的目标对象进行织入操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果希望对系统中 Foo 类型的类进行织入，则可以这么来定义 ClassFilter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FooClassFilter</span> <span class="keyword">implements</span> <span class="title class_">ClassFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(Class&lt;?&gt; cl)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Foo.class.equals(cl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，如果类型对我们所捕获的 Joinpoint 无所谓，那么 Pointcut 中使用的 ClassFilter 可以直接返回 <code>TrueClassFilter.INSTANCE</code>。当 Pointcut 中返回的 ClassFilter 类型为该类型实例时，Pointcut 的匹配将会针对系统中所有的目标类以及它们的实例进行。</p>
<h2 id="MethodMatcher"><a href="#MethodMatcher" class="headerlink" title="MethodMatcher"></a>MethodMatcher</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MethodMatcher</span> &#123;</span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span>;</span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">isRuntime</span><span class="params">()</span>;</span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass, Object... args)</span>;</span><br><span class="line">	<span class="type">MethodMatcher</span> <span class="variable">TRUE</span> <span class="operator">=</span> TrueMethodMatcher.INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MethodMatcher 定义了两个 matches 方法，这两个方法的分界线就是 isRuntime 方法。在对对象具体方法进行拦截的时候，可以忽略每次方法执行的时候调用者传入的参数，也可以每次都检查这些方法调用参数，以强化拦截条件。</p>
<ul>
<li><strong>isRuntime()：</strong></li>
<li><strong>返回 false：</strong>表示不会考虑具体 Joinpoint 的方法参数，这种类型的 MethodMatcher 称为 <code>StaticMethodMatcher</code>。因为不用每次都检查参数，所以只有 <code>boolean matches(Method method, Class&lt;?&gt; targetClass);</code> 会被执行，那么对于同样类型的方法匹配结果，就可以在框架内部缓存以提高性能。</li>
<li><strong>返回 true：</strong>表示该 MethodMatcher 将会每次都对方法调用的参数进行匹配检查，这种类型的 MethodMatcher 称之为 <code>DynamicMethodMatcher</code>，匹配效率相对于 <code>StaticMethodMatcher</code> 来说要差一些，最好避免使用。当 isRuntime 返回 true 后，并且当 <code>boolean matches(Method method, Class&lt;?&gt; targetClass);</code> 方法也返回 true 的时候，三个参数的 matches 方法才会被执行，以进一步检查匹配条件。如果两个参数的 matches 方法返回 false，那么不管 isRuntime 方法返回 true 还是 false，都不会执行三个参数 matches 方法。</li>
</ul>
<p>各个 Pointcut 类型之间的关系图：</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/Pointcut%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="Pointcut类型之间的关系图"></p>
<h3 id="NameMatchMethodPointcut"><a href="#NameMatchMethodPointcut" class="headerlink" title="NameMatchMethodPointcut"></a>NameMatchMethodPointcut</h3><p>这是最简单的 Pointcut 实现，可以根据自身指定的一组方法名称与 Joinpoint 处的方法名称进行匹配。除了可以指定方法名，还可以使用 “*” 通配符，实现简单的模糊匹配。</p>
<p>但是，NameMatchMethodPointcut 无法对重载的方法名进行匹配，因为它仅对方法名进行匹配，不会考虑参数相关信息，而且也没有提供可以指定参数匹配信息的途径。</p>
<h3 id="JdkRegexpMethodPointcut和Perl5RegexpMethodPointcut"><a href="#JdkRegexpMethodPointcut和Perl5RegexpMethodPointcut" class="headerlink" title="JdkRegexpMethodPointcut和Perl5RegexpMethodPointcut"></a>JdkRegexpMethodPointcut和Perl5RegexpMethodPointcut</h3><p>通过正则表达式匹配方法名。</p>
<h3 id="AnnotationMatchingPointcut"><a href="#AnnotationMatchingPointcut" class="headerlink" title="AnnotationMatchingPointcut"></a>AnnotationMatchingPointcut</h3><p>根据目标对象中是否存在指定类型的注解来匹配 Joinpoint，要使用该类型的 Pointcut，首先需要生命相应的注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类级别的注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ClassLevelAnnotation &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法级别的注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MethodLevelAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用起来像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AnnotationMatchingPointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationMatchingPointcut</span>(ClassLevelAnnotation.class, MethodLevelAnnotation.class);</span><br></pre></td></tr></table></figure>

<h3 id="ComposablePointcut"><a href="#ComposablePointcut" class="headerlink" title="ComposablePointcut"></a>ComposablePointcut</h3><p>Pointcut 通常还提供逻辑运算功能，而 ComposablePointcut 就是 Spring AOP 提供的可以进行 Pointcut 逻辑运算的 Pointcut 实现。像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ComposablePointcut</span> <span class="variable">pointcut1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComposablePointcut</span>(classFilterl,methodMatcher1);</span><br><span class="line"><span class="type">ComposablePointcut</span> <span class="variable">pointcut2</span> <span class="operator">=</span> ...</span><br><span class="line"></span><br><span class="line">ComposablePointcut unitedPoincut= pointcutl.union(pointcut2);</span><br><span class="line"><span class="type">ComposablePointcut</span> <span class="variable">intersectionPointcut</span> <span class="operator">=</span> pointcutl,intersection(unitedPoincut);</span><br><span class="line"></span><br><span class="line">assertEquals(pointcutl,intersectionPointcut);</span><br></pre></td></tr></table></figure>

<p>也能通过 <code>org.springframework.aop.support.Pointcuts</code> 工具类来实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pointcut</span> <span class="variable">pointcut1</span> <span class="operator">=</span> ...</span><br><span class="line"><span class="type">Pointcut</span> <span class="variable">pointcut2</span> <span class="operator">=</span> ...</span><br><span class="line"></span><br><span class="line"><span class="type">Pointcut</span> <span class="variable">unitedPoincut</span>          <span class="operator">=</span> Pointcuts.union(pointcut1,pointcut2);</span><br><span class="line"><span class="type">Pointcut</span> <span class="variable">intersectionPointcut</span>   <span class="operator">=</span> Pointcuts.intersection(pointcutl,pointcut2);</span><br></pre></td></tr></table></figure>

<h3 id="ControlFlowPointcut"><a href="#ControlFlowPointcut" class="headerlink" title="ControlFlowPointcut"></a>ControlFlowPointcut</h3><p>ControlFlowPointcut 匹配程序的调用流程，不是对某个方法执行所在的 Joinpoint 处的单一特征进行匹配。</p>
<p>假设我们所拦截的目标对象如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TargetObject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的调用类是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TargetCaller</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TargetObject target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        target.method1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTarget</span><span class="params">(TargetObject target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用之前的任何 Pointcut 实现，我们只能指定在 Targetobject 的 method1 方法每次执行的时候，都织入相应横切逻辑。也就是说，一旦通过 Pointcut 指定 method1 处为 Joinpoint，那么对该方法的执行进行拦截是必定的，不管 method1 是被谁调用。而通过 controlFlowPointcut，我们可以指定，只有当 Targetobject 的 method1 方法在 TargetCaller 类所声明的方法中被调用的时候，才对 method1 方法进行拦截，其他地方调用 method1 的话，不对 method1 进行拦截。</p>
<p>ControlFlowPointcut 使用起来大概像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ControlFlowPointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ControlFlowPointcut</span>(TargetCaller.class);</span><br><span class="line"><span class="type">Advice</span> <span class="variable">advice</span> <span class="operator">=</span> ... ;</span><br><span class="line"></span><br><span class="line"><span class="type">TargetObject</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TargetObject</span>();</span><br><span class="line"><span class="type">TargetObject</span> <span class="variable">targetProxy</span> <span class="operator">=</span> weaver.weave(advice).to(target).accordingto(pointcut);</span><br><span class="line"></span><br><span class="line"><span class="comment">// advice 的逻辑在这里不会被触发执行</span></span><br><span class="line">targetProxy.method1();</span><br><span class="line"></span><br><span class="line"><span class="comment">// advice 的逻辑在这里不会被触发执行</span></span><br><span class="line"><span class="comment">// 因为 TargetCaller 的 callMethod() 将调用 method1()</span></span><br><span class="line"><span class="comment">// 正像 ControlFlowPointcut(TargetCaller.class) 所指定的那样</span></span><br><span class="line"><span class="type">TargetCaller</span> <span class="variable">caller</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TargetCaller</span>();</span><br><span class="line">caller.setTarget(targetProxy);</span><br><span class="line">caller.callMethod();</span><br></pre></td></tr></table></figure>

<p>当织入器按照 Pointcut 的规定，将 Advice 织入到目标对象之后，从任何其他地方调用 method1，是不会触发 Advice 所包含的横切逻辑执行的。只有在 ControlFlowPointcut 规定的类内部调用目标对象的 method1，才会触发 Advice 中横切逻辑的执行。</p>
<blockquote>
<p><strong>注意：</strong>示例代码中 weaver 是虚构概念，不是 Spring 织入器的实现。</p>
</blockquote>
<p>如果在 ControlFlowPointcut 的构造方法中单独指定 Class 类型的参数，那么 ControlFlowPointcut 将尝试匹配指定的 Class 中声明的所有方法，跟目标对象的 Joinpoint 处的方法流程组合。如果还想指定调用类的某个具体方法，可以在构造 ControlFlowPointcut 的时候，传入第二个参数，即调用方法的名称：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ControlFlowPointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ControlFlowPointcut</span>(TargetCaller.class, <span class="string">&quot;callMethod&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="自定义-StaticMethodMatcherPointcut"><a href="#自定义-StaticMethodMatcherPointcut" class="headerlink" title="自定义 StaticMethodMatcherPointcut"></a>自定义 StaticMethodMatcherPointcut</h3><blockquote>
<p>继承抽象类 StaticMethodMatcher 即可。</p>
</blockquote>
<p>StaticMethodMatcher 根据自身语意，为其子类提供了如下几个方面的默认实现。</p>
<ul>
<li>默认所有 StaticMethodMatcher 的子类的 ClassFilter 均为 <code>ClassFilter.TRUE</code> 即忽略类的类型匹配。如果具体子类需要对目标对象的类型做进一步限制，可以通过 <code>public void setclassFilter(ClassFilter classFilter)</code> 方法设置相应的 ClassFilter 实现。</li>
<li>因为是 staticMethodMatcher，所以，其 MethodMatcher 的 isRuntime 方法返回 false，同时三个参数的 matches 方法抛出 <code>UnsupportedOperationException</code> 异常，以表示该方法不应该被调用到。</li>
</ul>
<p>最终我们需要做的就是实现两个参数的 matches 方法了</p>
<h3 id="自定义-DynamicMethodMatcherPointcut"><a href="#自定义-DynamicMethodMatcherPointcut" class="headerlink" title="自定义 DynamicMethodMatcherPointcut"></a>自定义 DynamicMethodMatcherPointcut</h3><blockquote>
<p>继承抽象类 DynamicMethodMatcher 即可。</p>
</blockquote>
<p>DynamicMethodMatcherPointcut 也为其子类提供了部分便利。</p>
<ul>
<li>getclassFilter() 方法返回 <code>ClassFilter.TRUE</code>，如果需要对特定的目标对象类型进行限定子类只要覆写这个方法即可。</li>
<li>对应的 MethodMatcher 的 isRuntime 总是返回 true，同时，StaticMethodMatcherPointcut 提供了两个参数的 matches 方法的实现，默认直接返回 true。</li>
</ul>
<p>要实现自定义 DynamicMethodMatcherPointcut，通常情况下，我们只需要实现三个参数的 matches 方法逻辑即可。但如果愿意，我们也可以覆写一下两个参数的 matches 方法，这样，不用每次都得到三个参数的 matches 方法执行的时候才检查所有的条件。</p>
<h1 id="Advice"><a href="#Advice" class="headerlink" title="Advice"></a>Advice</h1><p>Spring AOP 加入了开源组织 AOP Alliance，目的在于标准化 AOP 的使用，促进各个 AOP 实现产品之间的可交互性。鉴于此，Spring 中的 Advice 实现全部遵循 AOP Alliance 规定的接口。Spring 中各种 Advice 类型实现与 AOP Alliance 中标准接口之间的关系像这样：</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/Spring%E4%B8%AD%E7%9A%84Advice%E7%95%A5%E5%9B%BE.png" alt="Spring中的Advice略图"></p>
<p>Advice 实现了将被织入到 Pointcut 规定的 Joinpoint 处的横切逻辑。在 Spring 中，Advice 按照其自身实例能否在目标对象类的所有实例中共享这一标准，可以划分为两大类，即 <code>per-class</code> 类型的 Advice 和 <code>per-instance</code> 类型的 Advice。</p>
<h2 id="per-class-类型的-Advice"><a href="#per-class-类型的-Advice" class="headerlink" title="per-class 类型的 Advice"></a>per-class 类型的 Advice</h2><p>该类型的 Advice 实例可以在目标对象类的所有实例之间共享。这种类型的 Advice 通常只是提供方法拦截的功能，不会为目标对象类保存任何状态或者添加新的属性。</p>
<h3 id="BeforeAdvice"><a href="#BeforeAdvice" class="headerlink" title="BeforeAdvice"></a>BeforeAdvice</h3><p>Before Advice 所实现的横切逻辑将在相应的 Joinpoint 之前执行，在 Before Advice 执行完成之后程序执行流程将从 Joinpoint 处继续执行，所以 Before Advice 通常不会打断程序的执行流程。但是如果必要，也可以通过抛出相应异常的形式中断程序流程。</p>
<p>要在 Spring 中实现 Before Advice，通常只需要实现 <code>org.springframework.aop.MethodBeforeAdvice</code> 接口即可，该接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MethodBeforeAdvice</span> <span class="keyword">extends</span> <span class="title class_">BeforeAdvice</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(Method method, Object[] args, <span class="meta">@Nullable</span> Object target)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ThrowsAdvice"><a href="#ThrowsAdvice" class="headerlink" title="ThrowsAdvice"></a>ThrowsAdvice</h3><p>Throws Advice 的接口定义在 <code>org.springframework.aop.ThrowsAdvice</code>，虽然该接口没有定义任何方法，但是在实现相应的 ThrowsAdvice 时，我们的方法定义需要遵循如下规则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">([Method, args, target], ThrowableSubclass)</span>;</span><br></pre></td></tr></table></figure>

<p>其中，<code>[]</code> 中的三个参数可以省略。我们可以根据将要拦截的 Throwable 的不同类型。在同一个 ThrowAdvice 中实现多个 afterThrowing 方法。框架会使用 Java 反射机制来调用这些方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionBarrierThrowsAdvice</span> <span class="keyword">implements</span> <span class="title class_">ThrowsAdvice</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">        <span class="comment">// 普通异常处理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(RuntimeException e)</span> &#123;</span><br><span class="line">        <span class="comment">// 运行时异常处理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(Method m, Object[] args, 0bject target, ApplicationException e)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理应用程序生成的异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ThrowsAdvice 通常用于对系统中特定的异常情况进行监控，以统一的方式对所发生的异常进行处理。</p>
<h3 id="AfterReturningAdvice"><a href="#AfterReturningAdvice" class="headerlink" title="AfterReturningAdvice"></a>AfterReturningAdvice</h3><p><code>org.springframework.aop.AfterReturningAdvice</code> 接口定义了 Spring 的 AfterReturningAdvice，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AfterReturningAdvice</span> <span class="keyword">extends</span> <span class="title class_">AfterAdvice</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, Method method, Object[] args, <span class="meta">@Nullable</span> Object target)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 Spring 中的 AfterReturningAdvice，我们可以访问当前 Joinpoint 的方法返回值、方法、方法参数以及所在的目标对象。</p>
<p>如果有需要方法成功执行后进行横切逻辑，使用 AfterReturningAdvice 比较合适。另外，虽然 Spring 的 AfterReturningAdvice 可以访问到方法的返回值，但不可以更改返回值。</p>
<h3 id="AroundAdvice"><a href="#AroundAdvice" class="headerlink" title="AroundAdvice"></a>AroundAdvice</h3><p>Spring 中没有直接定义对应的 Around Advice 接口，而是直接采用 AOP Alliance 的标准接口，即 <code>org.aopalliance.intercept.MethodInterceptor</code>，该接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MethodInterceptor</span> <span class="keyword">extends</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">	Object <span class="title function_">invoke</span><span class="params">(<span class="meta">@Nonnull</span> MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 MethodInterceptor 的 invoke 方法的 MethodInvocation 参数，我们可以控制对相应 Joinpoint 的拦截行为。通过调用 invocation 的 proceed 方法，可以让程序执行继续沿着调用链传播，甚至捕获 proceed 方法可能抛出的异常。如果我们在哪一个 MethodInterceptor 中没有调用 proceed 方法，那么程序的执行将会在当前 MethodInterceptor 处断开执行，Joinpoint 上的调用链将被中断，同一 Joinpoint 上的其他 MethodInterceptor 的逻辑以及 Joinpoint 处的方法逻辑将不会被执行。</p>
<blockquote>
<p><strong>注意：</strong>除非清楚当前操作所产生的后果，不然千万不要忘记调用 proceed 方法。</p>
</blockquote>
<h2 id="per-instance-类型的-Advice"><a href="#per-instance-类型的-Advice" class="headerlink" title="per-instance 类型的 Advice"></a>per-instance 类型的 Advice</h2><p>与 per-class 类型的 Advice 不同，per-instance 类型的 Advice 不会在目标类所有对象实例之间共享，而是会为不同的实例对象保存它们各自的状态以及相关逻辑。</p>
<p>在 Spring AOP 中，Introduction 就是唯一的一种 per-instance 型 Advice。Introduction 可以在不改动目标类定义的情况下，为目标类添加新的属性以及行为。</p>
<p>在 Spring 中，为目标对象添加新的属性和行为必须声明相应的接口以及相应的实现。这样，再通过特定的拦截器将新的接口定义以及实现类中的逻辑附加到目标对象之上。之后，目标对象（确切地说是目标对象的代理对象）就拥有了新的状态和行为。这个特定的拦截器就是 <code>org.springframework.aop.IntroductionInterceptor</code>，其定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DynamicIntroductionAdvice</span> <span class="keyword">extends</span> <span class="title class_">Advice</span> &#123;</span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">implementsInterface</span><span class="params">(Class&lt;?&gt; intf)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IntroductionInterceptor</span> <span class="keyword">extends</span> <span class="title class_">MethodInterceptor</span>, DynamicIntroductionAdvice &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IntroductionInterceptor 继承了 MethodInterceptor 以及 DynamicIntroductionAdvice。</p>
<ul>
<li>通过 DynamicIntroductionAdvice，我们可以界定当前的 IntroductionInterceptor 为哪些接口提供相应的拦截功能；</li>
<li>通过 MethodInterceptor，IntroductionInterceptor 可以处理新添加的接口上的方法调用了。</li>
</ul>
<p>对于 IntroductionInterceptor 来说如果是新增加的接口上的方法调用，不必去调用 MethodInterceptor 的 proceed 方法，因为当前被拦截的方法实际上就是整个调用链中要最终执行的唯一方法。</p>
<p>因为 Introduction 较之其他 Advice 有些特殊，所以，我们有必要从总体上看一下 Spring 中对 Introduction 的支持结构：</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/Introduction%E7%9B%B8%E5%85%B3%E7%B1%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="Introduction相关类结构图"></p>
<p>Introduction 型的 Advice 两条分支，一条是以 DynamicIntroductionAdvice 为首的动态分支，另一条是以 IntroductionInfo 为首的静态可配置分支。</p>
<p>使用 DynamicIntroductionAdvice，我们可以到运行时再去判定当前 Introduction 可应用到的目标接口类型，而不用预先设定。而 IntroductionInfo 类型则完全相反，其定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IntroductionInfo</span> &#123;</span><br><span class="line">	Class&lt;?&gt;[] getInterfaces();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现类必须返回预定的目标接口类型，这样，在对 IntroductionInfo 型的 Introduction 进行织入的时候，实际上就不需要指定目标接口类型了，因为它自身就带有这些必要的信息。</p>
<p>大多数时候，我们如果要对目标对象拦截并添加 Introduction 逻辑，可以直接使用 Spring 提供的两个现成的实现类就可以了。</p>
<h3 id="DelegatingIntroductionInterceptor"><a href="#DelegatingIntroductionInterceptor" class="headerlink" title="DelegatingIntroductionInterceptor"></a>DelegatingIntroductionInterceptor</h3><p>DelegatingIntroductionInterceptor 不会自己实现将要添加到目标对象上的新的逻辑行为，而是委派给其他实现类，用法像这样：</p>
<blockquote>
<p>以简化开发人员为例，有时候测试人员忙不过来了，可能就会要几个开发人员过去帮忙做测试，那么这个时候原来的开发人员就拥有了测试人员的行为和属性。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IDeveloper</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">developSoftware</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Developer</span> <span class="keyword">implements</span> <span class="title class_">IDeveloper</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">developSoftware</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am happy with programming&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要为 Developer 添加测试人员的职能，要先将测试人员的职能定义成接口，像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITester</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isBusyAsTester</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSoftware</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后要给出测试人员的实现类，在实现类中给出要添加到目标对象（开发人员）的具体逻辑。当目标对象将要行使新的职能的时候，会通过该实现类寻求帮助：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tester</span> <span class="keyword">implements</span> <span class="title class_">ITester</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> busyAsTester;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSoftware</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I will ensure the quality&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBusyAsTester</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> busyAsTester;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBusyAsTester</span><span class="params">(<span class="type">boolean</span> busyAsTester)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.busyAsTester = busyAsTester;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 DelegatingIntroductionInterceptor 进行 Introduction 的拦截。有了新增加职能的接口定义以及相应实现类，使用 DelegatingIntroductionInterceptor，我们就可以把具体的 Inroduction 拦截委托给具体的实现类来完成，像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ITester</span> <span class="variable">delegate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tester</span>();</span><br><span class="line"><span class="type">DelegatingIntroductionInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DelegatingIntroductionInterceptor</span>(delegate);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给 developer 增加 tester 的职能</span></span><br><span class="line"><span class="type">IDeveloper</span> <span class="variable">developer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Developer</span>();</span><br><span class="line"><span class="type">ITester</span> <span class="variable">tester</span> <span class="operator">=</span> (ITester) weaver.weave(developer).with(interceptor).getProxy();</span><br><span class="line">tester.testSoftware();</span><br></pre></td></tr></table></figure>

<p>DelegatingIntroductionInterceptor 虽然是 Introduction 型的 Advice 实现，但它并没有兑现 Inroduction 作为 per-instance 型 Advice 的承诺。因为它只持有一个 “delegate”，供同一目标对象的所有实例共享使用，做不到为不同的实例对象保存它们各自的状态以及相关逻辑。</p>
<h3 id="DelegatePerTargetObjectIntroductionInterceptor"><a href="#DelegatePerTargetObjectIntroductionInterceptor" class="headerlink" title="DelegatePerTargetObjectIntroductionInterceptor"></a>DelegatePerTargetObjectIntroductionInterceptor</h3><p>与 DelegatingIntroductionInterceptor 不同 DelegatePerTargetObjectIntroductionInterceptor 会在内部持有一个目标对象与相应的 Introduction 逻辑实现类之间的映射关系。当每个目标对象上的新定义的接口方法被调用的时候，DelegatePerTargetObjectIntroductionInterceptor 会拦截这些调用，然后以目标对象实例作为键，到它持有的哪个映射关系中取得对应当前目标对象实例的 Introduction 实现类实例。</p>
<p>以此，DelegatePerTargetObjectIntroductionInterceptor 可以完全实现对 per-instance 的承诺。</p>
<p>与 DelegatingIntroductionInterceptor 的使用没有太大的区别，主要体现在构造方式上的不同。现在我们不需要自己构造 delegate 接口实例，而是只需要告知 DelegatePerTargetObjectIntroductionInterceptor 相应的 delegate 接口类型和对象实现类的类型，像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DelegatePerTargetObjectIntroductionInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DelegatePerTargetObjectIntroductionInterceptor</span>(Tester.class, ITester.class);</span><br></pre></td></tr></table></figure>

<hr>
<p>最后要说的是 Introduction 的性能问题。与 AspectJ 直接通过编译器将 Inroduction 织入目标对象不同，Spring AOP 采用的是动态代理机制，在性能上，Inroduction 型的 Advice 要差一些。如果有必要，可以考虑采用 AspectJ 的 Introduction 实现。</p>
<h1 id="Aspect"><a href="#Aspect" class="headerlink" title="Aspect"></a>Aspect</h1><p>Advisor 代表 Spring 中的 Aspect，但是与正常的 Aspect 不同，Advisor 通常只持有一个 Pointcut 和一个 Advice。理论上 Aspect 定义中可以有多个 Pointcut 和 Advice，所以，我们可以认为 Advisor 是一种特殊的 Aspect。</p>
<p>为了能够更清楚 Advisor 的实现结构体系，可以将 Advisor 简单划分为两个分支，一个分支以 <code>org.springframework.aop.PointcutAdvisor</code> 为首，另一个分支以 <code>org.springframework.aop.IntroductionAdvisor</code> 为首。</p>
<h2 id="PointcutAdvisor"><a href="#PointcutAdvisor" class="headerlink" title="PointcutAdvisor"></a>PointcutAdvisor</h2><p>实际上，PointcutAdvisor 才是真正定义一个 Pointcut 和一个 Advice 的 Advisor，大部分的 Advisor 实现都是 PointcutAdvisor 的实现类。</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/PointcutAdvisor%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%AD%90%E7%B1%BB.png" alt="PointcutAdvisor及相关子类"></p>
<h3 id="DefaultPointcutAdvisor"><a href="#DefaultPointcutAdvisor" class="headerlink" title="DefaultPointcutAdvisor"></a>DefaultPointcutAdvisor</h3><p>最通用的 PointcutAdvisor 实现，除了不能为其指定 Inroduction 类型的 Advice 之外，剩下的 任何类型的 Pointcut、任何类型的 Advice 都可以通过它来使用。使用起来像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> ...; <span class="comment">// 任何 Pointcut 类型</span></span><br><span class="line"><span class="type">Advice</span>   <span class="variable">advice</span>   <span class="operator">=</span> ...; <span class="comment">// 除 Inroduction 类型外的任何 Advice 类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">DefaultPointcutAdvisor</span> <span class="variable">advisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(pointcut, advice);</span><br><span class="line"><span class="comment">// 可以通过构造器或者 setter 注入 pointcut 和 advice</span></span><br></pre></td></tr></table></figure>

<h3 id="NameMatchMethodPointcutAdvisor"><a href="#NameMatchMethodPointcutAdvisor" class="headerlink" title="NameMatchMethodPointcutAdvisor"></a>NameMatchMethodPointcutAdvisor</h3><p>限定了自身可以使用的 Pointcut 类型为 NameMatchMethodPointcut，且外部不可更改。不过，对于使用的 Advice 来说，除了 Inroduction，其他任何类型的 Advice 都可以使用。使用起来像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Advice</span> <span class="variable">advice</span> <span class="operator">=</span> ...; <span class="comment">// 除 Inroduction 类型外的任何 Advice 类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">NameMatchMethodPointcutAdvisor</span> <span class="variable">advisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NameMatchMethodPointcutAdvisor</span>(advice);</span><br><span class="line">advisor.setMappedName(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line"><span class="comment">// OR</span></span><br><span class="line">advisor.setMappedNames(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;methodName1&quot;</span>, <span class="string">&quot;methodName2&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="RegexpMethodPointcutAdvisor"><a href="#RegexpMethodPointcutAdvisor" class="headerlink" title="RegexpMethodPointcutAdvisor"></a>RegexpMethodPointcutAdvisor</h3><p>限定了自身可以使用的 Pointcut 的类型，即只能通过正则表达式为其设置相应的 Pointcut。</p>
<p>其自身内部持有一个 AbstractRegexpMethodPointcut 的实例。AbstractRegexpMethodPointcut 有两个子类，即 JdkRegexpMethodPointcut 和 Perl5RegexpMethodPointcut。默认会使用 JdkRegexpMethodPointcut，如果要强制使用 Perl5RegexpMethodPointcut 可以通过 setPerl5(boolean) 方法设置。</p>
<h3 id="DefaultBeanFactoryPointcutAdvisor"><a href="#DefaultBeanFactoryPointcutAdvisor" class="headerlink" title="DefaultBeanFactoryPointcutAdvisor"></a>DefaultBeanFactoryPointcutAdvisor</h3><p>使用较少，其使用必须绑定 IoC 容器，作用是可以通过容器中注册的 Advice 注册的 BeanName 来关联对应的 Advice。</p>
<h2 id="IntroductionAdvisor"><a href="#IntroductionAdvisor" class="headerlink" title="IntroductionAdvisor"></a>IntroductionAdvisor</h2><p>IntroductionAdvisor 只能应用于类级别的拦截，只能使用 Inroduction 型的 Advice，纯粹就是为了 Inroduction 而生的。只有一个默认实现：DefaultIntroductionAdvisor。使用起来也比较简单，只可以指定 Inroduction 型的 Advice（即 IntroductionInterceptor）以及将被拦截的接口类型。</p>
<h2 id="Ordered"><a href="#Ordered" class="headerlink" title="Ordered"></a>Ordered</h2><p>Spring 在处理同一 Joinpoint 处的多个 Advisor 的时候，实际上会按照指定的顺序和优先级来执行它们，顺序号决定优先级，顺序号越小，优先级越高，优先级排在前面的，将被优先执行。我们可以从0或者1开始指定，因为小于的顺序号原则上由 Spring AOP 框架内部使用。默认情况下，如果我们不明确指定各个 Advisor 的执行顺序，那么 Spring 会按照它们的声明顺序来应用它们，最先声明的顺序号最小但优先级最大，其次次之。</p>
<h1 id="织入"><a href="#织入" class="headerlink" title="织入"></a>织入</h1><p>在 Spring AOP 中，使用类 <code>org.springframework.aop.framework.ProxyFactory</code> 作为织入器。ProxyFactory 并非 Spring AOP 中唯一可用的织入器，而是最基本的一个织入器实现。</p>
<p>Spring AOP 是基于代理模式的 AOP 实现，织入过程完成后，会返回织入了横切逻辑的目标对象的代理对象。使用 ProxyFactory 只需要指定如下两个最基本的东西：</p>
<ul>
<li><strong>要对其进行织入的目标对象。</strong>可以通过 ProxyFactory 的构造器或者 setter 注入。</li>
<li><strong>将要应用到目标对象的 Aspect，也就是 Spring 里面的 Advisor。</strong><ul>
<li>对于 Inroduction 之外的 Advice 类型，ProxyFactory 内部就会为这些 Advice 构造相应的 Advisor，只不过在为它们构造的 Advisor 中使用的 Pointcut 为 <code>Pointcut.TRUE</code>，这些 Advice 将被应用到系统中所有可识别的 Joinpoint 处。</li>
<li>如果要添加的 Advice 类型是 Inroduction 类型，<strong>则会根据该 Inroduction 的具体类型进行区分：</strong><ul>
<li>IntroductionInfo：因为它本身包含了必要的描述信息，框架内部会为其构造一个 DefaultIntroductionAdvisor；</li>
<li>DynamicIntroductionAdvice：框架内部将抛出 AopConfigException 异常（因为无法从DynamicIntroductionAdvice取得必要的目标对象信息）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="ProxyFactory-使用"><a href="#ProxyFactory-使用" class="headerlink" title="ProxyFactory 使用"></a>ProxyFactory 使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITask</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">ITask</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;execute&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于接口的代理"><a href="#基于接口的代理" class="headerlink" title="基于接口的代理"></a>基于接口的代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被代理对象</span></span><br><span class="line"><span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建 Advisor</span></span><br><span class="line"><span class="type">NameMatchMethodPointcutAdvisor</span> <span class="variable">advisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NameMatchMethodPointcutAdvisor</span>();</span><br><span class="line">advisor.setMappedName(<span class="string">&quot;execute&quot;</span>);</span><br><span class="line"><span class="type">Advice</span> <span class="variable">advice</span> <span class="operator">=</span> ...;</span><br><span class="line">advisor.setAdvice(advice);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 织入</span></span><br><span class="line"><span class="type">ProxyFactory</span> <span class="variable">weaver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(task);</span><br><span class="line">weaver.addAdvisor(advisor);</span><br><span class="line">weaver.setInterface(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;ITask.class&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用代理对象</span></span><br><span class="line"><span class="type">ITask</span> <span class="variable">proxyTask</span> <span class="operator">=</span> (ITask) weaver.getProxy();</span><br><span class="line">proxyTask.execute();</span><br></pre></td></tr></table></figure>

<p>通过 setInterface 方法可以明确告知 ProxyFactory，我们要对 ITask 接口类型进行代理。不过，如果没有其他行为属性的干预，我们也可以不使用 setInterface 方法明确指定具体的接口类型。默认情况下，ProxyFactory 只要检测到目标类实现了相应的接口，也会对目标类进行基于接口的代理。</p>
<p>简单点儿说，如果目标类实现了至少一个接口，不管我们有没有通过 ProxyFactory 的setInterfaces 方法明确指定要对特定的接口类型进行代理，只要不将 ProxyFactory 的 <code>optimize</code> 和 <code>proxyTargetclass</code> 两个属性的值设置为 true (这两个属性稍后将谈到)，那么 ProxyFactory 都会按照面向接口进行代理。</p>
<h3 id="基于类的代理"><a href="#基于类的代理" class="headerlink" title="基于类的代理"></a>基于类的代理</h3><p>如果目标类没有实现任何接口，那么，默认情况下，ProxyFactory 会对目标类进行基于类的代理，即使用 CGLIB。假设现在有一个对象，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Executable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Executable without any Interfaces&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对 Executable 进行代理的过程像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略构建 advisor</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 被代理对象</span></span><br><span class="line"><span class="type">Executable</span> <span class="variable">executable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Executable</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 织入</span></span><br><span class="line"><span class="type">ProxyFactory</span> <span class="variable">weaver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(executable);</span><br><span class="line">weaver.addAdvisor(advisor)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用代理对象</span></span><br><span class="line"><span class="type">Executable</span> <span class="variable">executable</span> <span class="operator">=</span> (Executable) weaver.getProxy(); </span><br></pre></td></tr></table></figure>

<p>但是，即使目标对象类实现了至少一个接口，我们也可以通过 proxyTargetClass 属性强制 ProxyFactory 采用基于类的代理。以 Task 为例，它实现了 ITask 接口，默认情况下 ProxyFactory 对其会采用基于接口的代理，但是，通过 proxyTargetClass，我们可以改变这种默认行为，像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weaver.setProxyTargetClass(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>除此之外，如果将 ProxyFactory 的 optimize 属性设定为 true 的话，ProxyFactory 也会采用基于类的代理机制。总的来说，如果满足一下列出的三种情况中的任何一种，ProxyFactory 将对目标类进行基于类的代理：</p>
<ol>
<li>目标类没有实现任何接口</li>
<li>ProxyFactory 的 proxyTargetClass 属性被设置为 true</li>
<li>ProxyFactory 的 optimeize 属性被设置为 true</li>
</ol>
<h3 id="Introduction-的织入"><a href="#Introduction-的织入" class="headerlink" title="Introduction 的织入"></a>Introduction 的织入</h3><p>Introduction 型的 Advice 比较特殊，如下所述：</p>
<ul>
<li>Introduction 可以为已经存在的对象类型添加新的行为，只能应用于对象级别的拦截，而不是通常 Advice 的方法级别的拦截，所以，进行 Inroduction 的织入过程中，不需要指定 Pointcut，而是需要指定目标接口类型。</li>
<li>Spring 的 Introduction 支持只能通过接口定义为当前对象添加心的行为，所以，我们需要在织入的时机，指定新织入的接口类型。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 织入对象</span></span><br><span class="line"><span class="type">IDeveloper</span> <span class="variable">developer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Developer</span>();</span><br><span class="line"><span class="type">ProxyFactory</span> <span class="variable">weaver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(developer);</span><br><span class="line">weaver.setInterface(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;IDeveloper.class, ITester.class&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 织入逻辑</span></span><br><span class="line"><span class="type">Advice</span> <span class="variable">advice</span> <span class="operator">=</span> ...;</span><br><span class="line"><span class="type">DefaultIntroductionAdvisor</span> <span class="variable">advisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultIntroductionAdvisor</span>(advice);</span><br><span class="line">weaver.addAdvisor(advisor);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用代理对象</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> weaver.getproxy();</span><br><span class="line">((ITester) proxy).testSoftware();</span><br><span class="line">((IDeveloper) proxy).developSoftware();</span><br></pre></td></tr></table></figure>

<p>对 Introduction 进行织入，新添加的接口类型必须是通过 setInterfaces 指定的。而原来的目标对象，是采用基于接口的代理形式还是采用基于类的代理形式，完全是可以自由选择的。</p>
<h2 id="ProxyFactory-实质"><a href="#ProxyFactory-实质" class="headerlink" title="ProxyFactory 实质"></a>ProxyFactory 实质</h2><p>为 ProxyFactory 提供具体代理机制实现的接口：<code>org.springframework.aop.framework.AopProxy</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AopProxy</span> &#123;</span><br><span class="line">	Object <span class="title function_">getProxy</span><span class="params">()</span>;</span><br><span class="line">	Object <span class="title function_">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring AOP 框架内使用 AopProxy 对使用的不同的代理实现机制进行了适度的抽象，针对不同的代理实现机制提供相应的 AopProxy 子类实现。目前，Spring AOP 框架内提供了针对 JDK 的动态代理和 CGLIB 两种机制的 AopProxy 实现。</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/AopProxy%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="AopProxy相关结构图"></p>
<h3 id="AopProxyFactory"><a href="#AopProxyFactory" class="headerlink" title="AopProxyFactory"></a>AopProxyFactory</h3><p>因为动态代理需要通过 InvocationHndler 提供调用拦截，所以 JdkDynamicAopProxy 同时实现了 InvocationHndler 接口。不同 AopProxy 实现的实例化过程采用工厂模式（确切地说是抽象工厂模式）进行封装，即通过 <code>org.springframework.aop.framework.AopProxyFactory</code> 进行。其定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AopProxyFactory</span> &#123;</span><br><span class="line">    AopProxy <span class="title function_">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AopProxyFactory 根据传入的 AdvisedSupport 实例提供的相关信息，来决定生成什么类型的 AopProxy。不过具体的工作会转交给它的实现类：<code>org.springframework.aop.framework.DefaultAopProxyFactory</code>。它的工作逻辑很简单，就是判断是否采用 CGLIB 生成动态代理对象，满足直接生成，否则生成 JDK 动态代理对象。</p>
<h3 id="AdvisedSupport"><a href="#AdvisedSupport" class="headerlink" title="AdvisedSupport"></a>AdvisedSupport</h3><p>AdvisedSupport 其实就是一个生成代理对象所需要的信息的载体，该类相关的类层次图如下：</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/AdvisedSupport%E7%B1%BB%E5%B1%82%E6%AC%A1%E5%9B%BE.png" alt="AdvisedSupport类层次图"></p>
<p>AdvisedSupport 所承载的信息可以划分为两类，一类以 <code>org.springframework.aop.framework.ProxyConfig</code> 为统领，记载生成代理对象的控制信息；一类以 <code>org.springframework.aop.framework.Advised</code> 为旗帜，承载生成代理对象所需要的必要信息，比如相关目标类、Advice、Advisor 等。</p>
<p>ProxyConfig 其实就是一个普通的 JavaBean，它定义了5个 boolean 属性，分别控制在生成代理对象的时候，应该采取哪些行为措施：</p>
<ol>
<li><strong>proxyTargetClass（默认false）</strong>设置为 true 则会使用 CGLIB 对目标对象进行代理。</li>
<li><strong>optimize（默认false）</strong>用于告知代理对象是否需要才去进一步的优化措施，如代理对象生成之后，即使为其添加或者移除了相应的 Advice，代理对象也可以忽略这种变动。</li>
<li><strong>opaque（默认false）</strong>用于控制生成的代理对象是否可以强制转型为 Advised，默认是 false，表示任何生成的代理对象都可强制转型为 Advised，我们可以通过 Advised 查询代理对象的一些状态。</li>
<li><strong>exposeProxy（默认false）</strong>是否将当前代理对象绑定到 ThreadLocal。出于性能考虑，默认不绑定。如果目标对象需要访问当前代理对象，可以通过 <code>AopContext.currentProxy()</code> 取得。</li>
<li><strong>frozen（默认false）</strong>是否允许更改针对代理对象生成的各项信息配置，默认不允许，比如， ProxyFactory 设置完毕，并且 frozen 设置为 true，则不能对 Advice 进行任何变动，这样可以优化代理对象生成的性能。</li>
</ol>
<p>要生成代理对象，只有 ProxyConfig 提供的控制信息还不够，我们还需要生成代理对象的一些具体信息，比如，要针对哪些目标类生成代理对象，要为代理对象加入何种横切逻辑等，这些信息都可以通过 <code>org.springframework.aop.framework.Advised</code> 设置或查询。默认情况下，Spring AOP 框架返回的代理对象都可以强制转型为 Advised，以查询代理对象的相关信息。</p>
<p>简单点说，我们可以使用 Advised 接口访问相应代理对象所持有的 Advisor，进行添加 Advisor、移除 Advisor 等相关动作。即使代理对象已经生成完毕，也可以对其进行这些操作。</p>
<p>AopProxy、AdvisedSupport 与 ProxyFactory 是什么关系呢？</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/ProxyFactory%E7%BB%A7%E6%89%BF%E5%B1%82%E6%AC%A1%E5%9B%BE.png" alt="ProxyFactory继承层次图"></p>
<p>ProxyFactory 集 AopProxy 和 AdvisedSupport 于一身，所以，可以通过 ProxyFactory 设置生成代理对象所需要的相关信息，也可以通过 ProxyFactory 取得最终生成的代理对象。前者是 AdvisedSupport 的职责，后者是 AopProxy 的职责。</p>
<p>为了重用相关逻辑，ProxyFactory 在实现的时候，将一些公用的逻辑抽取到了 <code>org.springframework.aop.framework.ProxyCreatorSupport</code> 中，它自身就继承了 AdvisedSupport，所以，生成代理对象的必要信息从其自身就可以获取到。为了简化子类生成不同类型的 AopProxy 的工作，ProxyCreatorSupport 内部持有一个 AopProxyFactory 实例，默认采用的是 DefaultAopProxyFactory，也可以通过构造方法或者是 setter 设置自定义的实现。</p>
<h2 id="ProxyCreatorSupport"><a href="#ProxyCreatorSupport" class="headerlink" title="ProxyCreatorSupport"></a>ProxyCreatorSupport</h2><p>ProxyFactory 只是 Spring AOP 中最基本的织入器实现，它还有另外的几个“兄弟”：</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/ProxyFactory%E7%9A%84%E2%80%9C%E5%85%84%E5%BC%9F%E2%80%9D.png" alt="ProxyFactory的“兄弟”"></p>
<h2 id="ProxyFactoryBean-介绍"><a href="#ProxyFactoryBean-介绍" class="headerlink" title="ProxyFactoryBean 介绍"></a>ProxyFactoryBean 介绍</h2><p>在 IoC 容器中，使用 <code>org.springframework.aop.framework.ProxyFactoryBean</code> 作为织入器，它的使用与 ProxyFactory 无太大差别。ProxyFactoryBean 本质上是一个用来生产 Proxy 的 FactoryBean。如果容器中的某个对象持有某个 FactoryBean 的引用，它取得的不是 FactoryBean 本身，而是 FactoryBean 的 getObject 方法所返回的对象。所以，如果容器中某个对象依赖于 ProxyFactoryBean，那么它将会使用到 ProxyFactoryBean 的 getObject 方法所返回的代理对象。</p>
<p>要让 ProxyFactoryBean 的 getobject 方法返回相应目标对象类的代理对象其实很简单。因为 ProxyFactoryBean 继承了与 ProxyFactory 共有的父类 ProxyCreatorSupport，而ProxyCreatorSupport 基本上已经把要做的事情（如设置目标对象配置其他部件生成对应的 AopProxy 等）全部完成了。我们只需在 ProxyFactoryBean 的 getobject 方法中通过父类的createAopProxy 方法取得相应的 AopProxy，然后 <code>return AopProxy.getProxy()</code> 即可。</p>
<h2 id="ProxyFactoryBean-使用"><a href="#ProxyFactoryBean-使用" class="headerlink" title="ProxyFactoryBean 使用"></a>ProxyFactoryBean 使用</h2><p>ProxyFactoryBean 在继承了父类 ProxyCreatorSupport 的所有配置之外，还添加了几个自己独有的，如下所示：</p>
<ul>
<li><strong>proxyInterfaces：</strong>如果要采用基于接口的代理方式，可以通过改属性配置相应的接口类型。实际上，它就是调用了 <code>AdvisedSupport::setInterfaces</code> 方法，二者等价，只是使用风格不同。另外，如果目标对象实现了某个或多个接口，即使不指定要代理的接口类型，ProxyFactoryBean 也可以自动检测到目标对象所实现的接口，并对其进行基于接口的代理。</li>
<li><strong>singleton：</strong>因为 ProxyFactoryBean 本质上是一个 FactoryBean，所以我们可以通过 singleton 属性，指定每次 getObject 调用是返回同一个代理对象，还是返回一个新的。通常情况下是返回同一个代理对象，即 singleton 为 true。只有在需要返回有状态的代理对象的情况下，才设置为 false，比如使用 Introduction 的场合。</li>
<li><strong>interceptorNames：</strong>可以通过改属性，一次性指定多个将要织入到目标对象的 Advice、Interceptor 以及 Advisor。可以在指定的 interceptorNames 某个元素名称之后添加 “*” 通配符，可以让 ProxyFactoryBean 在容器中搜寻符合条件的所有 Advisor 并应用到目标对象。</li>
</ul>
<p><strong>Introduction 的织入</strong></p>
<p>引入一个 ICounter 接口定义以及一个简单实现类，然后将这个接口的行为和状态添加到 ITask 相应实现类中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ICounter</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">resetCounter</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getCounter</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CounterImpl</span> <span class="keyword">implements</span> <span class="title class_">ICounter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ++count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resetCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>织入过程如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">DelegatePerTargetObjectIntroductionInterceptor <span class="title function_">interceptor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DelegatePerTargetObjectIntroductionInterceptor</span>(CounterImpl.class, ICounter.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line">ProxyFactoryBean <span class="title function_">proxyFactoryBean</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ProxyFactoryBean</span> <span class="variable">proxyFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactoryBean</span>();</span><br><span class="line">    proxyFactoryBean.setTargetName(<span class="string">&quot;Task&quot;</span>);</span><br><span class="line">    proxyFactoryBean.setProxyInterfaces(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;ICounter.class, ITask.class&#125;);</span><br><span class="line">    proxyFactoryBean.setInterceptorNames(<span class="string">&quot;interceptor&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> proxyFactoryBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将目标对象的 Bean 定义、ProxyFactoryBean 的 Bean 定义，以及相应 IntroductionInterceptor 的 Bean 定义的 scope，全部声明为 prototype，也就是<code>singleton=&quot;false&quot;</code>，并且，这种情况下，我们使用的是“taskName”而不是“task”来指定目标对象。这样才能保证每次取得的代理对象都持有各自独有的状态和行为。如下是调用执行的代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringDemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> SpringApplication.run(SpringDemoApplication.class, args);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ICounter</span> <span class="variable">counter1</span> <span class="operator">=</span> (ICounter) ac.getBean(<span class="string">&quot;proxyFactoryBean&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ICounter</span> <span class="variable">counter2</span> <span class="operator">=</span> (ICounter) ac.getBean(<span class="string">&quot;proxyFactoryBean&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.print(counter1.getCounter() + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">        System.out.print(counter1.getCounter() + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">        System.out.print(counter2.getCounter() + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出：</span></span><br><span class="line">    <span class="comment">// 1  2  1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ProxyFactoryBean-自动代理"><a href="#ProxyFactoryBean-自动代理" class="headerlink" title="ProxyFactoryBean 自动代理"></a>ProxyFactoryBean 自动代理</h2><p>要使用自动代理，需要以 Spring 的 IoC 容器为依托。Spring AOP 的自动代理的实现建立在 IoC 容器的 BeanPostProcessor 概念之上。通过 BeanPostProcessor，我们可以在遍历容器中所有 Bean 的基础上，对遍历到的 Bean 进行一些操作，有了这个前提条件，实现自动代理就很容易了。</p>
<p>只要提供一个 BeanPostProcessor，然后在这个 BeanPostProcessor 内部实现这样的逻辑，即当对象实例化的时候，为其生成代理对象并返回，而不是实例化后的目标对象本身，从而达到代理对象自动生成的目的。</p>
<p>Spring AOP 在 <code>org.springframework.aop.framework.autoproxy</code> 包中提供了两个常用的 AotoProxyCreator：BeanNameAutoProxyCreator 和 DefaultAdvisorAutoProxyCreator。</p>
<h1 id="TargetSource"><a href="#TargetSource" class="headerlink" title="TargetSource"></a>TargetSource</h1><p>TargetSource 的作用就好像是为目标对象在外面加了一个壳，就像是目标对象的容器。本来当每个针对目标对象的方法调用经历了层层拦截而到达调用链的终点的时候，就该去调用目标对象上定义的方法了。但 Spring AOP 在这里做了点手脚，它不是直接调用这个目标对象上的方法，而是通过 “插足于” 调用链与实际目标对象之间的某个 TargetSource 来取得具体的目标对象，然后再从 TargetSource 中取得的目标对象上的相应方法。</p>
<p>通常都是使用 setTarget 或者是 setTargetName 等方法来设置目标对象，但也还可以通过 setTargetSource 方法来指定目标对象。不论使用哪种方式，Spring AOP 框架内部都会通过一个 TargetSource 实现类对这个设置的目标对象进行封装。</p>
<p>TargetSource 最主要的特性就是，每次的方法调用都会触发 TargetSource 的 getTarget 方法，getTarget 方法将返回一个具体的目标对象。接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TargetSource</span> <span class="keyword">extends</span> <span class="title class_">TargetClassAware</span> &#123;</span><br><span class="line">	Class&lt;?&gt; getTargetClass();</span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">isStatic</span><span class="params">()</span>;</span><br><span class="line">	Object <span class="title function_">getTarget</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">releaseTarget</span><span class="params">(Object target)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>getTargetClass：</strong>返回目标对象类型；</li>
<li><strong>isStatic：</strong>用于表明是否要返回同一个目标对象实例，SingletonTargetSource 的这个方法肯定返回 true，其他的实现根据情况，通常返回 false；</li>
<li><strong>getTarget：</strong>核心方法，决定返回哪个目标对象实例；</li>
<li><strong>releaseTarget：</strong>释放当前调用的目标对象。但是否需要释放，完全是由实现的需要决定的，大部分时候，该方法可以只做空实现。</li>
</ul>
<p>常见的实现类如下：</p>
<h2 id="SingletonTargetSource"><a href="#SingletonTargetSource" class="headerlink" title="SingletonTargetSource"></a>SingletonTargetSource</h2><p><code>org.springframework.aop.target.SingletonTargetSource</code> 是使用的最多的 TargetSource 实现，通过名字都可以看出来它的实现很简单，就是内部只持有一个目标对象，当每次方法调用到达时，SingletonTargetSource 就会返回这同一个目标对象。</p>
<h2 id="PrototypeTargetSource"><a href="#PrototypeTargetSource" class="headerlink" title="PrototypeTargetSource"></a>PrototypeTargetSource</h2><p>如果为 ProxyFactory 或者 ProxyFactoryBean 设置一个 PrototypeTargetSource 类型  TargetSource，那么每次方法调用到达调用链终点，并即将调用目标对象上的方法的时候，PrototypeTargetSource 都会返回一个新的目标对象实例供调用。但要注意目标对象的 scope 必须为 prototype。</p>
<h2 id="HotSwappableTargetSource"><a href="#HotSwappableTargetSource" class="headerlink" title="HotSwappableTargetSource"></a>HotSwappableTargetSource</h2><p>使用 HotSwappableTargetSource 封装目标对象，可以让我们在应用程序运行的时候，根据某种特定条件，动态地替换目标对象类的具体实现，比如，IService 有多个实现类，如果程序启动之后，默认的 IService 实现类出现了问题，我们可以马上切换到 IService 的另一个实现上，而所有这些对于调用者来说都是透明的。使用起来像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">protected</span> HotSwappableTargetSource <span class="title function_">hotSwappableTargetSource</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HotSwappableTargetSource</span>(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">protected</span> ProxyFactoryBean <span class="title function_">proxy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ProxyFactoryBean</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactoryBean</span>();</span><br><span class="line">    proxy.setTargetSource(hotSwappableTargetSource());</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> SpringApplication.run(SpringDemoApplication.class, args);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> ac.getBean(<span class="string">&quot;proxy&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">HotSwappableTargetSource</span> <span class="variable">hotSwappableTargetSource</span> <span class="operator">=</span> (HotSwappableTargetSource) ac.getBean(<span class="string">&quot;hotSwappableTargetSource&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ITask</span> <span class="variable">initTarget</span> <span class="operator">=</span> (ITask) ((Advised) proxy).getTargetSource().getTarget();    </span><br><span class="line">    <span class="keyword">final</span> <span class="type">ITask</span> <span class="variable">oldTarget</span> <span class="operator">=</span> (ITask) hotSwappableTargetSource.swap(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ITask</span> <span class="variable">newTarget</span> <span class="operator">=</span> (ITask) ((Advised) proxy).getTargetSource().getTarget();</span><br><span class="line"></span><br><span class="line">    <span class="type">assert</span> <span class="variable">initTarget</span> <span class="operator">=</span>= oldTarget;</span><br><span class="line">    <span class="keyword">assert</span> initTarget != newTarget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用场景：在有两个数据库双击热备的情况下，如果一个数据库挂掉，则将程序迅速地切换到另一个数据库。可以使用 ThrowsAdvice 对数据库相关异常进行捕获，在捕捉到必要的切换信息后，就调用 HotSwappableTargetSource 的 swap 方法使用新的数据源替换旧的数据源。</p>
</blockquote>
<h2 id="CommonsPoolTargetSource"><a href="#CommonsPoolTargetSource" class="headerlink" title="CommonsPoolTargetSource"></a>CommonsPoolTargetSource</h2><p>通过 CommonsPoolTargetSource 我们可以提供一个目标对象的对象池，然后让某个 TargetSource 实现每次都从这个目标对象池中去取得目标对象，就好像数据库连接池中的哪些 Connection 一样。CommonsPoolTargetSource 使用现有的 Jakarta Commons Pool 提供对象池支持。CommonsPoolTargetSource 使用起来跟 PrototypeTargetSource 没什么太大差别，也需要目标对象的 scope 必须为 prototype。</p>
<p>CommonsPoolTargetSource 还有许多控制对象池的可配置属性，比如对象池的大小、初始对象数量等。如果不能使用 Jakarta Commons Pool 对象池，那么也可以通过扩展 <code>org.springframework.aop.target.AbstractPoolingTargetSource</code>，实现相应的提供对象池化功能的 TargetSource。</p>
<h2 id="ThreadLocalTargetSource"><a href="#ThreadLocalTargetSource" class="headerlink" title="ThreadLocalTargetSource"></a>ThreadLocalTargetSource</h2><p>通过 <code>org.springframework.aop.target.ThreadLocalTargetSource</code>，可以为不同的线程调用提供不同的目标对象，它可以保证各自线程上对目标对象的调用，可以被分配到当前线程对应的那个目标实现类实例上。同样，它的目标对象的 Bean 定义的 scope 也必须是 prototype。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://www.wrp.cool">码小瑞</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.wrp.cool/posts/22032/">https://www.wrp.cool/posts/22032/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.wrp.cool" target="_blank">知更</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/index_img.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/22033/"><img class="prev-cover" src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/index_img.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">AspectJ 形式的 Spring AOP</div></div></a></div><div class="next-post pull-right"><a href="/posts/40742/"><img class="next-cover" src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/index_img.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">IoC和Spring IoC</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar123"/></div><div class="author-info__name">码小瑞</div><div class="author-info__description">一直在学习，永远在路上</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">78</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/wangruipeng-wrp"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Joinpoint"><span class="toc-number">1.</span> <span class="toc-text">Joinpoint</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Pointcut"><span class="toc-number">2.</span> <span class="toc-text">Pointcut</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ClassFilter"><span class="toc-number">2.1.</span> <span class="toc-text">ClassFilter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MethodMatcher"><span class="toc-number">2.2.</span> <span class="toc-text">MethodMatcher</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NameMatchMethodPointcut"><span class="toc-number">2.2.1.</span> <span class="toc-text">NameMatchMethodPointcut</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JdkRegexpMethodPointcut%E5%92%8CPerl5RegexpMethodPointcut"><span class="toc-number">2.2.2.</span> <span class="toc-text">JdkRegexpMethodPointcut和Perl5RegexpMethodPointcut</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AnnotationMatchingPointcut"><span class="toc-number">2.2.3.</span> <span class="toc-text">AnnotationMatchingPointcut</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ComposablePointcut"><span class="toc-number">2.2.4.</span> <span class="toc-text">ComposablePointcut</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ControlFlowPointcut"><span class="toc-number">2.2.5.</span> <span class="toc-text">ControlFlowPointcut</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-StaticMethodMatcherPointcut"><span class="toc-number">2.2.6.</span> <span class="toc-text">自定义 StaticMethodMatcherPointcut</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-DynamicMethodMatcherPointcut"><span class="toc-number">2.2.7.</span> <span class="toc-text">自定义 DynamicMethodMatcherPointcut</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Advice"><span class="toc-number">3.</span> <span class="toc-text">Advice</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#per-class-%E7%B1%BB%E5%9E%8B%E7%9A%84-Advice"><span class="toc-number">3.1.</span> <span class="toc-text">per-class 类型的 Advice</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BeforeAdvice"><span class="toc-number">3.1.1.</span> <span class="toc-text">BeforeAdvice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThrowsAdvice"><span class="toc-number">3.1.2.</span> <span class="toc-text">ThrowsAdvice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AfterReturningAdvice"><span class="toc-number">3.1.3.</span> <span class="toc-text">AfterReturningAdvice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AroundAdvice"><span class="toc-number">3.1.4.</span> <span class="toc-text">AroundAdvice</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#per-instance-%E7%B1%BB%E5%9E%8B%E7%9A%84-Advice"><span class="toc-number">3.2.</span> <span class="toc-text">per-instance 类型的 Advice</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DelegatingIntroductionInterceptor"><span class="toc-number">3.2.1.</span> <span class="toc-text">DelegatingIntroductionInterceptor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DelegatePerTargetObjectIntroductionInterceptor"><span class="toc-number">3.2.2.</span> <span class="toc-text">DelegatePerTargetObjectIntroductionInterceptor</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Aspect"><span class="toc-number">4.</span> <span class="toc-text">Aspect</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#PointcutAdvisor"><span class="toc-number">4.1.</span> <span class="toc-text">PointcutAdvisor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DefaultPointcutAdvisor"><span class="toc-number">4.1.1.</span> <span class="toc-text">DefaultPointcutAdvisor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NameMatchMethodPointcutAdvisor"><span class="toc-number">4.1.2.</span> <span class="toc-text">NameMatchMethodPointcutAdvisor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RegexpMethodPointcutAdvisor"><span class="toc-number">4.1.3.</span> <span class="toc-text">RegexpMethodPointcutAdvisor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DefaultBeanFactoryPointcutAdvisor"><span class="toc-number">4.1.4.</span> <span class="toc-text">DefaultBeanFactoryPointcutAdvisor</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IntroductionAdvisor"><span class="toc-number">4.2.</span> <span class="toc-text">IntroductionAdvisor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ordered"><span class="toc-number">4.3.</span> <span class="toc-text">Ordered</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%87%E5%85%A5"><span class="toc-number">5.</span> <span class="toc-text">织入</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ProxyFactory-%E4%BD%BF%E7%94%A8"><span class="toc-number">5.1.</span> <span class="toc-text">ProxyFactory 使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BB%A3%E7%90%86"><span class="toc-number">5.1.1.</span> <span class="toc-text">基于接口的代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%B1%BB%E7%9A%84%E4%BB%A3%E7%90%86"><span class="toc-number">5.1.2.</span> <span class="toc-text">基于类的代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Introduction-%E7%9A%84%E7%BB%87%E5%85%A5"><span class="toc-number">5.1.3.</span> <span class="toc-text">Introduction 的织入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ProxyFactory-%E5%AE%9E%E8%B4%A8"><span class="toc-number">5.2.</span> <span class="toc-text">ProxyFactory 实质</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AopProxyFactory"><span class="toc-number">5.2.1.</span> <span class="toc-text">AopProxyFactory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AdvisedSupport"><span class="toc-number">5.2.2.</span> <span class="toc-text">AdvisedSupport</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ProxyCreatorSupport"><span class="toc-number">5.3.</span> <span class="toc-text">ProxyCreatorSupport</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ProxyFactoryBean-%E4%BB%8B%E7%BB%8D"><span class="toc-number">5.4.</span> <span class="toc-text">ProxyFactoryBean 介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ProxyFactoryBean-%E4%BD%BF%E7%94%A8"><span class="toc-number">5.5.</span> <span class="toc-text">ProxyFactoryBean 使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ProxyFactoryBean-%E8%87%AA%E5%8A%A8%E4%BB%A3%E7%90%86"><span class="toc-number">5.6.</span> <span class="toc-text">ProxyFactoryBean 自动代理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TargetSource"><span class="toc-number">6.</span> <span class="toc-text">TargetSource</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SingletonTargetSource"><span class="toc-number">6.1.</span> <span class="toc-text">SingletonTargetSource</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PrototypeTargetSource"><span class="toc-number">6.2.</span> <span class="toc-text">PrototypeTargetSource</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HotSwappableTargetSource"><span class="toc-number">6.3.</span> <span class="toc-text">HotSwappableTargetSource</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CommonsPoolTargetSource"><span class="toc-number">6.4.</span> <span class="toc-text">CommonsPoolTargetSource</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocalTargetSource"><span class="toc-number">6.5.</span> <span class="toc-text">ThreadLocalTargetSource</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/268/" title="Spring AOP 为 目标对象注入代理">Spring AOP 为 目标对象注入代理</a><time datetime="2022-12-14T12:57:28.000Z" title="发表于 2022-12-14 20:57:28">2022-12-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/59891/" title="什么是幸福？">什么是幸福？</a><time datetime="2022-12-13T06:37:47.000Z" title="发表于 2022-12-13 14:37:47">2022-12-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/22033/" title="AspectJ 形式的 Spring AOP">AspectJ 形式的 Spring AOP</a><time datetime="2022-12-08T05:55:01.000Z" title="发表于 2022-12-08 13:55:01">2022-12-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/22032/" title="Spring AOP 实现">Spring AOP 实现</a><time datetime="2022-12-04T03:46:38.000Z" title="发表于 2022-12-04 11:46:38">2022-12-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/40742/" title="IoC和Spring IoC">IoC和Spring IoC</a><time datetime="2022-11-30T10:39:50.000Z" title="发表于 2022-11-30 18:39:50">2022-11-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 码小瑞</div><div class="footer_custom_text"><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/icp.png" style="display:inline; padding:0 4px; vertical-align:text-bottom; max-height:1.4em; width:auto;"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备 19093360 号</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'xHUEmhrVmHWv8MupdDvR9FvM-gzGzoHsz',
      appKey: 'Cr1qzcPhqKCVqEhTSX6TRoa4',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="100" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>