<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Spring AOP 实现 | 知更</title><meta name="author" content="码小瑞"><meta name="copyright" content="码小瑞"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="《Spring揭秘》读书笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring AOP 实现">
<meta property="og:url" content="https://www.wrp.cool/posts/22032/index.html">
<meta property="og:site_name" content="知更">
<meta property="og:description" content="《Spring揭秘》读书笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/index_img.jpg">
<meta property="article:published_time" content="2022-12-04T03:46:38.000Z">
<meta property="article:modified_time" content="2022-12-05T16:58:27.929Z">
<meta property="article:author" content="码小瑞">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/index_img.jpg"><link rel="shortcut icon" href="/images/avatar.png"><link rel="canonical" href="https://www.wrp.cool/posts/22032/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 码小瑞","link":"链接: ","source":"来源: 知更","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring AOP 实现',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-06 00:58:27'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="知更" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">79</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-map-marker-alt"></i><span> 这里</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-user"></i><span> 我说我呀</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-book"></i><span> 喜欢看书</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 喜欢电影</span></a></li><li><a class="site-page child" href="/love/"><i class="fa-fw fa fa-heart red"></i><span> 还喜欢你</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-link"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">知更</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-map-marker-alt"></i><span> 这里</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-user"></i><span> 我说我呀</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-book"></i><span> 喜欢看书</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 喜欢电影</span></a></li><li><a class="site-page child" href="/love/"><i class="fa-fw fa fa-heart red"></i><span> 还喜欢你</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-link"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Spring AOP 实现</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-04T03:46:38.000Z" title="发表于 2022-12-04 11:46:38">2022-12-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-05T16:58:27.929Z" title="更新于 2022-12-06 00:58:27">2022-12-06</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>17分钟</span></span></div></div></div><article class="post-content" id="article-container"><h1 id="Joinpoint"><a href="#Joinpoint" class="headerlink" title="Joinpoint"></a>Joinpoint</h1><p>Spring AOP 中，仅支持方法执行类型的 Joinpoint。也就是仅能在方法内部执行开始时点进行横切逻辑织入。</p>
<h1 id="Pointcut"><a href="#Pointcut" class="headerlink" title="Pointcut"></a>Pointcut</h1><p>Spring 中以接口定义 <code>org,springframework.aop.Pintcut</code> 作为其 AOP 框架中所有 Pointcut 的最顶层抽象，该接口定义了两个方法用来帮助捕捉系统中的相应 Joinpoint，并提供了一个 TruePointcut 类型实例。如果 Pointcut 类型为 TruePointcut ，默认会对系统中的所有对象，以及对象上所有被支持的 Joinpoint 进行匹配。<code>org.springframeworkaop.Pointcut</code> 接口定义如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Pointcut</span> &#123;</span><br><span class="line">    ClassFilter <span class="title function_">getClassFilter</span><span class="params">()</span>;</span><br><span class="line">    MethodMatcher <span class="title function_">getMethodMatcher</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">Pointcut</span> <span class="variable">TRUE</span> <span class="operator">=</span> TruePointcut.INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ClassFilter"><a href="#ClassFilter" class="headerlink" title="ClassFilter"></a>ClassFilter</h2><p>ClassFilter 和 MethodMatcher 分别用于匹配将被执行织入操作的对象以及相应的方法。ClassFilter 接口的作用是对 Joinpoint 所处的对象进行 Class 级别的类型匹配，其定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ClassFilter</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(Class clazz)</span>;</span><br><span class="line">    <span class="type">ClassFilter</span> <span class="variable">TRUE</span> <span class="operator">=</span> TrueClassFilter.INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当织入的目标对象的 Class 类型与 Pointcut 所规定的类型相符时，matches 方法将会返回 true，否则，返回 false，即意味着不会对这个类型的目标对象进行织入操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果希望对系统中 Foo 类型的类进行织入，则可以这么来定义 ClassFilter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FooClassFilter</span> <span class="keyword">implements</span> <span class="title class_">ClassFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(Class&lt;?&gt; cl)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Foo.class.equals(cl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，如果类型对我们所捕获的 Joinpoint 无所谓，那么 Pointcut 中使用的 ClassFilter 可以直接返回 <code>TrueClassFilter.INSTANCE</code>。当 Pointcut 中返回的 ClassFilter 类型为该类型实例时，Pointcut 的匹配将会针对系统中所有的目标类以及它们的实例进行。</p>
<h2 id="MethodMatcher"><a href="#MethodMatcher" class="headerlink" title="MethodMatcher"></a>MethodMatcher</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MethodMatcher</span> &#123;</span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span>;</span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">isRuntime</span><span class="params">()</span>;</span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass, Object... args)</span>;</span><br><span class="line">	<span class="type">MethodMatcher</span> <span class="variable">TRUE</span> <span class="operator">=</span> TrueMethodMatcher.INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MethodMatcher 定义了两个 matches 方法，这两个方法的分界线就是 isRuntime 方法。在对对象具体方法进行拦截的时候，可以忽略每次方法执行的时候调用者传入的参数，也可以每次都检查这些方法调用参数，以强化拦截条件。</p>
<ul>
<li><strong>isRuntime()：</strong></li>
<li><strong>返回 false：</strong>表示不会考虑具体 Joinpoint 的方法参数，这种类型的 MethodMatcher 称为 <code>StaticMethodMatcher</code>。因为不用每次都检查参数，所以只有 <code>boolean matches(Method method, Class&lt;?&gt; targetClass);</code> 会被执行，那么对于同样类型的方法匹配结果，就可以在框架内部缓存以提高性能。</li>
<li><strong>返回 true：</strong>表示该 MethodMatcher 将会每次都对方法调用的参数进行匹配检查，这种类型的 MethodMatcher 称之为 <code>DunamicMethodMatcher</code>，匹配效率相对于 <code>StaticMethodMatcher</code> 来说要差一些，最好避免使用。当 isRuntime 返回 true 后，并且当 <code>boolean matches(Method method, Class&lt;?&gt; targetClass);</code> 方法也返回 true 的时候，三个参数的 matches 方法才会被执行，以进一步检查匹配条件。如果两个参数的 matches 方法返回 false，那么不管 isRuntime 方法返回 true 还是 false，都不会执行三个参数 matches 方法。</li>
</ul>
<p>各个 Pointcut 类型之间的关系图：</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/Pointcut%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="Pointcut类型之间的关系图"></p>
<h3 id="NameMatchMethodPointcut"><a href="#NameMatchMethodPointcut" class="headerlink" title="NameMatchMethodPointcut"></a>NameMatchMethodPointcut</h3><p>这是最简单的 Pointcut 实现，可以根据自身指定的一组方法名称与 Joinpoint 处的方法名称进行匹配。除了可以指定方法名，还可以使用 “*” 通配符，实现简单的模糊匹配。</p>
<p>但是，NameMatchMethodPointcut 无法对重载的方法名进行匹配，因为它仅对方法名进行匹配，不会考虑参数相关信息，而且也没有提供可以指定参数匹配信息的途径。</p>
<h3 id="JdkRegexpMethodPointcut和Perl5RegexpMethodPointcut"><a href="#JdkRegexpMethodPointcut和Perl5RegexpMethodPointcut" class="headerlink" title="JdkRegexpMethodPointcut和Perl5RegexpMethodPointcut"></a>JdkRegexpMethodPointcut和Perl5RegexpMethodPointcut</h3><p>通过正则表达式匹配方法名。</p>
<h3 id="AnnotationMatchingPointcut"><a href="#AnnotationMatchingPointcut" class="headerlink" title="AnnotationMatchingPointcut"></a>AnnotationMatchingPointcut</h3><p>根据目标对象中是否存在指定类型的注解来匹配 Joinpoint，要使用该类型的 Pointcut，首先需要生命相应的注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类级别的注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ClassLevelAnnotation &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法级别的注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MethodLevelAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用起来像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AnnotationMatchingPointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationMatchingPointcut</span>(ClassLevelAnnotation.class, MethodLevelAnnotation.class);</span><br></pre></td></tr></table></figure>

<h3 id="ComposablePointcut"><a href="#ComposablePointcut" class="headerlink" title="ComposablePointcut"></a>ComposablePointcut</h3><p>Pointcut 通常还提供逻辑运算功能，而 ComposablePointcut 就是 Spring AOP 提供的可以进行 Pointcut 逻辑运算的 Pointcut 实现。像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ComposablePointcut</span> <span class="variable">pointcut1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComposablePointcut</span>(classFilterl,methodMatcher1);</span><br><span class="line"><span class="type">ComposablePointcut</span> <span class="variable">pointcut2</span> <span class="operator">=</span> ...</span><br><span class="line"></span><br><span class="line">ComposablePointcut unitedPoincut= pointcutl.union(pointcut2);</span><br><span class="line"><span class="type">ComposablePointcut</span> <span class="variable">intersectionPointcut</span> <span class="operator">=</span> pointcutl,intersection(unitedPoincut);</span><br><span class="line"></span><br><span class="line">assertEquals(pointcutl,intersectionPointcut);</span><br></pre></td></tr></table></figure>

<p>也能通过 <code>org.springframework.aop.support.Pointcuts</code> 工具类来实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pointcut</span> <span class="variable">pointcut1</span> <span class="operator">=</span> ...</span><br><span class="line"><span class="type">Pointcut</span> <span class="variable">pointcut2</span> <span class="operator">=</span> ...</span><br><span class="line"></span><br><span class="line"><span class="type">Pointcut</span> <span class="variable">unitedPoincut</span>          <span class="operator">=</span> Pointcuts.union(pointcut1,pointcut2);</span><br><span class="line"><span class="type">Pointcut</span> <span class="variable">intersectionPointcut</span>   <span class="operator">=</span> Pointcuts.intersection(pointcutl,pointcut2);</span><br></pre></td></tr></table></figure>

<h3 id="ControlFlowPointcut"><a href="#ControlFlowPointcut" class="headerlink" title="ControlFlowPointcut"></a>ControlFlowPointcut</h3><p>ControlFlowPointcut 匹配程序的调用流程，不是对某个方法执行所在的 Joinpoint 处的单一特征进行匹配。</p>
<p>假设我们所拦截的目标对象如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TargetObject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的调用类是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TargetCaller</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TargetObject target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        target.method1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTarget</span><span class="params">(TargetObject target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用之前的任何 Pointcut 实现，我们只能指定在 Targetobject 的 method1 方法每次执行的时候，都织入相应横切逻辑。也就是说，一旦通过 Pointcut 指定 method1 处为 Joinpoint，那么对该方法的执行进行拦截是必定的，不管 method1 是被谁调用。而通过 controlFlowPointcut，我们可以指定，只有当 Targetobject 的 method1 方法在 TargetCaller 类所声明的方法中被调用的时候，才对 method1 方法进行拦截，其他地方调用 method1 的话，不对 method1 进行拦截。</p>
<p>ControlFlowPointcut 使用起来大概像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ControlFlowPointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ControlFlowPointcut</span>(TargetCaller.class);</span><br><span class="line"><span class="type">Advice</span> <span class="variable">advice</span> <span class="operator">=</span> ... ;</span><br><span class="line"></span><br><span class="line"><span class="type">TargetObject</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TargetObject</span>();</span><br><span class="line"><span class="type">TargetObject</span> <span class="variable">targetProxy</span> <span class="operator">=</span> weaver.weave(advice).to(target).accordingto(pointcut);</span><br><span class="line"></span><br><span class="line"><span class="comment">// advice 的逻辑在这里不会被触发执行</span></span><br><span class="line">targetProxy.method1();</span><br><span class="line"></span><br><span class="line"><span class="comment">// advice 的逻辑在这里不会被触发执行</span></span><br><span class="line"><span class="comment">// 因为 TargetCaller 的 callMethod() 将调用 method1()</span></span><br><span class="line"><span class="comment">// 正像 ControlFlowPointcut(TargetCaller.class) 所指定的那样</span></span><br><span class="line"><span class="type">TargetCaller</span> <span class="variable">caller</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TargetCaller</span>();</span><br><span class="line">caller.setTarget(targetProxy);</span><br><span class="line">caller.callMethod();</span><br></pre></td></tr></table></figure>

<p>当织入器按照 Pointcut 的规定，将 Advice 织入到目标对象之后，从任何其他地方调用 method1，是不会触发 Advice 所包含的横切逻辑执行的。只有在 ControlFlowPointcut 规定的类内部调用目标对象的 method1，才会触发 Advice 中横切逻辑的执行。</p>
<blockquote>
<p><strong>注意：</strong>示例代码中 weaver 是虚构概念，不是 Spring 织入器的实现。</p>
</blockquote>
<p>如果在 ControlFlowPointcut 的构造方法中单独指定 Class 类型的参数，那么 ControlFlowPointcut 将尝试匹配指定的 Class 中声明的所有方法，跟目标对象的 Joinpoint 处的方法流程组合。如果还想指定调用类的某个具体方法，可以在构造 ControlFlowPointcut 的时候，传入第二个参数，即调用方法的名称：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ControlFlowPointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ControlFlowPointcut</span>(TargetCaller.class, <span class="string">&quot;callMethod&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="自定义-StaticMethodMatcherPointcut"><a href="#自定义-StaticMethodMatcherPointcut" class="headerlink" title="自定义 StaticMethodMatcherPointcut"></a>自定义 StaticMethodMatcherPointcut</h3><blockquote>
<p>继承抽象类 StaticMethodMatcher 即可。</p>
</blockquote>
<p>StaticMethodMatcher 根据自身语意，为其子类提供了如下几个方面的默认实现。</p>
<ul>
<li>默认所有 StaticMethodMatcher 的子类的 ClassFilter 均为 <code>ClassFilter.TRUE</code> 即忽略类的类型匹配。如果具体子类需要对目标对象的类型做进一步限制，可以通过 <code>public void setclassFilter(ClassFilter classFilter)</code> 方法设置相应的 ClassFilter 实现。</li>
<li>因为是 staticMethodMatcher，所以，其 MethodMatcher 的 isRuntime 方法返回 false，同时三个参数的 matches 方法抛出 <code>UnsupportedOperationException</code> 异常，以表示该方法不应该被调用到。</li>
</ul>
<p>最终我们需要做的就是实现两个参数的 matches 方法了</p>
<h3 id="自定义-DynamicMethodMatcherPointcut"><a href="#自定义-DynamicMethodMatcherPointcut" class="headerlink" title="自定义 DynamicMethodMatcherPointcut"></a>自定义 DynamicMethodMatcherPointcut</h3><blockquote>
<p>继承抽象类 DynamicMethodMatcher 即可。</p>
</blockquote>
<p>DynamicMethodMatcherPointcut 也为其子类提供了部分便利。</p>
<ul>
<li>getclassFilter() 方法返回 <code>ClassFilter.TRUE</code>，如果需要对特定的目标对象类型进行限定子类只要覆写这个方法即可。</li>
<li>对应的 MethodMatcher 的 isRuntime 总是返回 true，同时，StaticMethodMatcherPointcut 提供了两个参数的 matches 方法的实现，默认直接返回 true。</li>
</ul>
<p>要实现自定义 DynamicMethodMatcherPointcut，通常情况下，我们只需要实现三个参数的 matches 方法逻辑即可。但如果愿意，我们也可以覆写一下两个参数的 matches 方法，这样，不用每次都得到三个参数的 matches 方法执行的时候才检查所有的条件。</p>
<h1 id="Advice"><a href="#Advice" class="headerlink" title="Advice"></a>Advice</h1><p>Spring AOP 加入了开源组织 AOP Alliance，目的在于标准化 AOP 的使用，促进各个 AOP 实现产品之间的可交互性。鉴于此，Spring 中的 Advice 实现全部遵循 AOP Alliance 规定的接口。Spring 中各种 Advice 类型实现与 AOP Alliance 中标准接口之间的关系像这样：</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/Spring%E4%B8%AD%E7%9A%84Advice%E7%95%A5%E5%9B%BE.png" alt="Spring中的Advice略图"></p>
<p>Advice 实现了将被织入到 Pointcut 规定的 Joinpoint 处的横切逻辑。在 Spring 中，Advice 按照其自身实例能否在目标对象类的所有实例中共享这一标准，可以划分为两大类，即 <code>per-class</code> 类型的 Advice 和 <code>per-instance</code> 类型的 Advice。</p>
<h2 id="per-class-类型的-Advice"><a href="#per-class-类型的-Advice" class="headerlink" title="per-class 类型的 Advice"></a>per-class 类型的 Advice</h2><p>该类型的 Advice 实例可以在目标对象类的所有实例之间共享。这种类型的 Advice 通常只是提供方法拦截的功能，不会为目标对象类保存任何状态或者添加新的属性。</p>
<h3 id="BeforeAdvice"><a href="#BeforeAdvice" class="headerlink" title="BeforeAdvice"></a>BeforeAdvice</h3><p>Before Advice 所实现的横切逻辑将在相应的 Joinpoint 之前执行，在 Before Advice 执行完成之后程序执行流程将从 Joinpoint 处继续执行，所以 Before Advice 通常不会打断程序的执行流程。但是如果必要，也可以通过抛出相应异常的形式中断程序流程。</p>
<p>要在 Spring 中实现 Before Advice，通常只需要实现 <code>org.springframework.aop.MethodBeforeAdvice</code> 接口即可，该接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MethodBeforeAdvice</span> <span class="keyword">extends</span> <span class="title class_">BeforeAdvice</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(Method method, Object[] args, <span class="meta">@Nullable</span> Object target)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ThrowsAdvice"><a href="#ThrowsAdvice" class="headerlink" title="ThrowsAdvice"></a>ThrowsAdvice</h3><p>Throws Advice 的接口定义在 <code>org.springframework.aop.ThrowsAdvice</code>，虽然该接口没有定义任何方法，但是在实现相应的 ThrowsAdvice 时，我们的方法定义需要遵循如下规则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">([Method, args, target], ThrowableSubclass)</span>;</span><br></pre></td></tr></table></figure>

<p>其中，<code>[]</code> 中的三个参数可以省略。我们可以根据将要拦截的 Throwable 的不同类型。在同一个 ThrowAdvice 中实现多个 afterThrowing 方法。框架会使用 Java 反射机制来调用这些方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionBarrierThrowsAdvice</span> <span class="keyword">implements</span> <span class="title class_">ThrowsAdvice</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">        <span class="comment">// 普通异常处理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(RuntimeException e)</span> &#123;</span><br><span class="line">        <span class="comment">// 运行时异常处理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(Method m, Object[] args, 0bject target, ApplicationException e)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理应用程序生成的异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ThrowsAdvice 通常用于对系统中特定的异常情况进行监控，以统一的方式对所发生的异常进行处理。</p>
<h3 id="AfterReturningAdvice"><a href="#AfterReturningAdvice" class="headerlink" title="AfterReturningAdvice"></a>AfterReturningAdvice</h3><p><code>org.springframework.aop.AfterReturningAdvice</code> 接口定义了 Spring 的 AfterReturningAdvice，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AfterReturningAdvice</span> <span class="keyword">extends</span> <span class="title class_">AfterAdvice</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, Method method, Object[] args, <span class="meta">@Nullable</span> Object target)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 Spring 中的 AfterReturningAdvice，我们可以访问当前 Joinpoint 的方法返回值、方法、方法参数以及所在的目标对象。</p>
<p>如果有需要方法成功执行后进行横切逻辑，使用 AfterReturningAdvice 比较合适。另外，虽然 Spring 的 AfterReturningAdvice 可以访问到方法的返回值，但不可以更改返回值。</p>
<h3 id="AroundAdvice"><a href="#AroundAdvice" class="headerlink" title="AroundAdvice"></a>AroundAdvice</h3><p>Spring 中没有直接定义对应的 Around Advice 接口，而是直接采用 AOP Alliance 的标准接口，即 <code>org.aopalliance.intercept.MethodInterceptor</code>，该接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MethodInterceptor</span> <span class="keyword">extends</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">	Object <span class="title function_">invoke</span><span class="params">(<span class="meta">@Nonnull</span> MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 MethodInterceptor 的 invoke 方法的 MethodInvocation 参数，我们可以控制对相应 Joinpoint 的拦截行为。通过调用 invocation 的 proceed 方法，可以让程序执行继续沿着调用链传播，甚至捕获 proceed 方法可能抛出的异常。如果我们在哪一个 MethodInterceptor 中没有调用 proceed 方法，那么程序的执行将会在当前 MethodInterceptor 处断开执行，Joinpoint 上的调用链将被中断，同一 Joinpoint 上的其他 MethodInterceptor 的逻辑以及 Joinpoint 处的方法逻辑将不会被执行。</p>
<blockquote>
<p><strong>注意：</strong>除非清楚当前操作所产生的后果，不然千万不要忘记调用 proceed 方法。</p>
</blockquote>
<h2 id="per-instance-类型的-Advice"><a href="#per-instance-类型的-Advice" class="headerlink" title="per-instance 类型的 Advice"></a>per-instance 类型的 Advice</h2><p>与 per-class 类型的 Advice 不同，per-instance 类型的 Advice 不会在目标类所有对象实例之间共享，而是会为不同的实例对象保存它们各自的状态以及相关逻辑。</p>
<p>在 Spring AOP 中，Introduction 就是唯一的一种 per-instance 型 Advice。Introduction 可以在不改动目标类定义的情况下，为目标类添加新的属性以及行为。</p>
<p>在 Spring 中，为目标对象添加新的属性和行为必须声明相应的接口以及相应的实现。这样，再通过特定的拦截器将新的接口定义以及实现类中的逻辑附加到目标对象之上。之后，目标对象（确切地说是目标对象的代理对象）就拥有了新的状态和行为。这个特定的拦截器就是 <code>org.springframework.aop.IntroductionInterceptor</code>，其定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DynamicIntroductionAdvice</span> <span class="keyword">extends</span> <span class="title class_">Advice</span> &#123;</span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">implementsInterface</span><span class="params">(Class&lt;?&gt; intf)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IntroductionInterceptor</span> <span class="keyword">extends</span> <span class="title class_">MethodInterceptor</span>, DynamicIntroductionAdvice &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IntroductionInterceptor 继承了 MethodInterceptor 以及 DynamicIntroductionAdvice。</p>
<ul>
<li>通过 DynamicIntroductionAdvice，我们可以界定当前的 IntroductionInterceptor 为哪些接口提供相应的拦截功能；</li>
<li>通过 MethodInterceptor，IntroductionInterceptor 可以处理新添加的接口上的方法调用了。</li>
</ul>
<p>对于 IntroductionInterceptor 来说如果是新增加的接口上的方法调用，不必去调用 MethodInterceptor 的 proceed 方法，因为当前被拦截的方法实际上就是整个调用链中要最终执行的唯一方法。</p>
<p>因为 Introduction 较之其他 Advice 有些特殊，所以，我们有必要从总体上看一下 Spring 中对 Introduction 的支持结构：</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/Introduction%E7%9B%B8%E5%85%B3%E7%B1%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="Introduction相关类结构图"></p>
<p>Introduction 型的 Advice 两条分支，一条是以 DynamicIntroductionAdvice 为首的动态分支，另一条是以 IntroductionInfo 为首的静态可配置分支。</p>
<p>使用 DynamicIntroductionAdvice，我们可以到运行时再去判定当前 Introduction 可应用到的目标接口类型，而不用预先设定。而 IntroductionInfo 类型则完全相反，其定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IntroductionInfo</span> &#123;</span><br><span class="line">	Class&lt;?&gt;[] getInterfaces();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现类必须返回预定的目标接口类型，这样，在对 IntroductionInfo 型的 Introduction 进行织入的时候，实际上就不需要指定目标接口类型了，因为它自身就带有这些必要的信息。</p>
<p>大多数时候，我们如果要对目标对象拦截并添加 Introduction 逻辑，可以直接使用 Spring 提供的两个现成的实现类就可以了。</p>
<h3 id="DelegatingIntroductionInterceptor"><a href="#DelegatingIntroductionInterceptor" class="headerlink" title="DelegatingIntroductionInterceptor"></a>DelegatingIntroductionInterceptor</h3><p>DelegatingIntroductionInterceptor 不会自己实现将要添加到目标对象上的新的逻辑行为，而是委派给其他实现类，用法像这样：</p>
<blockquote>
<p>以简化开发人员为例，有时候测试人员忙不过来了，可能就会要几个开发人员过去帮忙做测试，那么这个时候原来的开发人员就拥有了测试人员的行为和属性。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IDeveloper</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">developSoftware</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Developer</span> <span class="keyword">implements</span> <span class="title class_">IDeveloper</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">developSoftware</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am happy with programming&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要为 Developer 添加测试人员的职能，要先将测试人员的职能定义成接口，像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITester</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isBusyAsTester</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSoftware</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后要给出测试人员的实现类，在实现类中给出要添加到目标对象（开发人员）的具体逻辑。当目标对象将要行使新的职能的时候，会通过该实现类寻求帮助：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tester</span> <span class="keyword">implements</span> <span class="title class_">ITester</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> busyAsTester;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSoftware</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I will ensure the quality&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBusyAsTester</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> busyAsTester;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBusyAsTester</span><span class="params">(<span class="type">boolean</span> busyAsTester)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.busyAsTester = busyAsTester;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 DelegatingIntroductionInterceptor 进行 Introduction 的拦截。有了新增加职能的接口定义以及相应实现类，使用 DelegatingIntroductionInterceptor，我们就可以把具体的 Inroduction 拦截委托给具体的实现类来完成，像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ITester</span> <span class="variable">delegate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tester</span>();</span><br><span class="line"><span class="type">DelegatingIntroductionInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DelegatingIntroductionInterceptor</span>(delegate);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给 developer 增加 tester 的职能</span></span><br><span class="line"><span class="type">IDeveloper</span> <span class="variable">developer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Developer</span>();</span><br><span class="line"><span class="type">ITester</span> <span class="variable">tester</span> <span class="operator">=</span> (ITester) weaver.weave(developer).with(interceptor).getProxy();</span><br><span class="line">tester.testSoftware();</span><br></pre></td></tr></table></figure>

<p>DelegatingIntroductionInterceptor 虽然是 Introduction 型的 Advice 实现，但它并没有兑现 Inroduction 作为 per-instance 型 Advice 的承诺。因为它只持有一个 “delegate”，供同一目标对象的所有实例共享使用，做不到为不同的实例对象保存它们各自的状态以及相关逻辑。</p>
<h3 id="DelegatePerTargetObjectIntroductionInterceptor"><a href="#DelegatePerTargetObjectIntroductionInterceptor" class="headerlink" title="DelegatePerTargetObjectIntroductionInterceptor"></a>DelegatePerTargetObjectIntroductionInterceptor</h3><p>与 DelegatingIntroductionInterceptor 不同 DelegatePerTargetObjectIntroductionInterceptor 会在内部持有一个目标对象与相应的 Introduction 逻辑实现类之间的映射关系。当每个目标对象上的新定义的接口方法被调用的时候，DelegatePerTargetObjectIntroductionInterceptor 会拦截这些调用，然后以目标对象实例作为键，到它持有的哪个映射关系中取得对应当前目标对象实例的 Introduction 实现类实例。</p>
<p>以此，DelegatePerTargetObjectIntroductionInterceptor 可以完全实现对 per-instance 的承诺。</p>
<p>与 DelegatingIntroductionInterceptor 的使用没有太大的区别，主要体现在构造方式上的不同。现在我们不需要自己构造 delegate 接口实例，而是只需要告知 DelegatePerTargetObjectIntroductionInterceptor 相应的 delegate 接口类型和对象实现类的类型，像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DelegatePerTargetObjectIntroductionInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DelegatePerTargetObjectIntroductionInterceptor</span>(Tester.class, ITester.class);</span><br></pre></td></tr></table></figure>

<hr>
<p>最后要说的是 Introduction 的性能问题。与 AspectJ 直接通过编译器将 Inroduction 织入目标对象不同，Spring AOP 采用的是动态代理机制，在性能上，Inroduction 型的 Advice 要差一些。如果有必要，可以考虑采用 AspectJ 的 Introduction 实现。</p>
<h1 id="Aspect"><a href="#Aspect" class="headerlink" title="Aspect"></a>Aspect</h1><p>Advisor 代表 Spring 中的 Aspect，但是与正常的 Aspect 不同，Advisor 通常只持有一个 Pointcut 和一个 Advice。理论上 Aspect 定义中可以有多个 Pointcut 和 Advice，所以，我们可以认为 Advisor 是一种特殊的 Aspect。</p>
<p>为了能够更清楚 Advisor 的实现结构体系，可以将 Advisor 简单划分为两个分支，一个分支以 <code>org.springframework.aop.PointcutAdvisor</code> 为首，另一个分支以 <code>org.springframework.aop.IntroductionAdvisor</code> 为首。</p>
<h2 id="PointcutAdvisor"><a href="#PointcutAdvisor" class="headerlink" title="PointcutAdvisor"></a>PointcutAdvisor</h2><p>实际上，PointcutAdvisor 才是真正定义一个 Pointcut 和一个 Advice 的 Advisor，大部分的 Advisor 实现都是 PointcutAdvisor 的实现类。</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/PointcutAdvisor%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%AD%90%E7%B1%BB.png" alt="PointcutAdvisor及相关子类"></p>
<h3 id="DefaultPointcutAdvisor"><a href="#DefaultPointcutAdvisor" class="headerlink" title="DefaultPointcutAdvisor"></a>DefaultPointcutAdvisor</h3><p>最通用的 PointcutAdvisor 实现，除了不能为其指定 Inroduction 类型的 Advice 之外，剩下的 任何类型的 Pointcut、任何类型的 Advice 都可以通过它来使用。使用起来像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> ...; <span class="comment">// 任何 Pointcut 类型</span></span><br><span class="line"><span class="type">Advice</span>   <span class="variable">advice</span>   <span class="operator">=</span> ...; <span class="comment">// 除 Inroduction 类型外的任何 Advice 类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">DefaultPointcutAdvisor</span> <span class="variable">advior</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(pointcut, advice);</span><br><span class="line"><span class="comment">// 可以通过构造器或者 setter 注入 pointcut 和 advice</span></span><br></pre></td></tr></table></figure>

<h3 id="NameMatchMethodPointcutAdvisor"><a href="#NameMatchMethodPointcutAdvisor" class="headerlink" title="NameMatchMethodPointcutAdvisor"></a>NameMatchMethodPointcutAdvisor</h3><p>限定了自身可以使用的 Pointcut 类型为 NameMatchMethodPointcut，且外部不可更改。不过，对于使用的 Advice 来说，除了 Inroduction，其他任何类型的 Advice 都可以使用。使用起来像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Advice</span> <span class="variable">advice</span> <span class="operator">=</span> ...; <span class="comment">// 除 Inroduction 类型外的任何 Advice 类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">NameMatchMethodPointcutAdvisor</span> <span class="variable">advior</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NameMatchMethodPointcutAdvisor</span>(advice);</span><br><span class="line">advior.setMappedName(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line"><span class="comment">// OR</span></span><br><span class="line">advior.setMappedNames(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;methodName1&quot;</span>, <span class="string">&quot;methodName2&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="RegexpMethodPointcutAdvisor"><a href="#RegexpMethodPointcutAdvisor" class="headerlink" title="RegexpMethodPointcutAdvisor"></a>RegexpMethodPointcutAdvisor</h3><p>限定了自身可以使用的 Pointcut 的类型，即只能通过正则表达式为其设置相应的 Pointcut。</p>
<p>其自身内部持有一个 AbstractRegexpMethodPointcut 的实例。AbstractRegexpMethodPointcut 有两个子类，即 JdkRegexpMethodPointcut 和 Perl5RegexpMethodPointcut。默认会使用 JdkRegexpMethodPointcut，如果要强制使用 Perl5RegexpMethodPointcut 可以通过 setPerl5(boolean) 方法设置。</p>
<h3 id="DefaultBeanFactoryPointcutAdvisor"><a href="#DefaultBeanFactoryPointcutAdvisor" class="headerlink" title="DefaultBeanFactoryPointcutAdvisor"></a>DefaultBeanFactoryPointcutAdvisor</h3><p>使用较少，其使用必须绑定 IoC 容器，作用是可以通过容器中注册的 Advice 注册的 BeanName 来关联对应的 Advice。</p>
<h2 id="IntroductionAdvisor"><a href="#IntroductionAdvisor" class="headerlink" title="IntroductionAdvisor"></a>IntroductionAdvisor</h2><p>IntroductionAdvisor 只能应用于类级别的拦截，只能使用 Inroduction 型的 Advice，纯粹就是为了 Inroduction 而生的。只有一个默认实现：DefaultIntroductionAdvisor。使用起来也比较简单，只可以指定 Inroduction 型的 Advice（即 IntroductionInterceptor）以及将被拦截的接口类型。</p>
<h2 id="Ordered"><a href="#Ordered" class="headerlink" title="Ordered"></a>Ordered</h2><p>Spring 在处理同一 Joinpoint 处的多个 Advisor 的时候，实际上会按照指定的顺序和优先级来执行它们，顺序号决定优先级，顺序号越小，优先级越高，优先级排在前面的，将被优先执行。我们可以从0或者1开始指定，因为小于的顺序号原则上由 Spring AOP 框架内部使用。默认情况下，如果我们不明确指定各个 Advisor 的执行顺序，那么 Spring 会按照它们的声明顺序来应用它们，最先声明的顺序号最小但优先级最大，其次次之。</p>
<h1 id="织入"><a href="#织入" class="headerlink" title="织入"></a>织入</h1><p>在 Spring AOP 中，使用类 <code>org.springframework.aop.framework.ProxyFactory</code> 作为织入器。ProxyFactory 并非 Spring AOP 中唯一可用的织入器，而是最基本的一个织入器实现。</p>
<h1 id="TargetSource"><a href="#TargetSource" class="headerlink" title="TargetSource"></a>TargetSource</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://www.wrp.cool">码小瑞</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.wrp.cool/posts/22032/">https://www.wrp.cool/posts/22032/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.wrp.cool" target="_blank">知更</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/index_img.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/40742/"><img class="next-cover" src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/index_img.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">IoC和Spring IoC</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar123"/></div><div class="author-info__name">码小瑞</div><div class="author-info__description">一直在学习，永远在路上</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">79</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/wangruipeng-wrp"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Joinpoint"><span class="toc-number">1.</span> <span class="toc-text">Joinpoint</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Pointcut"><span class="toc-number">2.</span> <span class="toc-text">Pointcut</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ClassFilter"><span class="toc-number">2.1.</span> <span class="toc-text">ClassFilter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MethodMatcher"><span class="toc-number">2.2.</span> <span class="toc-text">MethodMatcher</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NameMatchMethodPointcut"><span class="toc-number">2.2.1.</span> <span class="toc-text">NameMatchMethodPointcut</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JdkRegexpMethodPointcut%E5%92%8CPerl5RegexpMethodPointcut"><span class="toc-number">2.2.2.</span> <span class="toc-text">JdkRegexpMethodPointcut和Perl5RegexpMethodPointcut</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AnnotationMatchingPointcut"><span class="toc-number">2.2.3.</span> <span class="toc-text">AnnotationMatchingPointcut</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ComposablePointcut"><span class="toc-number">2.2.4.</span> <span class="toc-text">ComposablePointcut</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ControlFlowPointcut"><span class="toc-number">2.2.5.</span> <span class="toc-text">ControlFlowPointcut</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-StaticMethodMatcherPointcut"><span class="toc-number">2.2.6.</span> <span class="toc-text">自定义 StaticMethodMatcherPointcut</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-DynamicMethodMatcherPointcut"><span class="toc-number">2.2.7.</span> <span class="toc-text">自定义 DynamicMethodMatcherPointcut</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Advice"><span class="toc-number">3.</span> <span class="toc-text">Advice</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#per-class-%E7%B1%BB%E5%9E%8B%E7%9A%84-Advice"><span class="toc-number">3.1.</span> <span class="toc-text">per-class 类型的 Advice</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BeforeAdvice"><span class="toc-number">3.1.1.</span> <span class="toc-text">BeforeAdvice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThrowsAdvice"><span class="toc-number">3.1.2.</span> <span class="toc-text">ThrowsAdvice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AfterReturningAdvice"><span class="toc-number">3.1.3.</span> <span class="toc-text">AfterReturningAdvice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AroundAdvice"><span class="toc-number">3.1.4.</span> <span class="toc-text">AroundAdvice</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#per-instance-%E7%B1%BB%E5%9E%8B%E7%9A%84-Advice"><span class="toc-number">3.2.</span> <span class="toc-text">per-instance 类型的 Advice</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DelegatingIntroductionInterceptor"><span class="toc-number">3.2.1.</span> <span class="toc-text">DelegatingIntroductionInterceptor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DelegatePerTargetObjectIntroductionInterceptor"><span class="toc-number">3.2.2.</span> <span class="toc-text">DelegatePerTargetObjectIntroductionInterceptor</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Aspect"><span class="toc-number">4.</span> <span class="toc-text">Aspect</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#PointcutAdvisor"><span class="toc-number">4.1.</span> <span class="toc-text">PointcutAdvisor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DefaultPointcutAdvisor"><span class="toc-number">4.1.1.</span> <span class="toc-text">DefaultPointcutAdvisor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NameMatchMethodPointcutAdvisor"><span class="toc-number">4.1.2.</span> <span class="toc-text">NameMatchMethodPointcutAdvisor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RegexpMethodPointcutAdvisor"><span class="toc-number">4.1.3.</span> <span class="toc-text">RegexpMethodPointcutAdvisor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DefaultBeanFactoryPointcutAdvisor"><span class="toc-number">4.1.4.</span> <span class="toc-text">DefaultBeanFactoryPointcutAdvisor</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IntroductionAdvisor"><span class="toc-number">4.2.</span> <span class="toc-text">IntroductionAdvisor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ordered"><span class="toc-number">4.3.</span> <span class="toc-text">Ordered</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%87%E5%85%A5"><span class="toc-number">5.</span> <span class="toc-text">织入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TargetSource"><span class="toc-number">6.</span> <span class="toc-text">TargetSource</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/22032/" title="Spring AOP 实现">Spring AOP 实现</a><time datetime="2022-12-04T03:46:38.000Z" title="发表于 2022-12-04 11:46:38">2022-12-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/40742/" title="IoC和Spring IoC">IoC和Spring IoC</a><time datetime="2022-11-30T10:39:50.000Z" title="发表于 2022-11-30 18:39:50">2022-11-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/38849/" title="行为型设计模式">行为型设计模式</a><time datetime="2022-11-17T05:35:23.000Z" title="发表于 2022-11-17 13:35:23">2022-11-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/56424/" title="结构型设计模式">结构型设计模式</a><time datetime="2022-11-17T05:35:08.000Z" title="发表于 2022-11-17 13:35:08">2022-11-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/31805/" title="创建型设计模式">创建型设计模式</a><time datetime="2022-11-17T05:09:37.000Z" title="发表于 2022-11-17 13:09:37">2022-11-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 码小瑞</div><div class="footer_custom_text"><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/icp.png" style="display:inline; padding:0 4px; vertical-align:text-bottom; max-height:1.4em; width:auto;"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">粤ICP备 19093360 号</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'xHUEmhrVmHWv8MupdDvR9FvM-gzGzoHsz',
      appKey: 'Cr1qzcPhqKCVqEhTSX6TRoa4',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="100" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>