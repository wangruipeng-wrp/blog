<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>《写在前面》</title>
    <url>/posts/62949/</url>
    <content><![CDATA[<div class="note success flat"><p>以宁静敬重的心写下的每一行代码，都会以最优雅的方式留存它的美丽。</p>
</div>

<ul>
<li><font size=3> 我在这里分享我所学的一些技术；</font></li>
<li><font size=3> 我在这里分享一些我喜欢的电影；</font></li>
<li><font size=3> 我在这里分享一些我喜欢的书；</font></li>
<li><font size=3><strong>我在这里，我一直在学习，我永远在路上。</strong></font></li>
</ul>
<hr>
<p>大家加油：）</p>
]]></content>
  </entry>
  <entry>
    <title>JVM 垃圾回收</title>
    <url>/posts/23073/</url>
    <content><![CDATA[<h1 id="对象已死？"><a href="#对象已死？" class="headerlink" title="对象已死？"></a>对象已死？</h1><p>在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”（“死去”即不可能再被任何途径使用的对象）了。</p>
<h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><p>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</p>
<p><strong>优点：</strong>原理简单，判断效率高。<br><strong>缺点：</strong>无法解决循环引用问题。</p>
<h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E5%88%A9%E7%94%A8%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E5%9B%9E%E6%94%B6.png" alt="利用可达性分析算法判断对象是否可回收"></p>
<h3 id="GC-Roots-对象"><a href="#GC-Roots-对象" class="headerlink" title="GC Roots 对象"></a>GC Roots 对象</h3><p><strong>固定对象：</strong></p>
<ul>
<li>栈帧中的本地变量表中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</li>
<li>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。</li>
<li>在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。</li>
<li>在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</li>
<li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</li>
<li>所有被同步锁（synchronized关键字）持有的对象。</li>
<li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>
</ul>
<p><strong>临时性对象：</strong></p>
<p>如果只针对 Java 堆中的某一块区域发起垃圾回收，必须考虑到内存区域并不是封闭独立的所以某个区域里的对象完全有可能被位于堆中其他区域的对象所引用，这时候就需要将这些关联区域的对象也一并加入GC Roots集合中去，才能保证可达性分析的正确性。</p>
<h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h3><p>可以用来做外部资源回收的工作，但是 try-finally 可以做的更好，并且 finalize() 方法执行效率低、执行成本高、不确定性大，所以一般不推荐使用，仅作了解。</p>
<p>真正宣告一个对象死亡，要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。</p>
<p>这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。这样做的原因是，如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。</p>
<p>如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 此代码演示了两点：</span></span><br><span class="line"><span class="comment">* 1.对象可以在被GC时自我拯救。</span></span><br><span class="line"><span class="comment">* 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalizeEscapeGC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">FinalizeEscapeGC</span> <span class="variable">SAVE_HOOK</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">isAlive</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;yes, I am still alive :)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;finalize method executed!&quot;</span>);</span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> <span class="title class_">FinalizeEscapeGC</span>();</span><br><span class="line">        <span class="comment">//对象第一次成功拯救自己</span></span><br><span class="line">        SAVE_HOOK = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="literal">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;no, I am dead :(&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下面这段代码与上面的完全相同，但是这次自救却失败了</span></span><br><span class="line">        SAVE_HOOK = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="literal">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;no, I am dead :(&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四大引用类型"><a href="#四大引用类型" class="headerlink" title="四大引用类型"></a>四大引用类型</h2><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似 <code>Object obj=new Object()</code> 这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></table></figure>

<h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">// 使对象只被弱引用关联</span></span><br></pre></td></tr></table></figure>

<h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">// 使对象只被虚引用关联</span></span><br></pre></td></tr></table></figure>

<h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。</p>
<p><strong>缺点：</strong></p>
<ol>
<li>效率不稳定，效率随着需要被回收的对象的增多而降低。</li>
<li>内存空间碎片化，会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li>
</ol>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E2%80%9C%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E2%80%9D%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="“标记-清除”算法示意图"></p>
<h2 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h2><p>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>
<p><strong>优点：</strong>对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。</p>
<p><strong>缺点：</strong>将可用内存缩小为了原来的一半。</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="标记-复制算法示意图"></p>
<p>现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。</p>
<p>HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。</p>
<h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>标记过程与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E2%80%9C%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E2%80%9D%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="“标记-整理”算法示意图"></p>
<p><code>标记-清除</code>算法与<code>标记-整理</code>算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策：</p>
<ul>
<li><strong>移动：</strong>移动操作必须全程暂停用户应用程序才能进行</li>
<li><strong>不移动：</strong>存活对象所导致的内存碎片化问题</li>
</ul>
<p>是否移动对象都存在弊端，移动则内存回收时会更复杂，不移动则内存分配时会更复杂</p>
<blockquote>
<p>有一种“和稀泥式”解决方案可以不在内存分配和访问上增加太大额外负担，做法是让虚拟机平时多数时间都采用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经大到影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间。</p>
</blockquote>
<h1 id="经典垃圾收集器"><a href="#经典垃圾收集器" class="headerlink" title="经典垃圾收集器"></a>经典垃圾收集器</h1><h2 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h2><p>“分代收集”（Generational Collection）的理论建立在两个分代假说之上：</p>
<ul>
<li>弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。</li>
<li>强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。</li>
</ul>
<p><em>分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则。</em></p>
<p>这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：<strong>收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。</strong></p>
<blockquote>
<p>显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间；如果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。</p>
</blockquote>
<p>设计者一般至少会把Java堆划分为新生代（Young Generation）和老年代（Old Generation）两个区域。顾名思义，在新生代中，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。</p>
<p>但是分代收集并非只是简单划分一下内存区域那么容易，它至少存在一个明显的困难：<strong>对象不是孤立的，对象之间会存在跨代引用。</strong>为了解决这个问题，就需要对分代收集理论添加第三条经验法则：</p>
<ul>
<li>跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。</li>
</ul>
<p>依据这条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构（该结构被称为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GCRoots进行扫描。虽然这种方法需要在对象改变引用关系（如将自己或者某个属性赋值）时维护记录数据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。</p>
<h2 id="垃圾收集器图示"><a href="#垃圾收集器图示" class="headerlink" title="垃圾收集器图示"></a>垃圾收集器图示</h2><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="HotSpot虚拟机的垃圾收集器"></p>
<p>图展示了七种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用，图中收集器所处的区域，则表示它是属于新生代收集器抑或是老年代收集器。</p>
<h2 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h2><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/SerialSerialOld%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="SerialSerial Old收集器运行示意图"></p>
<p>这个收集器是一个单线程工作的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。</p>
<p><strong>优点：</strong>简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。<br><strong>缺点：</strong>在进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。</p>
<p><strong>适用场景：</strong>对于内存资源受限的环境，它是所有收集器里额外内存消耗（Memory Footprint）最小的；对于单核处理器或处理器核心数较少的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p>
<h2 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h2><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/ParNewSerialOld%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="ParNewSerial Old收集器运行示意图"></p>
<p>它是 Serial 收集器的多线程版本。</p>
<p>是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。</p>
<p>默认开启的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。</p>
<h2 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h2><p>Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）</p>
<p>Parallel Scavenge收集器ᨀ供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX：MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX：GCTimeRatio参数。</p>
<p><strong>-XX：MaxGCPauseMillis：</strong>参数允许的值是一个大于0的毫秒数，收集器将尽力保证内存回收花费的时间不超过用户设定值。但垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的。</p>
<p><strong>-XX：GCTimeRatio：</strong>参数的值则应当是一个大于0小于100的整数，也就是垃圾收集时间占总时间的比率，相当于吞吐量的倒数。譬如把此参数设置为19，那允许的最大垃圾收集时间就占总时间的5%（即1&#x2F;(1+19)），默认值为99，即允许最大1%（即1&#x2F;(1+99)）的垃圾收集时间。</p>
<h2 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h2><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/SerialSerialOld%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="SerialSerial Old收集器运行示意图"></p>
<p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。在服务端模式下有两大用途：</p>
<ol>
<li>在 JDK 1.5 以及之前版本(Parallel Old 诞生以前)中与 Parallel Scavenge 收集器搭配使用。</li>
<li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li>
</ol>
<h2 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h2><p>Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/ParallelScavengeParallelOld%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Parallel ScavengeParallel Old收集器运行示意图"></p>
<h2 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h2><blockquote>
<p>CMS（Concurrent Mark Sweep）收集器是一种基于<strong>标记-清除</strong>算法实现的，以获取<strong>最短回收停顿时间</strong>为目标的收集器。<strong>优点：</strong>并发收集、低停顿。</p>
</blockquote>
<p><strong>整个运作过程分为四步：</strong></p>
<ol>
<li><strong>初始标记：</strong>仅仅只是标记一下GC Roots能直接关联到的对象，速度很快</li>
<li><strong>并发标记：</strong>从GC Roots的直接关联对象开始遍历整个对象图，耗时较长但是不需要停顿用户线程</li>
<li><strong>重新标记：</strong>修正在并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</li>
<li><strong>并发清除：</strong>使用标记-清除算法清理删除掉标记阶段判断的已经死亡的对象，不需要移动存活对象</li>
</ol>
<p>由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一起工作，所以从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/ConcurrentMarkSweep%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="ConcurrentMarkSweep收集器运行示意图"></p>
<p><strong>四个缺点：</strong></p>
<ol>
<li>与用户线程并发执行期间，会占用一部分线程而导致应用程序变慢而降低总吞吐量</li>
<li>款基于“标记-清除”算法实现，收集结束时可能会有大量空间碎片产生</li>
<li>无法清理浮动垃圾：在CMS的并发标记和并发清理阶段，用户线程是还在继续运行，会有新的垃圾对象产生。这部分垃圾就称为“浮动垃圾”，只能等下一次垃圾清楚再回收</li>
<li>需要预留空间：由于在垃圾收集阶段用户线程还需要持续运行，那就还需要预留足够内存空间提供给用户线程使用，因此CMS收集器必须预留一部分空间供并发收集时的程序运作使用</li>
</ol>
<hr>
<blockquote>
<p><strong>巨人的肩膀：</strong></p>
<ul>
<li>《深入理解Java虚拟机》</li>
</ul>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Java对象内存结构</title>
    <url>/posts/4996/</url>
    <content><![CDATA[<h1 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h1><p>当 new 一个新的对象时，首先检查这个对象所属的类是否已经被加载、解析和初始化。如果没有那必须先执行类加载过程。接下来虚拟机将为新生对象分配内存，为对象分配空间的任务实际上便等同于把一块确定大小的内存块（类加载完毕后对象大小也被确定）从 Java 堆中划分出来。</p>
<h2 id="对象内存空间分配"><a href="#对象内存空间分配" class="headerlink" title="对象内存空间分配"></a>对象内存空间分配</h2><p>分配空间有两种方式：指针碰撞和空闲列表。</p>
<p><strong>指针碰撞：</strong>假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”（Bump The Pointer）。</p>
<p><strong>空闲列表：</strong>但如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”（Free List）。</p>
<blockquote>
<p>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理（Compact）的能力决定。因此，当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用CMS这种基于清（Sweep）算法的收集器时，“理论上”就只能采用较为复杂的空闲列表来分配内存。<em>（CMS的实现里面，为了能在多数情况下分配得更快，设计了一个叫作Linear Allocation Buffer的分配缓冲区，通过空闲列表拿到一大块分配缓冲区之后，在它里面仍然可以使用指针碰撞方式来分配。）</em></p>
</blockquote>
<h2 id="指向新对象"><a href="#指向新对象" class="headerlink" title="指向新对象"></a>指向新对象</h2><p>对象创建在虚拟机中是非常频繁的行为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题关键是为对象内存分配这个动作提供原子性保证，有两种可选方案：CAS和线程隔离。</p>
<p><strong>CAS：</strong>对分配内存空间的动作进行同步处理，CAS配上失败重试的方式保证更新操作的原子性</p>
<p><strong>线程隔离：</strong>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。是否使用TLAB，可以通过-XX：+&#x2F;-UseTLAB参数来设定。</p>
<h2 id="初始化新对象"><a href="#初始化新对象" class="headerlink" title="初始化新对象"></a>初始化新对象</h2><p><strong>内存空间初始化：</strong>内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值，如果使用了TLAB的话，这一项工作也可以ᨀ前至TLAB分配时顺便进行。这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。</p>
<p><strong>对象头初始化：</strong>接下来，Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（懒加载）、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<h1 id="堆内存中的对象"><a href="#堆内存中的对象" class="headerlink" title="堆内存中的对象"></a>堆内存中的对象</h1><p>对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p>
<h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>HotSpot虚拟机对象的对象头部分包括两类信息：一类是用于存储对象自身的运行时数据，另一类是类型指针。</p>
<p><strong>对象自身的运行时数据：</strong>哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。</p>
<p><strong>类型指针：</strong>即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。</p>
<p>此外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据。</p>
<h2 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h2><p>实例数据部分是对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。</p>
<p>HotSpot虚拟机默认的分配顺序为longs&#x2F;doubles、ints、shorts&#x2F;chars、bytes&#x2F;booleans、oops（Ordinary Object Pointers，oops）</p>
<h2 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h2><p>对象的第三部分是对齐填充，这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是任何对象的大小都必须是8字节的整数倍。对象头部分已经被精心设计成正好是8字节的倍数（1倍或者2倍），因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p>
<h1 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h1><p>Java程序会通过栈上的reference数据来操作堆上的具体对象，主流的访问方式有两种：句柄、直接指针。</p>
<p><strong>句柄：</strong>使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。</p>
<p>使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E9%80%9A%E8%BF%87%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png" alt="通过句柄访问对象"></p>
<p><strong>直接指针：</strong>使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。</p>
<p>使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本。</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E9%80%9A%E8%BF%87%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png" alt="通过直接指针访问对象"></p>
<hr>
<blockquote>
<p><strong>巨人的肩膀：</strong></p>
<ul>
<li>《深入理解Java虚拟机》</li>
</ul>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>线程基础（下）</title>
    <url>/posts/32328/</url>
    <content><![CDATA[<p>承接上文，本文将介绍：线程的生命周期、如何捕获线程异常、以及可以让并行变串行的join()方法</p>
<h1 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h1><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4800715d63964fe28eaaebac61c364c4~tplv-k3u1fbpfcp-watermark.image" alt="线程的6个状态.png"></p>
<blockquote>
<p>在这张图片中，包含了线程的所有状态以及每种状态之间的互相转换过程。其中箭头的指向是固定的，单箭头的指向则表明了两个线程的状态是不可逆的，一旦从一端到另一端之后就无法再回去原来的状态。</p>
</blockquote>
<h2 id="NEW、RUNNABLE、TERMINATED"><a href="#NEW、RUNNABLE、TERMINATED" class="headerlink" title="NEW、RUNNABLE、TERMINATED"></a>NEW、RUNNABLE、TERMINATED</h2><ol>
<li><p><em>新创建（NEW）</em><br>线程一经创建，也就是去 new 了一个 Thread 类之后，未调用 start 方法之前，这时的线程就是「新创建」的状态</p>
</li>
<li><p><em>可运行（RUNNABLE）</em><br>有些地方可能将「可运行」状态称之为「就绪」状态，这两者其实都是「RUNNABLE」状态</p>
<p> 调用 start 方法开始，直到 run 方法中的代码执行完毕之前，如果没有其他的操作使得线程状态跑到上图右边的三种状态中去的话，线程将会一直处于「可运行」状态。</p>
<p> 注意：线程并没有一个「运行」的状态，就算是正在执行 run() 方法的线程状态也是「可运行」状态。</p>
</li>
<li><p><em>已终止（TERMINATED）</em><br>当 run 方法的代码执行完毕或者是抛出未处理的异常的时，线程就会处于「已终止」状态中。这个状态也是线程的最终状态，线程一旦进入了这个状态将无法再回到其他的状态中。</p>
<p> NEW、RUNNABLE、TERMINATED 这三种状态都是单向的，是无法返回的。NEW –&gt; RUNNABLE –&gt; TERMINATED</p>
</li>
<li><p><em>代码演示</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">500</span>)</span><br><span class="line">                <span class="comment">// run() 方法执行中</span></span><br><span class="line">                System.out.println(<span class="string">&quot;thread.state = &quot;</span> + Thread.currentThread().getState());  <span class="comment">// RUNNABLE</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;thread.state = &quot;</span> + thread.getState());  <span class="comment">// NEW</span></span><br><span class="line"></span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(<span class="string">&quot;thread.state = &quot;</span> + thread.getState());  <span class="comment">// RUNNABLE</span></span><br><span class="line"></span><br><span class="line">    thread.join();</span><br><span class="line">    System.out.println(<span class="string">&quot;thread.state = &quot;</span> + thread.getState());  <span class="comment">// TERMINATED</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="BLOCKED、WAITING、TIMED-WAITING"><a href="#BLOCKED、WAITING、TIMED-WAITING" class="headerlink" title="BLOCKED、WAITING、TIMED_WAITING"></a>BLOCKED、WAITING、TIMED_WAITING</h2><ol>
<li><p><em>被阻塞（BLOCKED）</em><br>如果线程执行了一个被 synchronize 关键字修饰的代码块，并且这个代码块还处于其他线程的执行之中，这时调用的线程就会处于阻塞的状态，等待其他线程执行完毕后再执行。<br>等待的这个线程在等待的时间内就是处于 <em>BLOCKED</em> 状态。</p>
<blockquote>
<p>习惯上来说 BLOCKED、WAITING、TIMED_WAITING 都称之为阻塞状态，而不仅仅是 BLOCKED。</p>
</blockquote>
</li>
<li><p><em>等待(WAITING)</em> 和 <em>计时等待(TIMED_WAITING)</em><br>当线程阻塞时就会进入等待的状态。其中等待和计时等待非常好理解，有带 time 参数的等待就是计时等待，反之则是等待。</p>
</li>
<li><p><em>代码演示</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">5</span>); <span class="comment">// 让 t1 和 t2 先跑一会</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;t1 sleep(50) t1.state = &quot;</span>+t1.getState()); <span class="comment">// TIMED_WAITING</span></span><br><span class="line">        System.out.println(<span class="string">&quot;t1 get LOCK，t2 be BLOCKED t2.state = &quot;</span> + t2.getState()); <span class="comment">// BLOCKED</span></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>); <span class="comment">// 进入 wait() 中</span></span><br><span class="line">        System.out.println(<span class="string">&quot;t1 wait(), t1.state = &quot;</span> + t1.getState()); <span class="comment">// WAITING</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="捕获线程异常"><a href="#捕获线程异常" class="headerlink" title="捕获线程异常"></a>捕获线程异常</h1><p>由于 Runnable 和 Thread 之间的解耦设计，导致 Thread 在运行 Runnable 时其实是无法感知到 Runnable 内部的运行逻辑的，Thread 无法知道这个线程执行完了是否需要处理返回值，是否会抛出什么异常等等</p>
<p>例如线程池，线程池中的 Thread 根本不知道会传进来一个什么样的 Runnable，对于 Thread 而言，只关注执行上的逻辑，而不关注 Runnable 内部的逻辑。</p>
<p>毫无疑问这样的设计是优秀的，但如果线程在执行的过程当中发生了异常，那处理起来就不是很方便了。针对这种情况可以利用 Thread.UncaughtExceptionHandler 捕获异常。</p>
<p>如果主线程抛出一个异常，可以直接使用 <code>try-catch</code> 捕获处理这个异常。如果异常是子线程中抛出的，那么主线程对这个异常并不敏感，无法直接捕获处理这个异常。虽然在控制台能看到异常信息，但是这个异常信息是子线程输出的，主线程并无法感知到这个异常，之所以能在控制台看到异常信息，是因为主线程与子线程共用了同一个控制台。</p>
<p>如果还不是很理解上面这段话，你可以跑一下这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;我是子线程抛出来的异常&quot;</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">5000</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;我是主线程抛出来的异常&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                System.out.println(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于主线程的异常，可以直接使用 <code>try-catch</code> 来捕获处理。对于子线程的异常，每次抛出异常的时机都不相同，主线程无法知道什么时候子线程会抛出异常，更无法捕获处理子线程中的异常。</p>
<p>其实这个例子也很形象的向我们展示了线程的工作过程：每个线程在执行期间是互不打扰的，自己干自己的事情。每个线程在领取到自己的任务（run方法）之后，等待被分配资源开始执行（start方法）之后便是一直闷头干下去，直到把工作做完（run方法执行完毕）</p>
<p>这样就要求子线程必须能够自行处理异常，也就是在子线程内部使用 <code>try-catch</code> 来处理异常。但子线程不一定能够处理自己的异常，有些异常需要向外通知父线程，让父线程去执行对应的处理逻辑。</p>
<p>这样看来，子线程更像是父线程的一个方法，异常可以在方法中使用 <code>try-catch</code> 自行处理，也可以标记在方法签名上向外抛出。</p>
<p>针对需要通知父线程处理的异常，可以使用 <em>Thread.UncaughtExceptionHandler</em> 这个接口来接收并处理异常。</p>
<p>这个接口的使用方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义的线程异常处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MyUncaughtExceptionHandler</span> <span class="keyword">implements</span> <span class="title class_">Thread</span>.UncaughtExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyUncaughtExceptionHandler</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;：成功捕获了异常。抛出异常的线程是：&quot;</span> + t.getName() + <span class="string">&quot;。抛出的异常是：&quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 方式一：设置为默认异常处理器</span></span><br><span class="line">    <span class="comment">// MyUncaughtExceptionHandler --&gt; Thread.defaultUncaughtExceptionHandler</span></span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> <span class="title class_">MyUncaughtExceptionHandler</span>(<span class="string">&quot;默认的线程异常处理器&quot;</span>));</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>()).start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式二：设置为线程专用的异常处理器</span></span><br><span class="line">    <span class="comment">// MyUncaughtExceptionHandler --&gt; t.uncaughtExceptionHandler</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>(), <span class="string">&quot;Thread-0&quot;</span>);</span><br><span class="line">    t.setUncaughtExceptionHandler(<span class="keyword">new</span> <span class="title class_">MyUncaughtExceptionHandler</span>(<span class="string">&quot;为 Thread-0 专门设置的异常处理器&quot;</span>));</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Task 抛出的异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先创建一个类实现 <code>Thread.UncaughtExceptionHandler</code> 作为自定义的线程异常处理器，再根据需要设置为默认的异常处理器，或者是为每个线程单独设置的异常处理器。</p>
<p>如果没有单独设置异常处理器也没有设置默认的异常处理器，那么调用 <code>ThreadGroup</code> 类对异常做处理，该类实现了 <code>Thread.UncaughtExceptionHandler</code> 接口，内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 首先检查是否存在父线程组，如果存在则调用父线程组的异常处理器进行处理，这里是一个递归的操作</span></span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">        parent.uncaughtException(t, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取全局异常处理器</span></span><br><span class="line">        Thread.<span class="type">UncaughtExceptionHandler</span> <span class="variable">ueh</span> <span class="operator">=</span> Thread.getDefaultUncaughtExceptionHandler();</span><br><span class="line">        <span class="comment">// 尝试使用全局异常处理器处理</span></span><br><span class="line">        <span class="keyword">if</span> (ueh != <span class="literal">null</span>) &#123;</span><br><span class="line">            ueh.uncaughtException(t, e);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(e <span class="keyword">instanceof</span> ThreadDeath)) &#123;</span><br><span class="line">            <span class="comment">// 不存在全局异常处理器，直接将异常的堆栈信息打印出来</span></span><br><span class="line">            System.err.print(<span class="string">&quot;Exception in thread \&quot;&quot;</span> + t.getName() + <span class="string">&quot;\&quot; &quot;</span>);</span><br><span class="line">            e.printStackTrace(System.err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="并行变串行，join"><a href="#并行变串行，join" class="headerlink" title="并行变串行，join()"></a>并行变串行，join()</h1><blockquote>
<p>join方法的作用是同步。在主线程中去创建并启动一个线程，再调用这个线程的join方法之后，会使得两个线程原本是并行关系变成串行关系，也就是主线程将会等待子线程执行完毕之后再继续执行。</p>
</blockquote>
<p>注意：join方法可以传入一个long类型的参数，表示过了多少毫秒之后两个线程将由串行关系再次转变成并行关系。但如果传入的参数是0的话，表示的是永久等待，也就是主线程将会等待直到子线程执行完毕之后再次执行，相当于不传参数的join方法。</p>
<p><strong>代码演示：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;开始执行&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Test</span>());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Test</span>());</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;所有子线程执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main方法执行结果</span></span><br><span class="line"><span class="comment">// 子线程Thread-0开始执行</span></span><br><span class="line"><span class="comment">// 子线程Thread-1开始执行</span></span><br><span class="line"><span class="comment">// 子线程Thread-0执行完毕</span></span><br><span class="line"><span class="comment">// 子线程Thread-1执行完毕</span></span><br><span class="line"><span class="comment">// 所有子线程执行完毕</span></span><br></pre></td></tr></table></figure>

<p>上面的代码如果将两个线程执行join方法的那行代码注释掉，则执行结果为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">所有子线程执行完毕</span><br><span class="line">子线程Thread-<span class="number">0</span>开始执行</span><br><span class="line">子线程Thread-<span class="number">1</span>开始执行</span><br><span class="line">子线程Thread-<span class="number">1</span>执行完毕</span><br><span class="line">子线程Thread-<span class="number">0</span>执行完毕</span><br></pre></td></tr></table></figure>

<p>很明显，join方法的调用会使得主线程去等待子线程执行完毕之后再重新执行代码。</p>
<h2 id="join期间被中断"><a href="#join期间被中断" class="headerlink" title="join期间被中断"></a>join期间被中断</h2><blockquote>
<p>如果主线程调用子线程的 join() 方法后，在子线程执行的期间，有 interrupt 通知进入了，怎么办？</p>
</blockquote>
<p>针对上面的问题，我再重申一下关于 join() 方法作用的介绍。<strong>主线程将会等待调用了join方法的子线程执行完毕后再继续执行</strong></p>
<p>实际上，是主线程在等待子线程执行完毕，也就是说陷入阻塞状态的是主线程而不是子线程。所以关于上面的问题如果有 interrupt 通知进入了主线程将会抛出一个 InterruptedException 来响应这个 interrupt 通知。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">mainThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        mainThread.interrupt();</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        thread.join();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程被中断了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main方法执行结果</span></span><br><span class="line">main线程被中断了</span><br></pre></td></tr></table></figure>

<p>启动一个子线程并调用join方法，这时主线程就在等待子线程的执行完毕，然后子线程去中断了主线程。也就是中断了一个正在<strong>因join方法陷入阻塞</strong>的线程，那么此时我们中断的是这个陷入阻塞的线程，而不是正在执行的子线程。</p>
<h2 id="join期间的线程状态"><a href="#join期间的线程状态" class="headerlink" title="join期间的线程状态"></a>join期间的线程状态</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">mainThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(mainThread.getState());</span><br><span class="line">        System.out.println(Thread.currentThread().getState());</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">    thread.join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main方法执行结果</span></span><br><span class="line"><span class="comment">// WAITING</span></span><br><span class="line"><span class="comment">// RUNNABLE</span></span><br></pre></td></tr></table></figure>
<p>在子线程中去打印主线程和子线程各自的状态，明显调用了join方法的主线程被阻塞了是WAITING状态，而正在运行的子线程则是RUNNABLE状态。</p>
<h2 id="join-方法分析"><a href="#join-方法分析" class="headerlink" title="join() 方法分析"></a>join() 方法分析</h2><p><strong>join() 方法源码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    join(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可知，join() 方法实际上还是调用了 wait() 方法的。如果没有传入时间参数，则是调用了 wait(0) 这个方法，代表永久等待，直到被唤醒。<br>有意思的是这其中并没有看到 notify() 或者是 notifyAll() 方法，也就是并没有线程去唤醒这个等待子线程执行完毕的主线程，但是当子线程执行完毕之后，这确确实实被唤醒了。</p>
<p>我们知道，主线程被唤醒的条件是子线程执行完毕，又知道线程执行完毕只有两种情况，一是 run() 方法运行结束，二是抛出了运行时异常。至此，答案水落石出，当线程执行完毕时，将会去执行 notifyAll() 方法唤醒其他的线程。</p>
<blockquote>
<p>注意：我们并不提倡使用 Thread 类的实例作为 synchronized 的锁对象原因也是在此，因为这可能会破坏原有的 wait-notify 结构。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>synchronized 关键字是怎样保证线程安全的</title>
    <url>/posts/11150/</url>
    <content><![CDATA[<p><strong>一句话说明 synchronized 关键字的作用：</strong></p>
<blockquote>
<p>保证在 <strong>「同一时刻」</strong> 最多只有 <strong>「一个」</strong> 线程执行该段代码，以达到保证 <strong>「并发安全」</strong> 的效果</p>
</blockquote>
<p>上一篇文章讲述的线程不安全的例子，现在就给出解决办法：synchronized。</p>
<h1 id="synchronized-关键字的使用方式"><a href="#synchronized-关键字的使用方式" class="headerlink" title="synchronized 关键字的使用方式"></a>synchronized 关键字的使用方式</h1><p>为了阅读方便，把前一篇文章中的示例代码再放到这里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共享变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 对共享变量的修改</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100_000</span>; i++) &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123; &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;num = &quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以理解为是一个锁的作用，用来保护需要同步执行的代码，只有拿到锁的线程才能执行被保护的代码。如果使用 synchronized 来保护 <code>num++</code> 这行代码 ，那就可以保证 num 变量的线程安全。因为这样同一个时刻就只有一个线程能执行 <code>num++</code> 了。被保护代码也称为临界区代码。</p>
<p>synchronized 既然是一把锁，那肯定就需要一个对象来充当这个锁对象，这个对象可以是类对象或者是实例对象。由此就有了两个锁的概念：类锁、对象锁。</p>
<p>再根据使用方式的不同，类锁可以分为：</p>
<ul>
<li>静态方法加锁</li>
<li>代码块直接指定类锁</li>
</ul>
<p>对象锁可以分为：</p>
<ul>
<li>普通方法加锁</li>
<li>代码块直接指定对象锁</li>
</ul>
<p>由于 Java 中的类是全局唯一的对象，而对象则可以存在多个。于是，类锁是全局唯一的，被类锁保护的代码在同一时刻肯定只有唯一一个线程能执行该代码；对象锁在全局可以同时存在多个，被对象锁保护的代码在同一时刻可能会被多个线程同时执行，但这些线程肯定持有不同的对象锁。</p>
<h2 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a>类锁</h2><p>由于类锁在全局的唯一性，所以使用类锁保护的代码可以保证在整个 JVM 实例中同一时刻只有一个线程能执行该方法。</p>
<h3 id="静态方法加锁"><a href="#静态方法加锁" class="headerlink" title="静态方法加锁"></a>静态方法加锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 synchronized 关键字添加在静态方法签名上，以 Task.class 类对象为锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码块指定类锁"><a href="#代码块指定类锁" class="headerlink" title="代码块指定类锁"></a>代码块指定类锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Task.class) &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h2><p>被 new 出来或者反射加载的对象，在内存中可以存在多份。所以被对象锁保护的代码同一时刻可能会被多个线程执行，但是这些线程持有的实例对象肯定不同。</p>
<h3 id="普通方法加锁"><a href="#普通方法加锁" class="headerlink" title="普通方法加锁"></a>普通方法加锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 synchronized 关键字添加在方法签名上，以 this 对象为锁</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码块指定对象锁"><a href="#代码块指定对象锁" class="headerlink" title="代码块指定对象锁"></a>代码块指定对象锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类锁和对象锁的使用场景"><a href="#类锁和对象锁的使用场景" class="headerlink" title="类锁和对象锁的使用场景"></a>类锁和对象锁的使用场景</h2><p>类锁的经典使用场景有单例模式的双重检查锁（DCL）实现，由于类锁限制的范围太广泛了，在整个 JVM 实例同一时刻只有一个线程能执行被保护代码，也就是完全放弃了并行带来的性能提升，在使用类锁的时候这一点是需要认真考量的。DCL 的外层判断也是为了降低锁的粒度，基于性能的考量而加的。</p>
<p>对象锁的使用场景就比较多了，早期的并发容器当中使用的都是对象锁来保护并发安全，例如 Vector 和 Hashtable。早期并发容器中对象锁的使用也可以做为一个参考，一个对象内部的资源需要被保护时，可以以这个对象为锁来使用 synchronized 关键字。</p>
]]></content>
  </entry>
  <entry>
    <title>synchronized 锁的方法，不急就再等等</title>
    <url>/posts/11151/</url>
    <content><![CDATA[<p>在 synchronized 的使用中，如果继续往下执行代码的条件不被满足的话可以先释放当前持有的锁对象再等等，等到执行条件被满足后再接着往下执行。</p>
<blockquote>
<p>就像平时去医院排队看病一样，轮到我们了在医生问诊的过程中，可能会先让你先去做某一项检查，等检查完拿到检查结果之后再重新排队等待医生叫号。<br>排队看病的例子中，当我们在被医生问诊的时候，我们就独占了医生这把锁；需要做某一项检查的时候就是往下继续问诊的流程继续不了了；拿到检查结果后我们也要重新排队等待医生继续问诊。</p>
</blockquote>
<p>在程序的世界里，我们使用 synchronized 锁来保护医生对象，一个医生同一时刻只能给一个病人问诊；调用 wait() 方法先去做检查；当问诊结束了调用 notify() 方法去通知下一位病人问诊。</p>
<h1 id="wait-方法介绍"><a href="#wait-方法介绍" class="headerlink" title="wait() 方法介绍"></a>wait() 方法介绍</h1><p><strong>wait() 方法的使用：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">    object.wait();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (Object.class) &#123;</span><br><span class="line">    Object.class.wait();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="built_in">this</span>.wait();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Object.class.wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>wait() 方法的重载：</strong></p>
<ul>
<li>wait(long timeout)：在 timeout 毫秒内如果没有被 notify 唤醒则自行唤醒。</li>
<li>wait(long timeout, int nanos)：在 1,000,000*timeout+nanos 纳米内如果没有被 notify 唤醒则自行唤醒。</li>
</ul>
<h1 id="notify-方法介绍"><a href="#notify-方法介绍" class="headerlink" title="notify() 方法介绍"></a>notify() 方法介绍</h1><p>调用 wait() 方法当前线程会放弃 synchronized 锁，相对应的调用 notify() 方法之后原来放弃 synchronized 锁的线程就会重新去竞争 synchronized 锁，竞争到锁的线程可以继续执行。</p>
<p>notify() 方法还有一个兄弟方法叫做 notifyAll()，notify() 方法只会唤醒被 wait() 阻塞的线程之一；而 notifyAll() 会唤醒全部被 wait() 阻塞的线程。</p>
<p>被 wait() 方法阻塞的线程想要被唤醒必须是另外的一个线程去调用了 notiify() 并且轮到本线程被唤醒，或者是直接调用 notifyAll()。</p>
<p><strong>代码示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Demo</span><span class="params">(<span class="type">int</span> num)</span> &#123; <span class="built_in">this</span>.num = num; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Integer&gt; waitList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">50</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Integer&gt; notifyList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                waitList.add(num);</span><br><span class="line">                LOCK.wait();</span><br><span class="line">                notifyList.add(num);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Demo</span>(i)).start();</span><br><span class="line">            Thread.sleep(<span class="number">10</span>); <span class="comment">// 一个个去睡觉</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// notifyDemo();</span></span><br><span class="line">        <span class="comment">// notifyAllDemo();</span></span><br><span class="line">        System.out.println(waitList);</span><br><span class="line">        System.out.println(notifyList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">notifyDemo</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                LOCK.notify();</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>); <span class="comment">// 一个个来唤醒</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">notifyAllDemo</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">            LOCK.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">50</span>); <span class="comment">// 等待全部唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 main() 方法中调用 notify() 方法的执行结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure>

<p>在 main() 方法中调用 notifyAll() 方法的执行结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span><br></pre></td></tr></table></figure>

<p>很明显，notify() 是顺序唤醒线程的，而 notifyAll() 是倒序唤醒线程的。如果想要深究这部分原因，进入到 Object 类中看到 wait()、notify()、notifyAll() 这三个方法都是被 native 修饰的方法。再深入就是 jvm 的 C++ 实现了，包括还得看 synchronized 的实现等等。这部分内容暂时道行还不够，就先不做介绍了，暂时就先记住这么个现象吧。</p>
<p>如果业务上需要对线程的唤醒顺序有要求的话，可以分用多个锁来指定唤醒对应线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                LOCK.wait();</span><br><span class="line">                System.out.println(<span class="string">&quot;被唤醒。&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">            LOCK.notify();</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            str.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                str.append(i + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">9</span>)</span><br><span class="line">                    str.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            str.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看上面这段代码，输出结果是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line">被唤醒。</span><br></pre></td></tr></table></figure>

<p>显然对于 notify() 和 wait() 之间的执行顺序，调用 notify() 或者 notifyAll() 之后并不会马上释放本线程的 monitor 锁，而是等待被线程执行完毕之后再释放 monitor 锁给被 wait() 阻塞的线程去竞争。</p>
<h1 id="问诊案例"><a href="#问诊案例" class="headerlink" title="问诊案例"></a>问诊案例</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeeDoctor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Doctor</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Doctor</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(LOCK) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello doctor.&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (needDoCheck()) &#123;</span><br><span class="line">                LOCK.notifyAll();</span><br><span class="line">                LOCK.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;You&#x27;re healthy&quot;</span>);</span><br><span class="line">            LOCK.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">needDoCheck</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (checkIsDone()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isChecking()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;is checking...&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;wait a minute&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是问诊案例的大概流程，有三个地方需要注意：</p>
<ol>
<li><p>判断是否需要等待应该使用 while 循环判断，因为很可能被唤醒的线程检查结果还没出来，还是需要继续等待。</p>
</li>
<li><p>尽量使用 notifyAll() 方法唤醒，因为不能确定被唤醒线程能否往下继续执行。如果被唤醒线程因条件不满足继续等待，那还有其他线程可以继续抢锁，而 notify() 在这种情况下会导致所有线程都陷入等待无法唤醒。</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Java运行时数据区域</title>
    <url>/posts/26815/</url>
    <content><![CDATA[<p>Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。分别有：</p>
<ul>
<li><strong>程序计数器</strong>（Program Counter Register）</li>
<li><strong>虚拟机栈</strong>（VM Stack）</li>
<li><strong>本地方法栈</strong>（Native Method Stack）</li>
<li><strong>方法区</strong>（Method Area）</li>
<li><strong>堆</strong>（Heap）</li>
</ul>
<p>其中，程序计数器、虚拟机栈、本地方法栈这三个区域是线程隔离的区域，每个线程都有自己的程序计数器、虚拟机栈、本地方法栈，所以这三个区域内的变量是线程安全的。我们称这类内存区域为“线程私有”的内存，他们的生命周期与线程相同。</p>
<p>方法区和堆则是所有线程共享的区域，存放在这里面的数据需要注意线程安全问题。</p>
<h1 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h1><p>程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的<br>字节码的行号指示器。它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<p>由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。</p>
<p>此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何 OutOfMemoryError 情况的区域。</p>
<h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1><p>虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<p><strong>局部变量表：</strong>局部变量表（Local Variables Table）是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。如果执行的是实例方法（没有被static修饰的方法），那局部变量表中第0位索引的变量槽默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问到这个隐含的参数</p>
<p><strong>操作数栈：</strong>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和读取内容，也就是出栈和入栈操作。譬如在做算术运算的时候是通过将运算涉及的操作数栈压入栈顶后调用运算指令来进行的，又譬如在调用其他方法的时候是通过操作数栈来进行方法参数的传递。举个例子，例如整数加法的字节码指令iadd，这条指令在运行的时候要求操作数栈中最接近栈顶的两个元素已经存入了两个int型的数值，当执行这个指令时，会把这两个int值出栈并相加，然后将相加的结果重新入栈。</p>
<p><strong>动态连接：</strong>Java 多态的基石，在运行时动态指定调用方法。</p>
<p><strong>方法出口：</strong>当一个方法开始执行后，只有两种方式退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者；第二种退出方式是在方法执行的过程中遇到了异常，并且这个异常没有在方法体内得到妥善处理，一个方法使用异常完成出口的方式退出，是不会给它的上层调用者提供任何返回值的。</p>
<blockquote>
<p>注：《Java虚拟机规范》明确允许Java虚拟机实现自行选择是否支持栈的动态扩展，而HotSpot虚拟机的选择是不支持扩展，所以除非在创建线程申请内存时就因无法获得足够内存而出现OutOfMemoryError异常，否则在线程运行时是不会因为扩展而导致内存溢出的，只会因为栈容量无法容纳新的栈帧而导致StackOverflowError异常。</p>
</blockquote>
<h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</p>
<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>此内存区域的唯一目的就是存放对象实例，Java世界里“几乎”所有的对象实例都在这里分配内存。</p>
<p>根据《Java虚拟机规范》的规定，Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。但对于大对象（典型的如数组对象），多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的内存空间。</p>
<p>Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。</p>
<h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p>
<p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。</p>
<p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p>
<h2 id="String-字符串常量池"><a href="#String-字符串常量池" class="headerlink" title="String 字符串常量池"></a>String 字符串常量池</h2><p>JDK7 以前 String 字符串常量池是存放在永久代空间中的，自 JDK7 移除永久代之后将 String 字符串常量池移动至堆内存。所以关于 String::intern() 方法在 JDK7 之后会有些不一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;计算机&quot;</span>).append(<span class="string">&quot;软件&quot;</span>).toString();</span><br><span class="line">    System.out.println(str1.intern() == str1);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;ja&quot;</span>).append(<span class="string">&quot;va&quot;</span>).toString();</span><br><span class="line">    System.out.println(str2.intern() == str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码在 JDK6 中运行，会得到两个false。原因是：在JDK 6中，intern()方法会把<strong>首次遇到</strong>的字符串实例复制到永久代的字符串常量池中存储，返回的也是永久代里面这个字符串实例的引用，而由StringBuilder创建的字符串对象实例在Java堆上，所以必然不可能是同一个引用，结果将返回false。</p>
<p>在 JDK7 中运行，会得到一个 true 一个 false，原因是：JDK7 的intern()方法实现不需要再拷贝字符串的实例到永久代了，<strong>因为字符串常量池已经移到Java堆中，那只需要在常量池里记录一下首次出现的实例引用即可</strong>，因此intern()返回的引用和由StringBuilder创建的那个字符串实例就是同一个。而对str2比较返回false，这是因为“java”这个字符串在执行String-Builder.toString()之前就已经出现过了，字符串常量池中已经有它的引用，<strong>不符合intern()方法要求“首次遇到”的原则</strong>，“计算机软件”这个字符串则是首次出现的，因此结果返回true。</p>
<h1 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h1><p>在JDK 1.4中新加入了NIO（New Input&#x2F;Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I&#x2F;O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著ᨀ高性能，因为避免了在Java堆和Native堆中来回复制数据。</p>
<p>显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。</p>
<hr>
<blockquote>
<p><strong>巨人的肩膀：</strong></p>
<ul>
<li>《深入理解Java虚拟机》</li>
</ul>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Redis 对象结构和数据类型</title>
    <url>/posts/35006/</url>
    <content><![CDATA[<blockquote>
<p>本文转载自：<a href="https://xiaolincoding.com/redis/data_struct/command.html">小林Coding-Redis 常见数据类型和应用场景</a></p>
</blockquote>
<p>Redis 是一个键值对数据库，它的键值对中的 key 就是字符串对象，value 可以是字符串对象也可以是其他的集合数据类型对象，比如：List、Hash、Set、Zset 等。</p>
<p>Redis 中常见的数据类型有五种：String（字符串）、Hash（哈希）、List（列表）、Set（集合）、Zset（有序集合）。</p>
<p>随着 Redis 版本更新，后面又支持了四种：BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）。</p>
<h1 id="Redis-对象结构"><a href="#Redis-对象结构" class="headerlink" title="Redis 对象结构"></a>Redis 对象结构</h1><p>Redis 是使用了一个<strong>哈希表</strong>保存所有键值对，哈希表的最大好处就是让我们可以用 O(1) 的时间复杂度来快速查找到键值对。哈希表其实就是一个数组，数组中的元素叫做哈希桶。</p>
<p>哈希桶存放的是指向键值对数据的指针，这样通过指针就能找到键值对数据。因为键值对的 value 可以是字符串对象或者集合对象，所以键值对中并不直接保存值本身，而是保存了 <code>void * key</code> 和 <code>void * value</code> 指针，分别指向了实际的键对象和值对象，这样一来，即使值是集合数据，也可以通过 value 指针找到。</p>
<p><strong>Redis对象结构示意图：</strong></p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/Redis%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="Redis对象结构示意图"></p>
<p>以上三个属性是 Redis 对象中重要的三个属性，Redis 对象还有其他的一些属性，这里就先不展开。</p>
<ul>
<li><strong>type</strong>：标识该对象是什么类型的对象（String、List、Hash、Set、Zset）</li>
<li><strong>encoding</strong>：标识该对象使用了哪种底层的数据结构</li>
<li><strong>ptr</strong>：指向底层数据结构的指针</li>
</ul>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>String 是最基本的 key-value 结构，key 是唯一标识，value 是具体的值，value其实不仅是字符串， 也可以是数字（整数或浮点数），value 最多可以容纳的数据长度是 <strong>512M</strong>。底层数据结构是 int 和 SDS（简单动态字符串）。</p>
<p>SDS 是 Redis 内部实现的字符串对象，并没有采用 C语言 的字符串表示。由 Redis 内部实现的 SDS 优势如下：</p>
<ol>
<li>SDS 可以保存二进制数据，因为 SDS 采用 len 属性的值来表示字符串是否结束。</li>
<li>SDS 获取字符串长度的时间复杂度是 O(1)，因为 SDS 采用 len 属性记录字符串长度</li>
<li>SDS 拼接字符串不会造成缓冲区溢出，是安全的，因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，空间不够会自动扩容，所以不会导致缓冲区溢出的问题。</li>
</ol>
<p>字符串对象的内部编码（encoding）有 3 种 ：<strong>int、embstr 和 raw</strong>。</p>
<ul>
<li><p><strong>int</strong>：如果保存的是可以用 long 类型表示的整数值，那么直接将值保存在 ptr 属性里面即可，编码设置为 int。</p>
</li>
<li><p><strong>embstr 和 raw</strong>：保存的是字符串，底层的数据结构都是 SDS，如果是较短的字符串那么将编码设置为 embstr，如果是较长的字符串那么将编码设置为 raw。</p>
</li>
</ul>
<p>embstr 和 raw 的边界在不同的 Redis 版本中是不相同的。embstr 会通过一次内存分配函数来分配一块连续的内存空间来保存 redisObject 和 SDS，而 raw 编码会通过调用两次内存分配函数来分别分配两块空间来保存redisObject 和 SDS。Redis 这样做会有很多好处：</p>
<ul>
<li>embstr 编码在创建和释放对象时只需要调用一次内存函数。</li>
<li>embstr 所有的数据都保存在一块连续的内存，可以更好的利用 CPU 缓存提高性能。</li>
</ul>
<p>但 embstr 也是有缺点的，如果需要重新分配字符串内存时，整个 redisObject 和 SDS 都需要重新分配空间，<strong>所以 embstr 编码的字符串对象是只读的</strong>，我们对 embstr 编码的字符串对象执行的任何修改，程序都会先将对象的编码从 embstr 转换成 raw，然后再执行修改。</p>
<p><strong>String 类型的使用场景：</strong>缓存对象、常规计数、分布式锁、分布式服务之间共享 Session 信息</p>
<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>List 列表是简单的字符串列表，按照插入顺序排序，可以从头部或尾部向 List 列表添加元素。列表的最大长度为 <code>2^32 - 1</code>，也即每个列表支持超过 40 亿个元素。在 Redis 3.2 版本之后，List 数据类型底层数据结构只由 quicklist 实现，替代了双向链表和压缩列表。</p>
<p><strong>List 类型的使用场景：</strong>消息队列</p>
<p>消息队列在存取消息时，必须要满足三个需求，分别是：<strong>消息保序、处理重复的消息和保证消息可靠性</strong>。</p>
<div class="note default flat"><p><strong>如何满足消息保序需求？</strong></p>
</div>

<p>List 本身就是按先进先出的顺序对数据进行存取的，所以，如果使用 List 作为消息队列保存消息的话，就已经能满足消息保序的需求了。</p>
<p>List 可以使用 LPUSH + RPOP （或者反过来，RPUSH + LPOP）命令实现消息队列。不过这种方式在消费者读取数据时，有一个潜在的性能风险点：</p>
<p>生产者往 List 中写入消息时并不会通知消费者去消费消息，消费者只能不断的尝试从 List 中去取消息，这会导致消费者的 CPU 一直消耗在 RPOP 命令上，带来不必要的性能损失。</p>
<p>为了解决这个问题，Redis提供了 BRPOP 命令。<strong>BRPOP命令也称为阻塞式读取</strong>，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据。和消费者程序自己不停地调用RPOP命令相比，这种方式能节省CPU开销。</p>
<div class="note default flat"><p><strong>如何处理重复的消息？</strong></p>
</div>

<p>需要为每一条消息生成一个 ID 号，消费者记录自己消费过的 ID，取出消息时先判断自己是否消费过此消息，如果消费过则不再处理。</p>
<div class="note default flat"><p><strong>如何保证消息可靠性？</strong></p>
</div>

<p>当消费者程序从 List 中读取一条消息后，List 就不会再留存这条消息了。所以，如果消费者程序在处理消息的过程出现了故障或宕机，就会导致消息没有处理完成，那么，消费者程序再次启动后，就没法再次从 List 中读取消息了。</p>
<p>为了留存消息，List 类型提供了 <code>BRPOPLPUSH</code> 命令，BRPOPLPUSH 命令从列表中取出最后一个元素，并插入到另外一个列表的头部；如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</p>
<blockquote>
<p>BRPOPLPUSH 命令：<code>BRPOPLPUSH L1 L2 10</code>，从 L1 取出一条消息返回并存入 L2 中，阻塞时间为 10s。</p>
</blockquote>
<p>使用 BRPOPLPUSH 命令后，如果消费者程序读了消息但没能正常处理，等它重启后，就可以从备份 List 中重新读取消息并进行处理了。</p>
<h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><p>Hash 是一个键值对（key - value）集合，特别适合用于存储对象。其中 value 的形式如：<code>value=[&#123;field1, value1&#125;,...&#123;fieldN, valueN&#125;]</code>。在 Redis7.0 以后底层的数据结构改为 listpack，不再使用压缩列表或哈希表。</p>
<p><strong>应用场景：</strong>缓存对象、购物车（以 用户ID 为 key，商品ID 为 field，商品数量为 value）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 缓存 UID:1 对象</span></span><br><span class="line">&gt; HSET UID:1 name admin age 18</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 UID:1 对象的姓名、年龄等属性值</span></span><br><span class="line">&gt; HGET UID:1 name</span><br><span class="line"><span class="string">&quot;admin&quot;</span></span><br><span class="line">&gt; HGET UID:1 age</span><br><span class="line"><span class="string">&quot;18&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建购物车</span></span><br><span class="line">&gt; HSET SHOPPINGCART:UID:01 1001 1 1002 2 1003 10</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取购物车信息</span></span><br><span class="line">&gt; HGETALL SHOPPINGCART:UID:01</span><br><span class="line">1) <span class="string">&quot;1001&quot;</span></span><br><span class="line">2) <span class="string">&quot;1&quot;</span></span><br><span class="line">3) <span class="string">&quot;1002&quot;</span></span><br><span class="line">4) <span class="string">&quot;2&quot;</span></span><br><span class="line">5) <span class="string">&quot;1003&quot;</span></span><br><span class="line">6) <span class="string">&quot;10&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>Set 类型是一个无序并唯一的集合，它的存储顺序不会按照插入的先后顺序进行存储。</p>
<p>一个集合最多可以存储 <code>2^32-1</code> 个元素。概念和数学中个的集合基本类似，可以交集，并集，差集等等，所以 Set 类型除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集。</p>
<p>但是 Set 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，可能会导致 Redis 实例阻塞。</p>
<p>在主从集群中，为了避免主库因为 Set 做聚合计算（交集、差集、并集）时导致主库被阻塞，我们可以选择一个从库完成聚合统计，或者把数据返回给客户端，由客户端来完成聚合统计。</p>
<div class="note primary flat"><p><strong>Set 集合运算操作</strong></p>
</div>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 交集运算</span></span><br><span class="line">SINTER key [key ...]</span><br><span class="line"><span class="comment"># 将交集结果存入新集合destination中</span></span><br><span class="line">SINTERSTORE destination key [key ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 并集运算</span></span><br><span class="line">SUNION key [key ...]</span><br><span class="line"><span class="comment"># 将并集结果存入新集合destination中</span></span><br><span class="line">SUNIONSTORE destination key [key ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 差集运算</span></span><br><span class="line">SDIFF key [key ...]</span><br><span class="line"><span class="comment"># 将差集结果存入新集合destination中</span></span><br><span class="line">SDIFFSTORE destination key [key ...]</span><br></pre></td></tr></table></figure>

<p><strong>应用场景：</strong>点赞、共同关注、抽奖活动。</p>
<div class="note default flat"><p><strong>点赞</strong></p>
</div>

<p>Set 集合可以保证一个用户只能点一个赞，这里举例子一个场景，key 是文章ID，value 是用户ID。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># uid:1 用户对文章 article:1 点赞</span></span><br><span class="line">&gt; SADD article:1 uid:1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># uid:2 用户对文章 article:1 点赞</span></span><br><span class="line">&gt; SADD article:1 uid:2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># uid:3 用户对文章 article:1 点赞</span></span><br><span class="line">&gt; SADD article:1 uid:3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># uid:1 取消了对 article:1 文章点赞</span></span><br><span class="line">&gt; SREM article:1 uid:1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 article:1 文章所有点赞用户</span></span><br><span class="line">&gt; SMEMBERS article:1</span><br><span class="line">1) <span class="string">&quot;uid:3&quot;</span></span><br><span class="line">2) <span class="string">&quot;uid:2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 article:1 文章的点赞用户数量</span></span><br><span class="line">&gt; SCARD article:1</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断用户 uid:1 是否对文章 article:1 点赞了</span></span><br><span class="line">&gt; SISMEMBER article:1 uid:1</span><br><span class="line">(<span class="built_in">integer</span>) 0  <span class="comment"># 返回0说明没点赞，返回1则说明点赞了</span></span><br></pre></td></tr></table></figure>

<div class="note default flat"><p><strong>共同关注</strong></p>
</div>

<p>Set 类型支持交集运算，所以可以用来计算共同关注的好友、公众号等。key 可以是用户id，value 则是已关注的公众号的id。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># uid:1 用户关注公众号 id 为 5、6、7、8、9</span></span><br><span class="line">&gt; SADD uid:1 5 6 7 8 9</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"><span class="comment"># uid:2  用户关注公众号 id 为 7、8、9、10、11</span></span><br><span class="line">&gt; SADD uid:2 7 8 9 10 11</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># uid:1 和 uid:2 共同关注的公众号</span></span><br><span class="line">&gt; SINTER uid:1 uid:2</span><br><span class="line">1) <span class="string">&quot;7&quot;</span></span><br><span class="line">2) <span class="string">&quot;8&quot;</span></span><br><span class="line">3) <span class="string">&quot;9&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给 uid:2 推荐 uid:1 关注的公众号</span></span><br><span class="line">&gt; SDIFF uid:1 uid:2</span><br><span class="line">1) <span class="string">&quot;5&quot;</span></span><br><span class="line">2) <span class="string">&quot;6&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给 uid:1 推荐 uid:2 关注的公众号</span></span><br><span class="line">&gt; SDIFF uid:2 uid:1</span><br><span class="line">1) <span class="string">&quot;10&quot;</span></span><br><span class="line">2) <span class="string">&quot;11&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证某个公众号是否被 uid:1 或 uid:2 关注</span></span><br><span class="line">&gt; SISMEMBER uid:1 5</span><br><span class="line">(<span class="built_in">integer</span>) 1 <span class="comment"># 返回1，说明关注了</span></span><br><span class="line">&gt; SISMEMBER uid:2 5</span><br><span class="line">(<span class="built_in">integer</span>) 0 <span class="comment"># 返回0，说明没关注</span></span><br></pre></td></tr></table></figure>

<div class="note default flat"><p><strong>抽奖活动</strong></p>
</div>

<p>存储某活动中中奖的用户名 ，Set 类型因为有去重功能，可以保证同一个用户不会中奖两次。</p>
<p>如果允许重复中奖，使用 SRANDMEMBER 命令。如果不允许重复中奖，使用 SPOP 命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从集合key中随机选出count个元素，元素不从key中删除</span></span><br><span class="line">SRANDMEMBER key [count]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从集合key中随机选出count个元素，元素从key中删除</span></span><br><span class="line">SPOP key [count]</span><br></pre></td></tr></table></figure>

<h1 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h1><p>Zset 有序集合相比于 Set 集合多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序集合的元素值，一个是元素排序值。</p>
<p>有序集合保留了集合不能有重复成员的特性（分值可以重复），但不同的是，有序集合中的元素可以排序。</p>
<p>在 Redis 7.0 中，Zset 有序集合的底层数据结构就交由 listpack 数据结构来实现了，压缩列表数据结构就被废弃了。</p>
<div class="note primary flat"><p><strong>常用命令</strong></p>
</div>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 往有序集合key中加入带分值元素</span></span><br><span class="line">ZADD key score member [[score member]...]   </span><br><span class="line"><span class="comment"># 往有序集合key中删除元素</span></span><br><span class="line">ZREM key member [member...]                 </span><br><span class="line"><span class="comment"># 返回有序集合key中元素member的分值</span></span><br><span class="line">ZSCORE key member</span><br><span class="line"><span class="comment"># 返回有序集合key中元素个数</span></span><br><span class="line">ZCARD key </span><br><span class="line"></span><br><span class="line"><span class="comment"># 为有序集合key中元素member的分值加上increment</span></span><br><span class="line">ZINCRBY key increment member</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正序获取有序集合key从start下标到stop下标的元素</span></span><br><span class="line">ZRANGE key start stop [WITHSCORES]</span><br><span class="line"><span class="comment"># 倒序获取有序集合key从start下标到stop下标的元素</span></span><br><span class="line">ZREVRANGE key start stop [WITHSCORES]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回有序集合中指定分数区间内的成员，分数由低到高排序。</span></span><br><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回指定成员区间内的成员，按字典正序排列, 分数必须相同。</span></span><br><span class="line">ZRANGEBYLEX key min max [LIMIT offset count]</span><br><span class="line"><span class="comment"># 返回指定成员区间内的成员，按字典倒序排列, 分数必须相同</span></span><br><span class="line">ZREVRANGEBYLEX key max min [LIMIT offset count]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 并集计算(相同元素分值相加)，numberkeys一共多少个key，结果保存至destkey集合</span></span><br><span class="line">ZUNIONSTORE destkey numberkeys key [key...] </span><br><span class="line"><span class="comment"># 交集计算(相同元素分值相加)，numberkeys一共多少个key，结果保存至destkey集合</span></span><br><span class="line">ZINTERSTORE destkey numberkeys key [key...]</span><br></pre></td></tr></table></figure>

<p><strong>应用场景：</strong>排行榜、电话或者姓名等排序</p>
<div class="note default flat"><p><strong>排行榜</strong></p>
</div>

<p>以文章点赞数排行榜为例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># arcticle:1 文章获得了200个赞</span></span><br><span class="line">&gt; ZADD user:1:ranking 200 arcticle:1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># arcticle:2 文章获得了40个赞</span></span><br><span class="line">&gt; ZADD user:1:ranking 40 arcticle:2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># arcticle:3 文章获得了100个赞</span></span><br><span class="line">&gt; ZADD user:1:ranking 100 arcticle:3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># arcticle:4 文章获得了50个赞</span></span><br><span class="line">&gt; ZADD user:1:ranking 50 arcticle:4</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># arcticle:5 文章获得了150个赞</span></span><br><span class="line">&gt; ZADD user:1:ranking 150 arcticle:5</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<div class="note default flat"><p><strong>电话排序</strong></p>
</div>

<p>使用有序集合的 ZRANGEBYLEX 或 ZREVRANGEBYLEX 可以帮助我们实现电话号码或姓名的排序，我们以 ZRANGEBYLEX （返回指定成员区间内的成员，按 key 正序排列，分数必须相同）为例。</p>
<p>注意：不要在分数不一致的 SortSet 集合中去使用 ZRANGEBYLEX和 ZREVRANGEBYLEX 指令，因为获取的结果会不准确。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; ZADD phone 0 13100111100 0 13110114300 0 13132110901 </span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">&gt; ZADD phone 0 13200111100 0 13210414300 0 13252110901 </span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">&gt; ZADD phone 0 13300111100 0 13310414300 0 13352110901 </span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有电话号码</span></span><br><span class="line">&gt; ZRANGEBYLEX phone - +</span><br><span class="line">1) <span class="string">&quot;13100111100&quot;</span></span><br><span class="line">2) <span class="string">&quot;13110114300&quot;</span></span><br><span class="line">3) <span class="string">&quot;13132110901&quot;</span></span><br><span class="line">4) <span class="string">&quot;13200111100&quot;</span></span><br><span class="line">5) <span class="string">&quot;13210414300&quot;</span></span><br><span class="line">6) <span class="string">&quot;13252110901&quot;</span></span><br><span class="line">7) <span class="string">&quot;13300111100&quot;</span></span><br><span class="line">8) <span class="string">&quot;13310414300&quot;</span></span><br><span class="line">9) <span class="string">&quot;13352110901&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 132 号段的号码</span></span><br><span class="line">&gt; ZRANGEBYLEX phone [132 (133</span><br><span class="line">1) <span class="string">&quot;13200111100&quot;</span></span><br><span class="line">2) <span class="string">&quot;13210414300&quot;</span></span><br><span class="line">3) <span class="string">&quot;13252110901&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h1><p>Bitmap，即位图，是一串连续的二进制数组（0和1），可以通过偏移量（offset）定位元素。BitMap 通过最小的单位bit来进行 <code>0|1</code> 的设置，表示某个元素的值或者状态，时间复杂度为 O(1)。使用它进行储存将非常节省空间，特别适合一些数据量大且使用二值统计的场景。</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/BitMap%E5%AD%98%E5%82%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="BitMap存储示意图"></p>
<p>Bitmap 本身是用 String 类型作为底层数据结构实现的一种统计二值状态的数据类型。</p>
<p>String 类型是会保存为二进制的字节数组，所以，Redis 就把字节数组的每个 bit 位利用起来，用来表示一个元素的二值状态，你可以把 Bitmap 看作是一个 bit 数组。</p>
<div class="note primary flat"><p><strong>常用命令</strong></p>
</div>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置值，其中value只能是 0 和 1</span></span><br><span class="line">SETBIT key offset value</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取值</span></span><br><span class="line">GETBIT key offset</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取指定范围内值为 1 的个数</span></span><br><span class="line"><span class="comment"># start 和 end 以字节为单位</span></span><br><span class="line">BITCOUNT key start end</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># BitMap间的运算</span><br><span class="line"># operations 位移操作符，枚举值</span><br><span class="line">#   AND 与运算 &amp;</span><br><span class="line">#   OR 或运算 |</span><br><span class="line">#   XOR 异或 ^</span><br><span class="line">#   NOT 取反 ~</span><br><span class="line"># result 计算的结果，会存储在该key中</span><br><span class="line"># key1 … keyn 参与运算的key，可以有多个，空格分割，NOT 运算只能一个key</span><br><span class="line"># 当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 <span class="number">0</span>。</span><br><span class="line"># 返回值是保存到 destkey 的字符串的长度（以字节<span class="type">byte</span>为单位），和输入 key 中最长的字符串长度相等。</span><br><span class="line">BITOP [operations] [result] [key1] [keyn…]</span><br><span class="line"></span><br><span class="line"># 返回指定key中第一次出现指定value(<span class="number">0</span>/<span class="number">1</span>)的位置</span><br><span class="line">BITPOS [key] [value]</span><br></pre></td></tr></table></figure>

<p><strong>应用场景：</strong>签到统计、判断用户登录状态、连续签到用户统计</p>
<div class="note default flat"><p><strong>连续签到用户统计</strong></p>
</div>

<p>以统计七天连续签到打卡的用户为例：</p>
<p>把每天的日期作为 Bitmap 的 key，userId 作为 offset，若是打卡则将 offset 位置的 bit 设置成 1。key 对应的集合的每个 bit 位的数据则是一个用户在该日期的打卡记录。</p>
<p>一共有 7 个这样的 Bitmap，如果我们能对这 7 个 Bitmap 的对应的 bit 位做 『与』运算。同样的 UserID offset 都是一样的，当一个 userID 在 7 个 Bitmap 对应对应的 offset 位置的 bit &#x3D; 1 就说明该用户 7 天连续打卡。</p>
<p>结果保存到一个新 Bitmap 中，我们再通过 BITCOUNT 统计 bit &#x3D; 1 的个数便得到了连续打卡 7 天的用户总数了。</p>
<h1 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h1><p>HyperLogLog 是一个用来做基数估计的数据类型，什么是基数估计呢？</p>
<p>比如现有数据集：{1, 3, 5, 7, 5, 7, 8}，其中构成这个集合的基本元素是：{1, 3, 5, 7, 8}，总共有 5 个，那么基数就是 5。基数估计就是在可接受的误差范围内，快速计算基数。</p>
<p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 <code>2^64</code> 个不同元素的基数，和元素越多就越耗费内存的 Set 和 Hash 类型相比，HyperLogLog 就非常节省空间。</p>
<p>不过，有一点需要你注意一下，HyperLogLog 的统计规则是基于概率完成的，所以它给出的统计结果是有一定误差的，标准误算率是 0.81%。</p>
<div class="note primary flat"><p><strong>HyperLogLog 使用命令：</strong></p>
</div>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加指定元素到 HyperLogLog 中</span></span><br><span class="line">PFADD key element [element ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回给定 HyperLogLog 的基数估算值。</span></span><br><span class="line">PFCOUNT key [key ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将多个 HyperLogLog 合并为一个 HyperLogLog</span></span><br><span class="line">PFMERGE destkey sourcekey [sourcekey ...]</span><br></pre></td></tr></table></figure>

<p><strong>应用场景：</strong>百万级网页 UV 计数</p>
<p>在统计 UV 时，你可以用 PFADD 命令（用于向 HyperLogLog 中添加新元素）把访问页面的每个用户都添加到 HyperLogLog 中。</p>
<p>接下来，就可以用 PFCOUNT 命令直接获得 page1 的 UV 值了，这个命令的作用就是返回 HyperLogLog 的统计结果。</p>
<h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><p>Stream 是 Redis 5.0 版本新增加的数据类型，是 Redis 专门为消息队列设计的数据类型。在 Redis 5.0 Stream 没出来之前，消息队列的实现方式都有着各自的缺陷，例如：</p>
<ul>
<li>发布订阅模式，不能持久化也就无法可靠的保存消息，并且对于离线重连的客户端不能读取历史消息的缺陷；</li>
<li>List 实现消息队列的方式不能重复消费，一个消息消费完就会被删除，而且生产者需要自行实现全局唯一 ID。</li>
</ul>
<p>基于以上问题，Redis 5.0 便推出了 Stream 用于完美地实现消息队列，它支持消息的持久化、支持自动生成全局唯一 ID、支持 ack 确认消息的模式、支持消费组模式等，让消息队列更加的稳定和可靠。</p>
<div class="note default flat"><p><strong>基本操作：生产和消费</strong></p>
</div>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># * 表示让 Redis 为插入的数据自动生成一个全局唯一的 ID</span></span><br><span class="line"><span class="comment"># 往名称为 mymq 的消息队列中插入一条消息，消息的键是 name，值是 zhangsan</span></span><br><span class="line">&gt; XADD mymq * name zhangsan</span><br><span class="line"><span class="string">&quot;1663241868161-0&quot;</span></span><br></pre></td></tr></table></figure>

<p>插入成功后会返回全局唯一的 ID：”1663241868161-0”。消息的全局唯一 ID 由两部分组成：</p>
<ul>
<li>第一部分“1663241868161”是数据插入时，以毫秒为单位计算的当前服务器时间；</li>
<li>第二部分表示插入消息在当前毫秒内的消息序号，这是从 0 开始编号的。例如，“1663241868161-0”就表示在“1663241868161”毫秒内的第 1 条消息。</li>
</ul>
<p>消费者通过 XREAD 命令从消息队列中读取消息时，可以指定一个消息 ID，并从这个消息 ID 的下一条消息开始进行读取（注意是输入消息 ID 的下一条信息开始读取，不读取输入ID的消息）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这里输入的毫秒时间戳是刚才生成的ID的前一毫秒</span></span><br><span class="line">&gt; XREAD STREAMS mymq 1663241868160-0</span><br><span class="line">1) 1) <span class="string">&quot;mymq&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1663241868161-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;zhangsan&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果想要实现阻塞读（当没有数据时，阻塞住），可以调用 XRAED 时设定 BLOCK 配置项，实现类似于 BRPOP 的阻塞读取操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 10000 = 10s，命令最后的“$”符号表示读取最新的消息</span></span><br><span class="line">&gt; XREAD BLOCK 10000 STREAMS mymq $</span><br><span class="line">(nil)</span><br><span class="line">(10.00s)</span><br></pre></td></tr></table></figure>

<div class="note default flat"><p><strong>消费组</strong></p>
</div>

<p>Stream 可以以使用 XGROUP 创建消费组，创建消费组之后，Stream 可以使用 XREADGROUP 命令让消费组内的消费者读取消息。</p>
<p>创建两个消费组，这两个消费组消费的消息队列是 mymq，都指定从第一条消息开始读取：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个名为 group1 的消费组，0-0 表示从第一条消息开始读取。</span></span><br><span class="line">&gt; XGROUP CREATE mymq group1 0-0</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 创建一个名为 group2 的消费组，0-0 表示从第一条消息开始读取。</span></span><br><span class="line">&gt; XGROUP CREATE mymq group2 0-0</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>消费组 group1 内的消费者 consumer1 从 mymq 消息队列中读取所有消息的命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 命令最后的参数“&gt;”，表示从第一条尚未被消费的消息开始读取。</span></span><br><span class="line">&gt; XREADGROUP GROUP group1 consumer1 STREAMS mymq &gt;</span><br><span class="line">1) 1) <span class="string">&quot;mymq&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1654254953808-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;xiaolin&quot;</span></span><br></pre></td></tr></table></figure>

<p>消息队列中的消息一旦被消费组里的一个消费者读取了，就不能再被该消费组内的其他消费者读取了，即同一个消费组里的消费者不能消费同一条消息。</p>
<p>不同消费组的消费者可以消费同一条消息（但是有前提条件，创建消息组的时候，不同消费组指定了相同位置开始读取消息）</p>
<p>使用消费组的目的是让组内的多个消费者共同分担读取消息，所以，我们通常会让每个消费者读取部分消息，从而实现消息读取负载在多个消费者间是均衡分布的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 让 group2 中的 consumer1 从 mymq 消息队列中消费一条消息</span></span><br><span class="line">&gt; XREADGROUP GROUP group2 consumer1 COUNT 1 STREAMS mymq &gt;</span><br><span class="line">1) 1) <span class="string">&quot;mymq&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1663243059501-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="comment"># 让 group2 中的 consumer2 从 mymq 消息队列中消费一条消息</span></span><br><span class="line">&gt; XREADGROUP GROUP group2 consumer2 COUNT 1 STREAMS mymq &gt;</span><br><span class="line">1) 1) <span class="string">&quot;mymq&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1663243061599-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="comment"># 让 group2 中的 consumer3 从 mymq 消息队列中消费一条消息</span></span><br><span class="line">&gt; XREADGROUP GROUP group2 consumer3 COUNT 1 STREAMS mymq &gt;</span><br><span class="line">1) 1) <span class="string">&quot;mymq&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1663243062597-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;3&quot;</span></span><br></pre></td></tr></table></figure>

<div class="note default flat"><p><strong>消息确认</strong></p>
</div>

<p>Streams 会自动使用内部队列（也称为 PENDING List）留存消费组里每个消费者读取的消息，直到消费者使用 XACK 命令通知 Streams “消息已经处理完成”。</p>
<p>消费确认增加了消息的可靠性，一般在业务处理完成之后，需要执行 XACK 命令确认消息已经被消费完成，整个流程的执行如下图所示：</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/Stream%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="Stream消息确认流程图"></p>
<p>如果消费者没有成功处理消息，它就不会给 Streams 发送 XACK 命令，消息仍然会留存。此时，消费者可以在重启后，用 XPENDING 命令查看已读取、但尚未确认处理完成的消息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; XPENDING mymq group1</span><br><span class="line">1) (<span class="built_in">integer</span>) 3</span><br><span class="line">2) <span class="string">&quot;1663245004996-0&quot;</span> <span class="comment"># 表示 group1 中所有消费者读取的消息最小 ID</span></span><br><span class="line">3) <span class="string">&quot;1663245010578-0&quot;</span> <span class="comment"># 表示 group1 中所有消费者读取的消息最大 ID</span></span><br><span class="line">4) 1) 1) <span class="string">&quot;consumer1&quot;</span></span><br><span class="line">      2) <span class="string">&quot;1&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;consumer2&quot;</span></span><br><span class="line">      2) <span class="string">&quot;1&quot;</span></span><br><span class="line">   3) 1) <span class="string">&quot;consumer3&quot;</span></span><br><span class="line">      2) <span class="string">&quot;1&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果想查看某个消费者具体读取了哪些数据，可以执行下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看 group1 里 consumer2 从 mymq 消息队列中读取未确认哪些消息</span></span><br><span class="line">&gt; XPENDING mymq group1 - + 10 consumer2</span><br><span class="line">1) 1) <span class="string">&quot;1663245009507-0&quot;</span></span><br><span class="line">   2) <span class="string">&quot;consumer2&quot;</span></span><br><span class="line">   3) (<span class="built_in">integer</span>) 276418</span><br><span class="line">   4) (<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<p>group1 里 consumer2 应答 1663245009507-0：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 应答</span></span><br><span class="line">&gt; XACK mymq GROUP1 1663245009507-0</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应答成功后没有未确认消息了</span></span><br><span class="line">&gt; XPENDING mymq GROUP1 - + 10 consumer2</span><br><span class="line">(empty array)</span><br></pre></td></tr></table></figure>

<div class="note default flat"><p><strong>对于 MQ 来说，为什么 Redis 显得不专业？</strong></p>
</div>

<ol>
<li><p>Redis 在以下 2 个场景下，可能会导致数据丢失：</p>
<ul>
<li>AOF 持久化配置为每秒写盘，但这个写盘过程是异步的，Redis 宕机时会存在数据丢失的可能</li>
<li>主从复制也是异步的，主从切换时，也存在丢失数据的可能 (opens new window)。</li>
</ul>
</li>
<li><p>Redis Stream 消息不可堆积</p>
<ul>
<li>Redis 的数据都存储在内存中，这就意味着一旦发生消息积压，则会导致 Redis 的内存持续增长，如果超过机器内存上限，就会面临被 OOM 的风险。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Docker 基础概念和基本用法</title>
    <url>/posts/24100/</url>
    <content><![CDATA[<p>本文主要记录一些 Docker 中的基本概念，以及一些常用命令，主要是为了理清楚 <code>镜像</code>、<code>容器</code>、<code>网络</code>、<code>数据卷</code> 这几个概念、作用、操作。当然能够帮到大家就更好了。</p>
<h1 id="Docker-介绍"><a href="#Docker-介绍" class="headerlink" title="Docker 介绍"></a>Docker 介绍</h1><p><strong>Docker 的四大组成对象：</strong></p>
<ul>
<li>Docker 镜像：相当于软件的安装包</li>
<li>Docker 容器：相当于安装完正在运行的软件</li>
<li>Docker 网络：负责软件之间的相互通信</li>
<li>Docker 数据卷：将软件内外的数据相互映射，提供容器内外数据交互功能</li>
</ul>
<p>Docker 是以 服务端&#x2F;客户端 的形式对外提供服务的，服务端是 docker daemon，客户端是 docker CLI。所有的镜像模块、容器模块、网络模块、数据卷模块都是实现在 docker daemon 之中的。</p>
<p>docker daemon 暴露了一套 RESTFul API 接口以对外提供服务，我们可以在控制台通过编写 http 请求来控制 docker daemon，但是这样太繁琐了。所以，Docker 提供了 docker CLI 可以在控制台更方便的控制 docker daemon。</p>
<h1 id="搭建-Docker-运行环境"><a href="#搭建-Docker-运行环境" class="headerlink" title="搭建 Docker 运行环境"></a>搭建 Docker 运行环境</h1><p>Docker 主要是运行在 Linux 系统中的，也有提供运行在 Windows、Mac 系统上的桌面软件，运行在 Windows、Mac 系统上的 Docker 也是搭了一层 Linux 的隔离。Windows 和 Mac 操作系统的 Docker 环境下载连接如下：</p>
<ul>
<li><a href="https://docs.docker.com/desktop/install/windows-install/">Windows 安装环境下载</a></li>
<li><a href="https://docs.docker.com/desktop/install/mac-install/">Mac 安装环境下载</a></li>
</ul>
<p><strong>CentOS 安装如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum install yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"></span><br><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line">sudo yum install docker-ce</span><br><span class="line"></span><br><span class="line">sudo systemctl enable docker  # 开机自启动</span><br><span class="line">sudo systemctl start docker   # 启动 Docker 服务</span><br></pre></td></tr></table></figure>

<p>安装完成，启动成功之后可以运行两条命令查看 Docker 的一些基本信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker version  # Docker 版本信息（包含客户端和服务端的版本信息）</span><br><span class="line">docker info     # Docker 详细信息（包含镜像、容器状态等）</span><br></pre></td></tr></table></figure>

<p><strong>配置国内镜像源：</strong></p>
<p>修改 <code>/etc/docker/daemon.json</code> 文件（如果不存在，直接创建即可）添加以下内容：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;https://registry.docker-cn.com&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>修改完成，重启 Docker 以生效：<code>systemctl restart docker</code></p>
<p>运行 <code>docker info</code> 看看是否已经生效，大概在倒数两三行的位置可以看到 Registry Mirrors 信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Registry Mirrors:</span><br><span class="line"> https://registry.docker-cn.com/</span><br></pre></td></tr></table></figure>

<h1 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h1><p>在 <a href="https://hub.docker.com/">dockerhub</a> 中搜索想要下载的镜像直接下载即可，有标注 <code>DOCKER OFFICIAL IMAGE</code> 字样的镜像为官方维护的镜像。也可以在控制台查看 dockerhub 的镜像信息：<code>docker search image-name</code></p>
<p>下载命令：<code>docker pull image-name</code></p>
<p><strong>镜像命名规则：</strong> <code>username</code>&#x2F;<code>repository</code>:<code>tag</code></p>
<ul>
<li><strong>username：</strong> 上传该镜像的用户，由官方维护的镜像无此信息</li>
<li><strong>repository：</strong> 镜像名称，通常是软件名</li>
<li><strong>tag：</strong> 镜像标签，通常是版本信息，也可以是环境需求、构建方式等信息</li>
</ul>
<p>当我们在下载镜像时如果没有明确给出 <code>tag</code> 时，Docker 会默认使用 <code>latest</code> 作为 <code>tag</code>，也就是默认下载最新版本的镜像。</p>
<p><strong>常用命令：</strong></p>
<table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">命令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">查看本地镜像信息</td>
<td align="left"><code>docker images</code></td>
</tr>
<tr>
<td align="left">查看本地镜像的详细信息</td>
<td align="left"><code>docker inspect image-name</code></td>
</tr>
<tr>
<td align="left">删除镜像</td>
<td align="left"><code>docker rmi image-name</code></td>
</tr>
</tbody></table>
<p><strong>创建镜像：</strong></p>
<p>提交容器修改保存成镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker commit -m &quot;message&quot; container-name your-image-name</span><br></pre></td></tr></table></figure>

<p>创建镜像之后可以使用 <code>docker images</code> 命令查看镜像信息。创建时如果忘了指定镜像名称可以通过 <code>docker tag</code> 重新命名镜像。</p>
<p><strong>镜像导入导出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 将镜像保存导出</span><br><span class="line">docker save -o save-path/save-name1.tar your-image-name1 your-image-name2</span><br><span class="line"># 将导出的镜像导入</span><br><span class="line">docker load -i image-path/image-name.tar</span><br></pre></td></tr></table></figure>

<p><strong>容器导入导出：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 导出容器（一次只能导出一个）</span><br><span class="line">docker export -o save-name.tar your-container-name</span><br><span class="line"># 导入容器（导入之后是镜像）</span><br><span class="line">docker import save-name.tar your-image-name</span><br></pre></td></tr></table></figure>

<h1 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h1><p>Docker 镜像运行起来就是 Docker 容器了，也就是一个个运行起来的软件。</p>
<p><strong>Docker 容器的生命周期：</strong></p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/docker%E5%AE%B9%E5%99%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="docker容器生命周期"></p>
<p>Docker 容器的生命周期分为五种状态，分别为：</p>
<ul>
<li><strong>Created：</strong>容器已经被创建，容器所需的相关资源已经准备就绪，但容器中的程序还未处于运行状态。</li>
<li><strong>Running：</strong>容器正在运行，也就是容器中的应用正在运行。</li>
<li><strong>Paused：</strong>容器已暂停，表示容器中的所有程序都处于暂停 ( 不是停止 ) 状态。</li>
<li><strong>Stopped：</strong>容器处于停止状态，占用的资源和沙盒环境都依然存在，只是容器中的应用程序均已停止。</li>
<li><strong>Deleted：</strong>容器已删除，相关占用的资源及存储在 Docker 中的管理信息也都已释放和移除。</li>
</ul>
<p><strong>常用命令：</strong></p>
<table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">命令</th>
<th align="left">常用参数</th>
</tr>
</thead>
<tbody><tr>
<td align="left">创建容器</td>
<td align="left"><code>docker create image-name</code></td>
<td align="left"><code>--name</code>（指定容器名称）</td>
</tr>
<tr>
<td align="left">启动容器</td>
<td align="left"><code>docker start container-name</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">创建并启动容器</td>
<td align="left"><code>docker run image-name</code></td>
<td align="left"><code>--name</code>、<code>-d</code>（后台运行）<br> <code>--rm</code>（停止后删除）、<code>-e</code>（设置环境）</td>
</tr>
<tr>
<td align="left">停止容器</td>
<td align="left"><code>docker stop container-name</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">删除容器</td>
<td align="left"><code>docker rm container-name</code></td>
<td align="left"><code>-v</code>（删除相关联的数据卷）</td>
</tr>
<tr>
<td align="left">查看容器状态</td>
<td align="left"><code>docker ps</code></td>
<td align="left"><code>-a</code>（查看全部容器）</td>
</tr>
<tr>
<td align="left">进入容器</td>
<td align="left"><code>docker exec container-name</code></td>
<td align="left"><code>-it</code>（当前控制台输入输出）<br> <code>bash</code>&#x2F;<code>sh</code>（以哪种方式启动）</td>
</tr>
</tbody></table>
<p><strong>写时复制：</strong></p>
<p>在通过镜像运行容器时，并不是马上就把镜像里的所有内容拷贝到容器所运行的沙盒文件系统中，而是利用 UnionFS 将镜像以只读的方式挂载到沙盒文件系统中。只有在容器中发生对文件的修改时，修改才会体现到沙盒环境上。</p>
<p>容器是基于镜像启动的，在启动容器的时候并不是直接创建一个容器，而是利用镜像直接启动，当发生修改时再利用写时复制机制去修改。这样可以大幅提高容器启动速度，做到秒启动。</p>
<h1 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h1><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/docker%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.png" alt="docker容器网络模型"></p>
<p>在 Docker 网络中，有三个比较核心的概念，也就是：<code>沙盒（Sandbox）</code>、<code>网络（Network）</code>、<code>端点（Endpoint）</code>。这三者形成了 Docker 网络的核心模型，也就是容器网络模型 ( Container Network Model )。</p>
<ul>
<li><strong>沙盒：</strong>每个容器完全独立的网络环境，隔离了容器网络与宿主机网络。</li>
<li><strong>网络：</strong>Docker 内部的虚拟子网，网络内的参与者相互可见并能够进行通讯。</li>
<li><strong>端点：</strong>可控封闭网络环境的出入口，当端口相互配对后，就能进行数据传输了。</li>
</ul>
<p>目前 Docker 官方为我们提供了五种 Docker 网络驱动，分别是：<strong>Bridge Driver（默认，网桥模式）</strong>、Host Driver、Overlay Driver、MacLan Driver、None Driver。docker daemon 中默认维护了一个 bridge 的网络，所有的容器默认都是加入到此网络中。</p>
<h2 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h2><p>要让一个容器连接到另外一个容器，可以在容器通过 <code>docker create</code> 或 <code>docker run</code> 创建时通过 <code>--link</code> 选项进行配置，同时也可以为连接指定一个别名，这样在代码中可以直接使用别名进行连接。如下就是创建 mysql 容器和 webapp 容器，让 webapp 容器连接至 mysql 容器中，并且在 webapp 容器中为 mysql 容器取别名为 database。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d --name mysql -e MYSQL_ROOT_PASSWORD=root mysql</span><br><span class="line">docker run -d --name webapp --link mysql:database webapp</span><br></pre></td></tr></table></figure>

<p>这样在 webapp 中如果需要连接 mysql 可以这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://database:3306/database-name&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>如果不是连接默认端口，那么需要在启动时通过 <code>--expose</code> 参数告诉容器暴露对应端口，使用如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d --name mysql --expose=3307 -e MYSQL_ROOT_PASSWORD=root mysql</span><br></pre></td></tr></table></figure>

<p>可通过 <code>docker ps</code> 命令查看容器对外暴露了哪些端口。</p>
<h2 id="创建网络"><a href="#创建网络" class="headerlink" title="创建网络"></a>创建网络</h2><p>我们也可以自定义网络，形成虚拟子网的目的，<strong>只有在同一网络之中的容器才可以互联</strong>。</p>
<ul>
<li>创建网络：<code>docker network create -d bridge network-name</code>，<code>-d</code> 指定网络类型</li>
<li>查看网络：<code>docker network ls</code></li>
<li>删除网络：<code>docker network rm network-name</code></li>
</ul>
<p>创建容器时指定网络：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d --name your-container-name --network=network-name container-name</span><br></pre></td></tr></table></figure>

<h2 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h2><p>将容器中的端口映射至宿主机的端口。如下：</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/docker%E7%BD%91%E7%BB%9C%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E6%A8%A1%E5%9E%8B.png" alt="docker网络端口映射模型"></p>
<p>要映射端口，我们可以在创建容器时使用 <code>-p</code> 或者是 <code>--publish</code> 参数。</p>
<p>使用方式：<code>-p &lt;host-port&gt;:&lt;container-port&gt;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d --name nginx -p 80:80 nginx</span><br></pre></td></tr></table></figure>

<p>可通过 <code>docker ps</code> 查看端口映射情况</p>
<h1 id="Docker-数据卷"><a href="#Docker-数据卷" class="headerlink" title="Docker 数据卷"></a>Docker 数据卷</h1><p>数据管理使用挂载的方式，通过数据卷可以方便管理挂载的目录</p>
<h2 id="容器数据管理"><a href="#容器数据管理" class="headerlink" title="容器数据管理"></a>容器数据管理</h2><p>容器内的文件系统是随着容器的生命周期而创建和移除的，容器内部的数据无法被持久化存储。由于容器隔离，操作容器内部文件也变得很麻烦。Docker 解决这一问题的方式是文件挂载，将宿主操作系统中的文件挂载到容器内部，便可以让容器内外都共享这个文件。通过这种方式可以互通容器内外的文件，那么文件数据持久化以及操作容器内部文件的问题也就得到了解决。</p>
<p>Docker 提供了三种文件挂载的方式：Bind Mount、Volume 和 Tmpfs Mount。</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/docker%E6%96%87%E4%BB%B6%E6%8C%82%E8%BD%BD.png" alt="docker文件挂载"></p>
<ul>
<li><p><strong>Bind Mount：</strong> 直接将宿主操作系统中的目录和文件挂载到容器内的文件系统中，形成挂载映射关系，在容器内外对文件的读写都相互可见。</p>
<blockquote>
<p>使用 <code>-v</code> 参数设置，示例：<code>-v &lt;host-path&gt;:&lt;container-path&gt;:ro</code>，ro（可选）表示容器内只读。为避免混淆，此处强制使用绝对路径。</p>
</blockquote>
</li>
<li><p><strong>Volume（数据卷）：</strong> 仅指定容器内的目录，宿主操作系统挂载的目录由 Docker 进行管理，不需要关心具体挂载到了宿主操作系统中的哪里。</p>
<blockquote>
<p>Bind Mount 模式为指定 <code>&lt;host-path&gt;</code> 则为 Volume。此种方式生成的数据在路径上会有 Docker 生成的 ID，所以能够自己命名：<code>-v name:&lt;container-path&gt;</code></p>
</blockquote>
</li>
<li><p><strong>Tmpfs Mount：</strong> 挂载系统内存中的一部分到容器的文件系统里，不过由于内存和容器的特征，它的存储并不是持久的，其中的内容会随着容器的停止而消失。</p>
<blockquote>
<p>使用 <code>--tmpfs</code> 参数挂载，<code>--tmpfs &lt;host-path&gt;</code></p>
</blockquote>
</li>
</ul>
<p>以上创建出来的数据挂载信息，或者是数据卷信息可以通过 <code>docker inspect</code> 命令查看。</p>
<h2 id="数据卷管理"><a href="#数据卷管理" class="headerlink" title="数据卷管理"></a>数据卷管理</h2><p>上面对数据卷的操作都是基于容器的，多少有点不方便，Docker 提供了独立操作数据卷的方式。</p>
<p><strong>数据卷使用命令：</strong></p>
<table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">命令</th>
</tr>
</thead>
<tbody><tr>
<td align="left">创建数据卷</td>
<td align="left"><code>docker volume create volume-name</code></td>
</tr>
<tr>
<td align="left">查看数据卷</td>
<td align="left"><code>docker volume ls</code></td>
</tr>
<tr>
<td align="left">删除数据卷</td>
<td align="left"><code>docker volume rm volume-name</code></td>
</tr>
<tr>
<td align="left">删除没有被引用且未命名的数据卷</td>
<td align="left"><code>docker volume prune -f</code></td>
</tr>
</tbody></table>
<p><strong>数据卷容器：</strong></p>
<p>创建数据卷容器的方式很简单，由于不需要容器本身运行，因而我们找个简单的系统镜像都可以完成创建。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker create --name appdata -v /webapp/storage ubuntu</span><br></pre></td></tr></table></figure>

<p>在使用数据卷容器时，我们不建议再定义数据卷的名称，因为我们可以通过对数据卷容器的引用来完成数据卷的引用。之前我们提到，Docker 的 Network 是容器间的网络桥梁，如果做类比，数据卷容器就可以算是容器间的文件系统桥梁。我们可以像加入网络一样引用数据卷容器，只需要在创建新容器时使用专门的 <code>--volumes-from</code> 选项即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d --name nginx --volumes-from appdata nginx</span><br></pre></td></tr></table></figure>

<p>引用数据卷容器时，不需要再定义数据卷挂载到容器中的位置，Docker 会以数据卷容器中的挂载定义将数据卷挂载到引用的容器中。</p>
<p>使用数据卷容器看起来与使用原始数据卷的方式差不多，但是数据卷容器主要是在迁移数据卷时提供方便。如果迁移数据卷至其他目录，不用修改引用容器中的数据卷，数据卷容器相当于对数据卷的路径做了一层包装或者是取了个别名的意思。</p>
<hr>
<blockquote>
<p><strong>巨人的肩膀：</strong></p>
<ul>
<li>掘金小册-开发者必备的 Docker 实践指南</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>Spring Security</title>
    <url>/posts/28582/</url>
    <content><![CDATA[<p>关于 Spring Security 的文章网上有很多，B站也有很多教程，我都看过一些，但感觉对这部分的知识还不是很牢固。网上的大部分文章主要都是从后端的用户认证开始讲起的，一上来就是这些比较偏向实用部分的内容我觉得不是很好理解，还有很多巨长的类名方法名等等，这并不是在说网上的这些文章写的不好，毕竟本文也是一篇前人栽树，后人乘凉的文章。但是写这篇文章的初衷是想要从一个简单的小例子入手，解释清楚那些巨长的类名方法名都是干嘛的，应该怎么使用。</p>
<p>Spring Security 的一些介绍就不多说了，直接一个小 demo 走起，这个 demo 力争简洁，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入账号：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入密码：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> sc.next();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 开始认证    </span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">AuthenticationManager</span> <span class="variable">am</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SampleAuthenticationManager</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1、封装一个 UsernamePasswordAuthenticationToken 对象</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Authentication</span> <span class="variable">unAuth</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(username, password);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、经过 AuthenticationManager 的认证，如果认证失败会抛出一个 AuthenticationException 错误</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Authentication</span> <span class="variable">auth</span> <span class="operator">=</span> am.authenticate(unAuth);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、将这个认证过的 Authentication 填入 SecurityContext 里面</span></span><br><span class="line">            SecurityContextHolder.getContext().setAuthentication(auth);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;认证失败：&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 SecurityContext 中取出 Authentication</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Authentication</span> <span class="variable">auth</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        System.out.println(<span class="string">&quot;认证成功！&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;输入的账号：&quot;</span> + auth.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;输入的密码：&quot;</span> + auth.getCredentials());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现一个简单 AuthenticationManager 用于认证</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SampleAuthenticationManager</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键认证部分</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Authentication <span class="title function_">authenticate</span><span class="params">(Authentication auth)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> auth.getName();</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> (String) auth.getCredentials(); <span class="comment">// getCredentials 返回的是密码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (username == <span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(username))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadCredentialsException</span>(<span class="string">&quot;账号不能为空&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (password == <span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(password))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadCredentialsException</span>(<span class="string">&quot;密码不能为空&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 认证成功，创建认证成功对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(auth.getName(), auth.getCredentials());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring Security 主要的两个功能是认证和鉴权。这两个功能组合起来就能完成用户登录的需求，也就是一个系统中最基础最重要的模块。根据不同系统的需求，用户认证的工作可能会很繁琐。具体的认证步骤由程序员自行编写，Spring Security 的策略是把每个认证步骤串联起来成为一整个认证流程。上面的这个 demo 仅仅是一个简单的账号密码判空操作而已。主要是说明了怎么编写认证步骤。</p>
<h1 id="重要组件"><a href="#重要组件" class="headerlink" title="重要组件"></a>重要组件</h1><ul>
<li>Authentication：认证对象接口，定义了认证对象的数据形式。</li>
<li>AuthenticationManager：认证工作的上层接口，用于校验 <code>Authentication</code>，返回一个认证完成后的 <code>Authentication</code> 对象。</li>
<li>SecurityContext：上下文对象，<code>Authentication</code> 对象会放在里面。</li>
<li>SecurityContextHolder：用于拿到上下文对象的静态工具类。</li>
</ul>
<h2 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h2><p>Authentication 只是定义了一种在 Spring Security 进行认证过的数据的数据形式应该是怎么样的，要有权限，要有密码，要有身份信息，要有额外信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Authentication</span> <span class="keyword">extends</span> <span class="title class_">Principal</span>, Serializable &#123;</span><br><span class="line">    <span class="comment">// 获取用户权限列表</span></span><br><span class="line">    Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities();</span><br><span class="line">    <span class="comment">// 获取证明用户认证的信息，通常情况下获取到的是密码等信息。</span></span><br><span class="line">    Object <span class="title function_">getCredentials</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 获取用户的额外信息，（这部分信息可以是我们的用户表中的信息）。</span></span><br><span class="line">    Object <span class="title function_">getDetails</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 获取用户身份信息，在未认证的情况下获取到的是用户名，在已认证的情况下获取到的是 UserDetails。</span></span><br><span class="line">    Object <span class="title function_">getPrincipal</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 获取当前 Authentication 是否已认证。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAuthenticated</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 设置当前 Authentication 是否已认证（true or false）。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setAuthenticated</span><span class="params">(<span class="type">boolean</span> var1)</span> <span class="keyword">throws</span> IllegalArgumentException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AuthenticationManager"><a href="#AuthenticationManager" class="headerlink" title="AuthenticationManager"></a>AuthenticationManager</h2><p><code>AuthenticationManager</code> 定义了一个认证方法，它将一个未认证的 <code>Authentication</code> 传入，返回一个已认证的 <code>Authentication</code>，默认使用的实现类为：<code>ProviderManager</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AuthenticationManager</span> &#123;</span><br><span class="line">    <span class="comment">// 认证方法</span></span><br><span class="line">    Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span> </span><br><span class="line">        <span class="keyword">throws</span> AuthenticationException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SecurityContext"><a href="#SecurityContext" class="headerlink" title="SecurityContext"></a>SecurityContext</h2><p>上下文对象，认证后的数据就放在这里面，这个接口里面只有两个方法，其主要作用就是 get or set <code>Authentication</code>。接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SecurityContext</span> <span class="keyword">extends</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    Authentication <span class="title function_">getAuthentication</span><span class="params">()</span>; <span class="comment">// 获取Authentication对象</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setAuthentication</span><span class="params">(Authentication authentication)</span>; <span class="comment">// 放入Authentication对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SecurityContextHolder"><a href="#SecurityContextHolder" class="headerlink" title="SecurityContextHolder"></a>SecurityContextHolder</h2><p>可以说是 <code>SecurityContext</code> 的工具类，用于 get or set or clear <code>SecurityContext</code>，默认会把数据都存储到当前线程中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityContextHolder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clearContext</span><span class="params">()</span> &#123;</span><br><span class="line">        strategy.clearContext(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SecurityContext <span class="title function_">getContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> strategy.getContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setContext</span><span class="params">(SecurityContext context)</span> &#123;</span><br><span class="line">        strategy.setContext(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>由这四个组件组成的认证流程就是：</p>
<ol>
<li>将登录请求的身份信息封装成未认证的 <code>Authentication</code></li>
<li>将未认证的 <code>Authentication</code> 交由 <code>AuthenticationManager</code> 实行认证</li>
<li><code>AuthenticationManager</code> 认证完成返回认证后的 <code>Authentication</code></li>
<li>将认证过的 <code>Authentication</code> 放入 <code>SecurityContext</code></li>
</ol>
<p>上面的这四个组件就是 Spring Security 当中最重要的几个组件，Spring Security 其他的内容也是围绕这几个组件展开的。</p>
<h1 id="ProviderManager"><a href="#ProviderManager" class="headerlink" title="ProviderManager"></a>ProviderManager</h1><p>ProviderManager 是 AuthenticationManager 的默认实现类，由它衍生出来了 AuthenticationProvider 接口。</p>
<p>原来的一个 AuthenticationManager 只做一次认证工作，但是 ProviderManager 把多个认证工作放在一个集合中，遍历取出每个认证对象一次次做认证工作，只要有一次通过了，就认为这次认证是成功的。在 ProviderManager 中把认证工作封装成了 AuthenticationProvider。</p>
<div class="note default flat"><p><strong>AuthenticationProvider：</strong></p>
</div>

<p>认证提供者，服务于 ProviderManager 类，由实现了这个接口的对象组成一个集合，在 ProviderManager 中遍历取出认证 Authentication。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AuthenticationProvider</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 认证</span></span><br><span class="line">    Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span></span><br><span class="line">            <span class="keyword">throws</span> AuthenticationException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否支持当前的 Authentication 对象</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class&lt;?&gt; authentication)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ProviderManager 这个类的代码比较复杂，摘一些跟它认证流程有关的代码出来看看，以下代码在源码的基础上有做改动，主要是为了方便看一些</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 构造方法之一，传入一个个的 AuthenticationProvider 对象</span></span><br><span class="line"><span class="comment"> * 待会就拿这些对象来认证。</span></span><br><span class="line"><span class="comment"> * parent 对象传入 null，parent 相当于是一个兜底的 AuthenticationManager，</span></span><br><span class="line"><span class="comment"> * 如果所有的 AuthenticationProvider 认证都没通过，则使用 parent 做一次认证。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ProviderManager</span><span class="params">(AuthenticationProvider... providers)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(Arrays.asList(providers), (AuthenticationManager)<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Authentication</span>&gt; toTest = authentication.getClass();</span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">parentResult</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次取出 provider 认证 authentication</span></span><br><span class="line">    <span class="keyword">for</span>(AuthenticationProvider provider : <span class="built_in">this</span>.getProviders()) &#123;</span><br><span class="line">        <span class="comment">// provider 不能支持 authentication，直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> (!provider.supports(toTest))  <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用 provider 进行认证</span></span><br><span class="line">            result = provider.authenticate(authentication);</span><br><span class="line">            <span class="comment">// 认证通过</span></span><br><span class="line">            <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.copyDetails(authentication, result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InternalAuthenticationServiceException | AccountStatusException | AuthenticationException e) &#123;</span><br><span class="line">            <span class="comment">// 某次异常处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// providers 认证失败，尝试使用 parent 认证</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.parent != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = parentResult = <span class="built_in">this</span>.parent.authenticate(authentication);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ProviderNotFoundException | AuthenticationException e) &#123;</span><br><span class="line">            <span class="comment">// 异常处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 认证成功，擦除密码信息</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.eraseCredentialsAfterAuthentication &amp;&amp; result <span class="keyword">instanceof</span> CredentialsContainer) &#123;</span><br><span class="line">            ((CredentialsContainer)result).eraseCredentials();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发布认证成功事件</span></span><br><span class="line">        <span class="keyword">if</span> (parentResult == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.eventPublisher.publishAuthenticationSuccess(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// 执行至此，说明 providers 和 parent 都没认证成功，包装异常信息抛出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码如果觉得比较复杂也可以不看，只需知道 ProviderManager 类的认证流程即可。</p>
<h1 id="DaoAuthenticationProvider"><a href="#DaoAuthenticationProvider" class="headerlink" title="DaoAuthenticationProvider"></a>DaoAuthenticationProvider</h1><p>DaoAuthenticationProvider 就是 AuthenticationProvider 的最常实现类，顾名思义，Dao 正是数据访问层的缩写，也暗示了这个身份认证器的实现思路。</p>
<p>按照我们最直观的思路，怎么去认证一个用户呢？</p>
<p>用户前台提交了用户名和密码，而数据库中保存了用户名和密码，认证便是负责比对同一个用户名，提交的密码和保存的密码是否相同便是了。</p>
<p>在 Spring Security 中。提交的用户名和密码，被封装成了 UsernamePasswordAuthenticationToken，而根据用户名加载用户的任务则是交给了 UserDetailsService。</p>
<h2 id="UserDetailsService"><a href="#UserDetailsService" class="headerlink" title="UserDetailsService"></a>UserDetailsService</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line">    <span class="comment">// 查询用户，去哪里查询自己实现，一般是数据库。</span></span><br><span class="line">    UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要我们自己编写一个类实现 UserDetailsService 接口，在数据库中查询出登录的用户，将其包装成 UserDetails 对象返回。</p>
<p>这个接口的实现类写完需要在 Spring Security 配置中注册我们自己写的实现类，否则 Spring Security 是不知道你实现了这个接口的。</p>
<h2 id="UserDetails"><a href="#UserDetails" class="headerlink" title="UserDetails"></a>UserDetails</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDetails</span> <span class="keyword">extends</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// 当前认证用户的权限列表</span></span><br><span class="line">    Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities();</span><br><span class="line">    <span class="comment">// 当前认证用户密码</span></span><br><span class="line">    String <span class="title function_">getPassword</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 当前认证用户用户名</span></span><br><span class="line">    String <span class="title function_">getUsername</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 账户是否没过期</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 账户是否没被锁定（可以用来做黑名单）</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 账户凭据是否没过期</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 账户是否启用</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是一个接口，用来包装对应的数据库查出来的我们自己的 User 对象，包装完之后交给 Spring Security 去判断当前认证的用户账号情况。</p>
<h2 id="DaoAuthenticationProvider-比对密码"><a href="#DaoAuthenticationProvider-比对密码" class="headerlink" title="DaoAuthenticationProvider 比对密码"></a>DaoAuthenticationProvider 比对密码</h2><p>以下代码从源码中来，又跟源码不大一样，为了好看一些，有做删减。</p>
<p><strong>先从数据库加载用户：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> UserDetails <span class="title function_">retrieveUser</span><span class="params">(String username, UsernamePasswordAuthenticationToken authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">loadedUser</span> <span class="operator">=</span> <span class="built_in">this</span>.getUserDetailsService().loadUserByUsername(username);</span><br><span class="line">        <span class="keyword">if</span> (loadedUser == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 找不到直接报错，</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> loadedUser;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UsernameNotFoundException | InternalAuthenticationServiceException | Exception e) &#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>比对密码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">additionalAuthenticationChecks</span><span class="params">(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    <span class="keyword">if</span> (authentication.getCredentials() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 前台没传密码，直接报错</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">presentedPassword</span> <span class="operator">=</span> authentication.getCredentials().toString();</span><br><span class="line">        <span class="comment">// 比对密码，passwordEncoder 是需要注册的密码器。</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.passwordEncoder.matches(presentedPassword, userDetails.getPassword())) &#123;</span><br><span class="line">            <span class="comment">// 密码不匹配，直接报错</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>PasswordEncoder：</strong>是一个接口，用来定义一些密码器的，Spring Security 提供了多种不同的密码策略，需要选择一种密码策略，在配置文件中注册。通常使用 BCryptPasswordEncoder。</p>
<div class="note default flat"><p><strong>小结：</strong></p>
</div>

<ol>
<li>顶层接口，一切的开始：AuthenticationManager，用于管理认证的每一个环节。</li>
<li>Authentication：认证对象，所有的一切都是为它服务的，放在 SecurityContext 中传来传去的。每一个认证环节的开始和结束都是它。</li>
<li>ProviderManager：AuthenticationManager 最重要的实现类，那也就是最重要的一个认证环节。</li>
<li>ProviderManager 把自己的认证工作委托给了多个 AuthenticationProvider，只要有一个认证成功了就认为是成功的。</li>
<li>AuthenticationManager 和 ProviderManager 的职责是不同的，主要就是它们的认证策略不同。</li>
<li>具体的登录密码比对工作交给了 DaoAuthenticationProvider，这也是 ProviderManager 最重要的一个 AuthenticationProvider。</li>
<li>通常需要实现 UserDetailsService 和 UserDetails，DaoAuthenticationProvider 根据这两个对象来校验密码。</li>
</ol>
<p>写这篇文章的目的主要是学习 Spring Security 的过程中有很多的不理解的地方，很多类名都特别长，长的又差不多，感觉很难理解。所以想要写一篇文章来帮助自己巩固这部分的知识，这篇文章的一些内容也是在网上其他文章中出现过的。</p>
<p>推荐一个 GitHub 上的一个 Spring Security 的仓库，写的真的不错：<a href="https://github.com/rookie-ricardo/spring-boot-learning-demo">向大佬学习</a></p>
<hr>
<p>本来鉴权部分应该是要单独的写一篇文章来总结的，但是看了看 Spring Security 的动态鉴权，看是看的明白个大概，就是道行太浅还用不上这么高级的东西。这里就先简单的介绍一下简单的鉴权方案吧。</p>
<p>有需要动态鉴权的同学也可以先看看这两篇文章，顺带一提，大佬写的文章真的不错。</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/365515214">Spring Security 鉴权流程</a></li>
<li><a href="https://juejin.cn/post/6847902222668431368">SpringSecurity动态鉴权流程解析</a></li>
</ul>
<p><strong>鉴权策略：</strong></p>
<ol>
<li>在 SecurityConfig 配置文件中手动开启 <code>@EnableGlobalMethodSecurity(prePostEnabled = true)</code></li>
<li>在 UserDetailService.loadUserByUsername 方法中查询出用户所具有的全部权限</li>
<li>将权限封装在 UserDetail.getAuthorities() 方法中供 Spring Security 获取</li>
<li>在每个需要授权的 API 上加上 <code>@PreAuthorize(&quot;hasAuthority(&#39;权限值&#39;)&quot;)</code> 注解</li>
<li>如果用户权限列表有该接口对应权限值就能访问对应接口</li>
</ol>
<hr>
<blockquote>
<p><strong>前人栽树：</strong></p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/365513384">Spring Security 认证流程</a></li>
<li><a href="https://juejin.cn/post/6846687598442708999">SpringSecurity+JWT认证流程解析</a></li>
</ul>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>JWT 工具类封装</title>
    <url>/posts/64951/</url>
    <content><![CDATA[<h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1><p>JWT（Json Web Token）是一种用于用户认证的技术，前端携带 JWT 访问后端服务器，后端服务器可以解析 JWT 判断是否由本服务器签发，以及解析出一些简单的数据后可以拿到本次请求的用户。引入 JWT 主要为了解决传统 session 验证的弊端，session 认证的弊端：</p>
<ol>
<li>Session 保存在服务器中，用户数增加对服务器开销造成一定压力。</li>
<li>Session 保存在服务器物理内存中，对分布式不友好。</li>
<li>依赖 Cookie，对于非浏览器的客户端、手机移动端等不适用。</li>
<li>客户端 Cookie 泄漏会导致服务器不安全。</li>
<li>由于依赖 Cookie，所以无法跨域。</li>
</ol>
<p>JWT 的优势：</p>
<ol>
<li>简洁、数据量小、传输速度快</li>
<li>存储在客户端，原则上是跨语言的，支持任何 web 形式。</li>
<li>不依赖 Cookie 和 Session，对分布式友好。</li>
<li>容易跨域，对单点登录友好。</li>
<li>对手机移动端适用。</li>
</ol>
<p>JWT 认证流程图：</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/JWT%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B.png" alt="JWT认证流程"></p>
<h2 id="JWT-结构"><a href="#JWT-结构" class="headerlink" title="JWT 结构"></a>JWT 结构</h2><p>JWT 分成三个部分，每个部分都是一个字符串，中间由 <code>.</code> 隔开。</p>
<ul>
<li>Header：头部，标记加密的算法</li>
<li>Payload：负载，存放具体数据</li>
<li>Signature：签名，由 “Header + Payload + 服务器本地密钥” 经 MD5 加密后的值。</li>
</ul>
<h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>Header 是一个描述 JWT 元数据的 JSON 对象，alg 属性表示签名使用的算法，默认为 HMAC SHA256（写为HS256）；typ 属性表示令牌的类型，JWT 令牌统一写为 JWT。最后，使用 Base64 URL 算法将上述 JSON 对象转换为字符串保存。一般是下面这样：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h3><p>有效载荷部分，是 JWT 的主体内容部分，也是一个 JSON 对象，包含需要传递的数据，可以存放自定义数据。JWT 指定七个默认字段供选择</p>
<ol>
<li>iss (issuer)：签发人</li>
<li>exp (expiration time)：过期时间</li>
<li>sub (subject)：主题</li>
<li>aud (audience)：受众</li>
<li>nbf (Not Before)：生效时间</li>
<li>iat (Issued At)：签发时间</li>
<li>jti (JWT ID)：编号</li>
</ol>
<p>注意：此部分内容未加密，不能存放敏感信息。</p>
<h3 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h3><p>signature 是签证信息，该签证信息是通过 <code>header</code> 和 <code>payload</code>，加上 <code>secret</code>，通过算法加密生成。</p>
<h1 id="JWTUtil"><a href="#JWTUtil" class="headerlink" title="JWTUtil"></a>JWTUtil</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入 JWT 依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.auth0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>java-jwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.auth0.jwt.JWT;</span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.JWTCreator;</span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.algorithms.Algorithm;</span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.exceptions.JWTDecodeException;</span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.interfaces.DecodedJWT;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JWTUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可从 application.yml 中获取</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">SECRET</span> <span class="operator">=</span> <span class="string">&quot;maxiaorui&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成用户 Token</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map     存放在 token 的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expires 过期时间（单位：秒）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generateUserToken</span><span class="params">(Map&lt;String, String&gt; map, Integer expires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> JWTCreator.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> JWT.create();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// payload</span></span><br><span class="line">        map.forEach(builder::withClaim);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定过期时间</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">expiresAt</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        expiresAt.add(Calendar.SECOND, expires);</span><br><span class="line">        builder.withExpiresAt(expiresAt.getTime());</span><br><span class="line"></span><br><span class="line"><span class="comment">//        builder.withIssuer(&quot;issuer&quot;);                       // 签发人</span></span><br><span class="line"><span class="comment">//        builder.withSubject(&quot;subject&quot;);                     // 主题</span></span><br><span class="line"><span class="comment">//        builder.withAudience(&quot;audience1&quot;, &quot;audience2&quot;);     // 受众</span></span><br><span class="line"><span class="comment">//        builder.withNotBefore(new Date());                  // 生效时间</span></span><br><span class="line"><span class="comment">//        builder.withIssuedAt(new Date());                   // 签发时间</span></span><br><span class="line"><span class="comment">//        builder.withJWTId(&quot;jti&quot;);                           // 编号</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成原始 Token，此处可对 payload 数据做混淆</span></span><br><span class="line">        <span class="keyword">return</span> builder.sign(Algorithm.HMAC256(SECRET));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验用户 Token</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token 用户 Token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> DecodedJWT</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DecodedJWT <span class="title function_">verify</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(token))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JWTDecodeException</span>(<span class="string">&quot;Token 无效&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果在生成 Token 的时候做了混淆此处应该解析混淆</span></span><br><span class="line">        <span class="keyword">return</span> JWT.require(Algorithm.HMAC256(SECRET)).build().verify(token);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 DecodedJWT 中解析 payload：<code>DecodedJWT.getClaims();</code></p>
<p>解析可能出现的异常：</p>
<ul>
<li>JWTDecodeException：header、payload 被修改会出现的异常</li>
<li>SignatureVerificationException：签名不匹配异常</li>
<li>TokenExpiredException：令牌过期异常</li>
<li>AlgorithmMismatchException：算法不匹配异常</li>
</ul>
<hr>
<p>说句题外话，有没有发现 JWT 的前面总是会加 <code>Bearer</code> 这个单词？？？</p>
<p>那么加了能干嘛呢，不加行不行呢？？</p>
<p>别问，问就是规范，至于什么规范？<a href="https://www.google.com/">谷歌</a>、<a href="https://www.bing.com/">必应</a>、<a href="https://www.baidu.com/">百度</a></p>
<blockquote>
<p><strong>前人栽树：</strong></p>
<ul>
<li><a href="https://cnodejs.org/topic/5b0c4a7b8a4f51e140d942fc">一篇文章告诉你JWT的实现原理</a></li>
<li><a href="https://www.cnblogs.com/johnvwan/p/15557287.html">JWT分布式场景应用解析 </a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>代码段记录</category>
      </categories>
  </entry>
  <entry>
    <title>Java并发：volatile</title>
    <url>/posts/63338/</url>
    <content><![CDATA[<h1 id="volatile-的特性"><a href="#volatile-的特性" class="headerlink" title="volatile 的特性"></a>volatile 的特性</h1><p>当我们声明共享变量为 volatile 后，对这个变量的读&#x2F;写将会很特别。理解 volatile特性的一个好方法是把对 volatile 变量的单个读&#x2F;写，看成是使用同一个锁对这些单个读&#x2F;写操作做了同步。下面我们通过具体的示例来说明，请看下面的示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileFeaturesExample</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">vl</span> <span class="operator">=</span> <span class="number">0L</span>; <span class="comment">//使用 volatile 声明 64 位的 long 型变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">long</span> l)</span> &#123;</span><br><span class="line">        vl = l; <span class="comment">//单个 volatile 变量的写</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getAndIncrement</span> <span class="params">()</span> &#123;</span><br><span class="line">        vl++; <span class="comment">//复合（多个）volatile 变量的读/写</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vl; <span class="comment">//单个 volatile 变量的读</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设有多个线程分别调用上面程序的三个方法，这个程序在语义上和下面程序等价：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileFeaturesExample</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">vl</span> <span class="operator">=</span> <span class="number">0L</span>; <span class="comment">// 64 位的 long 型普通变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">long</span> l)</span> &#123; <span class="comment">//对单个的普通变量的写用同一个锁同步</span></span><br><span class="line">        vl = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getAndIncrement</span> <span class="params">()</span> &#123; <span class="comment">//普通方法调用</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> get(); <span class="comment">//调用已同步的读方法</span></span><br><span class="line">        temp += <span class="number">1L</span>; <span class="comment">//普通写操作</span></span><br><span class="line">        set(temp); <span class="comment">//调用已同步的写方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">get</span><span class="params">()</span> &#123; <span class="comment">//对单个的普通变量的读用同一个锁同步</span></span><br><span class="line">        <span class="keyword">return</span> vl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上面示例程序所示，对一个 volatile 变量的单个读&#x2F;写操作，与对一个普通变量的读&#x2F;写操作使用同一个锁来同步，它们之间的执行效果相同。</p>
<p>锁的 happens-before 规则保证释放锁和获取锁的两个线程之间的内存可见性，这意味着对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入。</p>
<p>锁的语义决定了临界区代码的执行具有原子性。这意味着即使是 64 位的 long 型和 double 型变量，只要它是 volatile 变量，对该变量的读写就将具有原子性。如果是多个 volatile 操作或类似于 volatile++ 这种复合操作，这些操作整体上不具有原子性。</p>
<p>简而言之，volatile 变量自身具有下列特性：</p>
<ul>
<li>可见性。对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入。</li>
<li>原子性：对任意单个 volatile 变量的读&#x2F;写具有原子性，但类似于 volatile++ 这种复合操作不具有原子性。</li>
</ul>
<h1 id="volatile-写-读建立的-happens-before-关系"><a href="#volatile-写-读建立的-happens-before-关系" class="headerlink" title="volatile 写-读建立的 happens before 关系"></a>volatile 写-读建立的 happens before 关系</h1><p>上面讲的是 volatile 变量自身的特性，对程序员来说，volatile 对线程的内存可见性的影响比 volatile 自身的特性更为重要，也更需要我们去关注。</p>
<p>从内存语义的角度来说，volatile 的写-读与锁的释放-获取有相同的内存效果：volatile 写和锁的释放有相同的内存语义；volatile 读与锁的获取有相同的内存语义。</p>
<p>请看下面使用 volatile 变量的示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileExample</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">        a = <span class="number">1</span>;          <span class="comment">//1</span></span><br><span class="line">        flag = <span class="literal">true</span>;    <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;     <span class="comment">//3</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a;  <span class="comment">//4</span></span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设线程 A 执行 writer()方法之后，线程 B 执行 reader()方法。根据 happens before 规则，这个过程建立的 happens before 关系可以分为两类：</p>
<ol>
<li>根据程序次序规则，1 happens before 2; 3 happens before 4。</li>
<li>根据 volatile 规则，2 happens before 3。</li>
<li>根据 happens before 的传递性规则，1 happens before 4。</li>
</ol>
<p>上述 happens before 关系的图形化表现形式如下：</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/volatile-1.png" alt="volatile-1"></p>
<p>在上图中，每一个箭头链接的两个节点，代表了一个 happens before 关系。黑色箭头表示程序顺序规则；橙色箭头表示 volatile 规则；蓝色箭头表示组合这些规则后提供的 happens before 保证。</p>
<p>这里 A 线程写一个 volatile 变量后，B 线程读同一个 volatile 变量。A 线程在写volatile 变量之前所有可见的共享变量，在 B 线程读同一个 volatile 变量后，将立即变得对 B 线程可见。</p>
<h1 id="volatile-写的内存语义"><a href="#volatile-写的内存语义" class="headerlink" title="volatile 写的内存语义"></a>volatile 写的内存语义</h1><blockquote>
<p>当写一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量值刷新到主内存。</p>
</blockquote>
<p>以上面示例程序 VolatileExample 为例，假设线程 A 首先执行 writer()方法，随后线程 B 执行 reader()方法，初始时两个线程的本地内存中的 flag 和 a 都是初始状态。下图是线程 A 执行 volatile 写后，共享变量的状态示意图：</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/volatile-2.png" alt="volatile-2"></p>
<p>如上图所示，线程 A 在写 flag 变量后，本地内存 A 中被线程 A 更新过的两个共享变量的值被刷新到主内存中。此时，本地内存 A 和主内存中的共享变量的值是一致的。</p>
<h1 id="volatile-读的内存语义"><a href="#volatile-读的内存语义" class="headerlink" title="volatile 读的内存语义"></a>volatile 读的内存语义</h1><blockquote>
<p>当读一个 volatile 变量时，JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</p>
</blockquote>
<p>当读一个 volatile 变量时，JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</p>
<p>下面是线程 B 读同一个 volatile 变量后，共享变量的状态示意图：</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/volatile-3.png" alt="volatile-3"></p>
<p>如上图所示，在读 flag 变量后，本地内存 B 包含的值已经被置为无效。此时，线程 B 必须从主内存中读取共享变量。线程 B 的读取操作将导致本地内存 B 与主内存中的共享变量的值也变成一致的了。</p>
<p>如果我们把 volatile 写和 volatile 读这两个步骤综合起来看的话，在读线程 B 读一个 volatile 变量后，写线程 A 在写这个 volatile 变量之前所有可见的共享变量的值都将立即变得对读线程 B 可见。</p>
<div class="note default flat"><p><strong>volatile 读写内存语义总结：</strong></p>
</div>

<ul>
<li>线程 A 写一个 volatile 变量，实质上是线程 A 向接下来将要读这个 volatile 变量的某个线程发出了（其对共享变量所在修改的）消息。</li>
<li>线程 B 读一个 volatile 变量，实质上是线程 B 接收了之前某个线程发出的（在写这个 volatile 变量之前对共享变量所做修改的）消息。</li>
<li>线程 A 写一个 volatile 变量，随后线程 B 读这个 volatile 变量，这个过程实质上是线程 A 通过主内存向线程 B 发送消息。</li>
</ul>
<hr>
<blockquote>
<p><strong>巨人的肩膀：</strong></p>
<ul>
<li><a href="https://www.infoq.cn/minibook/java_memory_model">深入理解Java内存模型</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>Java并发：重排序规则</title>
    <url>/posts/41133/</url>
    <content><![CDATA[<p>关于重排序的一些概念性问题在<a href="https://www.wrp.cool/posts/41498/#%E6%9C%89%E5%BA%8F%E6%80%A7%E6%98%AF%E6%80%8E%E4%B9%88%E4%BA%A7%E7%94%9F%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E7%9A%84">Java 内存模型（JMM）</a>中 <em>「有序性是怎么产生并发问题的」</em> 一节有详细介绍。</p>
<p>程序最终的执行顺序是由 CPU 处理的，做为 Java 程序员更应该关心的是重排序的结果，而不是重排序的过程。</p>
<p>具体的在什么情况下会发生重排序，又是按照一个什么样的规则去重排序，这些问题应该交给 CPU 去处理，我们应该关心的是我们写的程序被重排序后是怎么样的。</p>
<h1 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h1><p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分下列三种类型：</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">代码示例</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">写后读</td>
<td align="left">a &#x3D; 1;b &#x3D; a;</td>
<td align="left">写一个变量之后，再读这个位置。</td>
</tr>
<tr>
<td align="left">写后写</td>
<td align="left">a &#x3D; 1;a &#x3D; 2;</td>
<td align="left">写一个变量之后，再写这个变量。</td>
</tr>
<tr>
<td align="left">读后写</td>
<td align="left">a &#x3D; b;b &#x3D; 1;</td>
<td align="left">读一个变量之后，再写这个变量。</td>
</tr>
</tbody></table>
<p>上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。</p>
<p>前面提到过，编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。</p>
<blockquote>
<p>注意：这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</p>
</blockquote>
<h1 id="as-if-serial-语义"><a href="#as-if-serial-语义" class="headerlink" title="as-if-serial 语义"></a>as-if-serial 语义</h1><p>as-if-serial 语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。</p>
<p>为了遵守 as-if-serial 语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。为了具体说明，请看下面计算圆面积的代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">pi</span>   <span class="operator">=</span> <span class="number">3.14</span>;         <span class="comment">//A</span></span><br><span class="line"><span class="type">double</span> <span class="variable">r</span>    <span class="operator">=</span> <span class="number">1.0</span>;          <span class="comment">//B</span></span><br><span class="line"><span class="type">double</span> <span class="variable">area</span> <span class="operator">=</span> pi * r * r;   <span class="comment">//C</span></span><br></pre></td></tr></table></figure>

<p>上面三个操作的数据依赖关系如下图所示：</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E9%87%8D%E6%8E%92%E5%BA%8F%E6%95%B0%E6%8D%AE%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB.png" alt="重排序数据依赖关系"></p>
<p>如上图所示，A 和 C 之间存在数据依赖关系，同时 B 和 C 之间也存在数据依赖关系。因此在最终执行的指令序列中，C 不能被重排序到 A 和 B 的前面（C 排到 A 和 B 的前面，程序的结果将会被改变）。但 A 和 B 之间没有数据依赖关系，编译器和处理器可以重排序 A 和 B 之间的执行顺序。下图是该程序的两种执行顺序：</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E9%87%8D%E6%8E%92%E5%BA%8F%E5%90%8E%E5%8F%AF%E8%83%BD%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB.png" alt="重排序后可能的依赖关系"></p>
<p>as-if-serial 语义把单线程程序保护了起来，遵守 as-if-serial 语义的编译器，runtime 和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。as-if-serial 语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。</p>
<h1 id="程序顺序规则"><a href="#程序顺序规则" class="headerlink" title="程序顺序规则"></a>程序顺序规则</h1><p>根据 happens- before 的程序顺序规则，上面计算圆的面积的示例代码存在三个 happens- before 关系：</p>
<ul>
<li>A happens- before B；</li>
<li>B happens- before C；</li>
<li>A happens- before C；</li>
</ul>
<p>这里的第 3 个 happens- before 关系，是根据 happens- before 的传递性推导出来的。</p>
<p>这里 A happens-before B，但实际执行时 B 却可以排在 A 之前执行（看上面的重排序后的执行顺序）。实际上如果 A happens-before B，JMM 并不要求 A 一定要在 B 之前执行。JMM 仅仅要求前一个操作（执行的结果）对后一个操作可见。这里操作 A 的执行结果不需要对操作 B 可见；而且重排序操作 A 和操作 B 后的执行结果，与操作 A 和操作 B 按 happens-before 顺序执行的结果一致。在这种情况下，JMM 会认为这种重排序并不非法（not illegal），JMM 允许这种重排序。</p>
<p>在计算机中，软件技术和硬件技术有一个共同的目标：在不改变程序执行结果的前提下，尽可能的开发并行度。编译器和处理器遵从这一目标，从 happens- before 的定义我们可以看出，JMM 同样遵从这一目标。</p>
<h1 id="重排序对多线程的影响"><a href="#重排序对多线程的影响" class="headerlink" title="重排序对多线程的影响"></a>重排序对多线程的影响</h1><p>现在让我们来看看，重排序是否会改变多线程程序的执行结果。请看下面的示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReorderExample</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">        a = <span class="number">1</span>;                   <span class="comment">//1</span></span><br><span class="line">        flag = <span class="literal">true</span>;             <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;                <span class="comment">//3</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>  a * a;        <span class="comment">//4</span></span><br><span class="line">            ……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>flag 变量是个标记，用来标识变量 a 是否已被写入。这里假设有两个线程 A 和 B，A 首先执行 writer() 方法，随后 B 线程接着执行 reader() 方法。线程 B 在执行操作 4 时，能否看到线程 A 在操作 1 对共享变量 a 的写入？</p>
<p>答案是：不一定能看到。</p>
<p>由于操作 1 和操作 2 没有数据依赖关系，编译器和处理器可以对这两个操作重排序；同样，操作 3 和操作 4 没有数据依赖关系，编译器和处理器也可以对这两个操作重排序。让我们先来看看，当操作 1 和操作 2 重排序时，可能会产生什么效果? 请看下面的程序执行时序图：</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/java-jmm-8.png" alt="java-jmm-8"></p>
<p>如上图所示，操作 1 和操作 2 做了重排序。程序执行时，线程 A 首先写标记变量 flag，随后线程 B 读这个变量。由于条件判断为真，线程 B 将读取变量 a。此时，变量 a 还根本没有被线程 A 写入，在这里多线程程序的语义被重排序破坏了！</p>
<p>下面再让我们看看，当操作 3 和操作 4 重排序时会产生什么效果（借助这个重排序，可以顺便说明控制依赖性）。下面是操作 3 和操作 4 重排序后，程序的执行时序图：</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/java-jmm-9.png" alt="java-jmm-9"></p>
<p>在程序中，操作 3 和操作 4 存在控制依赖关系。当代码中存在控制依赖性时，会影响指令序列执行的并行度。为此，编译器和处理器会采用猜测（Speculation）执行来克服控制相关性对并行度的影响。以处理器的猜测执行为例，执行线程 B 的处理器可以提前读取并计算 a*a，然后把计算结果临时保存到一个名为重排序缓冲（reorder buffer ROB）的硬件缓存中。当接下来操作 3 的条件判断为真时，就把该计算结果写入变量 i 中。</p>
<p>从图中我们可以看出，猜测执行实质上对操作 3 和 4 做了重排序。重排序在这里破坏了多线程程序的语义！</p>
<p>在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是 as-if-serial 语义允许对存在控制依赖的操作做重排序的原因）；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。</p>
<blockquote>
<p>虽然重排序的一些具体的发生过程并不是我们关心的重点，但作为程序员，求知好学也是应该的不是吗。下面的部分不感兴趣的同学跳过即可。</p>
</blockquote>
<h1 id="为什么会发生重排序"><a href="#为什么会发生重排序" class="headerlink" title="为什么会发生重排序"></a>为什么会发生重排序</h1><p>重排序分为真重排序和伪重排序，真重排序就像是在<a href="https://www.wrp.cool/posts/41498/">Java 内存模型（JMM）</a>中的 <em>「有序性是怎么产生并发问题的」</em> 所介绍的：<strong>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。</strong>伪重排序正是接下来所要介绍的：</p>
<blockquote>
<p>由于现代的处理器使用写缓冲区来临时保存向内存写入的数据，这对内存操作的执行顺序产生重要的影响。</p>
</blockquote>
<p><strong>写缓冲区的优点：</strong></p>
<ul>
<li>保证指令流水线持续运行，可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟</li>
<li>通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用</li>
</ul>
<p><strong>写缓冲区的缺点：</strong>每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读&#x2F;写操作的执行顺序，不一定与内存实际发生的读&#x2F;写操作顺序一致！请看下面示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Processor A</span></span><br><span class="line">a = <span class="number">1</span>; <span class="comment">//A1  </span></span><br><span class="line">x = b; <span class="comment">//A2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Processor B</span></span><br><span class="line">b = <span class="number">2</span>; <span class="comment">//B1  </span></span><br><span class="line">y = a; <span class="comment">//B2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始状态：a = b = 0；处理器允许执行后得到结果：x = y = 0</span></span><br></pre></td></tr></table></figure>

<p>假设处理器 A 和处理器 B 按程序的顺序并行执行内存访问，最终却可能得到 x &#x3D; y &#x3D; 0 的结果。具体的原因如下图所示：</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E4%BC%AA%E9%87%8D%E6%8E%92%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="伪重排序执行时序图"></p>
<p>以下面的这种时序执行时，程序就会得到 x &#x3D; y &#x3D; 0 的结果：</p>
<ol>
<li>处理器 A 和处理器 B 同时把共享变量写入自己的写缓冲区（A1，B1）</li>
<li>处理器 A 和处理器 B 同时从内存中读取另一个共享变量（A2，B2）</li>
<li>处理器 A 和处理器 B 刷自己写缓冲区中的脏数据到内存中（A3，B3）</li>
</ol>
<p>从内存操作实际发生的顺序来看，直到处理器 A 执行 A3 来刷新自己的写缓存区，写操作 A1 才算真正执行了。虽然处理器 A 执行内存操作的顺序为：A1-&gt;A2，但内存操作实际发生的顺序却是：A2-&gt;A1。此时，处理器 A 的内存操作顺序被重排序了（处理器 B 的情况和处理器 A 一样，这里就不赘述了）。</p>
<p>这里的关键是，由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。</p>
<p>为了保证内存可见性，java 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM 把内存屏障指令分为下列四类：</p>
<table>
<thead>
<tr>
<th align="left">屏障类型</th>
<th align="left">指令示例</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">LoadLoad Barriers</td>
<td align="left">Load1; LoadLoad; Load2</td>
<td align="left">确保 Load1 数据装载，之前于 Load2 及所有后续装载指令的装载。</td>
</tr>
<tr>
<td align="left">StoreStore Barriers</td>
<td align="left">Store1; StoreStore; Store2</td>
<td align="left">确保 Store1 数据对其他处理器可见（刷新到内存），之前于 Store2 及所有后续存储指令的存储。</td>
</tr>
<tr>
<td align="left">LoadStore Barriers</td>
<td align="left">Load1; LoadStore; Store2</td>
<td align="left">确保 Load1 数据装载，之前于 Store2 及所有后续的存储指令刷新到内存。</td>
</tr>
<tr>
<td align="left">StoreLoad Barriers</td>
<td align="left">Store1; StoreLoad; Load2</td>
<td align="left">确保 Store1 数据对其他处理器可见（刷新到内存），之前于 Load2 及所有后续装载指令的装载。</td>
</tr>
</tbody></table>
<p>StoreLoad Barriers 会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。</p>
<p>StoreLoad Barriers 是一个“全能型”的屏障，它同时具有其他三个屏障的效果。现代的多处理器大都支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（buffer fully flush）。</p>
<hr>
<blockquote>
<p><strong>巨人的肩膀：</strong></p>
<ul>
<li><a href="https://www.infoq.cn/minibook/java_memory_model">深入理解Java内存模型</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>Java并发：线程的执行结果和异常</title>
    <url>/posts/62788/</url>
    <content><![CDATA[<h1 id="利用-Future-获取线程执行结果和处理异常"><a href="#利用-Future-获取线程执行结果和处理异常" class="headerlink" title="利用 Future 获取线程执行结果和处理异常"></a>利用 Future 获取线程执行结果和处理异常</h1><p><strong>简介：</strong></p>
<p>如果当前任务需要另外的某一个任务执行完毕获取到返回值后才能继续执行，但是这个另外的任务又比较耗时，那么可以使用 Future 类将这个任务的返回结果包装起来，然后当前线程先去做点其他的事情，等到 Future 拿到结果之后再执行那部分的逻辑。这个被包装的对象就是 <code>Callable</code>。</p>
<p><strong>简而言之：</strong>如果有个很耗时的方法的需要执行，那么先开个线程让它执行，当前线程先做点其他的事情，不要一直在哪里傻等</p>
<p><strong>Callable 介绍：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Callable 是一个接口，跟 Runnable 一样用来包装要执行的任务，不同的是 Callable 接口可以拥有返回值和向外抛出异常。</p>
<div class="note modern primary no-icon flat"><p><strong>Future 的使用：</strong></p>
</div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">final</span> Future&lt;Integer&gt; future = service.submit(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get 方法的行为取决于 Callable 任务的状态，只有以下五种情况：</p>
<ol>
<li>任务正常完成：gei 方法会立即返回结果</li>
<li>任务尚未完成（可能是还没开始或执行中）：get将阻塞直到任务完成并返回结果</li>
<li>任务执行过程中抛出 Exception：get方法会抛出 ExecutionException<br>这里的异常是 call 方法产生的异常，不管 call 方法抛出了什么样的异常都会被 get 方法接收到，但是 get 方法只会抛出 ExecutionException 异常。</li>
<li>任务被取消：get 方法会抛出 CancellationException</li>
<li>任务超时：get 方法有一个重载方法，可以传入延迟时间，如果时间到了还没有获得结果，get方法就会抛出 TimeOutException。</li>
</ol>
<p><strong>Future 的其他方法介绍：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 尝试取消任务，如果任务已经完成、已取消或其他原因无法取消，则失败。 </span></span><br><span class="line"><span class="comment">     * 1、如果任务还没开始执行，则该任务不应该运行 </span></span><br><span class="line"><span class="comment">     * 2、如果任务已经开始执行，由参数mayInterruptIfRunning来决定执行该任务的线程是否应该被中断，这只是终止任务的一种尝试。</span></span><br><span class="line"><span class="comment">          若mayInterruptIfRunning为true，则会立即中断执行任务的线程并返回true</span></span><br><span class="line"><span class="comment">          若mayInterruptIfRunning为false，则会返回true且不会中断任务执行线程。</span></span><br><span class="line"><span class="comment">     * 3、调用这个方法后，以后对isDone方法调用都返回true。 </span></span><br><span class="line"><span class="comment">     * 4、如果这个方法返回true,以后对isCancelled返回true。 </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 判断任务是否被取消了，如果调用了cancel()则返回true </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 如果任务完成，则返回ture </span></span><br><span class="line"><span class="comment">     * 任务完成包含正常终止、异常、取消任务。在这些情况下都返回true </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note modern primary no-icon flat"><p><strong>FutureTask 的使用：</strong></p>
</div>

<p>上面的例子使用的是线程池的 submit 方法创建 Future 对象，现在介绍一种由普通线程创建的 Future 对象：FutureTask。</p>
<p>Thread 类是只能传入 Runnable 方法去执行的，而现在又需要一个 Future 对象，显而易见的我们需要一个类同时实现 Future 和 Runnable 对象。</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/FutureTask%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="FutureTask类关系图"></p>
<p>这个类的使用方式也很简单，需要 Runnable 对象的时候就把它当 Runnable 去用，需要 Future 的时候就把它当 Future 去用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>巨人的肩膀：</strong></p>
<p><a href="https://www.51cto.com/article/633900.html">并发编程之Future&amp;FutureTask深入解析</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>Java并发：AQS</title>
    <url>/posts/38839/</url>
    <content><![CDATA[<p>AQS 的全称是：AbstractQueuedSynchronizer（抽象队列同步器）j.u.c 包下所提供的一系列同步器，也是在 AQS 的帮助下实现的，比如 CountDownLatch、ReentrantLock、Semaphore、CyclicBarrier 等。</p>
<p>同步器都会有一个内部类继承自 AQS 并且重写 AQS 中的一些方法以定制化一些更具特征的功能，一般这个内部类被命名为 Sync。以 Sync 为工具对外提供一些操纵的接口，以此实现自定义同步器。</p>
<p>同步器都拥有让线程陷入阻塞以及唤醒阻塞线程继续执行的能力，之间的区别只是阻塞、唤醒线程的时机、方法、形式不同而已。也正是这些同步器提供了 Java 强大的并发能力。</p>
<p>所以其实这些同步器都必须具备共同的能力：<strong>阻塞、唤醒线程的能力。这项能力由 LockSupport 类提供。</strong></p>
<h1 id="LockSupport-的-park-和-unpark"><a href="#LockSupport-的-park-和-unpark" class="headerlink" title="LockSupport 的 park 和 unpark"></a>LockSupport 的 park 和 unpark</h1><p>LockSupport 类位于 <code>java.util.concurrent.locks</code> 包下，这个类中包含了 park 和 unpark 方法。park 方法可以阻塞当前线程一直到 unpark 方法被调用，unpark 方法也可以提前被调用。但是 unpark 方法是没有被计数的，也就是说提前调用多次 unpark 只会解除后续的一次 park 操作。另外 LockSupport 类是作用在线程上而不是同步器上的，一个线程在新的同步器上调用 park 操作可能会直接返回，因为在此之前可能还有剩余的 unpark 操作。</p>
<p><strong>使用示例，先 park 再 unpark</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;卧槽，我阻塞了。。。&quot;</span>);</span><br><span class="line">        LockSupport.park();</span><br><span class="line">        System.out.println(<span class="string">&quot;还好醒过来了。。吓死我了md&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">1</span>); <span class="comment">// 让 t1 跑一会</span></span><br><span class="line">    System.out.println(<span class="string">&quot;没事，我来将你唤醒。&quot;</span>);</span><br><span class="line">    LockSupport.unpark(t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用示例，先 unpark 再 park</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;这次我先将你唤醒！&quot;</span>);</span><br><span class="line">    LockSupport.unpark(Thread.currentThread());</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;先唤醒再阻塞。&quot;</span>);</span><br><span class="line">    LockSupport.park();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;醒过来了。。&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>LockSupport 类中其他阻塞线程的方法：</strong></p>
<ul>
<li>void park(Object blocker)</li>
<li>void parkNanos(long nanos)</li>
<li>void parkNanos(Object blocker, long nanos)</li>
<li>void parkUntil(long deadline)</li>
<li>void parkUntil(Object blocker, long deadline)</li>
<li>blocker：记录导致线程阻塞的对象，方便故障排查</li>
<li>nanos：阻塞当前线程，最长不超过 nanos 纳秒，或者被 unpark 唤醒</li>
<li>deadline：阻塞当前线程直到 deadline 之前，或者被 unpark 唤醒</li>
</ul>
<h1 id="AQS-概述"><a href="#AQS-概述" class="headerlink" title="AQS 概述"></a>AQS 概述</h1><p>开头提到的同步器都必须实现以下两个功能：</p>
<ul>
<li>同步资源的管理（例如：CountDownLatch 的倒数、锁的获取和释放），以及同步资源的更新和检查操作。</li>
<li>至少有一个方法导致调用线程在同步状态已经被获取时阻塞，以及在其他线程改变这个同步状态时解除阻塞等。</li>
</ul>
<p>实现这两个功能需要两个操作：acquire（申请同步资源）、release（释放同步资源），AQS 提供了这两个方法。</p>
<ul>
<li><strong>acquire：</strong>尝试申请同步资源，失败阻塞调用的线程，直到同步资源允许其继续执行。例如：ReentrantLock.lock()、CountDownLatch.await() 等方法</li>
<li><strong>release：</strong>释放当前线程所持有的同步资源，使得一或多个被 acquire 阻塞的线程继续执行。例如：ReentrantLock.unlock()、CountDownLatch.countDown() 等方法。</li>
</ul>
<p>AQS 并没有对自定义同步器的同步方法做统一的定义，因此在不同的同步器中 acquire 和 release 的名称可能有所不同，例如：Lock.lock、Semaphore.acquire、CountDownLatch.await、FutureTask.get 他们都是 acquire 方法的体现，而比如 Lock.unlock 则是 release 的体现了。</p>
<p>AQS 背后的基本思想其实很简单，acquire 操作如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (拿不到同步资源) &#123;</span><br><span class="line">    进入阻塞队列排队;</span><br><span class="line">    或者不排队，直接返回;</span><br><span class="line">&#125;</span><br><span class="line">拿到同步资源了，退出排队;</span><br></pre></td></tr></table></figure>

<p>release 操作如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">释放同步资源;</span><br><span class="line"><span class="keyword">if</span> (同步资源充足，允许被阻塞的线程获取)</span><br><span class="line">    唤醒能获取同步资源的线程;</span><br></pre></td></tr></table></figure>

<p>为了实现 acquire 和 release 操作，需要以下的三个基本组件的相互协作：</p>
<ul>
<li>同步状态的原子性管理</li>
<li>线程的阻塞与唤醒被阻塞的线程</li>
<li>线程排队的队列管理</li>
</ul>
<p>同时实现这三个功能是可以做到的，但是无法应对各种各样的同步需求，比如在互斥锁中同一时刻只允许有一个线程持有锁，而共享锁则允许同一时刻有多个线程持有锁、以及各种同步器之间的特性无法同时实现。AQS 实际上是将这些组件共同的部分（例如：acquire 和 release）提取出来了，而其他的同步器继承 AQS 来做一些个性化实现。</p>
<blockquote>
<p>这也是 Java 继承的一种应用，将公共部分提取出来作为父类，再由子类继承父类去做一些个性化定制。只是在自定义同步器中对 AQS 的继承跟常规继承还有点区别。这里的继承更像是一种组合的操作，而不是对 AQS 的扩展。</p>
</blockquote>
<h1 id="同步资源"><a href="#同步资源" class="headerlink" title="同步资源"></a>同步资源</h1><p><strong>概述：</strong>同步资源表示的是当前线程是否满足继续执行条件。这个条件更像是一个许可证，拿到执行许可证才能继续执行。所以你可以把同步资源理解为执行许可证。</p>
<p><strong>表示：</strong>AQS 使用 state 属性（int 32位）来设置同步资源，并暴露出 <code>getState</code>、<code>setState</code> 以及 <code>compareAndSet</code> 操作来读取和更新这个属性，这些方法都依赖于 j.u.c.atomic 包的支持。</p>
<p>AQS 并不维护同步资源的值，仅为其提供维护方法，具体如何对同步资源调配将有继承自 AQS 的同步器自行处理。同步器仅需实现对同步资源的获取与释放方法即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等）AQS 在顶层已经实现好了，同步器主要实现也仅能实现以下的几种方法：</p>
<ul>
<li><strong>isHeldExclusively()：</strong>该线程是否正在独占资源。只有用到condition才需要去实现它。</li>
<li><strong>tryAcquire(int)：</strong>独占方式。尝试获取资源，成功则返回true，失败则返回false。</li>
<li><strong>tryRelease(int)：</strong>独占方式。尝试释放资源，成功则返回true，失败则返回false。</li>
<li><strong>tryAcquireShared(int)：</strong>共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>
<li><strong>tryReleaseShared(int)：</strong>共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li>
</ul>
<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现 tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared 中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如 ReentrantReadWriteLock。</p>
<h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><p>整个框架的关键就是如何管理被阻塞的线程的队列，该队列是严格的 FIFO 队列，因此，框架不支持基于优先级的同步。</p>
<p>其实这里称之为队列我认为不是很准确，从数据结构的角度它更像是一个双端链表，可能从 FIFO 的特性来说它才更像是一个队列吧。</p>
<p>既然是双向链表，那么就只需要关注其节点的数据结构以及如何组织节点即可。</p>
<p>先看一下节点的数据结构，至于如何组织节点将在分析 acquire、release 的时候做具体介绍，其实也就是介绍节点的创建时机、以及怎样入队出队的时机。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">// 标识节点当前是共享模式还是独占模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// waitStatus 字段的值，下面会介绍</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程等待状态，取值在上面</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line">    <span class="comment">// 前驱节点的引用</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="comment">// 后继节点的引用</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="comment">// 这个就是线程本尊</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 Node 节点类很明显就是一个标准双端链表的节点类，有 prev、next 指向前驱和后继节点，thread 当然就是具体的线程，waitStatus 当然就是线程在队列中的状态了。</p>
<blockquote>
<ul>
<li><strong>CANCELLED：</strong>表示当前结点已取消调度。当 timeout 或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。</li>
<li><strong>SIGNAL：</strong>表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为 SIGNAL。</li>
<li><strong>CONDITION：</strong>表示结点等待在 Condition 上，当其他线程调用了 Condition 的 signal() 方法后，CONDITION 状态的结点将从等待队列转移到同步队列中，等待获取同步锁。</li>
<li><strong>PROPAGATE：</strong>共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。</li>
<li><strong>0：</strong>新结点入队时的默认状态。</li>
</ul>
</blockquote>
<p>注意：负值表示结点处于有效等待状态，而正值表示结点已被取消。所以源码中很多地方用 <code>&gt;0</code>、<code>&lt;0</code> 来判断结点的状态是否正常。</p>
<h1 id="AQS-结构"><a href="#AQS-结构" class="headerlink" title="AQS 结构"></a>AQS 结构</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头结点，你直接把它当做 当前持有锁的线程 可能是最好理解的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个链表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步资源状态，这个字段将由继承 AQS 的自定义同步器维护</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表当前持有独占锁的线程，继承自 AbstractOwnableSynchronizer</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br></pre></td></tr></table></figure>

<p>整个 AQS 维护了一个 state（同步资源）和一个阻塞队列，当多线程竞争同步资源被阻塞的线程会进入此队列排队。他们之间的关系如下：</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/AQS-1.png" alt="AQS-1"></p>
<hr>
<blockquote>
<p><strong>小结：</strong></p>
<p>AQS 是被抽象出来作为各个同步器最重要的工具 Sync 类的父类而存在的。AQS 定义了同步资源 state 属性，并且为其提供维护方法。同步器通过维护同步资源来调用 AQS 中对线程的阻塞入队&#x2F;唤醒出队等操作。</p>
</blockquote>
<p>关于 AQS 的概念性介绍就到这里，关于最重要的 acquire 和 release 方法会再单独开一篇文章做详解。</p>
<hr>
<blockquote>
<p><strong>巨人的肩膀：</strong></p>
<ul>
<li><a href="https://www.cnblogs.com/dennyzhangdd/p/7218510.html">《The java.util.concurrent Synchronizer Framework》 JUC同步器框架（AQS框架）原文翻译</a></li>
<li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer">一行一行源码分析清楚AbstractQueuedSynchronizer</a></li>
<li><a href="https://www.cnblogs.com/waterystone/p/4920797.html">Java并发之AQS详解</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>Java并发：同步工具类</title>
    <url>/posts/30379/</url>
    <content><![CDATA[<p>本文讲述控制并发流程的工具类，包括：CountDownLatch、Semaphore、CyclicBarrier、Condition。这些工具类的作用就是帮助程序员更容易控制线程之间的合作，让线程互相配合，以满足业务逻辑，比如让线程A等待线程B执行完毕后再执行的排队策略、或者是让多个线程等待到某个时刻再同时从某个阶段开始执行的合作策略。</p>
<h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><blockquote>
<p>中文名：倒计时门栓，举个例子可以类比成一个门锁，一旦门打开了，门外面等待的人就会一拥而入。而 CountDownLatch 就是用一个倒计时做为门锁，一旦计数到0，就把门锁打开，等待执行的线程就会在此时刻一起开始执行。</p>
</blockquote>
<p><strong>构造方法：</strong></p>
<ul>
<li><code>public CountDownLatch(int count)</code> 参数 count 为要倒数的值</li>
</ul>
<p><strong>重要方法：</strong></p>
<ul>
<li><code>public void await() throws InterruptedException</code><ul>
<li>等待，线程调用此方法后被挂起，等待直到 count 值为0才开始执行</li>
</ul>
</li>
<li><code>public boolean await(long timeout, TimeUnit unit)</code><ul>
<li>超时等待，线程调用此方法后会被挂起，在设置的最长等待时间之前如果倒计时结束则返回 true 并在倒计时结束时刻开始执行后续代码，到达最长等待时间之后则返回 false 并开始执行后续代码</li>
</ul>
</li>
<li><code>public void countDown()</code><ul>
<li>将 count 值减1，直到为0时，等待的线程才会被唤醒。</li>
</ul>
</li>
</ul>
<p><strong>CountDownLatch 使用示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(Math.abs(r.nextInt() % <span class="number">1000</span>));</span><br><span class="line">                latch.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;门锁打开了，开始执行，此刻时间是：&quot;</span> + System.currentTimeMillis());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    latch.countDown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 十个线程的开始执行时间都是相同的</span></span><br></pre></td></tr></table></figure>

<h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><blockquote>
<p>可以理解为：运行许可证。拿到 Semaphore 资源的线程才可以往下运行，运行完毕之后必须归还 Semaphore 资源。可以用来保护一些比较稀缺的资源，保证了同一时刻最多只有有限个线程在使用这些稀缺资源。</p>
</blockquote>
<p><strong>构造方法：</strong></p>
<ul>
<li><code>public Semaphore(int permits, boolean fair)</code><ul>
<li>permits：运行许可证数量</li>
<li>fair：是否使用公平锁策略</li>
</ul>
</li>
</ul>
<p><strong>重要方法：</strong></p>
<ul>
<li><code>public void acquire() throws InterruptedException</code><ul>
<li>申请许可证，如果暂时没许可证则陷入阻塞。</li>
</ul>
</li>
<li><code>public boolean tryAcquire()</code><ul>
<li>尝试申请许可证，看看现在有没有空闲的许可证，如果有的话直接获取，没有则去做别的事情。</li>
</ul>
</li>
<li><code>public void release()</code><ul>
<li>释放许可证，将用完的许可证放回去。必须在 finally 代码块中调用</li>
</ul>
</li>
</ul>
<p>以上摘抄了几个比较重要的方法出来说明，Semaphore 类中还有一些其他的方法能更灵活使用，包括设置阻塞超时、一次性获取多个许可证、一次性释放多个许可证等。</p>
<p><strong>Semaphore 使用示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Semaphore</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                s.acquire();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 申请到了许可证，往下执行&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;释放许可证&quot;</span>);</span><br><span class="line">                s.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Thread-&quot;</span> + i).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><blockquote>
<p>可以类比为春游时候的大巴车，等待人满发车。就是约定好一个数字（<em>大巴车的载客数</em>），先到的线程等待后到的线程（<em>先上车的同学等待后上车的同学</em>），等到线程数满足约定数量之后（<em>全部同学到齐</em>）全部开始执行（<em>发车</em>）。</p>
</blockquote>
<p><strong>构造方法：</strong></p>
<ul>
<li><code>public CyclicBarrier(int parties, Runnable barrierAction)</code><ul>
<li>parties：提前约定好等待线程的数量</li>
<li>barrierAction：等待所有线程到齐后执行的线程</li>
</ul>
</li>
</ul>
<p><strong>重要方法：</strong></p>
<ul>
<li><code>public int await() throws InterruptedException, BrokenBarrierException</code><ul>
<li>先到的线程开始等待后面的线程来了之后一起执行</li>
</ul>
</li>
<li><code>public int await(long timeout, TimeUnit unit) throws InterruptedException, BrokenBarrierException, TimeoutException</code><ul>
<li>设置超时的等待，超时抛出 TimeoutException</li>
</ul>
</li>
<li><code>public void reset()</code><ul>
<li>放弃正在等待中的线程，开始新一轮等待</li>
</ul>
</li>
</ul>
<div class="note primary modern no-icon flat"><p><strong>抛出 BrokenBarrierException 的3种情况：</strong></p>
</div>

<ol>
<li>其他等待的线程被中断</li>
<li>其他等待的线程超时</li>
<li>其他线程调用 CyclicBarrier.reset() 方法</li>
</ol>
<p><strong>CyclicBarrier 使用示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">CyclicBarrier</span> <span class="variable">cb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">5</span>, () -&gt; System.out.println(<span class="string">&quot;大巴发车&quot;</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>(i, cb), <span class="string">&quot;Thread-&quot;</span> + i).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier cb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Task</span><span class="params">(<span class="type">int</span> id, CyclicBarrier cb)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.cb = cb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread-&quot;</span> + id + <span class="string">&quot; 准备前往大巴车&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(Math.abs(r.nextInt() % <span class="number">10000</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread-&quot;</span> + id + <span class="string">&quot; 已经上大巴车了，开始等待其他同学到达&quot;</span>);</span><br><span class="line">            cb.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread-&quot;</span> + id + <span class="string">&quot;所乘坐的大巴车出发！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p><strong>CountDownLatch 和 CyclicBarrier 的区别：</strong></p>
<ol>
<li><strong>可重用性不同：</strong>CountDownLatch 在倒数到0并出发门栓打开后，就不能再次使用了，只能创建新的实例；而 CyclicBarrier 可以重复使用。</li>
<li><strong>作用不同：</strong>CyclicBarrier 要等到固定数量的线程都到达了栅栏位置才能继续执行，而 CountDownLatch 只需要等待计数器倒数至0。</li>
<li>CyclicBarrier 是线程之间的交互行为，重点在协作的线程；<br>CountDownLatch 是倒数事件的行为，重点在倒数的事件。</li>
</ol>
</blockquote>
<p><strong>CountDownLatch 的应用场景：</strong>有一个任务想要往下执行，但必须要等到其他的任务执行完毕后才可以继续往下执行。假如我们这个想要继续往下执行的任务调用一个CountDownLatch对象的await()方法，其他的任务执行完自己的任务后调用同一个CountDownLatch对象上的countDown()方法，这个调用await()方法的任务将一直阻塞等待，直到这个CountDownLatch对象的计数值减到0为止。</p>
<p><strong>CyclicBarrier 的应用场景：</strong>CyclicBarrier 可以构造一个栅栏，当某一个线程执行到栅栏前，它就会开始等待，直到所有线程都到达栅栏前，那么该栅栏就会打开，所有线程再统一出发，继续执行剩下的任务。</p>
<h1 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h1><blockquote>
<p>条件对象。是 Object 中的 wait()、notify()、notifyAll() 这几个方法的升级版（避免了 synchronized 的使用），不同的是这里的锁使用的是 ReentrantLock，而不是 monitor 锁。<br>关于 Object 中的 wait()、notify()、notifyAll() 这几个方法具体可以查看<a href="https://www.wrp.cool/posts/29010/">这里</a></p>
</blockquote>
<p><strong>创建 Condition 对象：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">c</span> <span class="operator">=</span> lock.newCondition();</span><br></pre></td></tr></table></figure>

<div class="note info modern no-icon flat"><p><strong>Condition 中与 Object 三个方法的对应：</strong></p>
</div>

<table>
<thead>
<tr>
<th align="left">Object</th>
<th align="left">Condition</th>
</tr>
</thead>
<tbody><tr>
<td align="left">wait()</td>
<td align="left">await()</td>
</tr>
<tr>
<td align="left">notify()</td>
<td align="left">signal()</td>
</tr>
<tr>
<td align="left">notifyAll()</td>
<td align="left">signalAll()</td>
</tr>
</tbody></table>
<p><strong>Condition 使用的示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两个线程交替打印 1-100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (count &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                c.signal();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;输出：&quot;</span> + String.format(<span class="string">&quot;%03d&quot;</span>, count++));</span><br><span class="line">                <span class="keyword">if</span> (count &lt;= <span class="number">100</span>)</span><br><span class="line">                    c.awaitUninterruptibly();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;奇数线程&quot;</span>).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;偶数线程&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的这个交替打印 1-100 的例子，还可以使用 synchronized 来实现，只是效率上较差了一些。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> count;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 打印奇数的线程</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (count &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + count++);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;奇数&quot;</span>).start();</span><br><span class="line">    <span class="comment">// 打印偶数的线程</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (count &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + count++);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;偶数&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个场景下使用 synchronized 的效率较差的原因是：竞争到锁的线程将判断是否满足打印条件，如果满足则打印，否则直接跳出，紧接着同步代码块执行完毕释放锁，两个线程重新进入竞争锁的步骤，如果在这个时候其中一个线程接连多次竞争到锁，但是却因为不满足打印条件而再次直接释放锁，这就是无意义的浪费</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>Java并发：并发容器</title>
    <url>/posts/3103/</url>
    <content><![CDATA[<blockquote>
<p>看并发容器的发展历史其实也反映了一个软件的发展历史，很明显大多数软件在研发的初期都是比较粗糙的，这也是由市场的性质所决定的，前期如果投入了过多的时间跟精力，那么一旦这款软件不被市场所接受，那全都白费了。并发容器的发展历程跟这如出一辙。</p>
</blockquote>
<p>早期的 jdk 中的并发容器只有 Vector 和 Hashtable，初期的设计这两种并发容器的效率并不理想，这两个并发容器的实现和早期的 ArrayList 和 HashMap 几乎一样，只是在其中的一些可能会导致并发不安全的方法上加了 synchronized 关键字用来同步。将 synchronized 加在方法上等于是锁住了整个实例对象。这样的设计是方便了开发人员，几乎是最少的成本实现了并发容器的功能，但是效率上就堪忧了。</p>
<p>再到后来的 Collections 提供的同步工具类：<code>Collections.synchronizedList(new ArrayList&lt;&gt;())</code>。这种方式来创建并发容器，实际上也只是把 synchronized 从方法签名上转移到了方法内部。锁的粒度更细了一些，但也不是那么优秀。</p>
<p>这两种方式虽然都不是很优秀，但也是一个发展的过程。接下来才是正文。</p>
<div class="note default flat"><p><strong>为什么普通容器不安全</strong></p>
</div>

<p>普通容器没有对写操作和扩容做同步操作，如果多个线程同时写到了同一个位置或者扩容的话，只有一个线程的修改能被保存下来。原理就像是不安全的 <code>i++</code> 一样。</p>
<p>甚至在 HashMap 中多线程同时扩容还会造成 <code>自己.next = 自己</code> 造成 CPU100% 的情况。具体情况可以参考<a href="https://coolshell.cn/articles/9606.html">这篇文章</a></p>
<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><p>Java8 中 的 ConcurrentHashMap 数据结构示意图：</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8-1.png" alt="并发容器-1"></p>
<p>第一排被框起来的一个个小方块就是 Node 节点类，这里要跟 Java7 的 Segment 区分好，jdk1.7 的 Segment 通过继承 ReentrantLock 来加锁，也就是每次锁住的是一个 Segment 实例，相当于是所有的 Segment 加起来才是完整的 ConcurrentHashMap，在一定程度上提高了并发度。一开始我认为 Java8 的 Node 跟 Java7 的 Segment 一样是不可扩容的，但这里的 Node 是可以扩容的，要区分开。</p>
<p>正常来说数据都是存放在 Node 数组里面的，如果发生了 hash 冲突，那会从 Node 往后再拉一个链表出来，把冲突的数据放在后面。当这个链表的长度达到 8 并且 Node 数组的长度超过 64，那么就会把链表转换成红黑树来存储冲突数据。</p>
<p>概括一下 ConcurrentHashMap 中的数据结构为：<code>数组 + 链表 + 红黑树</code></p>
<h2 id="put-方法流程"><a href="#put-方法流程" class="headerlink" title="put() 方法流程"></a>put() 方法流程</h2><p>方法定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来要分析的内容，onlyIfAbsent：元素是否可重复</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先就是一些常规流程，比如判空、获取新元素 hash 值、以及记录链表长度用于后面判断是否需要链表转红黑树操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line"><span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>根据前面的 ConcurrentHashMap 的数据结构，put() 方法添加的新元素可能会：</p>
<ul>
<li>落在 Node 节点上；</li>
<li>落在 Node 拉出来的链表上；</li>
<li>落在由链表转换的红黑树上。</li>
</ul>
<h3 id="新元素落在-Node-上"><a href="#新元素落在-Node-上" class="headerlink" title="新元素落在 Node 上"></a>新元素落在 Node 上</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自旋，确保肯定能插入成功</span></span><br><span class="line"><span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">    Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">    <span class="comment">// 找到 hash 对应位置的 Node 发现为 null，于是此次 put() 操作应该创建新 Node</span></span><br><span class="line">    <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// CAS 把新 Node 放进去</span></span><br><span class="line">        <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 数据落在链表或者红黑树上的情况，下面的分析将从此处开始</span></span><br><span class="line">        <span class="comment">// 数据落地后判断是否将链表转换成红黑树，该部分分析从此处开始</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h3 id="新元素落在链表上"><a href="#新元素落在链表上" class="headerlink" title="新元素落在链表上"></a>新元素落在链表上</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从此处开始才锁起来，锁的对象是被操作的整个 Node 节点</span></span><br><span class="line"><span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">    <span class="comment">/* 因为刚刚没有锁起来，在这里可能刚刚拿到的 f 节点已经被改了</span></span><br><span class="line"><span class="comment">     * 再做一次判断看看有没有被改，如果被改了那就自旋重来一次 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 关于这里的这个 if 说一点点点我自己的想法吧，</span></span><br><span class="line"><span class="comment">     * 如果是我写这个 if 我会这么写：if (tabAt(tab, i) != f) continue;</span></span><br><span class="line"><span class="comment">     * 首先这么写可以少一层缩进，代码上看起来会舒服一些</span></span><br><span class="line"><span class="comment">     * 另外下面还有一个判断是否要转换成红黑树的操作，直接 continue 的话可以少一次判断，</span></span><br><span class="line"><span class="comment">     * 少这一次判断不是为了省这一点点的判断的性能，而是此时如果其他线程增加了节点导致需要转换红黑树，</span></span><br><span class="line"><span class="comment">     * 那么哪个判断就进去了，虽然 treeifyBin() 方法也是线程安全的，但本来这不该是当前线程去做的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">        <span class="comment">// fh：头节点的 hash 值，大于 0 说明是链表</span></span><br><span class="line">        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            binCount = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 循环找到链表最后一个位置</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                K ek;</span><br><span class="line">                <span class="comment">// 找到了重复的键，判断是否覆盖</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                    oldVal = e.val;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                        e.val = value;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                <span class="comment">// 走到了链表尾，将新元素挂在链表尾部。</span></span><br><span class="line">                <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数据落在红黑树的情况，下面的分析将从此处开始</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="新元素落在红黑树上"><a href="#新元素落在红黑树上" class="headerlink" title="新元素落在红黑树上"></a>新元素落在红黑树上</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头节点是红黑树节点</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">    Node&lt;K,V&gt; p;</span><br><span class="line">    binCount = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 调用红黑树的插值方法插入新节点</span></span><br><span class="line">    <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        oldVal = p.val;</span><br><span class="line">        <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">            p.val = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="是否链转红"><a href="#是否链转红" class="headerlink" title="是否链转红"></a>是否链转红</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链表长度超过8转换成红黑树</span></span><br><span class="line"><span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">        <span class="comment">// 走到这里还不一定会转换成红黑树</span></span><br><span class="line">        <span class="comment">// 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树</span></span><br><span class="line">        treeifyBin(tab, i);</span><br><span class="line">    <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> oldVal;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note default flat"><p><strong>为什么链表转红黑树的阈值是8？</strong></p>
</div>

<p>根据泊松分布，如果 hash 函数的设计没问题的话，链表长度超过8的概率还不足千万分之一，已经是及其小的概率了。千万不要觉得8这个数字不是那么大就觉得 ConcurrentHashMap 会经常发生链表转红黑树的情况。</p>
<h3 id="put-流程小结"><a href="#put-流程小结" class="headerlink" title="put() 流程小结"></a>put() 流程小结</h3><ol>
<li>准备工作：判断 key value 不为空、计算 hash 值等。</li>
<li>如果：新元素落在新节点上。那么：CAS 新增节点。</li>
<li>如果：新元素落在链表上。那么：遍历链表插入新元素。</li>
<li>如果：新元素落在红黑树上。那么：调用红黑树方法插入新节点。</li>
<li>判断是否需要将链表转换为红黑树</li>
</ol>
<p>关于整个 put() 方法的工作流程这里还只是很表面的分析，这里还有几个重量级问题：第一个是初始化，第二个是扩容，第三个是帮助数据迁移。</p>
<h2 id="get-方法流程"><a href="#get-方法流程" class="headerlink" title="get() 方法流程"></a>get() 方法流程</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 ConcurrentHashMap 是否已经初始化完毕，以及对应位置的元素是否已经添加</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 头节点是不是我们想要的节点</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果头结点的 hash 小于 0，说明 正在扩容，或者该位置是红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// find 方法根据 e 的具体实现（ForwardingNode 或 TreeBin）而调用对应方法</span></span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 不是红黑树也不是头节点，那肯定是链表，遍历取出即可</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>get() 流程小结：</strong></p>
<ol>
<li>计算 hash 值</li>
<li>如果：值在 Node 节点中。那么：直接返回。</li>
<li>如果：正在扩容或者值在红黑树中。那么：调用对应方法找到 val 返回</li>
<li>如果：都不是。那么：肯定是链表，遍历返回 val</li>
<li>找不到，返回 null</li>
</ol>
<h1 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h1><p>先简单介绍一下 Cpoy On Write 思想吧。Cpoy On Write 就是一种写时复制的操作，字面上意思也很明确：写操作复制。执行写入操作时先复制一份副本，在副本上写入，再将指针指向被修改的副本。优点是在读取的时候不需要加锁，并且读写冲突不会抢锁，仅在写写冲突的时候会抢锁。缺点也很明显，多线程同时写的话会对内存造成比较大的压力；并且保证不了数据的实施一致性，只能保证数据的最终一致性，因为读操作拿到的数据可能不是最新的数据。</p>
<p>其多线程并发安全由内部数据不可变保证，不可变指的是每次修改都是在副本上修改，所以读取的数据永远不会改变。</p>
<div class="note default flat"><p><strong>Cpoy On Write 在迭代中的应用：</strong></p>
</div>

<p>一些没有 Cpoy On Write 能力的集合（ArrayList）在迭代的时候会发生什么事情：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">    <span class="keyword">for</span> (Integer i : list) </span><br><span class="line">        list.add(<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 方法抛出异常：</span></span><br><span class="line"><span class="comment">// java.util.ConcurrentModificationException</span></span><br></pre></td></tr></table></figure>

<p>抛出异常的原因也很简单，ArrayList 不允许在迭代的过程中新增或者删除元素。为什么不允许呢？</p>
<p>因为迭代的过程中新增或删除元素会导致迭代访问元素顺序错乱或者死循环跟下标越界问题。比如：访问到第5个元素的时候把第1个元素删了，此时所有元素往前移了一个位置，那原来的第六个元素的访问就被跳过了。</p>
<p>foreach 循环依赖了由 ArrayList 提供的 Iterator 对象。Iterator 对象维护了一个 expectedModCount 变量，这个变量记录了 Iterator 对象初始化时 ArrayList 发生了多少次增加或删除元素的操作，ArrayList 每次增加或删除元素都会维护 modCount 变量。于是每次迭代调用 iterator.next() 时都会检查 expectedModCount 与 modCount 是否相等，不相等则抛出 java.util.ConcurrentModificationException 异常。</p>
<p>上面的代码如果使用 CopyOnWriteArrayList 实现就不会抛出此异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">    <span class="keyword">for</span> (Integer i : list) &#123;</span><br><span class="line">        list.add(<span class="number">6</span>);</span><br><span class="line">        System.out.print(i + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(<span class="string">&quot;\n&quot;</span> + list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 方法输出：</span></span><br><span class="line"><span class="comment">// 1  2  3  4  5  </span></span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6, 6, 6, 6, 6]</span></span><br></pre></td></tr></table></figure>

<p>结果也是很明显，符合 Copy On Write 原则。新增元素时在副本上增加，不会影响到正在迭代的数据，指针切换后仍然遍历的是旧数据。</p>
<h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><p>阻塞队列（BlockingQueue）通常用于一个线程生产对象，而另外一个线程消费这些对象的场景。下图是对这个原理的阐述：</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="阻塞队列示意图"></p>
<p>在这个示意图中，<code>Thread 1</code> 代表生产线程，<code>Thread 2</code> 代表了消费线程。</p>
<p>生产线程将会持续生产新对象放到阻塞队列中，直到队列达到它所能容纳的临界点。达到临界点再往队列插入新对象时会发生阻塞，直到消费线程从队列中拿走一个对象。消费线程会一直在阻塞队列中拿出对象，如果队列为空的话，消费线程会发生阻塞，直到一个生产线程往队列中插入一个新对象。</p>
<p>每当有新对象入队时就会唤醒一个消费者线程；每当有一个对象出队时就会唤醒一个生产者线程。</p>
<div class="note default flat"><p><strong>使用示例：ArrayBlockingQueue</strong></p>
</div>

<p>ArrayBlockingQueue 是一个有界的阻塞队列，也是一个 FIFO 队列，其底层由一个不可扩容的数组实现，意味着同一时间能够存储元素数量是有上限的，数组容易在初始化时设定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(BlockingQueue&lt;Integer&gt; queue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.put(<span class="number">1</span>);</span><br><span class="line">            queue.put(<span class="number">2</span>);</span><br><span class="line">            queue.put(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(BlockingQueue&lt;Integer&gt; queue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(queue.take());</span><br><span class="line">            System.out.println(queue.take());</span><br><span class="line">            System.out.println(queue.take());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(queue);</span><br><span class="line">    <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(queue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(producer).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(consumer).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一些其他阻塞队列在实际开发中应当视情况选择合适的队列使用比如：延迟队列 DelayQueue、链阻塞队列 LinkedBlockingQueue、具有优先级的阻塞队列 PriorityBlockingQueue、同步队列 SynchronousQueue 等等。</p>
<hr>
<blockquote>
<p><strong>巨人的肩膀：</strong></p>
<ul>
<li><a href="https://www.javadoop.com/post/hashmap">Java7&#x2F;8 中的 HashMap 和 ConcurrentHashMap 全解析</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>Java并发：final</title>
    <url>/posts/38583/</url>
    <content><![CDATA[<p>final 是一个在 Java 基础阶段就会学到的关键字，首先回顾一下 final 的基本用法，再进一步深入了解 final 在并发中的应用。</p>
<h1 id="final-基本用法"><a href="#final-基本用法" class="headerlink" title="final 基本用法"></a>final 基本用法</h1><h2 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a>修饰类</h2><p>当某个类的整体定义为 final 时，就表明了你不能打算继承该类，而且也不允许别人这么做。即这个类是不能有子类的。</p>
<p>注意：final 类中的所有方法都隐式为 final，因为无法覆盖他们，所以在 final 类中给任何方法添加 final 关键字是没有任何意义的。</p>
<div class="note default flat"><p><strong>那么怎么扩展 final 类呢？</strong></p>
</div>

<p>设计模式中最重要的两种关系，一种是继承&#x2F;实现；另外一种是组合关系。所以当遇到不能用继承的（final 修饰的类），应该考虑用组合，如下代码大概写个组合实现的意思：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String innerString;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...init &amp; other methods</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 支持老的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> innerString.length(); <span class="comment">// 通过innerString调用老的方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加新方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toMyString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h2><p>final 修饰的方法不能被重写，不过重写的前提是继承，如果 final 修饰的方法同时又是 private 的将会导致子类无法重写此方法，子类可以定义相同的方法名和参数，该方法将成为子类的新方法，而不是继承自父类的方法。</p>
<p>final 方法虽然不能被重写，但是可以被重载的，如下代码是正确的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">finalFunction</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">finalFunction</span><span class="params">(String name)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类中所有的 private 方法都是隐式 final 的，由于子类看不到父类的 private 方法，所以也就不能重写它。在代码中仍然能够对 private 方法添加 final 修饰符，但是这并没有什么用处。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;func from A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;func from B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        a.func(); <span class="comment">// 编译错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修饰参数"><a href="#修饰参数" class="headerlink" title="修饰参数"></a>修饰参数</h2><p>final 修饰的参数不能被改变，被 final 修饰的基本数据类型的参数其值不能被改变，被 final 修饰的引用数据类型的参数其地址不能被改变，但对象内部的数据可以被改变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finalDemo</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> i, <span class="keyword">final</span> User user)</span> &#123;</span><br><span class="line">    user.name = <span class="string">&quot;zhangsan&quot;</span>; <span class="comment">// 正确</span></span><br><span class="line">    i = <span class="number">10</span>;                 <span class="comment">// 错误</span></span><br><span class="line">    user = <span class="keyword">new</span> <span class="title class_">User</span>();      <span class="comment">// 错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h2><p><strong>被 final 修饰的属性不一定都是编译器常量</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">//编译期常量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">J</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非编译期常量</span></span><br><span class="line">    <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> r.nextInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>k</code> 的值由随机数对象决定，所以不是所有的 final 修饰的字段都是编译期常量，只是 <code>k</code> 的值在被初始化后无法被更改。</p>
<p><strong>static final 变量</strong></p>
<p>一个既是static又是final 的字段只占据一段不能改变的存储空间，它必须在定义的时候进行赋值，否则编译器将不予通过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> r.nextInt(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">k2</span> <span class="operator">=</span> r.nextInt(<span class="number">10</span>); </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;k=&quot;</span>+t1.k+<span class="string">&quot; k2=&quot;</span>+t1.k2);</span><br><span class="line">        <span class="type">Test</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;k=&quot;</span>+t2.k+<span class="string">&quot; k2=&quot;</span>+t2.k2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码某次输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">k=6 k2=5</span><br><span class="line">k=1 k2=5</span><br></pre></td></tr></table></figure>

<p>对于不同的对象<code>k</code>的值是不同的，但是<code>k2</code>的值却是相同的，这是为什么呢？<br>因为 static 关键字所修饰的字段并不属于一个对象，而是属于这个类的。也可简单的理解为 static final 所修饰的字段仅占据内存的一个一份空间，一旦被初始化之后便不会被更改。</p>
<hr>
<p>对于 final 的基本用法就介绍到这里，接下来介绍 final 在并发中的应用：</p>
<h1 id="final-域的重排序规则"><a href="#final-域的重排序规则" class="headerlink" title="final 域的重排序规则"></a>final 域的重排序规则</h1><ol>
<li>在构造函数内对一个 final 域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li>
<li>初次读一个包含 final 域的对象的引用，与随后初次读这个 final 域，这两个操作之间不能重排序。</li>
</ol>
<p><strong>写 final 域的重排序规则：</strong></p>
<ul>
<li>JMM 禁止编译器把 final 域的写重排序到构造函数之外。</li>
<li>编译器会在 final 域的写之后，构造函数 return 之前，插入一个 StoreStore 屏障。这个屏障禁止处理器把 final 域的写重排序到构造函数之外。</li>
</ul>
<p><strong>读 final 域的重排序规则：</strong></p>
<ul>
<li>在一个线程中，初次读对象引用与初次读该对象包含的 final 域，JMM 禁止处<br>理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读 final 域操作的前面插入一个 LoadLoad 屏障。</li>
</ul>
<blockquote>
<p><strong>巨人的肩膀：</strong></p>
<ul>
<li><a href="https://www.infoq.cn/minibook/java_memory_model">深入理解Java内存模型</a></li>
<li><a href="https://pdai.tech/md/java/thread/java-thread-x-key-final.html">关键字: final详解</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>Java并发：Unsafe、CAS和原子类</title>
    <url>/posts/61146/</url>
    <content><![CDATA[<blockquote>
<p>我在网上看到一些文章写着：CAS 是一种自旋锁。这是一种错误的观念，CAS 跟自旋其实没什么关系，只是当 CAS 失败的时候通常会使用自旋补偿罢了。换句话说，自旋是 CAS 的一种常见的补偿操作，二者并无直接关系。</p>
</blockquote>
<p>我个人认为程序员对于 CAS 这样的一种工具其实不应该是仅仅当作工具去看待，更多的是要掌握 CAS 这种思想，并且运用到实际开发中。比如在商品下单的库存校验部分就可以用到 CAS 思想。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">set</span> reserve <span class="operator">=</span> reserve <span class="operator">-</span> #&#123;buyCount&#125; <span class="keyword">from</span> goods <span class="keyword">where</span> reserve <span class="operator">&gt;=</span> #&#123;buyCount&#125;</span><br></pre></td></tr></table></figure>

<p>由于单条 SQL 执行的时候具有原子性，就算是秒杀的时候也不会导致库存不足的情况出现，这也是 CAS 的一种体现。</p>
<p>这也印证了 CAS 和自旋并无直接关系，此处的 CAS 失败应该直接通知用户库存不足，而不是做自旋等待。</p>
<hr>
<p>Java 中 CAS 由 Unsafe 类实现，原子类是对 CAS 的包装，对外屏蔽了 Unsafe 类，以及提供一些方便的操作。</p>
<p>CAS 的全称为 Compare-And-Swap ，直译就是对比交换。是一条 CPU 的原子指令（cmpxchg 指令），其作用是让 CPU 先进行比较两个值是否相等，然后原子地更新某个位置的值。就是说 CAS 是靠硬件实现的，JVM 只是封装了汇编调用，那些 java.util.concurrent.atomic.* 类便是使用了这些封装后的接口，这些接口的提供者就是 Unsafe。</p>
<p>CAS 操作需要输入两个数值，一个旧值（期望操作前的值）和一个新值，在操作期间先比较下在旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。CAS 操作是原子性的，所以多线程并发使用 CAS 更新数据时，可以不使用锁。JDK 中大量使用了 CAS 来更新数据而防止加锁（synchronized 重量级锁）来保持原子更新。</p>
<h1 id="Unsafe-类"><a href="#Unsafe-类" class="headerlink" title="Unsafe 类"></a>Unsafe 类</h1><p>Unsafe 是位于 sun.misc 包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升 Java 运行效率、增强 Java 语言底层资源操作能力方面起到了很大的作用。但由于 Unsafe 类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用 Unsafe 类会使得程序出错的概率变大，使得 Java 这种安全的语言变得不再“安全”，因此对 Unsafe 的使用一定要慎重。</p>
<p>Unsafe 类的设计者并不希望 Unsafe 被轻易的使用，尽管 Unsafe 里面的方法都是 public 的，但是并没有办法使用它们，JDK API 文档也没有提供任何关于这个类的方法的解释。总而言之，对于 Unsafe 类的使用都是受限制的，只有授信的代码才能获得该类的实例，当然 JDK 库里面的类是可以随意使用的。</p>
<p>Unsafe 类是单例实现的，提供静态方法 getUnsafe 获取 Unsafe 实例，当且仅当调用 getUnsafe 方法的类为引导类加载器所加载时才合法，否则抛出 SecurityException 异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Unsafe</span> &#123;</span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe theUnsafe;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Unsafe</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">var0</span> <span class="operator">=</span> Reflection.getCallerClass();</span><br><span class="line">        <span class="comment">// 仅在引导类加载器`BootstrapClassLoader`加载时才合法</span></span><br><span class="line">        <span class="keyword">if</span>(!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;    </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(<span class="string">&quot;Unsafe&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> theUnsafe;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想要获取 Unsafe 类实例有以下两种实现方案：</p>
<p>通过反射：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Unsafe <span class="title function_">reflectGetUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> (Unsafe) field.get(<span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">        log.error(e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从getUnsafe方法的使用限制条件出发，通过Java命令行命令-Xbootclasspath&#x2F;a把调用Unsafe相关方法的类A所在jar包路径追加到默认的bootstrap路径中，使得A被引导类加载器加载，从而通过Unsafe.getUnsafe方法安全的获取Unsafe实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -Xbootclasspath/a: $&#123;path&#125; // path 为调用 Unsafe 相关方法的类所在 jar 包路径 </span><br></pre></td></tr></table></figure>

<h1 id="Unsafe-对-CAS-的实现"><a href="#Unsafe-对-CAS-的实现" class="headerlink" title="Unsafe 对 CAS 的实现"></a>Unsafe 对 CAS 的实现</h1><p>Unsafe 类中只有三个跟 CAS 有关的方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CAS 实现</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o             包含要修改字段的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> offset        要修改字段在该对象中的内存偏移量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expected      期望值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> update        更新值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>              更新成功 ? true : false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapObject</span><span class="params">(Object o, <span class="type">long</span> offset, Object expected, Object update)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> expected, <span class="type">int</span> update)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapLong</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">long</span> expected, <span class="type">long</span> update)</span>;</span><br></pre></td></tr></table></figure>

<p>写一个小例子演示怎么使用 Unsafe 的 CAS 操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException &#123;</span><br><span class="line">    <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> reflectGetUnsafe();</span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    u.setId(<span class="number">1001L</span>);</span><br><span class="line">    u.setName(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    u.setAge(<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Field</span> <span class="variable">id</span> <span class="operator">=</span> User.class.getDeclaredField(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">    <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> User.class.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="type">Field</span> <span class="variable">age</span> <span class="operator">=</span> User.class.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">idOffset</span> <span class="operator">=</span> unsafe.objectFieldOffset(id);</span><br><span class="line">    <span class="type">long</span> <span class="variable">nameOffset</span> <span class="operator">=</span> unsafe.objectFieldOffset(name);</span><br><span class="line">    <span class="type">long</span> <span class="variable">ageOffset</span> <span class="operator">=</span> unsafe.objectFieldOffset(age);</span><br><span class="line"></span><br><span class="line">    unsafe.compareAndSwapLong(u, idOffset, <span class="number">1001L</span>, <span class="number">1002L</span>);</span><br><span class="line">    unsafe.compareAndSwapObject(u, nameOffset, <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">    unsafe.compareAndSwapInt(u, ageOffset, <span class="number">18</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// User&#123;id=1002, name=&#x27;lisi&#x27;, age=20&#125;</span></span><br></pre></td></tr></table></figure>

<div class="note default flat"><p><strong>CAS 存在的问题：</strong></p>
</div>

<ol>
<li><p><strong>ABA 问题</strong><br>因为 CAS 需要在操作值的时候，检查值有没有发生变化，比如没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用 CAS 进行检查时则会发现它的值没有发生变化，但是实际上却变化了。</p>
<p>ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么 A-&gt;B-&gt;A 就会变成 1A-&gt;2B-&gt;3A。</p>
</li>
<li><p><strong>自旋开销过大</strong><br> 自旋CAS如果长时间不成功，会给 CPU 带来非常大的执行开销。</p>
</li>
<li><p><strong>只能够保证一个变量的原子操作</strong><br>当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁。</p>
<p>从 Java 1.5 开始，JDK 提供了 AtomicReference 类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行 CAS 操作。</p>
</li>
</ol>
<h1 id="原子类对-CAS-的包装"><a href="#原子类对-CAS-的包装" class="headerlink" title="原子类对 CAS 的包装"></a>原子类对 CAS 的包装</h1><p>原子类是 JUC 为我们提供的方便程序员使用 CAS 的工具类，位于 java.util.concurrent.atomic 包，该包下的所有类都是原子类。</p>
<p>接下来将把该包下的原子类分为：</p>
<ul>
<li>基本数据类型原子类，以 <code>AtomicInteger</code> 为代表</li>
<li>数组类型原子类，以 <code>AtomicIntegerArray</code> 为代表</li>
<li>引用类型原子类，以 <code>AtomicReference</code> 为代表</li>
<li>原子更新字段类，以 <code>AtomicIntegerFieldUpdater</code> 为代表</li>
</ul>
<p>以及解决了 ABA 问题的原子类：<code>AtomicStampedReference</code>，还有 JDK8 新增的 Adder 和 Accumulator</p>
<h2 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h2><p>AtomicInteger 的构造过程如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unsafe 类实例，Unsafe CAS 所需要的偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态加载 value 字段相对当前对象的“起始地址”的偏移量</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset(AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被包装的 int 值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AtomicInteger</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AtomicInteger</span><span class="params">(<span class="type">int</span> initialValue)</span> &#123; value = initialValue; &#125;</span><br></pre></td></tr></table></figure>

<p><strong>常用 API：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> <span class="comment">// 获取当前的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> <span class="comment">// CAS 更新，expect：预期值，update：更新值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span> <span class="comment">// 获取当前的值，并设置新的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> <span class="comment">// 获取当前的值，并自增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">()</span> <span class="comment">// 获取当前的值，并自减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span> <span class="comment">// 获取当前的值，并加上预期的值</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">lazySet</span><span class="params">(<span class="type">int</span> newValue)</span> <span class="comment">// 最终会设置成 newValue,使用 lazySet 设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span><br></pre></td></tr></table></figure>

<p>常用 API 具体的使用方法这里就不展开了，JDK API 文档里面都有，其实现原理也比较好理解。</p>
<h2 id="AtomicIntegerArray"><a href="#AtomicIntegerArray" class="headerlink" title="AtomicIntegerArray"></a>AtomicIntegerArray</h2><blockquote>
<p>数组中的每个元素都具备原子性。</p>
</blockquote>
<p><strong>常用方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> expect, <span class="type">int</span> update)</span> <span class="comment">// CAS 更新，i：数组下标</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">// 获取下标i的元素</span></span><br></pre></td></tr></table></figure>

<p><strong>常用方法演示：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AtomicIntegerArray</span> <span class="variable">array</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    array.compareAndSet(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    System.out.println(array.get(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h2 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h2><blockquote>
<p>使对象具备原子性的修改</p>
</blockquote>
<p><strong>常用方法：</strong>compareAndSet(V expect, V update)，与前文相同。</p>
<p><strong>常用方法演示：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line">    AtomicReference&lt;User&gt; atomicUser = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(u1);</span><br><span class="line">    System.out.println(atomicUser.get());</span><br><span class="line">    atomicUser.compareAndSet(u1, u2);</span><br><span class="line">    System.out.println(atomicUser.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// User&#123;name=&#x27;zhangsan&#x27;&#125;</span></span><br><span class="line"><span class="comment">// User&#123;name=&#x27;lisi&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>两个注意点：</strong></p>
<ol>
<li>AtomicArray 能够使数组中的每个元素都具有原子性，AtomicReference 可不是让对象里面的每个属性都具有原子性，仅仅是这个对象在修改的时候具有原子性。</li>
<li>对于 AtomicReference 的使用，可能这里会有一个误区，认为 AtomicReference 对于一个对象的包装好像没什么用处。看完上面的例子之后可能认为不使用 AtomicReference 而直接让 <code>u1 = u2</code> 好像也能达到同样的效果，针对上面的这个例子这确实没错。<strong>但是 <code>u1 = u2</code> 这不是一个原子操作！</strong>具体原因在<a href="https://www.wrp.cool/posts/41498/">Java 内存模型（JMM）</a>的 <em>「JMM 怎么解决原子性问题」</em> 小节中有具体介绍。</li>
</ol>
<p>在开篇的时候提到了 CAS 常常会采用自旋来做为失败补偿机制，在这里演示一个 CAS 自旋锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CASSpinLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; casSpinLock = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="keyword">while</span> (!casSpinLock.compareAndSet(<span class="literal">null</span>, current)) &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        sign.compareAndSet(current, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AtomicIntegerFieldUpdater"><a href="#AtomicIntegerFieldUpdater" class="headerlink" title="AtomicIntegerFieldUpdater"></a>AtomicIntegerFieldUpdater</h2><blockquote>
<p>将一个对象中的某个属性升级为具有原子能力的属性</p>
</blockquote>
<p><strong>使用场景：</strong></p>
<ol>
<li>在特定场景下才需要某个字段具有原子能力，如果一开始将该对象设计为原子对象，会给内存一定的压力。</li>
<li>为做不到线程安全的类设置原子能力。</li>
</ol>
<p>原子更新字段类的使用与前面的其他原子类有一些不同，主要就是在创建实例对象的时候不同，使用方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    AtomicIntegerFieldUpdater&lt;Data&gt; atomicDataI = AtomicIntegerFieldUpdater.newUpdater(Data.class, <span class="string">&quot;i&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>(<span class="number">0</span>);</span><br><span class="line">    atomicDataI.compareAndSet(data, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    System.out.println(atomicDataI.get(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Data</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意点：</strong></p>
<ol>
<li>原子更新字段类是将该字段升级为原子字段，这并不是针对某个对象的升级，而是针对于类的升级，被升级类的全部实例对象都可以使用该原子字段。</li>
<li>创建后与一般的原子类使用无异。</li>
</ol>
<h2 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h2><blockquote>
<p>需要手动为每次 CAS 更新操作维护一个版本号，以此来解决 ABA 问题。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line">    AtomicStampedReference&lt;User&gt; atomicUser = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(u1, <span class="number">1</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        atomicUser.compareAndSet(u1, u2, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        atomicUser.compareAndSet(u2, u1, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">    t.join();</span><br><span class="line"></span><br><span class="line">    System.out.println(atomicUser.compareAndSet(u1, u2, <span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    System.out.println(atomicUser.compareAndSet(u1, u2, <span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>AtomicStampedFieldUpdater</code> 网上看到很多文章都提到这个类说是啥带版本号原子更新字段啥的，但是在 oracle 文档却没有找到该类，可能是灵异事件吧。</p>
</blockquote>
<h2 id="Adder-和-Accumulator"><a href="#Adder-和-Accumulator" class="headerlink" title="Adder 和 Accumulator"></a>Adder 和 Accumulator</h2><p><code>LongAdder</code>、<code>LongAccumulator</code>、<code>DoubleAdder</code>、<code>DoubleAccumulator</code>，这四个类是在 JDK8 中新增的，接下来将主要分析 LongAdder 这个类，其他的几个类都差不多。引入 LongAdder 主要是为了优化 AtomicLong 在多线程并发情况下的效率，其背后的原理也是空间换时间。</p>
<p>AtomicLong 相对于 LongAdder 的缺点：速度慢，在多线程的情况下竞争同一个变量 <code>value</code> 导致出现大量线程自旋的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">LongAdder</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAdder</span>();</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        service.submit(<span class="keyword">new</span> <span class="title class_">Task</span>(counter));</span><br><span class="line">    &#125;</span><br><span class="line">    service.shutdown();</span><br><span class="line">    <span class="keyword">while</span> (!service.isTerminated()) &#123; &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    System.out.println(counter.sum());</span><br><span class="line">    System.out.println(<span class="string">&quot;LongAdder耗时：&quot;</span> + (end - start));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LongAdder counter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Task</span><span class="params">(LongAdder counter)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.counter = counter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            counter.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我的电脑上这段代码耗时大概是在 100ms 左右。同样的代码如果使用 AtomicLong 实现大概需要 1000ms 左右。二者在多线程的情况下差距十分明显。</p>
<p>LongAdder 的原理是：在最初无竞争时，只更新 base 的值，当有多线程竞争时通过分段的思想，让不同的线程更新不同的段，最后把这些段相加就得到了完整的 LongAdder 存储的值。</p>
<div class="note modern default no-icon flat"><p><strong>LongAdder 重要方法：</strong></p>
</div>

<p><strong>add(long x) 方法：</strong>使用它可以使LongAdder中存储的值增加x，x可为正可为负。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">long</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// as是Striped64中的cells属性</span></span><br><span class="line">    <span class="comment">// b是Striped64中的base属性</span></span><br><span class="line">    <span class="comment">// v是当前线程hash到的Cell中存储的值</span></span><br><span class="line">    <span class="comment">// m是cells的长度减1，hash时作为掩码使用</span></span><br><span class="line">    <span class="comment">// a是当前线程hash到的Cell</span></span><br><span class="line">    Cell[] as; <span class="type">long</span> b, v; <span class="type">int</span> m; Cell a;</span><br><span class="line">    <span class="comment">// 条件1：cells不为空，说明出现过竞争，cells已经创建</span></span><br><span class="line">    <span class="comment">// 条件2：cas操作base失败，说明其它线程先一步修改了base，正在出现竞争</span></span><br><span class="line">    <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">        <span class="comment">// true表示当前竞争还不激烈</span></span><br><span class="line">        <span class="comment">// false表示竞争激烈，多个线程hash到同一个Cell，可能要扩容</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 条件1：cells为空，说明正在出现竞争，上面是从条件2过来的</span></span><br><span class="line">        <span class="comment">// 条件2：应该不会出现</span></span><br><span class="line">        <span class="comment">// 条件3：当前线程所在的Cell为空，说明当前线程还没有更新过Cell，应初始化一个Cell</span></span><br><span class="line">        <span class="comment">// 条件4：更新当前线程所在的Cell失败，说明现在竞争很激烈，多个线程hash到了同一个Cell，应扩容</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            <span class="comment">// getProbe()方法返回的是线程中的threadLocalRandomProbe字段</span></span><br><span class="line">            <span class="comment">// 它是通过随机数生成的一个值，对于一个确定的线程这个值是固定的</span></span><br><span class="line">            <span class="comment">// 除非刻意修改它</span></span><br><span class="line">            (a = as[getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">            !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line">            <span class="comment">// 调用Striped64中的方法处理</span></span><br><span class="line">            longAccumulate(x, <span class="literal">null</span>, uncontended);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>最初无竞争时只更新base</li>
<li>直到更新base失败时，创建cells数组</li>
<li>当多个线程竞争同一个Cell比较激烈时，可能要扩容</li>
</ol>
<blockquote>
<p>请注意，这里的 casBase() 方法失败后，采用的是数组缓解多线程竞争的策略，再一次印证了自旋跟 CAS 没啥必须的关系。</p>
</blockquote>
<blockquote>
<p>具体的 longAccumulate 方法分析可以转至 <a href="https://zhuanlan.zhihu.com/p/65520633">死磕 java并发包之LongAdder源码分析</a> 进行具体了解。大佬写的很好，是我道行不够，看不明白。</p>
</blockquote>
<p><strong>sum()方法：</strong>获取LongAdder中真正存储的值的大小，通过把base和所有段相加得到。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    <span class="comment">// sum初始等于base</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> base;</span><br><span class="line">    <span class="comment">// 如果cells不为空</span></span><br><span class="line">    <span class="keyword">if</span> (as != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历所有的Cell</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="comment">// 如果所在的Cell不为空，就把它的value累加到sum中</span></span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="literal">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回sum</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 sum() 方法是把base和所有段的值相加得到，那么，这里有一个问题，如果前面已经累加到 sum 上的 Cell 的 value 有修改，不是就没法计算到了么？</p>
<p>答案确实如此，所以 LongAdder 可以说不是强一致性的，它是最终一致性的。</p>
<hr>
<blockquote>
<p><strong>巨人的肩膀：</strong></p>
<ul>
<li><a href="https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html">Java魔法类：Unsafe应用解析</a></li>
<li><a href="https://pdai.tech/md/java/thread/java-thread-x-juc-AtomicInteger.html">JUC原子类：CAS, Unsafe和原子类详解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/65520633">死磕 java并发包之LongAdder源码分析</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>Java并发：内存模型（JMM）</title>
    <url>/posts/41498/</url>
    <content><![CDATA[<p>并发问题产生的三大根源是「原子性」「可见性」「有序性」，引入 Java 内存模型就是为了解决这三个问题。</p>
<h1 id="并发问题是怎么产生的"><a href="#并发问题是怎么产生的" class="headerlink" title="并发问题是怎么产生的"></a>并发问题是怎么产生的</h1><div class="note default flat"><p><strong>为什么需要多线程？</strong></p>
</div>

<p>众所周知，CPU、内存、I&#x2F;O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为：</p>
<ul>
<li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I&#x2F;O 设备的速度差异；&#x2F;&#x2F; 导致 <code>原子性</code> 问题 </li>
<li>CPU 增加了缓存，以均衡与内存的速度差异；&#x2F;&#x2F; 导致 <code>可见性</code> 问题</li>
<li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用；&#x2F;&#x2F; 导致 <code>有序性</code> 问题</li>
</ul>
<h2 id="原子性是怎么产生并发问题的"><a href="#原子性是怎么产生并发问题的" class="headerlink" title="原子性是怎么产生并发问题的"></a>原子性是怎么产生并发问题的</h2><blockquote>
<p>原子性问题由分时复用引起</p>
</blockquote>
<p>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程1执行</span></span><br><span class="line">i += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程2执行</span></span><br><span class="line">i += <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是：<code>i += 1</code> 需要三条 CPU 指令 </p>
<ol>
<li>将变量 i 从内存读取到 CPU寄存器； </li>
<li>在CPU寄存器中执行 i + 1 操作；</li>
<li>将最后的结果i写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。</li>
</ol>
<p>由于CPU分时复用（线程切换）的存在，线程1执行了第一条指令后，就切换到线程2执行，假如线程2执行了这三条指令后，再切换会线程1执行后续两条指令，将造成最后写到内存中的i值是2而不是3。</p>
<h2 id="可见性是怎么产生并发问题的"><a href="#可见性是怎么产生并发问题的" class="headerlink" title="可见性是怎么产生并发问题的"></a>可见性是怎么产生并发问题的</h2><blockquote>
<p>可见性问题由 CPU 缓存引起</p>
</blockquote>
<p>可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程1执行的代码</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">i = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2执行的代码</span></span><br><span class="line">j = i;</span><br></pre></td></tr></table></figure>

<p>假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i &#x3D;10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。</p>
<p>此时线程2执行 j &#x3D; i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10。</p>
<p>这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p>
<h2 id="有序性是怎么产生并发问题的"><a href="#有序性是怎么产生并发问题的" class="headerlink" title="有序性是怎么产生并发问题的"></a>有序性是怎么产生并发问题的</h2><blockquote>
<p>有序性问题由重排序引起</p>
</blockquote>
<p>有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">i = <span class="number">1</span>;        <span class="comment">//语句1  </span></span><br><span class="line">flag = <span class="literal">true</span>;  <span class="comment">//语句2</span></span><br></pre></td></tr></table></figure>

<p>上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗? 不一定，为什么呢? 这里可能会发生指令重排序（Instruction Reorder）。</p>
<p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</p>
<ul>
<li>编译器优化的重排序。编译器在不改变单线程程序语义（as-if-serial 语义）的前提下，可以重新安排语句的执行顺序。</li>
<li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>内存系统的重排序。由于处理器使用缓存和读 &#x2F; 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>
</ul>
<p>从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E9%87%8D%E6%8E%92%E5%BA%8F%E4%BB%8E%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%B0%E6%8C%87%E4%BB%A4%E5%BA%8F%E5%88%97%E6%89%80%E7%BB%8F%E5%8E%86%E6%AD%A5%E9%AA%A4.png" alt="重排序从源代码到指令序列所经历步骤"></p>
<p>上述的 1 属于编译器重排序，2 和 3 属于处理器重排序，这些重排序都可能会导致多线程程序出现内存可见性问题。</p>
<ul>
<li>对于编译器重排序，JMM 的编译器重排序规则会禁止特定类型的编译器重排序。</li>
<li>对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序。</li>
</ul>
<blockquote>
<p>不管是编译器重排序还是处理器重排序都可以帮助提升程序性能，只是这样的重排序在特定的情况下可能会让代码变得不可靠，所以 JMM 要求在特定情况下是禁止重排序的，此处并非一昧禁止重排序。</p>
</blockquote>
<p>同样的，JMM 也不是一昧允许重排序，那么：<strong>重排序的规则是什么？</strong><br>由于篇幅问题此处不做展开，感兴趣的同学请移步：<a href="https://www.wrp.cool/posts/41133/">重排序所遵循的规则</a></p>
<h1 id="JMM-是怎么解决并发问题的"><a href="#JMM-是怎么解决并发问题的" class="headerlink" title="JMM 是怎么解决并发问题的"></a>JMM 是怎么解决并发问题的</h1><ul>
<li><strong>JMM 为我们提供了什么工具来解决并发问题？</strong></li>
<li>JMM 为我们提供了 synchronized、final、volatile、Lock锁、Happens-Before 规则。利用好这些工具能帮我们解决并发问题。</li>
</ul>
<h2 id="JMM-怎么解决原子性问题"><a href="#JMM-怎么解决原子性问题" class="headerlink" title="JMM 怎么解决原子性问题"></a>JMM 怎么解决原子性问题</h2><blockquote>
<p>JMM 要求对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。 </p>
</blockquote>
<p>请分析以下哪些操作是原子性操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x = <span class="number">10</span>;     <span class="comment">// 语句1：直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中</span></span><br><span class="line">y = x;      <span class="comment">// 语句2：包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</span></span><br><span class="line">x++;        <span class="comment">// 语句3：x++包括3个操作：读取x的值，进行加1操作，写入新的值。</span></span><br><span class="line">x = x + <span class="number">1</span>;  <span class="comment">// 语句4：同语句3</span></span><br></pre></td></tr></table></figure>

<p>上面4个语句只有语句1的操作具备原子性。</p>
<p>也就是说，只有简单的读取、赋值（必须是将数字赋值给某个变量）才是原子操作。变量之间的相互赋值不是原子操作。</p>
<blockquote>
<p>从上面可以看出，JMM 只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过 synchronized 和 Lock 来实现。由于 synchronized 和 Lock 能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p>
</blockquote>
<h2 id="JMM-怎么解决可见性问题"><a href="#JMM-怎么解决可见性问题" class="headerlink" title="JMM 怎么解决可见性问题"></a>JMM 怎么解决可见性问题</h2><p>JMM 提供了 volatile 关键字来保证可见性。</p>
<p>当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>
<p>由于篇幅问题此处不对 volatile 做展开，感兴趣的同学请移步<a href="https://www.wrp.cool/posts/63338/">Java并发：volatile</a></p>
<p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>
<blockquote>
<p>另外，synchronized 和 Lock 也能够保证可见性，synchronized 和 Lock 能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>
</blockquote>
<h2 id="JMM-怎么解决有序性问题"><a href="#JMM-怎么解决有序性问题" class="headerlink" title="JMM 怎么解决有序性问题"></a>JMM 怎么解决有序性问题</h2><p>JMM 提供了 Happens-Before 规则在一定程度上保证了有序性</p>
<p>一个 happens-before 规则通常对应于多个编译器重排序规则和处理器重排序规则。对于 java 程序员来说，happens-before 规则简单易懂，它避免程序员为了理解 JMM 提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现。 </p>
<div class="note simple default no-icon flat"><p><strong>规则一：程序顺序规则</strong><br>在一个线程中，按照代码的顺序，前面的操作 Happens-Before 于后面的任意操作。</p>
</div>

<p>在这条规则下可能会有一个疑问：<strong>既然指令可以重排序又怎么保证程序顺序规则？</strong></p>
<blockquote>
<p>以 Happens-Before 的角度回答这个问题：</p>
</blockquote>
<p>JMM 通过 Happens-Before 关系向开发人员提供<strong>跨越线程</strong>的内存可见性保证。</p>
<p>如果一个操作的执行结果对另外一个操作可见，那么这两个操作之间必然存在 Happens-Before 管理。</p>
<p>其次，Happens-Before 关系只是描述结果的可见性，并不表示指令执行的先后顺序，也就是说只要不对结果产生影响，仍然允许指令的重排序。</p>
<blockquote>
<p>以重排序的角度回答这个问题：</p>
</blockquote>
<p>在程序顺序规则下，JMM 并不是不允许重排序，JMM 仅仅要求前一个操作（执行的结果）对后一个操作可见。</p>
<p>假设根据程序顺序规则有 A Happens-Before B 如果操作A的结果不需要对操作B可见，并且操作A和操作B重排序前后的执行结果一致；</p>
<p>在这种情况下 JMM 会认为这种重排序并不非法，JMM 允许这种重排序。</p>
<div class="note simple default no-icon flat"><p><strong>规则二：volatile变量规则</strong><br>对一个 volatile 变量的写操作，Happens-Before 于后续对这个变量的读操作。</p>
</div>

<p>也就是说对一个 volatile 变量而言，肯定不会发生可见性问题。</p>
<p>因为 volatile 写完会被立即刷回主内存中，而读操作发生在这之后，那么每次读取都会读取到最新值。</p>
<div class="note simple default no-icon flat"><p><strong>规则三：传递规则</strong><br>如果A Happens-Before B，并且B Happens-Before C，则A Happens-Before C。</p>
</div>

<p>这个规则比较简单，此处不做展开。</p>
<div class="note simple default no-icon flat"><p><strong>规则四：锁定规则</strong><br>对一个锁的解锁操作 Happens-Before 于后续对这个锁的加锁操作。</p>
</div>

<p>这个很好理解，同一把锁的情况下，肯定是要先解锁才能再次上锁。已经锁了的情况下总不能再锁一次吧。</p>
<div class="note simple default no-icon flat"><p><strong>规则五：线程启动规则</strong><br>如果线程A调用线程B的 start() 方法来启动线程B，则 start() 操作 Happens-Before 于线程B中的任意操作。</p>
</div>

<p>我们也可以这样理解线程启动规则：线程A启动线程B之后，线程B能够看到线程A在启动线程B之前的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在线程A中初始化线程B</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="comment">//此处的变量x的值是多少呢？答案是100</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//线程A在启动线程B之前将共享变量x的值修改为100</span></span><br><span class="line">x = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//启动线程B</span></span><br><span class="line">threadB.start();</span><br></pre></td></tr></table></figure>

<p>上述代码是在线程A中执行的一个代码片段，根据线程启动规则，线程A启动线程B之后，线程B能够看到线程A在启动线程B之前的操作，在线程B中访问到的x变量的值为100。</p>
<div class="note simple default no-icon flat"><p><strong>规则六：线程终结规则</strong><br>线程A等待线程B完成（在线程A中调用线程B的 join() 方法实现），当线程B完成后（线程A调用线程B的 join() 方法返回），则线程A能够访问到线程B对共享变量的操作。</p>
</div>

<p>我们也可以这样理解线程终结规则：线程A的 join() 方法返回之后，线程A能看到线程B的所有操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//在线程B中，将共享变量x的值修改为100</span></span><br><span class="line">        x = <span class="number">100</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//在线程A中启动线程B</span></span><br><span class="line">    t.start();</span><br><span class="line">    <span class="comment">//在线程A中等待线程B执行完成</span></span><br><span class="line">    t.join();</span><br><span class="line">    <span class="comment">//此处访问共享变量x的值为100</span></span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note simple default no-icon flat"><p><strong>规则七：线程中断规则</strong><br>对线程 interrupt() 方法的调用 Happens-Before 于被中断线程的代码检测到中断事件的发生。</p>
</div>

<p>我们也可以这样理解线程中断规则：在 InterruptedException 的 catch 代码块中能够看到调用 interrupt() 方法之前的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在线程A中将x变量的值初始化为0</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//在线程A中初始化线程B</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="comment">//线程B检测自己是否被中断</span></span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted())&#123; &#125;</span><br><span class="line">        <span class="comment">//如果线程B被中断，则此时X的值为100</span></span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//在线程A中启动线程B</span></span><br><span class="line">    threadB.start();</span><br><span class="line">    <span class="comment">//在线程A中将共享变量X的值修改为100</span></span><br><span class="line">    x = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//在线程A中中断线程B</span></span><br><span class="line">    threadB.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note simple default no-icon flat"><p><strong>规则八：对象终结规则</strong><br>一个对象的初始化完成 Happens-Before 于它的 finalize() 方法的开始。</p>
</div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">TestThread</span><span class="params">()</span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;构造方法&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对象销毁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">TestThread</span>();</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p><strong>巨人的肩膀：</strong></p>
<ul>
<li><a href="https://pdai.tech/md/java/thread/java-thread-x-theorty.html">Java 并发 - 理论基础</a></li>
<li><a href="https://www.infoq.cn/minibook/java_memory_model">深入理解Java内存模型</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1734515">何为Happens-Before原则？这次彻底懂了！</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>Java并发：锁分类和介绍</title>
    <url>/posts/40896/</url>
    <content><![CDATA[<h1 id="Lock-接口"><a href="#Lock-接口" class="headerlink" title="Lock 接口"></a>Lock 接口</h1><p>Lock 并不是用于替代 synchronized 的，而是当使用 synchronized 不合适或者不满足要求的时候，为业务提供高级功能的。</p>
<div class="note info simple no-icon flat"><p><strong>synchronized 的缺点：</strong></p>
</div>

<ul>
<li><strong>效率低：</strong>锁的释放情况比较少、试图获取锁不能设定超时、不能中断一个正在试图获取锁的线程</li>
<li><strong>不够灵活：</strong>加锁和释放锁的时机单一、每个锁仅有单一的对象</li>
<li><strong>无法知道是否成功获取到锁：</strong>如果拿到锁了，我们也不知道，拿不到锁只能阻塞</li>
</ul>
<div class="note info simple no-icon flat"><p><strong>Lock 接口中的重要方法：</strong></p>
</div>

<ul>
<li><strong>void lock();</strong><ul>
<li>获取锁，如果拿不到锁，就阻塞</li>
<li>不会像 synchronized 一样在异常的时候自动释放锁</li>
<li>必须在 finally 中释放锁，以保证异常时锁一定被释放</li>
<li>阻塞不能被中断，一旦陷入死锁，就会永久等待</li>
</ul>
</li>
<li><strong>void lockInterruptibly() throws InterruptedException;</strong><ul>
<li>与 lock() 一样，但在等待锁的过程中可被中断</li>
</ul>
</li>
<li><strong>boolean tryLock();</strong><ul>
<li>尝试获取锁，获取成功返回 true，获取失败返回 false</li>
<li>该方法立即返回，不会阻塞</li>
</ul>
</li>
<li><strong>boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</strong><ul>
<li>与 tryLock() 相同，但可以设置超时时间，在超时时间阻塞</li>
</ul>
</li>
<li><strong>void unlock();</strong><ul>
<li>释放锁</li>
</ul>
</li>
</ul>
<div class="note primary modern"><p><strong>锁的分类思维导图：</strong></p>
</div>

<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/Java%E9%94%81%E5%88%86%E7%B1%BB%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.png" alt="Java锁分类思维导图"></p>
<h1 id="悲观锁-VS-乐观锁"><a href="#悲观锁-VS-乐观锁" class="headerlink" title="悲观锁 VS 乐观锁"></a>悲观锁 VS 乐观锁</h1><p>乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。</p>
<div class="note primary simple no-icon flat"><p><strong>为什么会出现乐观锁：</strong></p>
</div>

<ol>
<li>悲观锁的阻塞和唤醒带来的性能损耗</li>
<li>悲观锁可能会出现死锁</li>
<li>悲观锁可能会出现线程优先级反转，优先级低的线程拿到锁之后不释放，优先级高的线程反而需要等待优先级低的线程释放锁</li>
</ol>
<div class="note primary simple no-icon flat"><p>针对同一个数据的并发操作，<strong>悲观锁与乐观锁有以下不同：</strong></p>
</div>

<ul>
<li><strong>悲观锁：</strong>悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。</li>
<li><strong>乐观锁：</strong>乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。</li>
</ul>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81.png" alt="乐观锁和悲观锁"></p>
<ul>
<li>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。</li>
<li>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</li>
</ul>
<h1 id="公平锁-VS-非公平锁"><a href="#公平锁-VS-非公平锁" class="headerlink" title="公平锁 VS 非公平锁"></a>公平锁 VS 非公平锁</h1><blockquote>
<p><strong>为什么会出现非公平锁？</strong><br>避免唤醒线程带来的 CPU 开销，以及避免了线程唤醒期间带来的无线程持有锁导致的资源浪费。</p>
<ul>
<li><strong>例如：</strong></li>
<li>线程A 释放锁 线程B 准备获取锁</li>
<li>CPU 开始唤醒 线程B</li>
<li>线程C 申请获取锁</li>
<li>将锁先给 线程C，线程C 执行完之后再将锁还给 线程B</li>
</ul>
<p>线程B 可能会稍微等待一会，但是在此期间保证锁一直都有线程使用，没有浪费。并且 CPU 不必唤醒 线程C，节省了一次线程唤醒带来的开销。</p>
</blockquote>
<ul>
<li><p><strong>公平锁：</strong></p>
<ul>
<li>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。</li>
<li>优点：等待锁的线程不会饿死。</li>
<li>缺点：整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</li>
</ul>
</li>
<li><p><strong>非公平锁：</strong></p>
<ul>
<li>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。</li>
<li>优点：可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。</li>
<li>缺点：是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</li>
</ul>
</li>
</ul>
<blockquote>
<p>假设有一口水井，有管理员看守，管理员有一把锁，只有拿到锁的人才能够打水，打完水要把锁还给管理员。每个过来打水的人都要管理员的允许并拿到锁之后才能去打水，如果前面有人正在打水，那么这个想要打水的人就必须排队。管理员会查看下一个要去打水的人是不是队伍里排最前面的人，如果是的话，才会给你锁让你去打水；如果你不是排第一的人，就必须去队尾排队，这就是公平锁。</p>
</blockquote>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E5%85%AC%E5%B9%B3%E9%94%81%E6%BC%94%E7%A4%BA.png" alt="公平锁演示"></p>
<blockquote>
<p>对于非公平锁，管理员对打水的人没有要求。即使等待队伍里有排队等待的人，但如果在上一个人刚打完水把锁还给管理员而且管理员还没有允许等待队伍里下一个人去打水时，刚好来了一个插队的人，这个插队的人是可以直接从管理员那里拿到锁去打水，不需要排队，原本排队等待的人只能继续等待。</p>
</blockquote>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E6%BC%94%E7%A4%BA.png" alt="非公平锁演示"></p>
<h1 id="共享锁-VS-独占锁"><a href="#共享锁-VS-独占锁" class="headerlink" title="共享锁 VS 独占锁"></a>共享锁 VS 独占锁</h1><p>共享锁也成为读锁，指的是该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。顾名思义共享锁在各个线程之间是共享的，只要是读请求的线程都能够同时持有这把锁。</p>
<p>独享锁也叫排他锁、写锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是独享锁。</p>
<p>共享锁和独占锁在 Java 中经典的应用就是在 ReentrantReadWriteLock 这个类中了，深入到这个类的源码中发现这个类还实现了公平锁与非公平锁，在非公平锁的情况下就会有一个问题：<strong>想要获取写锁的线程可能会被饿死。</strong></p>
<blockquote>
<p><strong>为什么？</strong><br>非公平锁是可以插队的，如果当前有一个线程持有了读锁，一个需要写锁的线程正在排队；此时又来了一个需要读锁的线程，那么该线程可以直接持有读锁；但是哪个需要写锁的线程获取锁的时间就又要等待第二个持有读锁的线程执释放锁才能获取到锁；如果后面源源不断的出现需要读锁的线程，这些线程都能够直接持有读锁，那么哪个需要写锁的线程就会被饿死。长时间得不到执行。</p>
</blockquote>
<p>为了保证非公平锁的效率和避免出现写锁线程被饿死的情况，在非公平情况下肯定要对获取读锁做出一些限制。</p>
<div class="note modern primary flat"><p><strong>ReentrantReadWriteLock 非公平锁源码：</strong></p>
</div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">8159625535654395037L</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">writerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 写锁在任何情况下都可以插队</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">readerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/* 为了避免需要写锁的线程被饿死的情况</span></span><br><span class="line"><span class="comment">         * 仅当等待队列头的线程是等待写锁的线程，阻塞当前读线程</span></span><br><span class="line"><span class="comment">         * 有一定的概率出现这种情况，因为如果队首线程是等待读锁的线程</span></span><br><span class="line"><span class="comment">         * 而等待写锁的线程排在后面一点，当队首的读线程还没拿到锁的情况下</span></span><br><span class="line"><span class="comment">         * 新来的读锁线程还是可以插队的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="可重入锁-VS-不可重入锁"><a href="#可重入锁-VS-不可重入锁" class="headerlink" title="可重入锁 VS 不可重入锁"></a>可重入锁 VS 不可重入锁</h1><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。下面用示例代码来进行分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法1执行...&quot;</span>);</span><br><span class="line">        doOthers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doOthers</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法2执行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，类中的两个方法都是被内置锁 synchronized 修饰的，doSomething() 方法中调用 doOthers() 方法。因为内置锁是可重入的，所以同一个线程在调用 doOthers() 时可以直接获得当前对象的锁，进入 doOthers() 进行操作。</p>
<p>如果是一个不可重入锁，那么当前线程在调用 doOthers() 之前需要将执行 doSomething() 时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。</p>
<div class="note primary simple no-icon flat"><p><strong>可重入举例：</strong></p>
</div>

<p>有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E5%8F%AF%E9%87%8D%E5%85%A5%E6%BC%94%E7%A4%BA.png" alt="可重入演示"></p>
<div class="note primary simple no-icon flat"><p><strong>可重入举例：</strong></p>
</div>

<p>管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E6%BC%94%E7%A4%BA.png" alt="不可重入演示"></p>
<h1 id="自旋锁-VS-适应性自旋锁"><a href="#自旋锁-VS-适应性自旋锁" class="headerlink" title="自旋锁 VS 适应性自旋锁"></a>自旋锁 VS 适应性自旋锁</h1><blockquote>
<p><strong>自旋锁：</strong></p>
<p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p>
<p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p>
<p>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p>
</blockquote>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E8%87%AA%E6%97%8B%E9%94%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="自旋锁工作流程图"></p>
<p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。</p>
<p>自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">    <span class="type">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p><strong>巨人的肩膀：</strong></p>
<ul>
<li><a href="https://tech.meituan.com/2018/11/15/java-lock.html">不可不说的Java“锁”事</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>Java并发：ThreadLocal</title>
    <url>/posts/12951/</url>
    <content><![CDATA[<p>在线程池中必不可免的需要面对线程安全问题，在并发执行同一个任务的情况下，肯定需要访问到一些公共的对象，也就是会出现多个线程访问同一个对象的情况，这就涉及到了线程安全的问题。</p>
<p>这个时候就需要为线程池中的每一个线程都准备一个单独的变量供线程池中的每个线程去使用了。</p>
<div class="note warning modern no-icon flat"><p>于是：ThreadLocal 登场了。</p>
</div>

<p>说说我的理解吧，我认为 ThreadLocal 其实是一个封装的工具，可以使用 ThreadLocal 将线程池中各个线程都要访问到的对象封装起来，之后各个线程去访问被包装对象的时候，ThreadLocal 会生成一个这个对象的副本，也就是重新创建这个对象给线程去使用，以此将每个线程隔离开来，使得每个线程都能够拥有独属于自己的对象。</p>
<p>基于 ThreadLocal 为每个线程设置独享对象的特性，可以衍生出两个用法：</p>
<ul>
<li>隔离共享对象，用于保证线程安全</li>
<li>设置线程内的全局变量，在同一个线程内免去了参数传递的麻烦</li>
</ul>
<h1 id="ThreadLocal-用法一：隔离对象，保证线程安全"><a href="#ThreadLocal-用法一：隔离对象，保证线程安全" class="headerlink" title="ThreadLocal 用法一：隔离对象，保证线程安全"></a>ThreadLocal 用法一：隔离对象，保证线程安全</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateUtils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;DateFormat&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;DateFormat&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> DateFormat <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面的代码的简写形式</span></span><br><span class="line">    <span class="comment">// public static final ThreadLocal&lt;DateFormat&gt; threadLocal = ThreadLocal.withInitial(() -&gt; new SimpleDateFormat(&quot;yyyy-MM-dd&quot;));</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用方式</span></span><br><span class="line">        <span class="type">DateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> DateUtils.threadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 SimpleDateFormat 对象并不是线程安全的，如果在线程池中需要用到 SimpleDateFormat 对象的话，是不能让所有线程共用同一个对象的，那样会出现线程不安全问题。但如果线程每次运行都创建一个新的 SimpleDateFormat 对象的话，那么又太浪费资源了。</p>
<p>实际上这里还有一个解决方式：把用到 SimpleDateFormat 对象的地方都抽取出来加上 synchronized 关键字，把 SimpleDateFormat 对象给锁上，但是每个线程要使用的时候又都要去排队，这也并不是一个好方法，特别是线程池在执行的情况下，并发量很大，排队的时间就会很长。</p>
<blockquote>
<p>使用 ThreadLocal 之后是一个什么样的流程呢？</p>
</blockquote>
<ol>
<li>线程需要使用 SimpleDateFormat 对象</li>
<li>调用 initialValue() 方法，生成一个 SimpleDateFormat 对象</li>
<li>给到需要的线程去使用，之后再保存在线程中，下次再要用了直接拿出来就可以了</li>
<li>也就是一个懒加载的方式</li>
</ol>
<h1 id="ThreadLocal-用法二：设置线程内的全局变量"><a href="#ThreadLocal-用法二：设置线程内的全局变量" class="headerlink" title="ThreadLocal 用法二：设置线程内的全局变量"></a>ThreadLocal 用法二：设置线程内的全局变量</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;User&gt; userContextHolder = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Interceptor</span>().checkingLogin(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkingLogin</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        userContextHolder.set(user);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Controller</span>().getList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Controller</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userContextHolder.get();</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Service</span>().getList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userContextHolder.get();</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 防止内存泄漏</span></span><br><span class="line">        userContextHolder.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name)</span> &#123; <span class="built_in">this</span>.name = name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="string">&quot;User&#123;name=&#x27;&quot;</span> + name + <span class="string">&quot;&#x27;&#125;&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以利用 ThreadLocal 在线程中传递参数，免去了到处传参的麻烦，使用的话就像上面的这段代码一样就可以了。</p>
<div class="note danger modern"><p><strong>存在内存泄漏的风险，使用完一定要调用 remove() 释放 user 对象。</strong></p>
</div>

<h1 id="ThreadLocal-是怎么做到线程隔离的"><a href="#ThreadLocal-是怎么做到线程隔离的" class="headerlink" title="ThreadLocal 是怎么做到线程隔离的"></a>ThreadLocal 是怎么做到线程隔离的</h1><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/ThreadLocal%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="ThreadLocal原理图"></p>
<ol>
<li>每个 Thread 都有一个唯一对应的 ThreadLocalMap<ul>
<li>ThreadLocalMap 以 ThreadLocal 对象为键，值是 initialValue() 或者 set() 方法中我们自己设置的</li>
</ul>
</li>
<li>首次调用 get() 方法时，ThreadLocal 会为当前线程初始化 ThreadLocalMap</li>
<li>再调用 initialValue() 方法，返回对应的我们设置的对象，以该对象为值，ThreadLocal 对象为键存储至 ThreadLocalMap</li>
<li>再返回该对象给线程使用</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取线程自己的 ThreadLocalMap</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 ThreadLocalMap</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用重载的 initialValue() 方法获取需要设置的值</span></span><br><span class="line">    <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<div class="note info modern"><p><strong>小结：</strong></p>
</div>
<blockquote>
<ol>
<li>ThreadLocal 中的值是保存在 Thread.ThreadLocalMap 中的，这可能也是为什么叫 ThreadLocal 吧</li>
<li>取值的方式是懒加载的，实际上也只能懒加载。<br>我们可能会定义很多个 ThreadLocal 对象出来用，但并不是每个线程都需要用到全部的 ThreadLocal，没到要用的时候程序也无法预先判断这个线程需要用到哪些 ThreadLocal。</li>
</ol>
</blockquote>
<h1 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h1><blockquote>
<p>ThreadLocalMap 是 ThreadLocal 的一个静态内部类，没有实现 Map 接口，底层由 Entry 数组实现。</p>
</blockquote>
<ul>
<li>ThreadLocalMap 键：ThreadLocal 对象</li>
<li>ThreadLocalMap 值：通过 initialValue() 或 set() 方法传入的对象</li>
</ul>
<div class="note info modern no-icon flat"><p><strong>Entry 类：</strong></p>
</div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ThrealLocalMap 键值对实现的具体对象，需要注意的是 <code>k</code> 是一个弱引用。</p>
<blockquote>
<p><strong>Java 中的四种引用类型：</strong></p>
<ul>
<li><strong>强引用：</strong>我们常常 new 出来的对象就是强引用类型，只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足的时候</li>
<li><strong>软引用：</strong>使用 SoftReference 修饰的对象被称为软引用，软引用指向的对象在内存要溢出的时候被回收</li>
<li><strong>弱引用：</strong>使用 WeakReference 修饰的对象被称为弱引用，只要发生垃圾回收，若这个对象只被弱引用指向，那么就会被回收</li>
<li><strong>虚引用：</strong>虚引用是最弱的引用，在 Java 中使用 PhantomReference 进行定义。虚引用中唯一的作用就是用队列接收对象即将死亡的通知</li>
</ul>
</blockquote>
<p>往 ThreadLocalMap 中添加元素：set() 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 hash 找到 key 在 Entry[] 的第一个下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决 hash 冲突</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i]; e != <span class="literal">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get(); <span class="comment">// get() 方法由 WeakReference 继承自 Reference 而来</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前 ThreadLocal 已经存在，则覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果找到的 e 不为空，但是 k 为空，则证明该 k 被 gc 回收</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到可插入位置，新建元素</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">    <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ThreadLocalMap 的冲突处理：往后继续找到合适的位置插入，而不是在该位置拉一个链表或者红黑树。</p>
</blockquote>
<p>从 ThreadLocalMap 中取出元素：getEntry() 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找到第一个 key 比较与传入的 key 是否相等，相等直接返回，不相等由哈希冲突策略继续往下找</span></span><br><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先找到ThreadLocal的索引位置, 如果索引位置处的entry不为空并且键与threadLocal是同一个对象, 则直接返回; 否则去后面的索引位置继续查找。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>ThreadLocal 是 ThreadPool 的好朋友，借助 ThreadLocal 可以实现多线程环境下的线程安全，或者为单独的线程设置全局变量</li>
<li>ThreadLocal 是一个将线程不安全对象变成线程安全的工具，具体将被包装的对象为每个线程都做一份拷贝，大家各自用各自的变量，不争不抢，线程就安全了</li>
<li>Thread 会维护自己的 ThreadLocalMap，以 ThreadLocal 为键，set() 或 initialValue() 中的返回对象为值</li>
<li>ThreadLocalMap 是 ThreadLocal 的静态内部类，不实现 Map 接口</li>
<li>ThreadLocalMap 处理哈希冲突的策略是：向后移位，直到找到合适位置为止</li>
</ol>
<hr>
<blockquote>
<p><strong>巨人的肩膀：</strong><br><a href="https://pdai.tech/md/java/thread/java-thread-x-threadlocal.html">Java 并发 - ThreadLocal详解</a><br><a href="https://javaguide.cn/java/concurrent/threadlocal.html">万字解析 ThreadLocal 关键字</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>Java并发：线程池</title>
    <url>/posts/64600/</url>
    <content><![CDATA[<h1 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h1><div class="note info no-icon flat"><p><strong>多线程使用会出现的两个问题：</strong></p>
</div>

<ol>
<li>多个线程会占用过多内存</li>
<li>反复创建线程开销过大</li>
</ol>
<div class="note info no-icon flat"><p><strong>解决这两个问题的方法：</strong></p>
</div>

<ol>
<li>使用尽量少线程，不让太多线程占用内存。</li>
<li>让这部分线程都保持工作，可以反复执行任务。避免线程生命周期的损耗。</li>
</ol>
<hr>
<p>线程池最核心的部分：<strong>让线程可以反复执行任务</strong>。</p>
<blockquote>
<p>一段伪代码大概演示线程池最重要的线程复用的方式</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> Queue.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (task != <span class="literal">null</span>) &#123;</span><br><span class="line">    task.run();</span><br><span class="line">    task = Queue.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h1><h2 id="手动创建"><a href="#手动创建" class="headerlink" title="手动创建"></a>手动创建</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 核心线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CORE_POOL_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_POOL_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空闲线程存活时间、单位。非核心线程空闲时间超过此参数将会被回收</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">KEEP_ALIVE_TIME</span> <span class="operator">=</span> <span class="number">60</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">TimeUnit</span> <span class="variable">UNIT</span> <span class="operator">=</span> TimeUnit.SECONDS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池所使用的缓冲队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; WORK_QUEUE = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池创建线程使用的工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadFactory</span> <span class="variable">THREAD_FACTORY</span> <span class="operator">=</span> Thread::<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池拒绝处理任务时的拒绝策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">RejectedExecutionHandler</span> <span class="variable">HANDLER</span> <span class="operator">=</span> (Runnable r, ThreadPoolExecutor e) -&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(<span class="string">&quot;Task &quot;</span> + r.toString() +</span><br><span class="line">            <span class="string">&quot; rejected from &quot;</span> +</span><br><span class="line">            e.toString());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ThreadPoolExecutor</span> <span class="variable">executorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            CORE_POOL_SIZE,</span><br><span class="line">            MAXIMUM_POOL_SIZE,</span><br><span class="line">            KEEP_ALIVE_TIME,</span><br><span class="line">            UNIT,</span><br><span class="line">            WORK_QUEUE,</span><br><span class="line">            THREAD_FACTORY,</span><br><span class="line">            HANDLER</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里也感叹一下线程池的封装，将所有的操作参数全部暴露出来给到调用者去设置，最大程度的将线程池的内部逻辑与用户操作部分解耦。这是很优秀的设计，值得学习。<br>能考虑的这么全面，要是我来设计的话估计就只能是暴露个 <code>CORE_POOL_SIZE</code>出来就差不多了。</p>
</blockquote>
<div class="note primary modern"><p><strong>线程池添加线程规则：</strong></p>
</div>

<ol>
<li>如果线程数小于 <code>CORE_POOL_SIZE</code>，即使其他工作线程处于空闲状态，也会创建一个新的线程来运行新任务。</li>
<li>如果线程数等于（或大于）<code>CORE_POOL_SIZE</code> 但少于 <code>MAXIMUM_POOL_SIZE</code>，则将任务放入队列。</li>
<li>如果队列已满，并且线程数小于 <code>MAXIMUM_POOL_SIZE</code>，则创建一个新线程来运行任务。</li>
<li>如果队列已满，并且线程数大于或等于 <code>MAXIMUM_POOL_SIZE</code>，则拒绝该任务。</li>
</ol>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%B7%BB%E5%8A%A0%E7%BA%BF%E7%A8%8B%E8%A7%84%E5%88%99.png" alt="线程池添加线程规则"></p>
<h2 id="自动创建"><a href="#自动创建" class="headerlink" title="自动创建"></a>自动创建</h2><blockquote>
<p>线程池的自动创建是利用 <code>Executors</code> 工具类中的静态方法来创建线程池对象。<code>Executors</code> 为我们定义了一些比较有特性的线程池。如下是四个常用的线程池：</p>
</blockquote>
<hr>
<div class="note primary modern no-icon flat"><p><strong>FixedThreadPool</strong>：定长线程池<br>可控制线程最大并发数，超出的线程会在队列中等待。</p>
</div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<div class="note primary modern no-icon flat"><p><strong>CachedThreadPool</strong>：可缓存线程池<br>如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p>
</div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<div class="note primary modern no-icon flat"><p><strong>SingleThreaded</strong>：单线程的线程池<br>只会用唯一的工作线程来执行任务。</p>
</div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<div class="note primary modern no-icon flat"><p><strong>ScheduledThreadPool</strong>：支持定时及周期性任务执行<br>可以当做定时任务使用。</p>
</div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建</span></span><br><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">scheduledExecutorService</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, TimeUnit.NANOSECONDS, <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延迟 5s 执行</span></span><br><span class="line">scheduledExecutorService.schedule(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// run 方法</span></span><br><span class="line">&#125;, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延迟 1s 执行，之后每隔 3s 执行一次</span></span><br><span class="line">scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// run 方法</span></span><br><span class="line">&#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>以上四种线程构造函数参数对比：</strong></p>
<table>
<thead>
<tr>
<th align="left">Paramter</th>
<th align="left">FixedThreadPool</th>
<th align="left">CachedThreadPool</th>
<th align="left">SingleThreaded</th>
<th align="left">ScheduledThreadPool</th>
</tr>
</thead>
<tbody><tr>
<td align="left">corePoolSize</td>
<td align="left">constructor-arg</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">constructor-arg</td>
</tr>
<tr>
<td align="left">maxPoolSize</td>
<td align="left">same as corePoolSize</td>
<td align="left">Integer.MAX_VALUE</td>
<td align="left">1</td>
<td align="left">Integer.MAX_VALUE</td>
</tr>
<tr>
<td align="left">keepAliveTime</td>
<td align="left">0 seconds</td>
<td align="left">60 seconds</td>
<td align="left">0 seconds</td>
<td align="left">0 seconds</td>
</tr>
</tbody></table>
<h1 id="如何停止线程池"><a href="#如何停止线程池" class="headerlink" title="如何停止线程池"></a>如何停止线程池</h1><div class="note primary simple no-icon flat"><p><strong>停止线程相关的 5 个方法：</strong></p>
</div>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isShutdown</span><span class="params">()</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isTerminated</span><span class="params">()</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">awaitTerminated</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<h2 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown();"></a>shutdown();</h2><blockquote>
<p>调用 shutdown 方法之后，线程池并不是立刻就被关闭。事实上这个方法仅仅是初始化整个关闭过程，因为这个时候线程池中可能还有很多任务正在被执行，或者是任务队列中有大量正在等待被执行的任务，所以不是调用 shutdown 方法就立即关闭。在执行这个方法之后，线程池就接收到关闭信息，所以这个时候线程池为了优雅起见，会把正在执行的任务以及队列中等待的任务都执行完毕之后再关闭。</p>
</blockquote>
<h2 id="isShutdown"><a href="#isShutdown" class="headerlink" title="isShutdown();"></a>isShutdown();</h2><blockquote>
<p>isShutdown() 方法可以返回一个布尔值，true 或者 false 来判断线程池是不是已经开始关闭工作，也就是是否执行了 shutdown() 或者 shutdownNow() 方法。这个停止不是说完全停止，因为完全停止指的是所有的任务都执行完毕。</p>
</blockquote>
<h2 id="isTerminated"><a href="#isTerminated" class="headerlink" title="isTerminated();"></a>isTerminated();</h2><blockquote>
<p>返回整个线程池是不是已经完全终止了，这不仅仅线程池已经关闭，同时代表线程池中的所有任务都执行完毕了，就是线程池里面的线程包括正在执行的任务以及队列里面的任务都执行完了。</p>
</blockquote>
<h2 id="awaitTerminated-long-timeout-TimeUnit-unit"><a href="#awaitTerminated-long-timeout-TimeUnit-unit" class="headerlink" title="awaitTerminated(long timeout, TimeUnit unit);"></a>awaitTerminated(long timeout, TimeUnit unit);</h2><blockquote>
<p>这个方法作用相对比较弱，它不是用来停止线程池的，而是用来判断线程池的状态的。比如我们给 awaitTermination() 方法传入的参数是 10 秒，那么它就会等待 10 秒钟。</p>
<p>调用 awaitTermination() 方法之后，当前线程会等待一段时间，如果在等待的这段时间内，线程池已经关闭并且内部任务都执行完毕了，这个方法会返回true，否则超时会返回 false。、</p>
<p>所以这个方法只是一个用来测试在一段时间内这个线程是不是完全停止的。它起到的主要作用是检测，而不是关闭。</p>
</blockquote>
<h2 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow();"></a>shutdownNow();</h2><blockquote>
<p>这个方法比较暴力，它与前面我们介绍的方法都不一样，这个方法后面带了一个 Now，也就表示立刻关闭的意思。如果要想立刻关闭掉，我们作为线程池的设计者，我们想一下应该怎么办才比较优雅。在执行 shutdownNow() 方法之后，首先会给所有线程池中的线程发送 interrupt 中断信号，尝试中断这些任务的执行，然后会将任务队列中正在等待的所有任务转移到一个 List 中并返回，我们可以根据返回的任务List来进行一些补救的操作，例如记录在案并在后期重试。</p>
</blockquote>
<h1 id="线程池的生命周期函数"><a href="#线程池的生命周期函数" class="headerlink" title="线程池的生命周期函数"></a>线程池的生命周期函数</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadPool</span> <span class="keyword">extends</span> <span class="title class_">ThreadPoolExecutor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在每个线程执行之前调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.beforeExecute(t, r);</span><br><span class="line">        System.out.println(t.getName() + <span class="string">&quot;开始执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在每个线程执行之后调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.afterExecute(r, t);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在执行 shutdown 方法之后，并且线程池中所有线程执行结束时调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">terminated</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;所有线程执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处省略创建 threadPool 对象代码</span></span><br><span class="line"></span><br><span class="line">        threadPool.execute(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我被执行了。。。&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL实战：怎么选择普通索引和唯一索引？</title>
    <url>/posts/24920/</url>
    <content><![CDATA[<h1 id="查询操作下两个索引的不同"><a href="#查询操作下两个索引的不同" class="headerlink" title="查询操作下两个索引的不同"></a>查询操作下两个索引的不同</h1><p><strong>普通索引的查询过程：</strong></p>
<blockquote>
<p>对于普通索引的查询而言，查询到满足条件的第一条记录之后，还需要接着往下找，直到出现第一个不满足的记录。</p>
</blockquote>
<p><strong>唯一索引的查询过程：</strong></p>
<blockquote>
<p>对于唯一索引的查询而言，查询到满足条件的第一条记录之后，直接返回，不会再继续向下查找。</p>
</blockquote>
<p>对于查询操作来说，普通索引和唯一索引的差别就是在命中第一条记录之后有没有一个往下继续比较的动作而已。显然，一个比较的动作对于性能的影响是微乎其微，可以忽略不计的，因此本文的重点也并不在此。</p>
<h1 id="change-buffer"><a href="#change-buffer" class="headerlink" title="change buffer"></a>change buffer</h1><p>在 <a href="https://www.wrp.cool/posts/42257/">【MySQL实战】深入浅出索引</a> 这篇文章中有提到过 MySQL 中的 <code>页</code> 的概念，页（Page）是 InnoDB 中管理数据的最小单元。</p>
<p>一个 <code>页</code> 中会存放很多条记录，不管是更新还是查找数据，都是要将 <code>页</code> 先读到内存当中的，然后在内存中更新数据，完了再把更新完的 <code>页</code> 写回磁盘。</p>
<p>可以看到在这个过程之中，存在着性能浪费。更新数据并不一定会更新到整个 <code>页</code> 中的数据，但是读数据到内存中却是将整个 <code>页</code> 的数据全部读取出来的，写回磁盘的过程也是将整个 <code>页</code> 的数据全部写回磁盘的。而读写磁盘都是非常昂贵的 IO 操作。于是在更新中肯定会有一些操作来避免或者是尽量的减少这样的 IO 浪费。</p>
<p>change buffer 就是这样的一种技术。</p>
<p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。</p>
<p>将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 merge。除了访问这个数据页会触发 merge 外，系统有后台线程会定期 merge。在数据库正常关闭（shutdown）的过程中，也会执行 merge 操作。</p>
<p>也就是说要尽量在 merge 的过程要刷越多的数据到磁盘上越好，在一个页上一次性刷的数据越多，反过来刷的次数就会越少，性能就会越高。</p>
<p>值得注意的是，change buffer 实际上它是可以持久化的数据。也就是说，change buffer 在内存中有拷贝，也会被写入到磁盘上。</p>
<div class="note info flat"><p><strong>change buffer 的使用：</strong></p>
</div>

<p>change buffer 用的是 buffer pool 里的内存，因此不能无限增大。change buffer 的大小，可以通过参数 innodb_change_buffer_max_size 来动态设置。这个参数设置为 50 的时候，表示 change buffer 的大小最多只能占用 buffer pool 的 50%。</p>
<h1 id="更新操作下两个索引的不同"><a href="#更新操作下两个索引的不同" class="headerlink" title="更新操作下两个索引的不同"></a>更新操作下两个索引的不同</h1><p>第一种情况是，<strong>这个记录要更新的目标页在内存中。</strong>这时，InnoDB 的处理流程如下：</p>
<ul>
<li>对于唯一索引来说，找到待更新的位置，判断到没有冲突，插入这个值，语句执行结束；</li>
<li>对于普通索引来说，找到待更新的位置，插入这个值，语句执行结束。<br>这样看来，普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的 CPU 时间。但，这不是我们关注的重点。</li>
</ul>
<p>第二种情况是，<strong>这个记录要更新的目标页不在内存中。</strong>这时，InnoDB 的处理流程如下：</p>
<ul>
<li>对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；</li>
<li>对于普通索引来说，则是将更新记录在 change buffer，语句执行就结束了。</li>
</ul>
<p>将数据从磁盘读入内存涉及随机 IO 的访问，是数据库里面成本最高的操作之一。change buffer 因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。</p>
<blockquote>
<p>对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 change buffer 了。因此，唯一索引的更新就不能使用 change buffer，<strong>实际上也只有普通索引可以使用</strong>。</p>
</blockquote>
<h1 id="比较-change-buffer-和-redo-log-的差别"><a href="#比较-change-buffer-和-redo-log-的差别" class="headerlink" title="比较 change buffer 和 redo log 的差别"></a>比较 change buffer 和 redo log 的差别</h1><div class="note info flat"><p><strong>以写为例，change buffer 的工作流程：</strong></p>
</div>

<ol>
<li>待更新数据页在内存中，直接更新内存中的数据页。记录 redo log。</li>
<li>待更新数据页不在内存中，在内存的 change buffer 区域记录下“我要在数据页X中更新一条数据”。记录 redo log。</li>
</ol>
<p>这样的操作执行成本其实很低，不论数据页是否在内存中，都是写一次内存，然后再写一次磁盘（顺序写）。比起直接去磁盘更新对应数据性能要好一些。</p>
<div class="note info flat"><p><strong>以读为例，change buffer 的工作流程：</strong></p>
</div>

<ol>
<li>要读取的数据页在内存中，直接返回对应结果。</li>
<li>要读取的数据页不在内存中，将对应的数据页读取到内存中，再应用 change buffer 里面的操作日志，生成对应的结果返回。</li>
</ol>
<blockquote>
<p>值得注意的是：更新操作写完 redo log 之后，如果此时需要马上读取这部分数据，并不需要立即更新 redo log 中的数据到数据页中，可以读取对应数据页之后应用 change buffer 日志返回正确结果。</p>
</blockquote>
<hr>
<p>OK，最后回到本文主题：<strong>普通索引和唯一索引，应该怎么选择？</strong></p>
<p>如果在业务上可以接受，首先建议选择普通索引，因为可以应用 change buffer 的优化。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL实战：深入浅出索引</title>
    <url>/posts/42257/</url>
    <content><![CDATA[<blockquote>
<ul>
<li><a href="https://time.geekbang.org/column/article/69236">《极客时间-MySQL实战45讲》04 | 深入浅出索引（上）</a></li>
<li><a href="https://time.geekbang.org/column/article/69636">《极客时间-MySQL实战45讲》05 | 深入浅出索引（下）</a></li>
<li>笔记整理</li>
</ul>
</blockquote>
<hr>
<p>首先还是要先了解 <strong>页（Page）</strong> 这个概念，才能更好的理解 InnoDB 中的索引。</p>
<div class="note success flat"><p><strong>页是什么？</strong></p>
</div>

<ul>
<li><p>页（Page）是 InnoDB 中管理数据的最小单元。</p>
</li>
<li><p>聚簇索引中的叶子结点就是一个个的页。</p>
<blockquote>
<p><em>插句题外话：</em><br><em>之前初学 MySQL 的时候，由于 DML 操作的都是一行行的数据，所以那时候总是以为 MySQL 中的最小数据单位就是 row。UPDATE 的时候就去磁盘中拿到对应的数据出来，然后 UPDATE 之后再放回去。但现在看来显然不是，MySQL 是先把该行数据所在的页先加载到内存中修改完了再延迟刷回磁盘的。</em></p>
</blockquote>
</li>
</ul>
<div class="note success flat"><p><strong>页的概览</strong></p>
</div>

<p>MySQL 中的数据最终都是存在聚簇索引树的叶子结点中的，也就是页之间其实是双向链表的这么一种数据结构，并且页与页之间也是有序的。在叶子结点中存储用户数据的部分是一种单向链表的结构。</p>
<p>当我们在查找数据的时候，为了快速判断要查找的数据是否在当前页之中。在页中还会记录页本页用户数据中的最大值和最小值。</p>
<p>如果所需要的数据就在当前页中，为了避免整个页去查找，MySQL 又在页中加入了另一个区域 Page Directory 目录，里面有很多个槽位（Slots），每一个槽位都指向了一条 User Records 中的记录。每隔几条数据，就会创建一个槽位。在一个完整的页中，每隔6条数据就会有一个 Slot。有了 Page Directory 之后，页内的用户数据就不需要去维护有序性了，直接插入在链表尾部即可。</p>
<p>Slot 会在新增数据的时候创建和维护，之后就可以对一张页的数据进行<strong>粗略</strong>的二分查找。因为二分查找出来的结果只能是个大概的位置，找到了这个大概的位置之后，还需要回到 User Records 中继续的进行挨个遍历匹配。</p>
<blockquote>
<p>粗略画了下页的概览图，如下：</p>
</blockquote>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/1654781897359.png" alt="1654781897359"></p>
<blockquote>
<p><strong>小结：</strong></p>
<p>MySQL 查找数据的方式，首先是通过索引将数据所在的页先加载到内存中去，之后在内存中尽量的缩小所在数据的范围，再去遍历数据找到最终所需要的数据。</p>
</blockquote>
<hr>
<h1 id="索引的常见模型"><a href="#索引的常见模型" class="headerlink" title="索引的常见模型"></a>索引的常见模型</h1><p>三种常见、也比较简单的数据结构，它们分别是<code>哈希表</code>、<code>有序数组</code>和<code>N叉树</code></p>
<blockquote>
<p>你心里要有个概念，数据库底层存储的核心就是基于这些数据模型的。每碰到一个新数据库，我们需要先关注它的数据模型，这样才能从理论上分析出这个数据库的适用场景。</p>
</blockquote>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希表是一种以键 - 值（key-value）存储数据的结构，我们只要输入待查找的键即 key，就可以找到其对应的值即 Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。如果多个 key 值经过哈希函数的换算，出现了同一个值。这种情况称为哈希冲突，一般可以往后拉出来一个链表解决。</p>
<ul>
<li><strong>优点：</strong><ul>
<li>新增数据快，可以直接查询到要添加的位置，直接添加或者添加为链表的尾结点。</li>
<li>等值查询速度快。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>由于无序，所以哈希索引做区间查询的速度是很慢的。</li>
</ul>
</li>
<li><strong>适用场景：</strong><ul>
<li>只有等值查询的场景。</li>
</ul>
</li>
</ul>
<h2 id="有序数组"><a href="#有序数组" class="headerlink" title="有序数组"></a>有序数组</h2><p>是一种数组按照下标升序或者降序存储数据的结构。</p>
<ul>
<li><strong>优点：</strong><ul>
<li>使用二分法做查询速度很快，时间复杂度是 O(log(N))</li>
<li>支持区间查询，先用二分法查询到区间最左的元素，再向右遍历直至最又的元素。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>往中间添加一个数据需要往后挪动所有的数据，这个过程很慢，时间复杂度是 O(log(N))</li>
</ul>
</li>
<li><strong>适用场景：</strong><ul>
<li>有序数组只适用于读多写少的情况。</li>
</ul>
</li>
</ul>
<h2 id="N叉树"><a href="#N叉树" class="headerlink" title="N叉树"></a>N叉树</h2><p>为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的大小。</p>
<p>以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。</p>
<p><strong>InnoDB 引擎中使用的是 B+树 这种N叉树的数据结构作为索引模型。</strong></p>
<h1 id="InnoDB-的索引模型"><a href="#InnoDB-的索引模型" class="headerlink" title="InnoDB 的索引模型"></a>InnoDB 的索引模型</h1><p>在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。准确的说应该是存在 B+ 树中的叶子节点中的。每个叶子节点就是开头说的<strong>页（Page）</strong>。</p>
<p>每一个索引在 InnoDB 里面都对应了一棵 B+ 树。根据叶子节点的内容，索引类型分为主键索引和非主键索引。主键索引的叶子节点存的是整行数据。</p>
<ul>
<li>在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。</li>
<li>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。</li>
</ul>
<div class="note primary flat"><p><strong>基于主键索引和普通索引的查询有什么区别？</strong></p>
</div>

<ul>
<li>如果语句是 select * from T where ID&#x3D;1，即主键查询方式，则只需要搜索 ID 这棵 B+ 树</li>
<li>如果语句是 select * from T where k&#x3D;5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为<strong>回表</strong>。</li>
</ul>
<p>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。</p>
<div class="note primary flat"><p>为什么普通索引的叶子节点上要存放的是 ID，为什么不直接存对应行数据的地址呢？</p>
</div>

<ul>
<li><strong>优点：</strong><br>  减少了页分裂或者页合并时候二级索引的维护工作。</li>
<li><strong>缺点：</strong><ol>
<li>二级索引体积可能会变大，因为其中存储了主键信息。</li>
<li>二级索引的访问需要两次查找，要多一次回表的操作。</li>
</ol>
</li>
</ul>
<div class="note primary flat"><p>一个老生常谈的话题了，为啥不用 select *，而要把查询的字段全部写出来呢？</p>
</div>

<p>select * 是肯定要回表的，会导致索引覆盖用不了。</p>
<h1 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h1><p>前文说过 InnoDB 页之间是有序的，为了维护这个有序性，在插入新值和删除旧值的时候就需要做一些必要的维护。</p>
<blockquote>
<p>有个概念可能会混淆，得先说清楚，索引是肯定有序的，这里的有序无序指的是插入的顺序。</p>
</blockquote>
<p>如果都是有序插入的话，每次都直接在页内插入一条新的数据或者申请一个新的页再插入数据即可，这样子可以保证除了最后一页所有页都是满的，空间利用率最高。有序插入的方案是最优的，自增主键就是一种 InnoDB 提供的有序插入的方案。</p>
<div class="note primary flat"><p><strong>页分类与页合并</strong></p>
</div>

<ul>
<li><p><strong>页分裂：</strong></p>
<blockquote>
<p>如果无序插入到一个页内空间已经满了的话，就需要再开新的一页来存储这个数据。根据 B+ 树的算法，会挪动部分数据过去新的页，这个过程称为<strong>页分裂</strong>。在这种情况下，性能自然会受影响。除了性能外，页分裂操作还影响数据页的利用率。因为新开的数据页不一定会被填满。</p>
</blockquote>
</li>
<li><p><strong>页合并：</strong></p>
<blockquote>
<p>当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</p>
</blockquote>
</li>
</ul>
<div class="note info flat"><p><strong>两个建议：</strong></p>
</div>

<ol>
<li>使用自增主键。这样可以保证每次插入都是有序插入的，可以防止页分裂。</li>
<li>删除先做逻辑上的删除，不要做物理删除，这样可以防止页合并。等到有时间了再去真正的删除。</li>
</ol>
<p>新增或者删除的时候多了分裂或者合并的操作，性能自然会受到影响。除了考虑性能外，从存储空间的角度来看，也应该用自增主键，因为普通索引的叶子节点上存储的是主键，显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</p>
<h1 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h1><p>由于二级索引并没有存放真实的数据，所以需要到主键索引上进行一次回表的操作，这自然会影响性能。</p>
<p>那如果我只要查 ID 呢？二级索引的叶子节点上就是记录了 ID，那么自然不需要回表，自然提高了性能。于是很自然的一个想法就出现了，那就是把一些经常会查询到的字段一起记录在二级索引上，这就是<strong>覆盖索引</strong>。</p>
<p>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</p>
<blockquote>
<p>比如有这样的一个需求：<strong>根据身份证号码查询姓名</strong></p>
</blockquote>
<p>身份证号码作为每个人的唯一标识，肯定会有很多根据身份证号码查询身份信息的请求，应该要在身份证号码这个字段上建一个索引。但查询姓名这个需求是一个很高频的需求，这个时候就可以把身份证号码跟姓名一起建立一个联合索引。这样它可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。</p>
<p>当然，索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。</p>
<h1 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h1><p>假设现在有一个（姓名，年龄）的联合索引：</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95.jpg" alt="最左前缀索引"></p>
<p>可以看到，索引项是按照索引定义里面出现的字段顺序排序的。</p>
<p>当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到 ID4，然后向后遍历得到所有需要的结果。</p>
<p>如果你要查的是所有名字第一个字是“张”的人，你的 SQL 语句的条件是”where name like ‘张 %’”。这时，你也能够用上这个索引，查找到第一个符合条件的记录是 ID3，然后向后遍历，直到不满足条件为止。</p>
<p>可以看到，不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个<strong>最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符</strong>。</p>
<p>很显然，这里的（姓名，年龄）索引中的（姓名）是可以复用的，于是此处相当于拥有了两个索引，分别是：（姓名，年龄）、（姓名）</p>
<p>那么，<strong>在建立联合索引的时候，如何安排索引内的字段顺序呢？</strong></p>
<ol>
<li>如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。<ul>
<li>比如上面（姓名，年龄）的例子，通过建立（姓名，年龄），相当于拥有了（姓名，年龄）和（姓名）两个索引，不需要为（姓名）单独再创建一个索引。</li>
</ul>
</li>
<li>考虑字段大小，将字段大一点的排到前面去。<ul>
<li>比如上面（姓名，年龄）的例子，如果还需要姓名跟年龄都建立索引，那么就应该建立（姓名，年龄）这样的联合索引，然后再建立一个（年龄）的索引。因为单独的（年龄）索引占用的空间比起单独的（姓名）的空间要来的小。</li>
</ul>
</li>
</ol>
<h1 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h1><blockquote>
<p>在 MySQL5.6 以后引入了索引下推优化（index condition pushdown)。</p>
</blockquote>
<p>还是拿上面（姓名，年龄）索引的例子，需求是这样的：检索出表中“名字第一个字是张，而且年龄是 10 岁的所有男孩”。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">SQL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tuser <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;张%&#x27;</span> <span class="keyword">and</span> age<span class="operator">=</span><span class="number">10</span> <span class="keyword">and</span> is_male<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段值。</p>
<p>， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p>
<blockquote>
<p><strong>无索引下推优化：</strong></p>
<p>查找到第一个符合 <code>name like &#39;张%&#39;</code> 的记录，也就是 ID3 的张六，之后开始一个个回表对比其他字段值，<strong>共需回表4次</strong>。</p>
</blockquote>
<blockquote>
<p><strong>有索引下推优化：</strong></p>
<p>查找到第一个符合 <code>name like &#39;张%&#39;</code> 的记录，也就是 ID3 的张六，之后在（姓名，年龄）这科索引树下直接判断是否符合 <code>age=10</code> 的条件，如果符合，则回表对比其他字段值；如果不符合，直接放弃回表，减少回表次数，<strong>共需回表2次</strong>。</p>
</blockquote>
<hr>
<blockquote>
<p>网友热心总结的一些问题，复习的时候可以试着回答一下。</p>
</blockquote>
<ol>
<li>select * from T where k betwee 3 and 5 这条语句的执行流程是什么样的?</li>
<li>回表的概念是什么?</li>
<li>索引覆盖的概念是什么, 索引覆盖的优点是什么?</li>
<li>最左前缀原则的概念是什么? 说明最左前缀原则的执行过程.</li>
<li>索引下推的概念是什么? MySQL 5.6 的下推优化是怎么做的?</li>
</ol>
<blockquote>
<p><strong>参考文章：</strong><a href="https://zhuanlan.zhihu.com/p/382375842">MySQL 页完全指南——浅入深出页的原理</a></p>
</blockquote>
<p>大家加油：）</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL实战：全局锁、表锁、行锁</title>
    <url>/posts/27299/</url>
    <content><![CDATA[<blockquote>
<ul>
<li><a href="https://time.geekbang.org/column/article/69862">《极客时间-MySQL实战45讲》06 | 全局锁和表锁 ：给表加个字段怎么有这么多阻碍？</a></li>
<li><a href="https://time.geekbang.org/column/article/70215">《极客时间-MySQL实战45讲》07 | 行锁功过：怎么减少行锁对性能的影响？</a></li>
<li>笔记整理</li>
</ul>
</blockquote>
<span id="more"></span>

<p>根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类。</p>
<p>在正式开篇之前还是得先搞清楚两个概念：共享锁和排他锁</p>
<ul>
<li><strong>共享锁：</strong>所有线程都可以拥有共享锁，故名为共享。一般是读锁。</li>
<li><strong>排他锁：</strong>仅一个线程可以拥有锁，其他线程必须等待该线程释放锁后才可以拿到锁，故名为排他。一般是写锁。</li>
</ul>
<hr>
<h1 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h1><blockquote>
<p>顾名思义，全局锁的锁定对象是整个数据库实例。</p>
</blockquote>
<ul>
<li><strong>加锁语法：</strong><code>flush tables with read lock; (FTWRL)</code></li>
<li><strong>释放锁语法：</strong><code>unlock tables;</code></li>
</ul>
<p>这是一把读锁，使用之后所有的线程只能读取数据而不能修改数据，方式是阻塞其他线程的以下一些语句：</p>
<ul>
<li>数据更新语句（数据的增删改）</li>
<li>数据定义语句（包括建表、修改表结构等）</li>
<li>更新类事务的提交语句。</li>
</ul>
<p>比较多的使用场景是全局逻辑备份，<strong>用于保证备份时的数据一致性</strong>。其底层支持是 <a href="https://www.wrp.cool/posts/574/">MVCC 多版本并发控制</a></p>
<blockquote>
<p>在备份的场景里，FTWRL 相较于 <code>set global read_only=true;</code> 的优势：</p>
</blockquote>
<ol>
<li>readonly 的值可能会被用来做其他逻辑，比如用来判断一个库是主库还是备库。影响面比较大，不建议使用。</li>
<li>异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。</li>
</ol>
<blockquote>
<p><strong>MySQL 全局备份方式：</strong><br>官方自带的逻辑备份工具是 mysqldump。当 mysqldump 使用参数 <code>–single-transaction</code> 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。</p>
<p><strong>注意：</strong><br>MySQL 并非所有的引擎都支持 <code>–single-transaction</code> 参数，底层需要 MVCC 的支持，而目前仅 InnoDB 提供了 MVCC 支持。如果有的表使用了不支持事务的引擎，那么备份就只能通过 FTWRL 方法。这往往是 DBA 要求业务开发人员使用 InnoDB 替代 MyISAM 的原因之一。</p>
</blockquote>
<h1 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h1><p>MySQL5.5 开始引入了元数据锁，自此MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。</p>
<h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><blockquote>
<p>用于锁定整个表对象，分为读锁和写锁。</p>
</blockquote>
<p>读锁（ <code>lock tables … read</code>）：该锁是一种<strong>共享锁</strong>，MySQL 中的表一旦被加上了读锁，其他线程的修改语句就会被阻塞。所有线程均仅可读。<br>写锁（ <code>lock tables … write</code>）：该锁是一种<strong>排他锁</strong>，MySQL 中的表一旦被加上了写锁，除了拥有锁的线程之外，其他的线程对该表的读写操作都会被阻塞。</p>
<div class="note danger flat"><p>对于 InnoDB 这种支持行锁的引擎，一般不使用 lock tables 命令来控制并发，毕竟锁住整个表的影响面太大了。</p>
</div>

<h2 id="元数据锁（meta-data-lock，MDL）"><a href="#元数据锁（meta-data-lock，MDL）" class="headerlink" title="元数据锁（meta data lock，MDL）"></a>元数据锁（meta data lock，MDL）</h2><blockquote>
<p>这是一种列锁，锁住的是表的表结构。也就是说上锁期间会对 DDL 的操作做限制。同样分为了 MDL 读锁和 MDL 写锁。</p>
</blockquote>
<p>MDL 是 server 层的锁，表级锁，主要用于隔离 DML 和 DDL 操作之间的干扰。每执行一条 DML、DDL 语句时都会申请 MDL锁，DML 操作需要 MDL 读锁（共享），DDL 操作需要 MDL 写锁（排他）。MDL 加锁过程是系统自动控制，无法直接干预。</p>
<div class="note danger flat"><p>MDL 可能导致线程爆满，打爆数据库系统。</p>
</div>

<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/MDL%E9%98%BB%E5%A1%9E%E8%BF%87%E7%A8%8B%E6%BC%94%E7%A4%BA%E5%9B%BE.jpg" alt="MDL阻塞过程演示图"></p>
<p>在上面的这个图中，sessionA 正常启动，正常获取 MDL 读锁，之后 sessionB 启动，也获取到 MDL 读锁。</p>
<p>之后 sessionC 启动需要获取 MDL 写锁，此时由于 MDL 读锁还没释放，于是 sessionC 进入阻塞状态等待获取 MDL 写锁。</p>
<p>但是如果碰巧 sessionA 或者 sessionB 中有一个是长事务，那么 sessionC 被阻塞的时间就会久一些，sessionC 之后的所有线程都拿不到 MDL 锁，不论是 MDL 读锁还是 MDL 写锁都拿不到。</p>
<p>如果此时恰巧有很多的请求进来，全部都被阻塞在一起，很快就会导致线程爆满，数据库被打爆。</p>
<h1 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h1><blockquote>
<p>顾名思义，行锁就是针对数据表中行记录的锁。这很好理解，比如事务 A 更新了一行，而这时候事务 B 也要更新同一行，则必须等事务 A 的操作完成后才能进行更新。</p>
</blockquote>
<h2 id="行锁的两阶段协议"><a href="#行锁的两阶段协议" class="headerlink" title="行锁的两阶段协议"></a>行锁的两阶段协议</h2><div class="note default flat"><p>举例说明：</p>
</div>

<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E8%A1%8C%E9%94%81-%E4%B8%A4%E9%98%B6%E6%AE%B5%E5%8D%8F%E8%AE%AE.jpg" alt="行锁-两阶段协议"></p>
<p>在这个例子中，事务B会被事务A阻塞，直到事务A commit 才会执行事务B。显然事务A持有 id&#x3D;1、id&#x3D;2 这两行的锁。</p>
<blockquote>
<p>可以得出：</p>
<p>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。<br><strong>这个就是两阶段锁协议。</strong></p>
</blockquote>
<p>由两阶段协议可得：</p>
<div class="note warning flat"><p><strong>如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</strong></p>
</div>

<blockquote>
<p><strong>像这样：</strong></p>
<p>假设你负责实现一个电影票在线交易业务，顾客 A 要在影院 B 购买电影票。我们简化一点，这个业务需要涉及到以下操作：</p>
<ol>
<li>从顾客 A 账户余额中扣除电影票价；</li>
<li>给影院 B 的账户余额增加这张电影票价；</li>
<li>记录一条交易日志。</li>
</ol>
<p>由于两阶段协议，所以应该尽量把最可能造成锁冲突、影响并发度的锁往后放。<br>所以以上三条语句在编码时的执行顺序应该是：<code>1 3 2</code> 或者是 <code>3 1 2</code></p>
</blockquote>
<h2 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h2><blockquote>
<p><strong>什么是死锁：</strong></p>
<p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。</p>
</blockquote>
<div class="note default flat"><p><strong>举例：</strong></p>
</div>

<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E6%8B%BF%E8%A1%8C%E9%94%81%E4%B8%BE%E4%B8%AA%E6%AD%BB%E9%94%81%E4%BE%8B%E5%AD%90.jpg" alt="拿行锁举个死锁例子"></p>
<p>此时，事务A在等待事务B中 id&#x3D;2 的行锁，事务B又在等待事务A id&#x3D;1 的锁，陷入了一种事务A等事务B，事务B等事务A的状态，这就是死锁现象。</p>
<div class="note primary flat"><p><strong>死锁的应对策略：</strong></p>
</div>

<ol>
<li><p>直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。<br> 在 InnoDB 中，innodb_lock_wait_timeout 的默认值是 50s，对于在线服务来说，这个等待时间往往是无法接受的。但是如果把这个超时时间设置的很短呢？那又可能误伤到很多只是锁等待的线程，这也不好。所以这个方案需要把握好一个比较精准的度。</p>
</li>
<li><p>发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。</p>
</li>
</ol>
<blockquote>
<p>正常情况下我们还是要采用第二种策略，即：<strong>主动死锁检测</strong>，而且 innodb_deadlock_detect 的默认值本身就是 on。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。</p>
<p>你可以想象一下这个过程：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。</p>
<p>但是如果很大量的请求都要同时更新同一行的数据呢？</p>
<p>每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 O(n) 的操作。假设有 1000 个并发线程要同时更新同一行，那么死锁检测操作就是 100 万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的 CPU 资源。因此，你就会看到 CPU 利用率很高，但是每秒却执行不了几个事务。</p>
</blockquote>
<div class="note primary flat"><p><strong>怎么解决由这种热点性更新导致的性能问题呢？</strong></p>
</div>

<ol>
<li>在业务上保证不出现死锁的情况，将死锁检测关掉。<ul>
<li><strong>缺点：</strong>业务上的实现很困难</li>
</ul>
</li>
<li>控制并发度。<ul>
<li><strong>怎么做？</strong>借助中间件，或者是直接修改 MySQL 源码。</li>
</ul>
</li>
<li>从数据库设计上优化。<ul>
<li><strong>怎么做？</strong>将一条数据扩展成多条数据，每次随机选择其中一条记录来做修改，人为的将并发度降低。</li>
</ul>
</li>
</ol>
<hr>
<blockquote>
<p>网友热心总结的一些问题，复习的时候可以试着回答一下。</p>
</blockquote>
<ol>
<li>MySQL从加锁范围上分为哪三类?</li>
<li>全局锁加锁方法的执行命令是什么?主要的应用场景是什么?</li>
<li>做整库备份时为什么要加全局锁?</li>
<li>MySQL的自带备份工具, 使用什么参数可以确保一致性视图, 在什么场景下不适用?</li>
<li>不建议使用set global readonly &#x3D; true的方法加全局锁有哪两点原因?</li>
<li>表级锁有哪两种类型?  各自的使用场景是什么?</li>
<li>MDL中读写锁之间的互斥关系怎样的?</li>
<li>如何安全的给小表增加字段?</li>
<li>两阶段锁的概念是什么? 对事务使用有什么帮助?</li>
<li>死锁的概念是什么? 举例说明出现死锁的情况.</li>
<li>死锁的处理策略有哪两种? </li>
<li>等待超时处理死锁的机制什么?有什么局限?</li>
<li>死锁检测处理死锁的机制是什么? 有什么局限?</li>
<li>有哪些思路可以解决热点更新导致的并发问题?</li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL实战：事务隔离</title>
    <url>/posts/574/</url>
    <content><![CDATA[<blockquote>
<ul>
<li><a href="https://time.geekbang.org/column/article/68963">《极客时间-MySQL实战45讲》03 | 事务隔离：为什么你改了我还看不见？</a></li>
<li><a href="https://time.geekbang.org/column/article/70562">《极客时间-MySQL实战45讲》08 | 事务到底是隔离还是不隔离的？</a></li>
<li>笔记整理</li>
</ul>
</blockquote>
<span id="more"></span>

<h1 id="事务的基本特性（ACID）"><a href="#事务的基本特性（ACID）" class="headerlink" title="事务的基本特性（ACID）"></a>事务的基本特性（ACID）</h1><ul>
<li><strong>原子性（Atomicity）：</strong>事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。</li>
<li><strong>一致性（Consistency）：</strong>事务开始前和结束后，数据库的完整性约束没有被破坏。</li>
<li><strong>隔离性（Isolation）：</strong>同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。</li>
<li><strong>持久性（Durability）：</strong>事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。</li>
</ul>
<h1 id="不考虑隔离性可能产生的问题"><a href="#不考虑隔离性可能产生的问题" class="headerlink" title="不考虑隔离性可能产生的问题"></a>不考虑隔离性可能产生的问题</h1><ul>
<li><strong>脏读：</strong>指在一个事务处理过程中读取了另一个未提交的事务中的数据。<ul>
<li>比如事务A将 x 的值从0修改为1，但未回滚或提交，此时事务B读取了 x 的值为1，随后事务A回滚，将 x 的值重新设置为0。那么事务B读取的 x 的值为1的哪个过程就称为脏读。</li>
</ul>
</li>
<li><strong>不可重复读：</strong>一个事务内多次查询<strong>同一个数据</strong>却返回了不同的数据值。<ul>
<li>比如事务A查询 x 值为0，此时事务B将 x 的值修改为0并提交，事务A再次查询 x 的值为1。事务A并未对 x 的值做操作，但是两次查询 x 的值发生了变化，这个现象就被称为不可重复读。</li>
</ul>
</li>
<li><strong>幻读：</strong>一个事务内多次查询<strong>同一批数据</strong>却返回了不同批的数据。<ul>
<li>比如事务A查询用户表有100个用户，此时事务B新增或者删除了一些用户，之后事务A再次查询用户表返回的不是100个用户。这个现象就被称为幻读。</li>
</ul>
</li>
</ul>
<blockquote>
<p>幻读和不可重复读看起来好像很相似，都是读取了另外一个事务所提交的修改，但区别是<strong>不可重复读针对的是数据项，而幻读针对的是数据量</strong>。</p>
</blockquote>
<h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><ul>
<li><strong>读未提交（READ UNCOMMITTED）：</strong>一个事务还没提交时，它做的变更就能被别的事务看到。</li>
<li><strong>读已提交（READ COMMITTED）：</strong>一个事务提交之后，它做的变更才会被其他事务看到。</li>
<li><strong>可重复读（REPEATABLE READ）：</strong>一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。</li>
<li><strong>串行化（SERIALIZABLE ）：</strong>顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li>
</ul>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%BE%E4%BE%8B.jpg" alt="事务隔离级别举例"></p>
<ul>
<li><strong>读未提交：</strong> V1 的值是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2。</li>
<li><strong>读已提交：</strong> V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以，V3 的值也是 2。</li>
<li><strong>可重复读：</strong> V1、V2 是 1，V3 是 2。之所以 V2 还是 1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。</li>
<li><strong>串行化：</strong>在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2。</li>
</ul>
<h1 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h1><p>事务隔离级别中的 READ UNCOMMITIED 总是读取最新的数据行，而不是符合当前事务版本的数据行。而 SERIALIZABLE 则会对所有读取的行都加锁。这两种隔离级别都能够独立实现，而 READ COMMITTED 和 REPEATABLE READ 这两种隔离级别则需要依赖于 MVVC 多版本并发控制来实现。</p>
<div class="note primary flat"><p><strong>MVCC 多版本并发控制</strong></p>
</div>

<p><strong>什么是 MVCC？</strong></p>
<blockquote>
<p>MVCC，全称 Multi-Version Concurrency Control，即多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。</p>
</blockquote>
<p><strong>MVCC 能做什么？</strong></p>
<blockquote>
<p>借助 MVCC 实现了 READ COMMITTED，REPEATABLE READ 等隔离级别。</p>
</blockquote>
<h1 id="InnoDB-中的-MVCC"><a href="#InnoDB-中的-MVCC" class="headerlink" title="InnoDB 中的 MVCC"></a>InnoDB 中的 MVCC</h1><p>InnDB 中每个事务都有一个唯一的事务 ID，记为 transaction_id。它在事务开始时向 InnDB 申请，按照时间先后严格递增。</p>
<p>而每行数据其实都有多个版本，这就依赖 undo log 来实现了。每次事务更新数据就会生成一个新的数据版本，并把  transaction_id 记为 row trx_id。同时旧的数据版本会保留在 undo log 中，而且新的版本会记录旧版本的回滚指针，通过它直接拿到上一个版本。</p>
<p>为了保证每个事务中拿到的数据都是不被其他事务污染的，InnoDB 还需要一个 read-view（一致性读视图） 来保存每次事务查询的时候不被污染的那一份数据。</p>
<p>所以，InnDB 中的 MVCC 其实是通过在每行记录后面保存两个隐藏的列来实现的。一列是事务 ID：<code>trx_id</code>；另一列是回滚指针：<code>roll_pt</code>。</p>
<h2 id="undo-log（回滚日志）"><a href="#undo-log（回滚日志）" class="headerlink" title="undo log（回滚日志）"></a>undo log（回滚日志）</h2><p>回滚日志保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。</p>
<p>根据操作和删除日志时机的不同，undo log 分为两种： insert undo log 和 update undo log。</p>
<h3 id="insert-undo-log"><a href="#insert-undo-log" class="headerlink" title="insert undo log"></a>insert undo log</h3><p>由于 INSERT 操作记录没有历史版本只对当前事务本身可见，对于其他事务此记录不可见，所以 insert undo log 可以在事务提交后直接删除而不需要进行 purge 操作。</p>
<blockquote>
<p>purge（清除）：的主要任务是将数据库中已经 mark del 的数据删除，另外也会批量回收 undo pages</p>
</blockquote>
<p>在事务提交时，这个事务所做的 INSERT 的操作所记录的 undo log 的日志会被直接删除。</p>
<h3 id="update-undo-log"><a href="#update-undo-log" class="headerlink" title="update undo log"></a>update undo log</h3><p>由于 UPDATE 操作的历史版本可能其他的事务需要用到，所以 UPDATE 操作的 undo log 保存的时间会长一些，只有在系统中没有比这个回滚日志更早的版本时，purge 线程将进行最后的删除操作。</p>
<p>假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="回滚日志流程图"></p>
<p>如果发生了回滚，4就会变成3再变成2再变成1，一步一步的恢复到初始状态。</p>
<blockquote>
<p>当不需要这些回滚日志的时候，这些日志就会被删除。<br>什么时候不需要这些回滚日志呢？<strong>当系统里没有比这个回滚日志更早的 read-view 的时候。</strong></p>
</blockquote>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/1654328337012.png" alt="1654328337012"></p>
<h2 id="read-view（一致性读视图）"><a href="#read-view（一致性读视图）" class="headerlink" title="read-view（一致性读视图）"></a>read-view（一致性读视图）</h2><p>read view 是 InnDB 在实现 MVCC 时用到的一致性读视图，用于支持 RC（读提交）以及 RR（可重复读）隔离级别的实现。</p>
<p>read view 不是真实存在的，只是一个概念，undo log 才是它的实现，<strong>主要是通过版本和 undolog 计算出来的</strong>，作用是决定事务能看到哪些数据。</p>
<p>每个事务或者语句有自己的一致性视图。普通查询语句是一致性读，一致性读会根据 row trx_id 和一致性视图确定数据版本的可见性。</p>
<div class="note warning flat"><p><strong>可见性规则</strong></p>
</div>

<blockquote>
<p>一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本”。</p>
</blockquote>
<p>在实现上， InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交。</p>
<p>数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。（注意：低水位是数组内最小值，高水位是系统内最大的事务ID再加1，高水位不在数组内）</p>
<p>这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。而数据版本的可见性规则，就是基于数据的 row trx_id 和这个一致性视图的对比结果得到的。</p>
<div class="note primary flat"><p><strong>这个视图数组把所有的 row trx_id 分成了几种不同的情况，如下：</strong></p>
</div>

<ol>
<li><strong>小于低水位：</strong>表示这个版本是已提交的事务，这个数据是可见的；</li>
<li><strong>大于等于高水位：</strong>表示这个版本是由将来启动的事务生成的，是肯定不可见的；</li>
<li><strong>大于等于低水位 &amp;&amp; 小于高水位：</strong><ul>
<li><strong>就是当前事务：</strong>可见；</li>
<li><strong>row trx_id 在数组中：</strong>表示这个版本是由还没提交的事务生成的，不可见；</li>
<li><strong>row trx_id 不在数组中：</strong>表示这个版本是已经提交了的事务生成的，可见。</li>
</ul>
</li>
</ol>
<blockquote>
<p>关于第三点的 row trx_id 在不在数组中，不是很好理解，专门画了个图：</p>
</blockquote>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/MVCC%E6%B0%B4%E4%BD%8D%E5%9B%BE.png" alt="MVCC水位图"></p>
<div class="note info flat"><p><strong>一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：</strong></p>
</div>

<ol>
<li>版本未提交，不可见；</li>
<li>版本已提交，但是是在视图创建后提交的，不可见；</li>
<li>版本已提交，而且是在视图创建前提交的，可见。</li>
</ol>
<h1 id="更新不用-read-view"><a href="#更新不用-read-view" class="headerlink" title="更新不用 read-view"></a>更新不用 read-view</h1><div class="note danger flat"><p><strong>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）</strong></p>
</div>

<blockquote>
<p><strong>为什么 UPDATE 操作必须使用当前读？</strong></p>
<p>当 <code>x=1</code> 事务A 执行：<code>set x = x + 1</code>；事务B 也执行：<code>set x = x + 1</code>。<br><strong>一致性读：</strong></p>
<ul>
<li>事务A 与 事务B 拿到 x 的初始数据都是 x&#x3D;1，执行完毕后 x&#x3D;2，<strong>丢失其中一次更新</strong></li>
</ul>
<p><strong>当前读：</strong></p>
<ul>
<li>事务A 开始执行。事务B 等待 事务A 执行完毕</li>
<li>事务A 执行完毕，x&#x3D;2。事务B 开始执行，x&#x3D;3</li>
</ul>
<p><strong>可见当前读未丢失更新</strong></p>
</blockquote>
<div class="note success flat"><p><strong>这也是行锁的两阶段协议存在的原因，防止更新丢失。</strong></p>
</div>

<div class="note primary flat"><p><strong>除了 update 语句外，select 语句如果加锁，也是当前读。</strong></p>
</div>

<h1 id="一个例子结束本文"><a href="#一个例子结束本文" class="headerlink" title="一个例子结束本文"></a>一个例子结束本文</h1><p>假设现在有一个表 t，初始化语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `k` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(id, k) <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>此时，分别有事务A、事务B、事务C，执行流程如下：</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E4%BA%8B%E5%8A%A1%E4%B8%BE%E4%BE%8B.jpg" alt="事务举例"></p>
<p><strong>注意：</strong>begin&#x2F;start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动。如果你想要马上启动一个事务，可以使用 start transaction with consistent snapshot 这个命令。</p>
<ul>
<li>第一种启动方式，一致性视图是在执行第一个快照读语句时创建的；</li>
<li>第二种启动方式，一致性视图是在执行 start transaction with consistent snapshot 时创建的。</li>
</ul>
<p><strong>但是：</strong>在读提交的隔离级别下，“start transaction with consistent snapshot; ”这个用法就没意义了，等效于普通的 start transaction。</p>
<p><strong>因为：</strong>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。</p>
<blockquote>
<p>本例中，事务A、事务B、事务C分别的查询结果：</p>
<ul>
<li><strong>事务A</strong>读取的 k &#x3D; 1：事务A 的一致性视图开启时 k &#x3D; 1。</li>
<li><strong>事务B</strong>读取的 k &#x3D; 3：事务B 的更新采用当前读，当前 k 值已经被事务C修改成2。</li>
<li><strong>事务C</strong>读取的 k &#x3D; 1：事务C 最初始拿到的 k 值就是1。</li>
</ul>
</blockquote>
<hr>
<p>大家加油：）</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL实战：一条SQL更新语句是如何执行的？</title>
    <url>/posts/39005/</url>
    <content><![CDATA[<blockquote>
<ul>
<li><a href="https://time.geekbang.org/column/article/68633">《极客时间-MySQL实战45讲》02 | 日志系统：一条SQL更新语句是如何执行的？</a></li>
<li>笔记整理</li>
</ul>
</blockquote>
<span id="more"></span>

<p>与上一篇笔记中的查询流程相同，一条更新语句也是要经过连接器、分析器、优化器、执行器等功能模块，最后到达存储引擎。</p>
<p>例如这样的一个表，然后有这样的一条更新的语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> T(ID <span class="type">int</span> <span class="keyword">primary</span> key, c <span class="type">int</span>);</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> T <span class="keyword">set</span> c<span class="operator">=</span>c<span class="operator">+</span><span class="number">1</span> <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>在上一篇笔记中说过在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表 T 上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因。</p>
<p>但与查询流程所不相同的是，更新流程涉及到两个重要的日志模块：redo log（重做日志）和binlog（归档日志）。</p>
<h1 id="重要日志模块：redo-log"><a href="#重要日志模块：redo-log" class="headerlink" title="重要日志模块：redo log"></a>重要日志模块：redo log</h1><p>其实就是 MySQL 里经常说到的 WAL 技术，WAL 的全称是 Write-Ahead Logging（预写日志记录），它的关键点就是先写日志，再写磁盘。</p>
<blockquote>
<p>需要注意的是：redo log 也是在磁盘里的，并不是保存在内存里。</p>
</blockquote>
<p><strong>redo log工作流程：</strong></p>
<ol>
<li>当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log 里面。</li>
<li>更新内存，将这条记录的最新值放到内存里。</li>
<li>之后 InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。</li>
</ol>
<p><strong>干嘛要搞的这么复杂，直接写磁盘不好吗？</strong></p>
<ul>
<li><strong>直接写磁盘？？</strong>那不是每次都要去找要写在哪里，数据那么多，等找出来不是人都麻了。</li>
<li><strong>那redo log不也是写磁盘？？</strong>redo log是在磁盘中单独开辟出来的一块空间写滴，每次要写就在后面追加写上去就完了，不用每次都去找要写在哪里，等有空了再去找写在哪里然后写进去，省去了一个寻址的操作。<strong>顺序写可比随机写快的多的多</strong></li>
</ul>
<p><strong>还有个事儿，redo log的大小是固定的哇！！！</strong></p>
<blockquote>
<p>换句话说就是长江后浪推前浪，前浪被拍死在沙滩上哇！！前浪都被后浪卷死了哇！！！</p>
</blockquote>
<p>看图吧您！！</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/redo_log%E5%BE%AA%E7%8E%AF%E5%86%99%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="redo_log循环写示意图"></p>
<p>write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。就像是循环数组一样。</p>
<p><strong>讲这么多，redo log干嘛的哇？？</strong>用来搞哪个crash-safe的哇！！</p>
<blockquote>
<p>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe。</p>
<p>redo log是将未提交的数据写入磁盘，不是写入内存，因此如果数据库异常重启了，那么InnoDB也可以通过读取redo log来重新恢复那些未提交的事务。这样的能力称之为crash-safe</p>
</blockquote>
<h1 id="重要的日志模块：binlog"><a href="#重要的日志模块：binlog" class="headerlink" title="重要的日志模块：binlog"></a>重要的日志模块：binlog</h1><blockquote>
<p><strong>为什么有了redo log还需要binlog？</strong></p>
<p>上一篇笔记中说过 MySQL 整体来看，其实就有两块：一块是 Server 层，负责 MySQL 功能层面的事情，另外一块是引擎层，负责存储相关的具体事宜。redo log 只是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）。</p>
<p>因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力。</p>
</blockquote>
<h2 id="两种日志的不同点："><a href="#两种日志的不同点：" class="headerlink" title="两种日志的不同点："></a>两种日志的不同点：</h2><ol>
<li><p>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</p>
</li>
<li><p>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID&#x3D;2 这一行的 c 字段加 1 ”。</p>
</li>
<li><p>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</p>
</li>
</ol>
<p><strong>binlog的工作流程：</strong></p>
<ol>
<li><p>执行器先找引擎取 ID&#x3D;2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID&#x3D;2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</p>
</li>
<li><p>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</p>
</li>
<li><p>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，<strong>此时 redo log 处于 prepare 状态。</strong></p>
</li>
<li><p>然后告知执行器执行完成了，随时可以提交事务。执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</p>
</li>
<li><p>执行器调用引擎的提交事务接口，<strong>引擎把刚刚写入的 redo log 改成提交（commit）状态</strong>，更新完成。</p>
</li>
</ol>
<p>整个执行流程示意图（图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。）<br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/binlog%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="binlog执行流程示意图"></p>
<p>最后的三步将redo log的写入分成了两个部分，prepare和commit 这就是“两阶段提交”</p>
<h2 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h2><p>两阶段提交是为了保证两个日志的一致性设计的。</p>
<p><strong>假设没有两阶段提交，会怎样？</strong></p>
<ul>
<li><p><strong>先提交redo log：</strong>（提交完MySQL挂掉）</p>
<ul>
<li>重启恢复：redo log 比 binlog 多出一条数据，<ul>
<li>如果后续拿 binlog 做备份恢复，则丢失该条数据</li>
<li>如果此时拿 binlog 做一个从库复制，则从库比主库少了该条数据</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>先提交binlog：</strong>（提交完MySQL挂掉）</p>
<ul>
<li>重启恢复：使用redo log恢复，此时 binlog 比库中多了一条数据记录<ul>
<li>如果后续拿 binlog 做备份恢复，会莫名多出来一条数据（该记录未曾提交）</li>
<li>如果此时拿 binlog 做一个从库复制，则从库比主库多了该条数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>有了两阶段提交之后呢？</strong></p>
<p>两阶段提交流程：1. prepare 阶段、2.写 binlog、3. commit<br>    - 在2之前崩溃：发现没有 commit 且两份日志不统一，自动回滚。两份日志一致<br>    - 在3之前崩溃：虽然没有 commit 但是两份日志统一，自动提交。两份日志一致<br>    - 备份：全靠 binlog</p>
<hr>
<blockquote>
<p>网友热心总结的一些问题，复习的时候可以试着回答一下。</p>
</blockquote>
<ol>
<li>redo log的概念是什么? 为什么会存在.</li>
<li>什么是WAL(write-ahead log)机制, 好处是什么.</li>
<li>redo log 为什么可以保证crash safe机制.</li>
<li>binlog的概念是什么, 起到什么作用, 可以做crash safe吗? </li>
<li>binlog和redolog的不同点有哪些? </li>
<li>物理一致性和逻辑一直性各应该怎么理解? </li>
<li>执行器和innoDB在执行update语句时候的流程是什么样的?</li>
<li>如果数据库误操作, 如何执行数据恢复?</li>
<li>什么是两阶段提交, 为什么需要两阶段提交, 两阶段提交怎么保证数据库中两份日志间的逻辑一致性(什么叫逻辑一致性)?</li>
<li>如果不是两阶段提交, 先写redo log和先写bin log两种情况各会遇到什么问题?</li>
</ol>
<p>大家加油：）</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL实战：一条SQL查询语句是如何执行的？</title>
    <url>/posts/7327/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://time.geekbang.org/column/intro/100020801">《极客时间-MySQL实战45讲》01 | 基础架构：一条SQL查询语句是如何执行的？</a></p>
<ul>
<li>笔记整理</li>
</ul>
</blockquote>
<span id="more"></span>

<h1 id="MySQL-架构示意图"><a href="#MySQL-架构示意图" class="headerlink" title="MySQL 架构示意图"></a>MySQL 架构示意图</h1><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/MySQL%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" alt="MySQL逻辑架构图"></p>
<p>MySQL架构上从大体来说可以分为Server层和存储引擎层两个部分。</p>
<p><strong>Server层：</strong>包括连接器、查询缓存、分析器、优化器、执行器等，其中涵盖了MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有的跨存储引擎的功能也都在这一层实现，比如存储过程、触发器、视图等。</p>
<p><strong>存储引擎层：</strong>负责数据的存储和读取。其架构模式是插件式的，支持InnoDB、MyISAM、Menory等多个存储引擎。现在最常用的存储引擎是InnoDB，InnoDB从MySQL 5.5.5版本开始成为默认存储引擎。</p>
<h1 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h1><blockquote>
<p>连接器负责跟客户端建立连接、获取权限、维持和管理连接。</p>
</blockquote>
<p>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。<strong>之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</strong>但是这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。<u>修改完成后，只有再新建的连接才会使用新的权限设置。</u></p>
<p>由于 <u>MySQL 在执行过程中临时使用的内存是管理在连接对象里面的</u>。所以一旦一个连接使用时间过长，执行的操作越多，其所占用的内存也越大，而这些内存资源只有在连接被断开的时候才会被释放。一旦内存占用过大，就有可能会被系统强行杀掉，从现象上来看就是MySQL的异常重启。解决这个问题的方法一般有以下两种：</p>
<ol>
<li><strong>定期断开长连接。</strong>使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li>
<li>如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，<strong>通过执行mysql_reset_connection来重新初始化连接资源。</strong>这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li>
</ol>
<h1 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h1><p>执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。</p>
<p>大多数情况下建议不要使用查询缓存，为什么呢？因为<strong>查询缓存往往弊大于利！</strong></p>
<p>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。这对于经常更新的表来说，查询缓存的命中率会非常低。除非是一些静态表，例如系统配置表之类的。</p>
<p>MySQL 也提供了显示指定是否使用缓存的方式：将参数 query_cache_type 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。而对于确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定，像下面这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> SQL_CACHE <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">10</span>；</span><br></pre></td></tr></table></figure>

<h1 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h1><p>对于SQL语句做词法分析、语法分析。</p>
<ul>
<li><strong>词法分析：</strong>分析SQL语句中的每个单词代表什么意思</li>
<li><strong>语法分析：</strong>分析SQL语句是否满足MySQL的语法要求</li>
</ul>
<h1 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h1><ul>
<li>决定使用索引的方式</li>
<li>如果是多表连接查询还需要决定表连接的先后顺序</li>
</ul>
<h1 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h1><p><strong>执行流程（没索引）：</strong></p>
<ol>
<li>调用 InnoDB 引擎接口取这个满足条件的第一行。</li>
<li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li>
<li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li>
</ol>
<p>在数据库的慢查询日志中有一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p>
<p>但是在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined 并不是完全相同的。</p>
<hr>
<p>实际上在连接器、分析器、执行器阶段都是会做权限的校验的，因此把权限校验的这一块内容放在最后一起说明：</p>
<p><strong>连接器的权限校验：</strong>应该是库的校验，因为连接是可以指定连接到哪个库中去的，不指定库的话连接成功之后也是要返回可以操作的库给用户的。</p>
<p><strong>分析器的权限校验：</strong>在分析器应该是做的表权限验证，因为分析器已经分析出要执行的SQL了需要调用那一张表了，在此处进行表的权限验证就是最合适的。</p>
<p><strong>执行器的权限校验：</strong>在执行器这一块我认为是做的一个存储过程、触发器、函数之类的验证，因为在这些模块中是可能会调用到其他的表的，而在分析器的时候并不知道这些模块都调用到什么表，因此MySQL需要判断当前用户是否有对这些模块所调用到的表的权限。</p>
<hr>
<blockquote>
<p>网友热心总结的一些问题，复习的时候可以试着回答一下。</p>
</blockquote>
<ol>
<li>Server 有多少组件，各自都是什么作用？</li>
<li>Server 层和存储引擎层各是什么作用？</li>
<li><code>you have an error in your SQL syntax</code> 这个错误是在词法分析还是语法分析的报错？</li>
<li>对于表的操作权限验证在哪里进行？</li>
<li>执行器执行查询语句的流程是怎么样的？</li>
</ol>
<p>大家加油：）</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>Redis 持久化机制（RDB 和 AOF）</title>
    <url>/posts/59553/</url>
    <content><![CDATA[<p>RDB和AOF分别是Redis所提供的两种持久化方式，其中RDB是全量备份，也就是一个快照的方式，对应的AOF就是一个增量备份的方式，是一个日志备份的方式。</p>
<blockquote>
<p>本文非原创，出自：<a href="https://pdai.tech/md/db/nosql-redis/db-redis-x-rdb-aof.html">Redis进阶 - 持久化：RDB和AOF机制详解</a></p>
</blockquote>
<hr>
<h1 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h1><p>触发 Redis 进行 RDB 备份的方式有两种，手动备份和自动备份。自动备份需要在配置文件种设置一些配置项，手动备份只需要手动向 Redis 控制台输入 <code>save</code> 命令或者是 <code>bgsave</code> 命令。</p>
<ul>
<li><code>save</code>：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存比较大的实例会造成长时间<strong>阻塞</strong>，线上环境不建议使用</li>
<li><code>bgsave</code>：Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短</li>
</ul>
<p><strong>bgsave流程如下所示：</strong></p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20220221142546.png" alt="20220221142546"></p>
<h2 id="会自动触发RDB备份的四种情况"><a href="#会自动触发RDB备份的四种情况" class="headerlink" title="会自动触发RDB备份的四种情况"></a>会自动触发RDB备份的四种情况</h2><ul>
<li>redis.conf 中配置 <code>save m n</code>，即在 <code>m</code> 秒内有 <code>n</code> 次修改时，自动触发 bgsave 生成 rdb 文件</li>
<li>主从复制时，从节点要从主节点进行全量复制时也会触发 bgsave 操作，生成当时的快照发送到从节点</li>
<li>reload 命令重新加载 redis 时也会触发 bgsave 操作</li>
<li>默认情况下执行 shutdown 命令时，如果没有开启 aof 持久化，那么也会触发 bgsave 操作</li>
</ul>
<h2 id="redis-conf-中配置RDB备份"><a href="#redis-conf-中配置RDB备份" class="headerlink" title="redis.conf 中配置RDB备份"></a>redis.conf 中配置RDB备份</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">save 900 1  # 如果900秒内有1条Key信息发生变化，则进行快照</span><br><span class="line">save &quot;&quot;     # 关闭RDB快照功能</span><br><span class="line"></span><br><span class="line">dir /home/work/app/redis/data/  # rdb 文件保存路径</span><br><span class="line">dbfilename dump.rdb             # rdb 文件名称</span><br><span class="line"></span><br><span class="line"># 如果持久化出错，主进程是否停止写入</span><br><span class="line"># 这个特性的主要目的是使运维人员在第一时间就发现Redis的运行错误，并进行解决</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"># 是否压缩，将在字符串类型的数据被快照到磁盘文件时，启用 LZF 压缩算法</span><br><span class="line"># Redis 官方的建议是请保持该选项设置为 yes</span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"># 导入时是否检查</span><br><span class="line">rdbchecksum yes</span><br></pre></td></tr></table></figure>

<p>rdbchecksum：从RDB快照功能的version 5 版本开始，一个64位的CRC冗余校验编码会被放置在RDB文件的末尾，以便对整个RDB文件的完整性进行验证。这个功能大概会多损失10%左右的性能，但获得了更高的数据可靠性。所以如果您的Redis服务需要追求极致的性能，就可以将这个选项设置为no。</p>
<h2 id="拍摄快照的过程中如何保证数据一致性？"><a href="#拍摄快照的过程中如何保证数据一致性？" class="headerlink" title="拍摄快照的过程中如何保证数据一致性？"></a>拍摄快照的过程中如何保证数据一致性？</h2><blockquote>
<p>由于生产环境中我们为Redis开辟的内存区域都比较大（例如6GB），那么将内存中的数据同步到硬盘的过程可能就会持续比较长的时间，而实际情况是这段时间Redis服务一般都会收到数据写操作请求。那么如何保证数据一致性呢？</p>
</blockquote>
<p>RDB 中的核心思路是 Copy-on-Write，来保证在进行快照操作的这段时间，需要压缩写入磁盘上的数据在内存中不会发生变化。在正常的快照操作中，一方面 Redis 主进程会 fork 一个新的快照进程专门来做这个事情，这样保证了 Redis 服务不会停止对客户端包括写请求在内的任何响应。另一方面这段时间发生的数据变化会以副本的方式存放在另一个新的内存区域，待快照操作结束后才会同步到原来的内存区域。 </p>
<p>举个例子：如果主线程对这些数据也都是读操作（例如图中的键值对 A），那么，主线程和 bgsave 子进程相互不影响。但是，如果主线程要修改一块数据（例如图中的键值对 C），那么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20220221144234.png" alt="20220221144234"></p>
<h2 id="RDB优缺点"><a href="#RDB优缺点" class="headerlink" title="RDB优缺点"></a>RDB优缺点</h2><p><strong>优点</strong></p>
<ul>
<li>RDB 文件是某个时间节点的快照，默认使用 LZF 算法进行压缩，压缩后的文件体积远远小于内存大小，适用于备份、全量复制等场景；</li>
<li>Redis 加载 RDB 文件恢复数据要远远快于 AOF 方式；</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>RDB 方式实时性不够，无法做到秒级的持久化；</li>
<li>每次调用 bgsave 都需要 fork 子进程，fork 子进程属于重量级操作，频繁执行成本较高；</li>
<li>版本兼容 RDB 文件问题；</li>
</ul>
<hr>
<h1 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h1><p>Redis 是 “写后” 日志，Redis 先执行命令，把数据写入内存，然后才记录日志。日志里记录的是 Redis 收到的每一条命令，这些命令是以文本形式保存。即先写内存，后写日志。</p>
<h2 id="为什么采用写后日志？"><a href="#为什么采用写后日志？" class="headerlink" title="为什么采用写后日志？"></a>为什么采用写后日志？</h2><p>Redis要求高性能，采用写后日志有两方面好处：</p>
<ul>
<li>避免额外的检查开销：Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。 </li>
<li>不会阻塞当前的写操作。</li>
</ul>
<p>但这种方式存在潜在风险：</p>
<ul>
<li>如果命令执行完成，写日志之前宕机了，会丢失数据。</li>
<li>主线程写磁盘压力大，导致写盘慢，阻塞后续操作。</li>
</ul>
<h2 id="如何实现-AOF"><a href="#如何实现-AOF" class="headerlink" title="如何实现 AOF"></a>如何实现 AOF</h2><p>AOF日志记录Redis的每个写命令，步骤分为：命令追加（append）、文件写入（write）和文件同步（sync）。</p>
<ul>
<li><strong>命令追加：</strong>当AOF持久化功能打开了，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器的 aof_buf 缓冲区。</li>
<li><strong>文件写入和同步：</strong>关于何时将 aof_buf 缓冲区的内容写入AOF文件中，Redis提供了三种写回策略：</li>
</ul>
<h2 id="三种写回策略"><a href="#三种写回策略" class="headerlink" title="三种写回策略"></a>三种写回策略</h2><ul>
<li><strong>always 同步写回：</strong> 每个写命令执行完，立马同步地将日志写回磁盘</li>
<li><strong>everysec 每秒写回：</strong> 每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘</li>
<li><strong>no 操作系统控制的写回：</strong> 每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</li>
</ul>
<p><strong>三种写会策略的优缺点：</strong></p>
<table>
<thead>
<tr>
<th align="left">配置项</th>
<th align="left">写回时机</th>
<th align="left">优点</th>
<th align="left">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">always</td>
<td align="left">同步写回</td>
<td align="left">可靠性高，数据基本不丢失</td>
<td align="left">每个写命令都要落盘，性能影响较大</td>
</tr>
<tr>
<td align="left">everysec</td>
<td align="left">每秒写回</td>
<td align="left">性能适中</td>
<td align="left">宕机时丢失一秒内数据</td>
</tr>
<tr>
<td align="left">no</td>
<td align="left">操作系统控制写回</td>
<td align="left">性能好</td>
<td align="left">宕机丢失数据较多</td>
</tr>
</tbody></table>
<blockquote>
<p>为了提高文件写入效率，在现代操作系统中，当用户调用 write 函数，将一些数据写入文件时，操作系统通常会将数据暂存到一个内存缓冲区里，当缓冲区的空间被填满或超过了指定时限后，才真正将缓冲区的数据写入到磁盘里。<br>这样的操作虽然提高了效率，但也为数据写入带来了安全问题：如果计算机停机，内存缓冲区中的数据会丢失。为此，系统提供了 fsync、fdatasync 同步函数，可以强制操作系统立刻将缓冲区中的数据写入到硬盘里，从而确保写入数据的安全性。</p>
</blockquote>
<h2 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h2><blockquote>
<p>AOF会记录每个写命令到AOF文件，随着时间越来越长，AOF文件会变得越来越大。如果不加以控制，会对Redis服务器，甚至对操作系统造成影响，而且AOF文件越大，数据恢复也越慢。为了解决AOF文件体积膨胀的问题，Redis提供AOF文件重写机制来对AOF文件进行“瘦身”。Redis通过创建一个新的AOF文件来替换现有的AOF，新旧两个AOF文件保存的数据相同，但新AOF文件没有了冗余命令。</p>
</blockquote>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20220221161556.png" alt="20220221161556"></p>
<div class="note default flat"><p><strong>AOF重写流程</strong></p>
</div>

<p>AOF 重写过程是由后台进程 bgrewriteaof 来完成的。主线程 fork 出后台的 bgrewriteaof 子进程，fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。所以 <strong>AOF 在重写时，在 fork 进程时是会阻塞住主线程的</strong>。</p>
<ol>
<li>主线程fork出子进程重写aof日志</li>
<li>子进程重写日志完成后，主线程追加aof日志缓冲</li>
<li>替换日志文件</li>
</ol>
<h2 id="redis-conf中配置AOF"><a href="#redis-conf中配置AOF" class="headerlink" title="redis.conf中配置AOF"></a>redis.conf中配置AOF</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appendonly no # appendonly 参数开启 AOF 持久化</span><br><span class="line"></span><br><span class="line"># AOF持久化的文件名，默认是appendonly.aof</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line"># AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的</span><br><span class="line">dir ./</span><br><span class="line"></span><br><span class="line">appendfsync everysec # 同步写回策略</span><br><span class="line"></span><br><span class="line"># aof重写期间是否同步</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"># 加载aof出错如何处理</span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line"># AOF 重写时，缓冲区满 32MB 写一次 fsync()，防止写硬盘时I/O突增。</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br><span class="line"></span><br><span class="line"># 重写触发配置，手动 “BGREWRITEAOF” 命令不受这两个参数限制</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>appendfsync</code>：这个参数项是AOF功能最重要的设置项之一，主要用于设置“真正执行”操作命令向AOF文件中同步的策略。与上节对应，appendfsync参数项可以设置三个值，分别是：always、everysec、no，默认的值为 everysec。</p>
</li>
<li><p><code>auto-aof-rewrite-percentage</code>：表示如果当前AOF文件的大小超过了上次重写后AOF文件的百分之多少后，就再次开始重写AOF文件。例如该参数值的默认设置值为100，意思就是如果AOF文件的大小超过上次AOF文件重写后的1倍，就启动重写操作。 </p>
</li>
<li><p><code>auto-aof-rewrite-min-size</code>：表示启动AOF文件重写操作的AOF文件最小大小，如果AOF文件大小低于这个值，则不会触发重写操作。</p>
</li>
</ul>
<hr>
<h1 id="RDB和AOF混合方式"><a href="#RDB和AOF混合方式" class="headerlink" title="RDB和AOF混合方式"></a>RDB和AOF混合方式</h1><blockquote>
<p>Redis 4.0 中提出了一个混合使用 AOF 日志和内存快照的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。</p>
</blockquote>
<p>这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。</p>
<p>如下图所示，T1 和 T2 时刻的修改，用 AOF 日志记录，等到第二次做全量快照时，就可以清空 AOF 日志，因为此时的修改都已经记录到快照中了，恢复时就不再用日志了。</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20220221162108.png" alt="20220221162108"></p>
<p>这个方法既能享受到 RDB 文件快速恢复的好处，又能享受到 AOF 只记录操作命令的简单优势, 实际环境中用的很多。</p>
<h1 id="从持久化中恢复数据"><a href="#从持久化中恢复数据" class="headerlink" title="从持久化中恢复数据"></a>从持久化中恢复数据</h1><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/redis%E5%8A%A0%E8%BD%BD%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E9%A1%BA%E5%BA%8F%E5%9B%BE.png" alt="redis加载持久化数据顺序图"></p>
<p>为什么会优先加载AOF呢？因为AOF保存的数据更完整，通过上面的分析我们知道AOF基本上最多损失1s的数据。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Spring Boot 集成 Redis</title>
    <url>/posts/44305/</url>
    <content><![CDATA[<blockquote>
<p>使用 Spring Boot 操作 Redis 其实非常简单，本文主要记录一下整合的步骤，方便后续查看。</p>
</blockquote>
<span id="more"></span>

<ol>
<li><p>添加 Redis 依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 yml 文件中配置 Redis 服务器信息</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">database:</span> <span class="string">&quot;指定所使用的是 Redis 中的哪个数据库&quot;</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">&quot;Redis 服务器 IP 地址&quot;</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">&quot;Redis 端口号&quot;</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">&quot;指定登录客户端的密码，如果没有可以不指定&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 Spring Boot 中使用 StringRedisTemplate 操作 Redis 缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Redis 工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor(onConstructor = @__(@Autowired))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisOperator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以 key 为键获取 Redis 中的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置 Redis 键值对</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        set(key, value, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置 Redid 键值对</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 过期时间，单位：秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String key, String value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(key, value, time);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除 Redis 中的键值对</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(String... keys)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String key : keys)</span><br><span class="line">            redisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>以上是我在日常开发中真实使用到的一些对 Redis 的操作，在此封装成一个简单的工具类，以后随着使用的越多会封装更多简便的方法。</p>
</blockquote>
]]></content>
      <categories>
        <category>代码段记录</category>
      </categories>
  </entry>
  <entry>
    <title>Keepalived 实现 Nginx 的主备和互备</title>
    <url>/posts/42807/</url>
    <content><![CDATA[<blockquote>
<p>本文侧重点是讲解 Keepalived 的原理以及使用方式。</p>
</blockquote>
<p><strong>简单讲解一下 Keepalived 的工作原理：</strong></p>
<ol>
<li>通过 VRRP 协议将虚拟IP绑定至本机的一张网卡上</li>
<li>将 Nginx 服务器的IP隐藏起来不对用户暴露，用户直接访问虚拟IP</li>
<li>通过虚拟IP对同一个集群内的不同节点网卡的绑定来实现控制用户访问不同的节点</li>
</ol>
<h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ol>
<li>CentOS 7 虚拟机1，IP地址：<code>192.168.160.136</code>，为了方便区分取主机名为 <code>keep_136</code></li>
<li>CentOS 7 虚拟机2，IP地址：<code>192.168.160.137</code>，为了方便区分取主机名为 <code>keep_137</code></li>
<li>分别安装：<code>nginx-1.20.1</code>、<code>keepalived-2.2.4</code></li>
<li>绑定虚拟IP为 <code>192.168.160.161</code></li>
</ol>
<h3 id="实验准备工作"><a href="#实验准备工作" class="headerlink" title="实验准备工作"></a>实验准备工作</h3><ol>
<li><p><strong>安装 Nginx</strong></p>
<ul>
<li>详细步骤记录于：<a href="https://www.wrp.cool/posts/62048/">Nginx 安装</a></li>
</ul>
</li>
<li><p><strong>安装 Keepalived</strong></p>
<ul>
<li><strong>下载：</strong><a href="https://www.keepalived.org/download.html">https://www.keepalived.org/download.html</a></li>
<li><strong>依赖：</strong><code>yum -y install libnl libnl-level</code></li>
<li><strong>配置：</strong><code>./configure --prefix=/usr/local/keepalived --sysconf=/etc</code></li>
<li><strong>安装：</strong><code>make &amp;&amp; make install</code></li>
<li><strong>配置文件：</strong><code>/etc/keepalived/keelalived.conf</code></li>
</ul>
</li>
<li><p><strong>注册 Keepalived 为系统服务</strong></p>
<ul>
<li>进入 Keepalived 的安装目录下的<code>/keepalived/etc/</code>，以本实验为例： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/software/keepalived-2.2.4/keepalived/etc</span><br></pre></td></tr></table></figure></li>
<li>复制安装目录下的<code>init.d</code>目录下的<code>keepalived</code>文件拷贝到<code>/etc/init.d</code>目录中 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp -a init.d/keepalived /etc/init.d/</span><br></pre></td></tr></table></figure></li>
<li>复制<code>sysconfig</code>目录中的<code>keepalive</code>文件至<code>/etc/sysconfig</code>目录中 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp -a sysconfig/keepalived /etc/sysconfig/</span><br></pre></td></tr></table></figure></li>
<li>重新加载 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure></li>
<li>启动、关闭、重启 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start keepalived</span><br><span class="line">systemctl stop keepalived</span><br><span class="line">systemctl restart keepalived</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="主备实验步骤"><a href="#主备实验步骤" class="headerlink" title="主备实验步骤"></a>主备实验步骤</h3><ol>
<li><p>配置 Keepalived 主机（keep_136）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line"># 全局配置</span><br><span class="line">global_defs &#123;</span><br><span class="line">    router_id keep_136          # 路由ID：当前安装 keepalived 节点主机的标识符，全局唯一</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 计算机节点</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER                # 标识当前节点为主节点或者是备节点。MASTER/BACKUP</span><br><span class="line">    interface ens33             # 指定虚拟IP所绑定的本机网卡</span><br><span class="line">    virtual_router_id 51        # 虚拟路由ID，保持主备节点一致即可</span><br><span class="line">    priority 100                # 标识计算节点权重，当主节点宕机后权重高的节点优先成为主节点</span><br><span class="line">    advert_int 1                # 心跳检测间隔时间，单位：秒</span><br><span class="line"></span><br><span class="line">    # 认证授权的密码，防止非法节点接入</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 虚拟IP</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.160.161</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 Keepalived 备用机（keep_137）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">    router_id keep_137</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 80</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.160.161</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="互备实验步骤"><a href="#互备实验步骤" class="headerlink" title="互备实验步骤"></a>互备实验步骤</h3><blockquote>
<p>做完了主备之后，互备其实很简单，就是在备用机中添加一份主机的配置，在主机中添加一份备用机的配置。</p>
</blockquote>
<ol>
<li><p>配置 Keepalived 主机（keep_136）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 添加一个备用机节点的配置</span><br><span class="line">vrrp_instance VI_2 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 52</span><br><span class="line">    priority 80</span><br><span class="line">    advert_int 1</span><br><span class="line"></span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.160.162</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置 Keepalived 备用机（keep_137）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 添加一个主机节点的配置</span><br><span class="line">vrrp_instance VI_2 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 52</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line"></span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.160.162</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="验证配置"><a href="#验证配置" class="headerlink" title="验证配置"></a>验证配置</h3><ol>
<li>分别启动两台虚拟机中的 Keepalived 服务</li>
<li>观察此时的虚拟IP绑定在哪台虚拟机中，可使用 <code>ip addr</code> 命令查看</li>
<li>打开浏览器访问虚拟IP，此时由主机提供服务</li>
<li>停止提供服务的 Keepalived</li>
<li>浏览器中再次访问该虚拟IP，此时可见由备用机开始提供服务</li>
</ol>
]]></content>
      <categories>
        <category>代码段记录</category>
      </categories>
  </entry>
  <entry>
    <title>Git 钩子自动化部署 Spring Boot 项目</title>
    <url>/posts/19410/</url>
    <content><![CDATA[<p>开发过程中，接口开发完毕给测试人员做测试的时候会很经常的需要将一些测试提交的修改更新到测试服务器上去，但是如果每次提交都手动的去测试服务器打包代码，重启服务的话，那太麻烦了。</p>
<p>之前在 Linux 服务器上部署这个博客的时候有了解到 git 里面有一个钩子的东西可以做这种自动化的部署，于是最近研究了一下针对上面的问题可以使用 git 的钩子来做一个项目的自动部署，这样就不用每次都去手动的部署了，要更新的时候只需要把代码提交到 git 上就可以完成自动化部署。</p>
<p>接下来详细说一下部署的过程，也算是做一个记录，方便以后查看。</p>
<hr>
<p><font size=4><strong>在测试环境上搭建git仓库</strong></font></p>
<ol>
<li><p><strong>安装git</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install git</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建一个 git 用户并且设置密码</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd git</span><br><span class="line">passwd git</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>选定一个目录作为git仓库，并初始化这个git仓库</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个 project.git 的目录，并初始化为 git 仓库</span></span><br><span class="line">git init --bare projuce.git</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>将本地的 ssh 公钥部署到服务器上</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1) 创建 ssh 公钥</span></span><br><span class="line">ssh-keygen -t rsa -C &quot;你的邮箱&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2) 创建 authorized_keys 文件</span></span><br><span class="line">touch /home/git/.ssh/authorized_keys</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3) 将本地创建的公钥复制到 authorized_keys 中，一行一个</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>本地项目添加测试服务器的 git 远程仓库地址</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add origin git@&#x27;测试服务器IP&#x27;:&#x27;仓库路径&#x27;</span><br></pre></td></tr></table></figure>
<p>接下来就是在本地正常的提交代码到测试服务器的 git 仓库了，就像是平时开发一样提交即可。</p>
</li>
</ol>
<hr>
<p><font size=4><strong>将代码部署到测试服务器</strong></font></p>
<ol>
<li><p><strong>检出代码</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git --work-tree=&#x27;要发布的目录&#x27; --git-dir=&#x27;远程仓库地址&#x27; checkout -f</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>打包</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn package</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>启动</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar xxx.jar</span><br></pre></td></tr></table></figure></li>
</ol>
<p><font size=4><strong>自动化部署到测试服务器</strong></font></p>
<p>自动化部署的流程跟以上是一样的，只是利用了 git 的钩子来自动的执行一个部署的脚本，以此免去了人工手动部署的工作。</p>
<ol>
<li><p><strong>在测试服务器上的 git 远程仓库中有一个 <code>hooks</code> 文件夹，在这个文件夹中创建 <code>post-receive</code> 文件</strong></p>
<blockquote>
<p>这个文件就是钩子，当我们的代码提交到这个远程仓库中就会触发这个文件的执行，于是我们就可以把代码部署的脚本写在这个文件中，利用这个来实现自动部署。</p>
</blockquote>
</li>
<li><p><strong>赋予 <code>post-receive</code> 可执行权限</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x post-receive</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>自动部署代码脚本</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">echo &quot;删除项目目录&quot;</span><br><span class="line">rm -rf &quot;项目目录&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;创建项目目录&quot;</span><br><span class="line">mkdir &quot;项目目录&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;拉取代码&quot;</span><br><span class="line">git --work-tree=&#x27;项目根目录&#x27; --git-dir=&#x27;远程仓库地址&#x27; checkout -f</span><br><span class="line"></span><br><span class="line">echo &quot;进入项目根目录&quot;</span><br><span class="line">cd ~/foodie-prod/foodie/</span><br><span class="line"></span><br><span class="line">echo &quot;maven 打包&quot;</span><br><span class="line">/usr/local/apache-maven-3.8.1/bin/mvn package # 此处 maven 打包需要使用全路径</span><br><span class="line"></span><br><span class="line">echo &quot;停止正在运行的 Spring Boot&quot;</span><br><span class="line">appid=`ps -ef |grep java|grep foodie|awk &#x27;&#123;print $2&#125;&#x27;`</span><br><span class="line">kill $appid</span><br><span class="line"></span><br><span class="line">echo &quot;进入 jar 包所在路径&quot;</span><br><span class="line">cd &quot;jar 包所在路径&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;后台启动 Spring Boot&quot;</span><br><span class="line">nohup java -jar -Dspring.profiles.active=&quot;配置文件&quot; foodie-api-0.0.1-SNAPSHOT.jar &gt; ~/temp.log 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line">echo &quot;休眠 10s 等待 Spring Boot 启动&quot;</span><br><span class="line">sleep 10</span><br><span class="line"></span><br><span class="line">echo &quot;自动化发布脚本执行结束！&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>以上脚本在编写时应该对每一步都进行校验以保证最终成功运行。<br>钩子的运行日志可以提交代码时查看。</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>代码段记录</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL 安装</title>
    <url>/posts/7587/</url>
    <content><![CDATA[<p>记录一下 Linux 中安装 MySQL 的步骤。</p>
<span id="more"></span>

<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>MySQL 下载地址：<a href="https://www.mysql.com/downloads/">https://www.mysql.com/downloads/</a></p>
<ol>
<li><p><strong>进入下载地址点击这个链接</strong><br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20210818114657.png" alt="20210818114657"></p>
</li>
<li><p><strong>选择 MySQL Yum Repository</strong><br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20210818115056.png" alt="20210818115056"></p>
</li>
<li><p><strong>进入这个页面之后选择合适的的版本点击 <code>Download</code></strong><br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20210818120024.png" alt="20210818120024"></p>
</li>
<li><p><strong>右键这个链接选择“复制链接地址”到 Linux 系统中使用 <code>wget</code> 下载即可</strong><br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20210818120520.png" alt="20210818120520"></p>
</li>
</ol>
<hr>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol>
<li><p><strong>检查是否安装了 MySQL 或者 Mariadb，如果安装了需要先卸载</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查是否安装了 MySQL</span></span><br><span class="line">rpm -qa |grep mysql</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">卸载 MySQL</span></span><br><span class="line">rpm -e --nodeps &quot;上面查询出来的全部内容&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>开始安装</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将下载的 MySQL 文件加载进本地 yum 源中</span></span><br><span class="line">yum -y localinstall mysql80-community-release-el7-3.noarch.rpm</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过 yum 源进行安装</span></span><br><span class="line">yum -y install mysql-community-server</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>启动 MySQL</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动</span></span><br><span class="line">service mysqld start</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 MySQL 服务是否启动成功</span></span><br><span class="line">ps -ef |grep mysql</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h1 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h1><ol>
<li><p><strong>查询 MySQL 临时密码</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep &#x27;temporary password&#x27; /var/log/mysqld.log</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>登录 MySQL</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p&#x27;临时密码&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>修改 root 用户密码</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">调整密码复杂度和长度</span></span><br><span class="line">set global validate_password.policy=0;</span><br><span class="line">set global validate_password.length=4;</span><br><span class="line"></span><br><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &quot;新密码&quot;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="SQL的四种语言：DDL、DML、DCL、TCL"><a href="#SQL的四种语言：DDL、DML、DCL、TCL" class="headerlink" title="SQL的四种语言：DDL、DML、DCL、TCL"></a>SQL的四种语言：DDL、DML、DCL、TCL</h1><ul>
<li><p><strong>DDL（Data Definition Language）</strong></p>
<ul>
<li>数据定义语言，定义表结构跟约束</li>
<li>关键字：CREATE、ALTER、DROP、TRUNCATE（清空表）</li>
</ul>
</li>
<li><p><strong>DML（Data Manipulation Language）</strong></p>
<ul>
<li>数据操纵语言，可操控具体数据</li>
<li>关键字：SELECT、INSERT、UPDATE、DELETE</li>
</ul>
</li>
<li><p><strong>DCL（Data Control Language）</strong></p>
<ul>
<li>数据库控制语言，授权，角色控制等</li>
<li>关键字：GRANT、REVOKE</li>
</ul>
</li>
<li><p><strong>TCL（Transaction Control Language）</strong></p>
<ul>
<li>事务控制语言</li>
<li>关键字：BEGIN、COMMIT、ROLLBACK</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>代码段记录</category>
      </categories>
  </entry>
  <entry>
    <title>【Spring Boot】全局异常处理器</title>
    <url>/posts/19537/</url>
    <content><![CDATA[<p>记录一下最近在开发中遇到的一个问题有以及一个不错的解决方案。</p>
<p>通常情况下一个请求从前端发起到后端的 Controller 接收这个请求，再去调用对应的 Service 方法去处理对应的逻辑，再由 Controller 将处理的结果封装成一个 JSON 对象返回给前端。这是我们的一个正常的请求处理的过程，但是这其中也有一些例外的地方，如果在 Service 处理的时候出现了一些业务上的逻辑问题流程已经无法再继续往下面去走了，这个时候需要在 Service 直接返回到前端需要怎么做？</p>
<span id="more"></span>

<p>其实可以通过约定不同的返回值给到 Controller 去判断需要怎么处理再怎么返回给前端。但是这样会带来两个问题：</p>
<ol>
<li>一旦项目中的返回类型多了起来就会造成 Controller 层代码的冗余。</li>
<li>Service 一旦返回事务就会提交，这样子就没办法灵活的来控制我们的事务了。当然这也可以通过 Service 层代码编写的逻辑来解决，但这么处理就不是那么的优雅了。</li>
</ol>
<p>一个优雅的处理方式应该是定义好一个业务异常类 BizException，这个类需要继承 RuntimeException 类，一旦在 Service 中需要返回的时候就抛出 BizException 异常，这样事务就可以回滚，然后再由 Spring Boot 的全局异常处理器来捕获这个异常直接将我们自定义的异常信息返回给前端。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义业务异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BizException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处的异常信息仅仅为了演示而定义的只有一个 errMsg 字段</span></span><br><span class="line">    <span class="comment">// 实际使用中可以根据需要将这个异常信息定义的丰富一些，比如使用一个 Enum 来维护这些异常信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String errMsg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BizException</span><span class="params">(String errMsg)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.errMsg = errMsg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局异常处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ApiResponse 类为接口全局响应类</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(BizException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ApiResponse&lt;String&gt; <span class="title function_">businessExceptionHandler</span><span class="params">(BizException e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ApiResponse.fail(e.getErrMsg());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>代码段记录</category>
      </categories>
  </entry>
  <entry>
    <title>学会2-3树，其实红黑树一点都不难</title>
    <url>/posts/18972/</url>
    <content><![CDATA[<p>好了，终于来到了这块最难啃的骨头了——<strong>红黑树</strong>。</p>
<p>首先，当然是直接摆出红黑树大名鼎鼎的五条基本性质了</p>
<ol>
<li><font color=blue>节点是红色或者黑色。</font></li>
<li><font color=blue>根节点是黑色。</font></li>
<li><font color=blue>所有叶子节点都是黑色。（叶子节点是空节点）</font></li>
<li><font color=blue>不存在能够和两条红链接相连的节点。（每个红色的节点的两个子节点都是黑色）</font></li>
<li><font color=blue>从任意一个节点到叶子节点，经过的黑色节点数量是一样的。（黑平衡）</font></li>
</ol>
<p>只要满足以上五个性质的二叉搜索树就可以称之为红黑树。</p>
<span id="more"></span>

<blockquote>
<p>温馨提示：本文比较长，开始之前还请你耐下心来，一步一步仔细看完，我相信这篇文章会带给你一些收获。继续加油！：）</p>
</blockquote>
<p>红黑树其实也是一种二叉搜索树，只不过这是一种性能更好的二叉搜索树。二叉搜索树的结构决定了增删改查这些操作对于二叉搜索树而言都是对数级别的时间复杂度，所以这是一种高效的数据结构，但它有一个致命的缺陷，就是有序插入元素的情况下，它会严重的向一边倾斜退化成一个链表，也就是所谓的失衡。所以，我们希望我们的二叉搜索树在任何情况下都能保持左图的样子，或者说是尽量保持成左图的样子，而永远不要退化成右图的样子。于是我们为二叉搜索树加入了平衡机制，其中红黑树就是这么一种机制。<strong>对于二叉搜索树的有序性而言，红黑树在这基础上又添加了平衡性。</strong>以上红黑树的五条基本性质就是维持平衡的手段。</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20210720231008.png" alt="20210720231008"></p>
<p>像左图这样的树我们称之为平衡的，而红黑树仅仅只是维持平衡的手段而已，<font color=blue>红黑树在本质上依然是一棵二叉搜索树。</font></p>
<p>像红黑树这样的数据结构，肯定也不是一朝一夕能够发明出来的，而是有一个演化的过程，从二叉搜索树到红黑树之间就有一个不可缺少的过渡——<strong>2-3查找树</strong>。</p>
<h1 id="2-3查找树"><a href="#2-3查找树" class="headerlink" title="2-3查找树"></a>2-3查找树</h1><br>

<p><strong>定义：</strong></p>
<ul>
<li>一棵2-3查找树要么是一棵空树，要么由<code>2-节点</code>和<code>3-节点</code>组成。</li>
<li><code>2-节点</code>：含有一个节点本身的值和两条链接，左连接指向的2-3树值都小于该节点，右链接指向的2-3树值都大于该节点。</li>
<li><code>3-节点</code>：含有两个节点本身的值和三条链接，左连接指向的2-3树值都小于该节点，中链接指向的2-3树值都位于节点的两个值之间，右链接指向的2-3树值都大于该节点。</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>2-3查找树是一种完美平衡的树结构，也就是说一棵2-3树中的任意节点的左子树、中子树、右子树高度相等。</li>
</ul>
<p><strong>由完美平衡可知：</strong></p>
<ul>
<li><code>2-节点</code>要么没有两条链接都指向空，要么两条链接都不为空。</li>
<li><code>3-节点</code>要么没有三条链接都指向空，要么三条链接都不为空。</li>
</ul>
<p><strong>如图：</strong><br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/album_temp_1627184547.PNG" alt="album_temp_1627184547"></p>
<blockquote>
<p><strong>接下来将分析2-3树中的各种插入情况</strong></p>
</blockquote>
<h2 id="向2-节点添加元素"><a href="#向2-节点添加元素" class="headerlink" title="向2-节点添加元素"></a>向2-节点添加元素</h2><p>首先，需要在2-3树中搜索到一个可以添加节点的位置，如果搜索结束于一个<code>2-节点</code>，那么很好办，只需要将这个<code>2-节点</code>替换成一个<code>3-节点</code>。像这样：<br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/IMG_0045.PNG" alt="IMG_0045"></p>
<hr>
<p>其实向一个<code>2-节点</code>插入元素是非常简单的，只需要将一<code>2-节点</code>变换成一个<code>3-节点</code>即可。但是这很简单的一步却是保持2-3树完美平衡<strong>最关键的一步</strong>。</p>
<p>试想一个问题：一棵完美的平衡二叉树，也就是满二叉树，它的节点个数是奇数还是偶数？答案非常简单，是奇数，根节点的左子树和右子树的节点数是相同的，于是整棵树的节点数就是<code>2 * 左子树的节点数 + 1</code>。采用递归的思想，整棵树无论对于哪个节点求节点个数得出的答案都是奇数。</p>
<p>于是，如果一棵二叉树的节点个数是偶数，那么这棵二叉树绝对不是完美平衡，想要得到一棵完美平衡的二叉树必备的一个条件就是树的节点个数为奇数。实际上一棵完美平衡的二叉树的节点数是等于<code>2 ^ h - 1</code>的。（其中h为树的高度，根节点的高度为1）</p>
<p>一棵二叉树在生成的过程当中，依次将元素插入其中，这不可能保证整棵树的节点个数在任何情况下都是奇数。事实上，在节点只能存放一个元素的情况下，不可能实现完美平衡的树结构。2-3树中的<code>3-节点</code>正是为了解决这一情况而存在的。</p>
<p>正常情况下，向二叉树中的一个左右子树都为空的节点插入元素无论插入在左子树还是右子树中肯定会造成这个节点的不完美平衡，但是现在引入了<code>3-节点</code>这样的一个过渡的节点，说白了，这其实是在暂存一下这种不平衡的情况，一旦在这个<code>3-节点</code>中再次插入一个元素之后立马会分裂成为一棵左右子树都不为空的二叉树。</p>
<h2 id="向3-节点添加元素"><a href="#向3-节点添加元素" class="headerlink" title="向3-节点添加元素"></a>向3-节点添加元素</h2><p>单纯的向一棵仅有一个三节点的2-3树添加元素是比较简单的，这里简单讲一下思路即可。</p>
<ol>
<li>将新节点插入<code>3-节点</code>中，组成一个临时的<code>4-节点</code>。此时这个<code>4-节点</code>中包含三个值和四条链接。</li>
<li>将这个<code>4-节点</code>的三个值都抽取出来成为三个<code>2-节点</code>，中值抽取出来的<code>2-节点</code>作为根，根的左链接指向三个节点中的最小者，右链接指向三个节点中的最大者。</li>
</ol>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/album_temp_1627305570.PNG" alt="album_temp_1627305570"></p>
<blockquote>
<p>也许有些同学也注意到了，这一步操作使得树的高度增加了，在将<code>4-节点</code>分裂为三个<code>2-节点</code>的过程当中，树高由1变成了2。这也是2-3树的生长方式，当根节点已经是一个<code>3-节点</code>的时候插入一个新的节点，此时根节点分裂为三个<code>2-节点</code>，树高度加1。与普通的二叉查找树不同的是2-3树的生长方向是由下至上生长的，而二叉查找树的生长方向是由上至下生长的。</p>
</blockquote>
<h3 id="向一个父节点为2-节点的3-节点添加元素"><a href="#向一个父节点为2-节点的3-节点添加元素" class="headerlink" title="向一个父节点为2-节点的3-节点添加元素"></a>向一个父节点为2-节点的3-节点添加元素</h3><ol>
<li>插入到<code>3-节点</code>中，组成一个临时的<code>4-节点</code>。</li>
<li>将<code>4-节点</code>的中值所抽取出来的根节点插入至父节点，使父节点从原来的<code>2-节点</code>变成<code>3-节点</code><br> 此处插入过程与“向<code>2-节点</code>添加元素”相同。</li>
<li>将<code>4-节点</code>分裂出来的两个<code>2-节点</code>移动至父节点中，成为<code>3-节点</code>的两个子树。</li>
</ol>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/album_temp_1627307311.PNG" alt="album_temp_1627307311"></p>
<h3 id="向一个父节点为3-节点的3-节点添加元素"><a href="#向一个父节点为3-节点的3-节点添加元素" class="headerlink" title="向一个父节点为3-节点的3-节点添加元素"></a>向一个父节点为3-节点的3-节点添加元素</h3><ol>
<li>插入到<code>3-节点</code>中，组成一个临时的<code>4-节点</code>。</li>
<li>将<code>4-节点</code>的中值抽取出来的根节点插入至父节点，使父节点从原来的<code>3-节点</code>变成一个临时的<code>4-节点</code>。</li>
<li>将<code>4-节点</code>分裂出来的两个<code>2-节点</code>移动至父节点也就是新的临时的<code>4-节点</code>中，成为新的临时<code>4-节点</code>的两个子树。</li>
<li>将新的临时的<code>4-节点</code>分裂出来的根继续往上插入<br> 此处插入的过程与“向一个父节点为<code>2-节点</code>的<code>3-节点</code>添加元素”相同。</li>
</ol>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/album_temp_1627307543.PNG" alt="album_temp_1627307543"></p>
<h3 id="向“从插入节点出发直到根节点全部都是3-节点”的节点添加元素"><a href="#向“从插入节点出发直到根节点全部都是3-节点”的节点添加元素" class="headerlink" title="向“从插入节点出发直到根节点全部都是3-节点”的节点添加元素"></a>向“从插入节点出发直到根节点全部都是3-节点”的节点添加元素</h3><ol>
<li>一直按照“向一个父节点为<code>3-节点</code>的<code>3-节点</code>添加元素”的方式插入元素，那么直到最后根节点也会变成一个临时的<code>4-节点</code>。</li>
<li>将根节点转换成的临时<code>4-节点</code>分裂开来，按照“向<code>3-节点</code>添加元素”的方式，中值成为整颗2-3树新的根，此时树高加一。</li>
</ol>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/album_temp_1627310222.PNG" alt="album_temp_1627310222"></p>
<hr>
<p><strong>以上就是2-3树中插入元素的全部情况，做个小结：</strong></p>
<ol>
<li>向<code>2-节点</code>插入元素：直接插入至<code>2-节点中</code>生成一个三节点。</li>
<li>向<code>3-节点</code>插入元素：<ol>
<li>父节点为<code>2-节点</code>：组成临时<code>4-节点</code>，分裂后的根插入父节点组成<code>3-节点</code>。</li>
<li>父节点为<code>3-节点</code>：组成临时<code>4-节点</code>，分裂后的根插入父节点，再次组成临时<code>4-节点</code>。<br> 不断重复此过程，直到找到一个<code>2-节点</code>为止。如果直到根节点还找不到，则将根节点分裂成三个<code>2-节点</code>，此时树高加一。</li>
</ol>
</li>
</ol>
<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>其实我更愿意这么来理解红黑树：<font color=blue>使用二叉树来表现2-3树</font>。换句话说，其实2-3树和红黑树是等价的。</p>
<blockquote>
<p>其实一般的红黑树是等价于2-3-4树的，也就是我们前面说的2-3树中再加了一个<code>4-节点</code>。但是本文讲述的红黑树是左倾红黑树，具体的左倾红黑树与一般红黑树的区别，在这就留个坑吧。在这里只需要记住一点：<strong>左倾红黑树中红链接全部都是左连接</strong>。</p>
</blockquote>
<p>一棵2-3树中的<code>2-节点</code>跟二叉查找树中的节点是完全相同的，也就是说普通的节点就可以表示2-3树中的<code>2-节点</code>。于是我们只要能够使用二叉树的形式来表现一个<code>3-节点</code>我们就可以成功的将一棵2-3树转化成为红黑树。</p>
<p>将<code>3-节点</code>中的两个值分别当作是两个<code>2-节点</code>分裂开，中间使用一条连接将这两个<code>2-节点</code>相连接起来，表示了这两个<code>2-节点</code>代表了一个<code>3-节点</code>。这样的链接被称为红链接。</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/album_temp_1627903082.PNG" alt="album_temp_1627903082"></p>
<p>为了方便表示红链接我们注意到每个红色链接都会指向唯一的一个节点，所以我们将节点标记为红色来表示指向此节点的链接是红链接，相反的没有被红链接指向的节点全部就被标记为黑色。</p>
<p>本文一开始就提出的红黑树的五条基本性质中的第1点、第2点、第3点也就是这么来的，性质4和性质5稍微有一些抽象：</p>
<ol>
<li><font color=blue>节点是红色或者黑色</font>：每个节点都会被标记为红色或者黑色。</li>
<li><font color=blue>根节点是黑色</font>：二叉树中没有链接指向根节点，所以根节点被标记为黑色。</li>
<li><font color=blue>所有叶子节点都是黑色</font>：叶子节点都是空节点，没有被红链接所指向，所以标记为黑色。</li>
<li><font color=blue>不存在能够和两条红链接相连的节点</font>：如果将红黑树中由红链接相连的节点合并起来，得到的就是一棵2-3树。相反，如果将一棵2-3树中的<code>3-节点</code>画作由红色左连接相连的两个<code>2-节点</code>，那么肯定不会存在能够和两条红链接相连的节点。</li>
<li><font color=blue>从任意一个节点到叶子节点，经过的黑色节点数量是一样的。</font>：如果将红链接画平，那么第5点将很容易理解。</li>
</ol>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/album_temp_1627905396.PNG" alt="album_temp_1627905396"></p>
<blockquote>
<p>上图中粗链接表示为红链接</p>
</blockquote>
<h2 id="着色和旋转"><a href="#着色和旋转" class="headerlink" title="着色和旋转"></a>着色和旋转</h2><p>保持红黑树五大性质的两大法宝就是着色和旋转，其中旋转又分为左旋转和右旋转。</p>
<h3 id="着色"><a href="#着色" class="headerlink" title="着色"></a>着色</h3><p>着色操作比较简单，只需要改变对节点颜色的标记即可。</p>
<h3 id="左旋转和右旋转"><a href="#左旋转和右旋转" class="headerlink" title="左旋转和右旋转"></a>左旋转和右旋转</h3><p>下图中粗链接表示为红链接<br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20210803095327.png" alt="20210803095327"></p>
<p>具体的旋转过程在<a href="https://www.wrp.cool/posts/54793/">AVL 树</a>这篇文章中已经有具体的说明。这里不再过多的赘述。</p>
<blockquote>
<p>需要注意的是：旋转过后应该保持根节点颜色相同，以及这里的旋转过程是在插入节点时调用的，在2-3树中插入操作总是和树中的节点相互融合的，所以要将旋转后的节点标记为红色。</p>
</blockquote>
<!-- TODO 聊清楚左右旋转的着色原理 -->

<hr>
<p>在正式开始插入操作之前，有一点需要先注意：新插入的节点默认是红色的节点，因为在插入的时候除非是插入在根节点的位置之外，所有的插入首先都是与原有的节点做融合操作，而融合进其他节点的节点在红黑树中被标记为红色。</p>
<h2 id="向红黑树中的“2-节点”插入元素"><a href="#向红黑树中的“2-节点”插入元素" class="headerlink" title="向红黑树中的“2-节点”插入元素"></a>向红黑树中的“2-节点”插入元素</h2><p>向一个<code>2-节点</code>中插入元素之后，会与原来的<code>2-节点</code>一起形成一个<code>3-节点</code>。这就引申出了两种情况：</p>
<ol>
<li>插入节点小于<code>2-节点</code>，插入在<code>2-节点</code>的左边，成为<code>2-节点</code>的左孩子。<br> 符合左倾红黑树的定义，即红链接在左边，此时无需修改。</li>
<li>插入节点大于<code>2-节点</code>，插入在<code>2-节点</code>的右边，成为<code>2-节点</code>的右孩子。<br> 不符合左倾红黑树的定义，即红链接在右边，此时需要对被插入节点做一次左旋转的操作，以将右红链接纠正为左红链接。</li>
</ol>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/album_temp_1628078520.PNG" alt="album_temp_1628078520"></p>
<h2 id="向红黑树中的“3-节点”插入元素"><a href="#向红黑树中的“3-节点”插入元素" class="headerlink" title="向红黑树中的“3-节点”插入元素"></a>向红黑树中的“3-节点”插入元素</h2><p>向一个<code>3-节点</code>中插入元素之后，与原来的<code>3-节点</code>之间会产生三种情况：</p>
<ol>
<li>插入的元素小于<code>3-节点</code>的两个元素。</li>
<li>插入的元素位于<code>3-节点</code>的两个元素之间。</li>
<li>插入的元素大于<code>3-节点</code>的两个元素。</li>
</ol>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/album_temp_1628079653.PNG" alt="album_temp_1628079653"></p>
<blockquote>
<p>注意：以上的三种情况中最后的一个步骤都是需要将根节点也就是b节点转换成黑色的，这样才能保持红黑树的第五条性质，黑平衡。</p>
</blockquote>
<h2 id="插入代码实现"><a href="#插入代码实现" class="headerlink" title="插入代码实现"></a>插入代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RBTree</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">RED</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">BLACK</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> e;</span><br><span class="line">        Node left, right;</span><br><span class="line">        <span class="type">boolean</span> color;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.e = e;</span><br><span class="line">            <span class="built_in">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">this</span>.color = RED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 左旋转</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">leftRotate</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">// 暂存</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> node.right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 旋转</span></span><br><span class="line">        node.right = x.left;</span><br><span class="line">        x.left = node;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 着色</span></span><br><span class="line">        x.color = node.color;</span><br><span class="line">        node.color = RED;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 右旋转</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">rightRotate</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">// 暂存</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">x</span> <span class="operator">=</span> node.left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 旋转</span></span><br><span class="line">        node.left = x.right;</span><br><span class="line">        x.right = node;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 着色</span></span><br><span class="line">        x.color = node.color;</span><br><span class="line">        node.color = RED;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isRed</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">node</span> <span class="operator">=</span>= <span class="literal">null</span> ? BLACK : node.color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">flipColors</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        node.color = RED;</span><br><span class="line">        node.left.color = BLACK;</span><br><span class="line">        node.right.color = BLACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">        add(root, e);</span><br><span class="line">        root.color = BLACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">add</span><span class="params">(Node node, <span class="type">int</span> e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.e &gt; e) &#123;</span><br><span class="line">            node.left = add(node.left, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.e &lt; e) &#123;</span><br><span class="line">            node.right = add(node.right, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isRed(node.right) &amp;&amp; !isRed(node.left))</span><br><span class="line">            node = leftRotate(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isRed(node.left) &amp;&amp; isRed(node.left.left))</span><br><span class="line">            node = rightRotate(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isRed(node.left) &amp;&amp; isRed(node.right))</span><br><span class="line">            flipColors(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>本文中的参考图片出自《算法：第4版》这本书中的红黑树章节。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构：AVL 树</title>
    <url>/posts/54793/</url>
    <content><![CDATA[<p>上一篇文章所讲述的【<a href="https://www.wrp.cool/posts/46128/">二叉搜索树</a>】其实有一个非常严重的漏洞：如果插入的元素都是有序的怎么办？</p>
<blockquote>
<p>如果按照有序的方式或者近乎有序的方式将元素插入到二叉搜索树当中去，那么此时的二叉搜索树将退化成一个链表的数据结构。于是引入平衡这种机制来防止这种情况的发生，引入平衡的二叉树被成为平衡二叉树。</p>
</blockquote>
<p><strong>平衡：</strong><font color=blue>一棵树中对于任意节点都有左子树的高度减去右子树的高度的绝对值小于等于1，则称这棵二叉树是平衡的。</font></p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>首先还是先看看百度百科中对于AVL树的定义（<a href="https://baike.baidu.com/item/AVL%E6%A0%91">AVL树-百度百科</a>）。</p>
<p><strong>AVL树的特点：</strong></p>
<ul>
<li>本身首先是一棵二叉搜索树</li>
<li>带有平衡性：每个节点的左右子树的高度之差的绝对值（<strong>平衡因子</strong>）最多为1。<br>也就是说，AVL树，本质上是带了平衡功能的二叉搜索树。</li>
</ul>
<p><strong>平衡因子：</strong>左子树的高度减去右子树的高度。（注意：平衡因子的值可能为负，不过这是正常的，平衡因子的正负性能够帮助我们区分二叉树是向左倾斜的还是向右倾斜的）</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><blockquote>
<p>本质上AVL树还是一种二叉搜索树，但是引入了“平衡因子”的概念来维护树的平衡，所以在树的节点类中要新增加一个<code>height</code>变量来维护树的高度。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节点类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> e, height;</span><br><span class="line">    <span class="keyword">public</span> Node left, right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> e, Node left, Node right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.height = <span class="number">1</span>; <span class="comment">// 新节点默认高度为 1</span></span><br><span class="line">        <span class="built_in">this</span>.e = e;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设计两个辅助函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取节点高度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="type">return</span> <span class="variable">node</span> <span class="operator">=</span>= <span class="literal">null</span> ? <span class="number">0</span> : node.height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取平衡因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getBalanceFactor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="type">return</span> <span class="variable">node</span> <span class="operator">=</span>= <span class="literal">null</span> ? <span class="number">0</span> : getHeight(node.left) - getHeight(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="树的平衡与失衡"><a href="#树的平衡与失衡" class="headerlink" title="树的平衡与失衡"></a>树的平衡与失衡</h1><p>一个节点的平衡因子由有这个节点左子树的高度减去右子树的高度得到的。如果平衡因子的绝对值小于等于一，则这个节点是平衡的，反之则称之为失衡。</p>
<p><font color=blue>那么什么情况会导致树的失衡呢？</font><br>当左右子树的高度本来就相差1的情况下，其中较高的子树再次加1的情况下，此时就会产生失衡。</p>
<p><font color=blue>那么失衡总共有多少种情况呢？</font><br>四种，分别是LL型、RR型、LR型、RL型，L和R分别是Left和Right的缩写。<br>其中第一个字母代表的是较高的子树是左子树还是右子树，第二个字母代表的是新增的节点是增加在较高子树的左子树还是右子树。<br>除了这四种失衡的情况，其余的情况就都是平衡的了。</p>
<p>下面为这四种情况分别举个例子：<br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20210714225927.png" alt="20210714225927"></p>
<blockquote>
<p>以上的四种情况失衡的节点都是根节点。</p>
</blockquote>
<h1 id="左旋转与右旋转-平衡-LL和RR"><a href="#左旋转与右旋转-平衡-LL和RR" class="headerlink" title="左旋转与右旋转 平衡 LL和RR"></a>左旋转与右旋转 平衡 LL和RR</h1><p>左旋转与右旋转就是对不平衡节点的平衡操作，就拿上面比较简单的LL和RR的例子来演示左旋转与右旋转。</p>
<p><strong>具体的旋转过程用这两张图来表示：</strong><br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-AVL-3.jpg" alt="数据结构-AVL-3"><br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-AVL-2.jpg" alt="数据结构-AVL-2"></p>
<blockquote>
<p>这里的<code>D、E、F、G</code>分别是挂在在<code>A、B、C</code>节点下的二叉树，这里假设<code>D、E、F、G</code>高度相同。为了方便理解，你可以直接把<code>D、E、F、G</code>就当成是单个节点。</p>
</blockquote>
<p><font color=blue>这里最重要的一点是旋转前后整个树依然保持着二叉搜索树的性质，也就是图中的结论在旋转前和旋转后都是成立的。</font></p>
<p><font size=5><strong>编码实现：</strong></font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 左旋转</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">leftRotate</span><span class="params">(Node a)</span> &#123;</span><br><span class="line">    <span class="comment">// 暂存</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">b</span> <span class="operator">=</span> a.right;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">e</span> <span class="operator">=</span> b.left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 旋转</span></span><br><span class="line">    b.left = a;</span><br><span class="line">    a.right = e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新Height</span></span><br><span class="line">    a.height = Math.max(getHeight(a.left), getHeight(a.right)) + <span class="number">1</span>;</span><br><span class="line">    b.height = Math.max(getHeight(b.left), getHeight(b.right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 右旋转</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">rightRotate</span><span class="params">(Node a)</span> &#123;</span><br><span class="line">    <span class="comment">// 暂存</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">b</span> <span class="operator">=</span> a.left;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">f</span> <span class="operator">=</span> b.right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 旋转</span></span><br><span class="line">    b.right = a;</span><br><span class="line">    a.left = f;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新Height</span></span><br><span class="line">    a.height = Math.max(getHeight(a.left), getHeight(a.right)) + <span class="number">1</span>;</span><br><span class="line">    b.height = Math.max(getHeight(b.left), getHeight(b.right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="左旋转与右旋转-平衡-LR和RL"><a href="#左旋转与右旋转-平衡-LR和RL" class="headerlink" title="左旋转与右旋转 平衡 LR和RL"></a>左旋转与右旋转 平衡 LR和RL</h1><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-AVL-4.jpg" alt="数据结构-AVL-4"></p>
<p>大概的处理过程就是这个样子，先旋转其中一个节点，将LR和RL变成LL或者是RR的形式，最后再旋转一次即可完成对LR和RL的平衡。</p>
<h1 id="在二叉搜索树中引入AVL"><a href="#在二叉搜索树中引入AVL" class="headerlink" title="在二叉搜索树中引入AVL"></a>在二叉搜索树中引入AVL</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 保持平衡</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">keepBalance</span><span class="params">(Node node)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 平衡维护</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">balance</span> <span class="operator">=</span> getBalanceFactor(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LL</span></span><br><span class="line">    <span class="keyword">if</span> (balance &gt;= <span class="number">2</span> &amp;&amp; getBalanceFactor(root.left) &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> rightRotate(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RR</span></span><br><span class="line">    <span class="keyword">if</span> (balance &lt;= -<span class="number">2</span> &amp;&amp; getBalanceFactor(root.right) &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> leftRotate(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LR</span></span><br><span class="line">    <span class="keyword">if</span> (balance &gt;= <span class="number">2</span> &amp;&amp; getBalanceFactor(root.left) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        root.left = leftRotate(root.left);</span><br><span class="line">        <span class="keyword">return</span> rightRotate(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RL</span></span><br><span class="line">    <span class="keyword">if</span> (balance &lt;= -<span class="number">2</span> &amp;&amp; getBalanceFactor(root.right) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        root.right = rightRotate(root.right);</span><br><span class="line">        <span class="keyword">return</span> leftRotate(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">    root = add(root, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">add</span><span class="params">(Node root, <span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(e, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e &lt; root.e) root.left = add(root.left, e);</span><br><span class="line">    <span class="keyword">if</span> (e &gt; root.e) root.right = add(root.right, e);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新Height</span></span><br><span class="line">    root.height = Math.max(getHeight(root.left), getHeight(root.right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 平衡维护</span></span><br><span class="line">    <span class="keyword">return</span> keepBalance(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delNode</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">    delNode(root, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">delNode</span><span class="params">(Node root, <span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e &gt; root.e) &#123;</span><br><span class="line">        root.right = delNode(root.right, e);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e &lt; root.e) &#123;</span><br><span class="line">        root.left = delNode(root.left, e);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size --;</span><br><span class="line">    Node retNode;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span>) retNode =  root.right;</span><br><span class="line">    <span class="keyword">if</span> (root.right == <span class="literal">null</span>) retNode = root.left;</span><br><span class="line">    retNode = delMax(root.left);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新Height</span></span><br><span class="line">    root.height = Math.max(getHeight(root.left), getHeight(root.right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 平衡维护</span></span><br><span class="line">    <span class="keyword">return</span> keepBalance(retNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构：二叉搜索树</title>
    <url>/posts/46128/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote>
<p>二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： <font color=blue>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。</font>二叉搜索树作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势；所以应用十分广泛，例如在文件系统和数据库系统一般会采用这种数据结构进行高效率的排序与检索操作。</p>
<p>以上资料来自：<a href="https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91">二叉搜索树-百度百科</a></p>
</blockquote>
<span id="more"></span>

<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BST</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> e;</span><br><span class="line">        <span class="keyword">public</span> Node left, right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> e, Node left, Node right)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.e = e;</span><br><span class="line">            <span class="built_in">this</span>.left = left;</span><br><span class="line">            <span class="built_in">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BST</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">    add(root, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">add</span><span class="params">(Node root, <span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        size ++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>(e, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (e &lt; root.e) &#123;</span><br><span class="line">        root.left = add(root.left, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e &gt; root.e) &#123;</span><br><span class="line">        root.right = add(root.right, e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> find(root, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">find</span><span class="params">(Node root, <span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e &lt; root.e) </span><br><span class="line">        <span class="keyword">return</span> find(root.left, e);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e &gt; root.e)</span><br><span class="line">        <span class="keyword">return</span> find(root.right, e);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除最大元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">delMax</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        root.right = delMax(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        size --;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span>) &#123;</span><br><span class="line">            root = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除任意元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delNode</span><span class="params">(<span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> delNode(root, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">delNode</span><span class="params">(Node root, <span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e &gt; root.e) &#123;</span><br><span class="line">        root.right = delNode(root.right, e);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e &lt; root.e) &#123;</span><br><span class="line">        root.left = delNode(root.left, e);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size --;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line">    <span class="keyword">if</span> (root.right == <span class="literal">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">    <span class="keyword">return</span> delMax(root.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前序遍历（递归版本）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    System.out.println(root);</span><br><span class="line">    preOrder(root.left);</span><br><span class="line">    preOrder(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前序遍历（循环版本）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用栈来模拟递归</span></span><br><span class="line">    IStack&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayStack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        System.out.print(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>)</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>)</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序遍历（递归版本）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    inOrder(root.left);</span><br><span class="line">    System.out.println(root);</span><br><span class="line">    inOrder(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序遍历（循环版本）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用栈来模拟递归</span></span><br><span class="line">    IStack&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayStack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        System.out.print(node);</span><br><span class="line"></span><br><span class="line">        root = node.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后序遍历（递归版本）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    postOrder(root.left);</span><br><span class="line">    postOrder(root.right);</span><br><span class="line">    System.out.println(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用栈来模拟递归</span></span><br><span class="line">    IStack&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayStack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span> &amp;&amp; root.right != prev) &#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.print(root);</span><br><span class="line">            prev = root;</span><br><span class="line">            root = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="层序遍历二叉树"><a href="#层序遍历二叉树" class="headerlink" title="层序遍历二叉树"></a>层序遍历二叉树</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">levelOrder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    IQueue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">Queue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    queue.enque(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> queue.deque();</span><br><span class="line">        System.out.println(node);</span><br><span class="line"></span><br><span class="line">        queue.enque(node.left);</span><br><span class="line">        queue.enque(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于二叉搜索树是一种比较简单的数据结构，所以本文更多的是一些代码的记录，并不对其中的逻辑做深入的阐述。<br>如果你发现了什么错误或者是有什么疑问都欢迎在评论区指出。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/posts/11306/</url>
    <content><![CDATA[<p>本来像是这样的排序算法在网上搜个快速排序能找到很多的博客在详细的说明快速排序的实现、特点、性能、时间复杂度等等，但还是决定要自己写一篇博客来讲讲这个算法，实际上是想要分享一些在学习这个算法的过程中一些让我感到惊讶的地方。</p>
<p><font color=blue>也正是因为这样的一些比较独特的，比较不可思议却又是合乎情理的存在才让算法变得更神秘，更吸引人了。</font></p>
<span id="more"></span>

<hr>
<p>先简单的讲一下快速排序的核心思想：</p>
<blockquote>
<p>每次在数组中随机的找到一个元素，以这个元素为基准将整个数组分成大于基准元素的部分和小于基准元素的部分，之后再按照小于基准元素、基准元素、大于基准元素这样的顺序排好，之后再递归的对小于基准元素部分和大于基准元素部分分别进行相同的操作。有一些书中也会将这个基准元素称为标兵。</p>
</blockquote>
<p>根据这样的一个思想我们可以很快速的设计出第一版的快速排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> l;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[l]))</span><br><span class="line">            swap(arr, i, ++j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, l, j);</span><br><span class="line"></span><br><span class="line">    sort(arr, l, j - <span class="number">1</span>);</span><br><span class="line">    sort(arr, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处swap函数用于交换数组中两个下标处的值。</span></span><br></pre></td></tr></table></figure>

<p>有些书上的快速排序实现的过程可能跟上面代码并不一致，这里也想说一点关于自己的想法，对于算法的实现我们更应该关注的是这个算法的思想，以及我们所实现的算法的时间复杂度分析上，而不是去纠结具体实现的方式。</p>
<p>上面的代码看着好起来并不复杂，但是想要彻底的理解的话其实并不容易，关键是要能够理解 j 代表什么，也就是 j 的语义。</p>
<p><font color=blue>此处的 j 代表了小于标兵元素部分的最右边的元素。</font></p>
<blockquote>
<p>上面的代码对于初学者可能并不是特别友好，如果你有任何的疑问欢迎在评论区提问。</p>
</blockquote>
<hr>
<p><strong>有意思的地方现在开始了：</strong></p>
<p>如果你觉得上面的代码没问题的话，在这里强烈建议你设计一个数据规模是百万这个级别并且已经排好序的数组来跑一下上面的这个快速排序算法，你会发现这一点也不快速。</p>
<p>由于我们每次所选择的标兵元素都是数组中的第一个元素，所以如果是一个已经排好序的数组，这个快速排序算法会直接退化成一个<code>O(n^2)</code>级别的算法。</p>
<p>改进的方式是使用随机标兵，于是上面的代码迎来了第一次改进。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机标兵（针对有序数组的优化）</span></span><br><span class="line">    swap(arr, l, l + random.nextInt(r - l + <span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> l;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[l]))</span><br><span class="line">            swap(arr, i, ++j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, l, j);</span><br><span class="line"></span><br><span class="line">    sort(arr, l, j - <span class="number">1</span>);</span><br><span class="line">    sort(arr, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码的逻辑还是没有改变，还是选取数组中的第一个元素为标兵元素，但是在每次选取之前将数组中的第一个元素和数组中的随机任何一个元素交换一下位置，以达到随机标兵的效果。</p>
<hr>
<p>但就算是这样这个算法依旧不完美，设想一下：<strong>如果是一个所有元素都相同的数组呢？</strong><br>比如一个容量为一百万的数组里面存放的元素全部都是0。</p>
<p>如果是这样的情况，那么随机标兵也就没有作用了，快速排序也就再次退化成了一个<code>O(n^2)</code>级别的算法。</p>
<p>于是第二次改进：<strong>双路快速排序</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机标兵（针对完全有序数组所进行的优化）</span></span><br><span class="line">    swap(arr, l, l + random.nextInt(r - l + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l + <span class="number">1</span>, j = r;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[i] &lt; arr[l]) i++;</span><br><span class="line">        <span class="keyword">while</span> (arr[j] &gt; arr[l]) j--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        swap(arr, i++, j--);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, l, j);</span><br><span class="line"></span><br><span class="line">    sort(arr, l, j - <span class="number">1</span>);</span><br><span class="line">    sort(arr, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>双路快速排序算法已经是一个可以满足所有场景的快速排序算法了。</p>
<p>但是这还不够完美，还是刚刚的例子，如果数组中全部元素都相同的话，虽然可以满足O(nlogn)这个级别的速度实现排序，但是如果全部元素都相同的话快速排序还可以做到O(n)级别的时间复杂度。</p>
<p>于是最终版本：<strong>三路快速排序</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(T[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机标兵（针对完全有序数组所进行的优化）</span></span><br><span class="line">    SortingHelper.swap(arr, l, l + random.nextInt(r - l + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">lt</span> <span class="operator">=</span> l, i = l + <span class="number">1</span>, gt = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; gt) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arr[i].compareTo(arr[l]) &lt; <span class="number">0</span>) </span><br><span class="line">            SortingHelper.swap(arr, ++lt, i++);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[i].compareTo(arr[l]) &gt; <span class="number">0</span>) </span><br><span class="line">            SortingHelper.swap(arr, i, --gt);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i++;</span><br><span class="line">    &#125;</span><br><span class="line">    SortingHelper.swap(arr, l, lt);</span><br><span class="line"></span><br><span class="line">    sort(arr, l, lt - <span class="number">1</span>);</span><br><span class="line">    sort(arr, gt, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>排序算法</category>
      </categories>
  </entry>
  <entry>
    <title>Spring Boot 跨域处理</title>
    <url>/posts/63535/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.CorsConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.UrlBasedCorsConfigurationSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.filter.CorsFilter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CorsFilter <span class="title function_">corsFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 添加cors配置信息</span></span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置允许请求的域名</span></span><br><span class="line">        config.addAllowedOrigin(<span class="string">&quot;https://www.wrp.cool&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置是否发送cookie信息</span></span><br><span class="line">        config.setAllowCredentials(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置允许请求的方式</span></span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置允许的header</span></span><br><span class="line">        config.addAllowedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 为url添加映射路径</span></span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">corsSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">        corsSource.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, config);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 返回重新定义好的corsSource</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CorsFilter</span>(corsSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>代码段记录</category>
      </categories>
  </entry>
  <entry>
    <title>Spring基础：事务传播行为</title>
    <url>/posts/33401/</url>
    <content><![CDATA[<p>记录一下Spring中的事务传播行为，也就是 <code>@Transactional</code> 这个注解中的 <code>propagation</code> 属性的值分别是什么，有什么，各自又代表了什么。</p>
<p>事务传播行为就是：<font color=blue>当方法与方法之间有发生嵌套调用的情况下，父级方法和子级方法之间的事务如何处理。</font>通过我们定义不同的传播行为，可以使得父级方法和子级方法有不同的处理事务的方式。</p>
<span id="more"></span>

<p>Spring 中的7种事务传播行为：</p>
<table>
<thead>
<tr>
<th>事务传播类型</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>Propagation.REQUIRED</td>
<td>如果当前没有事务，就新建一个事务，如果已经存在一个事务中，则加入到这个事务中。</td>
<td>父级有子级就父级共享父级没有子级就自己创建。</td>
</tr>
<tr>
<td>Propagation.SUPPORTS</td>
<td>支持当前事务，如果当前没有事务，就以非事务的方式运行。</td>
<td>父级有子级就父级共享父级没有就一起没有。</td>
</tr>
<tr>
<td>Propagation.MANDATORY</td>
<td>使用当前的事务，如果当前没有事务，就抛出异常。</td>
<td>父级必须要有。</td>
</tr>
<tr>
<td>Propagation.REQUIRES_NEW</td>
<td>新建事务，如果当前存在事务，把当前事务挂起。</td>
<td>子级肯定有父级有父级自己的，子级不父级共享。</td>
</tr>
<tr>
<td>Propagation.NOT_SUPPORTED</td>
<td>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</td>
<td>子级肯定没有，就父级有子级也不要。</td>
</tr>
<tr>
<td>Propagation.NEVER</td>
<td>以非事务方式执行，如果当前存在事务，则抛出异常。</td>
<td>子级没有父级也不能有。</td>
</tr>
<tr>
<td>Propagation.NESTED</td>
<td>如果当前存在事务，则成为当前事务的子事务。如果当前没有事务，则执行与<code>Propagation.REQUIRED</code>类似的操作。</td>
<td>父级有子级就父级共享，当子级回滚时也不影父级和其他兄弟。但是如父级回滚了，那子级肯定跟父级一起回滚。</td>
</tr>
</tbody></table>
<blockquote>
<p>参考文章：<br><a href="https://segmentfault.com/a/1190000013341344">Spring事务传播行为详解</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring 基础</category>
      </categories>
  </entry>
  <entry>
    <title>maven 数据源配置</title>
    <url>/posts/243/</url>
    <content><![CDATA[<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- spring源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>central<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/libs-milestone/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 淘宝源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>代码段记录</category>
      </categories>
  </entry>
  <entry>
    <title>递归</title>
    <url>/posts/38362/</url>
    <content><![CDATA[<p>大家应该都听过这么一个故事：</p>
<blockquote>
<p>从前有座山，山上有座庙，庙里有个老和尚和一个小和尚，老和尚在给小和尚讲一个故事，故事是什么呢？故事就是：从前有座山，山上有座庙，庙里有个老和尚和一个小和尚，老和尚在给小和尚讲一个故事，故事是什么呢？故事就是：从前有座山，山上有座庙，庙里有个老和尚和一个小和尚，老和尚在给小和尚讲一个故事，故事是什么呢？故事就是：…..</p>
</blockquote>
<p>也都应该经历过这么一个场景：</p>
<blockquote>
<p>有一些理发店里面呢，会有两个镜子相对的情况，镜子A里面可以看到镜子B，镜子B里面又可以看到镜子A，镜子A跟镜子B之间互相反射的循环反反复复的无穷无尽。</p>
</blockquote>
<p>我认为这可以算是现实世界中的递归现象。当然了，现实世界中类似于这样的现象并不少见。我觉得发明了递归算法的人一定也是在这其中的某一个场景或者是某一个故事下获得的灵感。</p>
<p><font color=blue>毕竟，计算机科学就是一种对于现实世界的抽象。</font></p>
<span id="more"></span>

<hr>
<p>学习计算机的同学所接触到的第一个递归算法应该都是递归求阶乘或者是数组求和这样的算法。虽然求阶乘或者是求和这只是很简单的递归代码，但是递归算法该有的，它也一样都没有落下。其实这样的功能只需要一层简单的循环就可以搞定，递归算法在这里反而是降低了代码的可读性，并没有为我们带来实际上的好处。<br><font color=#aaa>这里并不是不鼓励同学们使用递归来编写逻辑代码，而是希望不要过度设计自己的代码，还是那句话，刚刚好的才是最美：）</font></p>
<p><font size=5 ><strong>递归</strong></font> <a href="https://baike.baidu.com/item/%E9%80%92%E5%BD%92">百度百科</a></p>
<blockquote>
<p>程序调用自身的编程技巧称为递归（ recursion）。递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。<strong>一般来说，递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。</strong></p>
</blockquote>
<p>结合一下递归求阶乘的代码理解一下上面百度百科的这段话，特别是最后一句话。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归求阶乘</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个简单的递归代码，但是麻雀虽小，却也五脏俱全。在这个例子中，<strong>边界条件、递归前进段和递归返回段</strong>都是很明确的。</p>
<ul>
<li><strong>边界条件：</strong>n &#x3D;&#x3D; 1</li>
<li><strong>递归前进段：</strong>每次调用 <code>factorial(n - 1)</code> 时递归算法就前进一个函数单位</li>
<li><strong>递归返回段：</strong>当<code>n-1</code>减到<code>n==1</code>的时候，也就是if条件成立返回1的时候，<code>factorial(n - 1)</code>开始返回，每次返回，递归就结束一次<code>factorial(n - 1)</code>函数的调用，也就是返回一个函数单位。</li>
</ul>
<blockquote>
<p>简单一些来理解的话：递归无非就是一个满足了<strong>直接或者是间接的调用自身、以及在某个时候会结束对自身调用</strong>这两个条件的函数，仅此而已。</p>
</blockquote>
<p> 如果要我一句话来描述递归算法的话，我会说：<font color=blue>比起循环，这是一种更能够提高代码可读性的循环。</font></p>
<p> 我认为递归所能完成的逻辑，换成循环来做这样的事情甚至效率上还要更高一些，因为循环并不需要额外的方法调用的成本。但是在某些复杂的场景下，使用递归会让我们的代码变得非常简洁易于理解，比如：二叉树的前、中、后序的遍历；求一个二叉树的节点个数等等。</p>
<p> 但是递归也有一个非常明显的缺点，那就是几乎所有的编程语言的函数调用栈都有一个明确的大小，这就导致了递归函数的调用层数不能超出这个大小，否则会产生一个栈内存的溢出，在Java中这是一个叫做<code>StackOverflowError</code>的异常。</p>
<hr>
<p><font size=5 ><strong>递归函数的宏观语义</strong></font></p>
<p>递归的本质实际上就是将一个问题不断的拆解成一个一个的小的问题，直到最后的一个问题小到不能再小了，这个时候我们可以很容易的解决这个问题，将这个问题的解决结果返回给上一个问题，解决掉上一个问题之后再解决上上个问题以此类推，最终解决我们的问题。<strong>拆解问题的过程也就是递归前进段，解决掉最基本问题开始返回的阶段也就是递归返回段。</strong></p>
<p>更多的时候我喜欢把递归函数理解成一个单元，也就是递归单元。因为递归函数调用自身后还是走一遍自身的逻辑，每次递归调用在逻辑上并没有产生任何的变化，相应的我们只是改变了每次调用的参数而已。<strong>将递归函数拆解成的一个一个的小问题的这个步骤，就体现在每次调用递归函数的参数列表都要比上一次的参数列表要更简单一点点。</strong></p>
<p>很多时候编写递归逻辑的时候都是因为递归调用自身的这个动作会令我们感到很迷惑，没有办法理解到这一步操作是怎么执行的。我第一次接触二叉树前序遍历的代码的时候就是倒在了这一步。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树前序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prevOrder</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    System.out.print(node);</span><br><span class="line">    prevOrder(node.left);</span><br><span class="line">    prevOrder(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我刚刚开始看这代码的时候我完全无法理解为什么上面这段代码为什么会以中、左、右的方式输出一个二叉树，甚至我完全不能够明白这段代码的逻辑。原因是我自己的思维跟着递归函数一起被递归进去了，一直试图去理解每次递归进去之后发生了什么事情，而递归函数的逻辑一直没变。就像是开头的哪个老和尚讲故事一样，我完全没办法跳出递归逻辑。</p>
<p><font color=blue>但是，如果能从宏观的角度来看这段代码，就舒服多了。</font></p>
<ul>
<li><strong>首先，明白我们写的递归函数是要完成一个什么样的功能。</strong></li>
<li><strong>然后，不要去研究递归进去的逻辑是什么样的，仅仅只看第一层逻辑。</strong></li>
<li>因为递归进去的逻辑跟第一层的逻辑是完全一样的。</li>
</ul>
<p>如果要把 <code>prevOrder</code> 这个递归函数所做的事情理解成一个递归单元的话，我们只需要整理出这个函数所要实现的功能就可以理解这个递归函数的逻辑。</p>
<p><font size=4><strong>Q&amp;A Time</strong></font></p>
<ul>
<li><strong>Q：prevOrder这个函数的功能是什么？</strong></li>
<li>A：按照中、左、右的顺序输出一棵二叉树。</li>
<li><strong>Q：第7行的逻辑是什么？</strong></li>
<li>A：输出当前节点。</li>
<li><strong>Q：第8行的逻辑是什么？</strong></li>
<li>A：按照中、左、右的顺序输出当前节点的左子树。</li>
<li><strong>Q：第9行的逻辑是什么？</strong></li>
<li>A：按照中、左、右的顺序输出当前节点的右子树。</li>
</ul>
<blockquote>
<p>看到这里如果还不能够明白这个递归逻辑的话，我建议在纸上画一棵高度为3，7个节点的满二叉树然后按照上面 Q&amp;A 再结合代码依次访问一下这棵二叉树上的各个节点，你也许能更加直观的感受什么是递归的宏观语义。</p>
</blockquote>
<p>我所理解的递归函数的宏观语义是：</font></p>
<ul>
<li><p>将一个大的问题一点一点的拆分成许多个小的问题，或者说是抽象成多个小问题，<strong>每一个问题就是一个递归单元，每一个递归单元在逻辑上都是相同的，唯一不同的只是参数列表。</strong></p>
</li>
<li><p>在这个例子中，前序遍历当前节点、前序遍历当前节点的左子树、前序遍历当前节点的右子树，这是<strong>完完全全相同的逻辑。</strong></p>
</li>
<li><p>当我们能够按照这种思维来解读递归代码的话，我们可以完全不关心递归调用里面的逻辑是怎样的，递归调用也就可以理解成为一种普通的函数调用。</p>
</li>
</ul>
<hr>
<p><font size=5 ><strong>如何编写一个递归程序？</strong></font></p>
<p>借助力扣第206号问题（<a href="https://leetcode-cn.com/problems/reverse-linked-list/">反转链表</a>）来讲述如何梳理出递归函数的宏观语义以及怎么编写递归函数。</p>
<blockquote>
<p>给你<strong>单链表</strong>的头节点 <code>head</code> 请你反转链表，并返回反转后的链表<br><strong>示例一：</strong><br>输入：head &#x3D; (1) -&gt; (2) -&gt; (3) -&gt; (4) -&gt; (5) -&gt; NULL<br>输出：head &#x3D; (5) -&gt; (4) -&gt; (3) -&gt; (2) -&gt; (1) -&gt; NULL<br><strong>示例二：</strong><br>输入：head &#x3D; (1) -&gt; (2) -&gt; NULL<br>输出：head &#x3D; (2) -&gt; (1) -&gt; NULL<br><strong>示例三：</strong><br>输入：head &#x3D; (1) -&gt; NULL<br>输出：head &#x3D; (1) -&gt; NULL<br><strong>示例四：</strong><br>输入：head &#x3D; NULL<br>输出：head &#x3D; NULL</p>
</blockquote>
<p>如果一个问题已经明确了要使用递归来求解的话，我们第一步要做的就是找出这个拆解后最基本的那个问题，对于反转链表的这个问题来说，显而易见最基本的问题就是当链表为空或者是链表只有一个节点的情况。一个空链表反转过后还是一个空链表，一个只有一个节点的链表反转过后还是只有一个节点。找出最基本的问题只是递归函数中最基础的部分，如果连最基本的问题都找不出来的话，那么几乎可以断定这个问题无法使用递归求解。</p>
<p>完成了最基本的部分接下来才是一个如何编写一个递归函数的重头戏，<font color=blue>将递归函数单元化，也就是找出这个递归函数的宏观语义，清楚这个递归函数要表达什么。</font>将递归函数看作是一个单元之后其实就不需要再考虑我们要求解的这个问题具体是什么了，解决问题的重点就放在了怎么解决一个一个拆解出来的小问题了。</p>
<ul>
<li>这里我再啰嗦一下解释一下示例一这个例子：</li>
<li>反转前：<code>head</code> 的值为1，指向了值为2的节点，值为2的节点指向了值为3的节点…最终指向NULL</li>
<li>反转后：<code>head</code> 的值为5，指向了值为4的节点，值为4的节点指向了值为3的节点…最终指向NULL</li>
</ul>
<p>假如我们现在处于返回段的 <code>(3)</code> 这个节点，结合递归函数的宏观语义来看一下此时链表的状态。前面的 <code>(1)</code> 和 <code>(2)</code> 节点是没有变化的，因为我们现在处于 <code>(3)</code> 这个节点，还没有反转到 <code>(1)</code> 和 <code>(2)</code> 。<font color=blue>但是对于已经反转过的 <code>(4)</code> 和 <code>(5)</code> 来说，应该是 <code>NULL &lt;- (4) &lt;- (5)</code> 这个样子的。</font>而此时的 <code>(3)</code> 这个节点仍然是指向了 <code>(4)</code> 这个节点的。</p>
<p>好了，分析到此为止，答案已经是显而易见的了。当我们处于 <code>(3)</code> 这个节点的时候，我们只需要将 <code>(3)</code> 这个节点当作是已经反转完成的链表的下一个待反转节点再将 <code>(3)</code> 这个节点反转过来就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)  <span class="comment">// 最基本的问题</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">rev</span> <span class="operator">=</span> reverseList(head.next);  <span class="comment">// 得到已经反转完成的链表</span></span><br><span class="line">        head.next.next = head;                  <span class="comment">// 将当前节点挂接在已经反转完成的链表的下一个节点，注意：head.next此时指向的是已经反转完成的链表的尾节点。</span></span><br><span class="line">        head.next = <span class="literal">null</span>;                       <span class="comment">// 执行到这一步的时候，head已经挂载到反转完成链表的尾节点的位置了，但是链表尾节点必须指向null，所以令 head.next = null</span></span><br><span class="line">        <span class="keyword">return</span> rev;                             <span class="comment">// 返回已经反转完成的链表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的这段代码也就是力扣上第206号问题的答案，有兴趣的同学可以将代码复制到力扣上第206号问题的解答区中去验证结果。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>Java：Lambda 表达式</title>
    <url>/posts/47234/</url>
    <content><![CDATA[<p>jdk1.8 之后才出现了 Lambda 表达式这个东西，这说明了 Lambda 表达式实际上并不是编程中必须掌握的一项技能，但是既然 jdk1.8 之后支持了lambda表达式，那么说明 Lambda 表达式肯定是会有其独特的用处。其实 Lambda 表达式最重要的就是让我们写的代码更加的优雅，看起来更加的舒服。同时，使用 Lambda 表达式也能在一定程度上少写一些代码，提高一些编程的效率。不过我还是认为 Lambda 表达式最重要的是让代码变得更加优雅。</p>
<p>关于 Lambda 表达式的一些基本的使用在网上实际上已经有了很多的博客或者教程，本文就不再赘述这些别人已经写过的东西了，主要还是想聊一下自己在学习 Lambda 表达式过程中的一些理解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="number">2021</span>);</span><br><span class="line">    list.add(<span class="number">0</span>);</span><br><span class="line">    list.add(<span class="number">5</span>);</span><br><span class="line">    list.add(<span class="number">23</span>);</span><br><span class="line">    list.forEach(item -&gt; System.out.print(item));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：20210523</span></span><br></pre></td></tr></table></figure>
<p><code>item -&gt; System.out.print(item)</code> 这就是一个最基本的 Lambda 表达式，这实际上是一个抽象方法的实现，只不过是写成这个样子，看起来更加优雅了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">for</span> (T t : <span class="built_in">this</span>) &#123;</span><br><span class="line">        action.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的是 forEach() 方法的接口定义，具体的实现内容先不看，先看看 forEach 的参数列表中的 <code>Consumer&lt;? super T&gt; action</code> 这个东西，它叫函数式接口。</p>
<blockquote>
<p>在《Java核心技术 卷一》这本书中对函数式接口的定义是这样的：<br>对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个 lambda 表达式。<br>这种接口称为<strong>函数式接口</strong>（functional interface）</p>
<p>粗浅的理解可以是：一个接口中如果只定义了一个抽象方法的话，那么这个接口就是一个函数式接口。</p>
</blockquote>
<p>看看这个 Consumer 所谓的函数式接口中唯一定义的一个抽象方法长什么样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span>;</span><br></pre></td></tr></table></figure>

<p>上面说的 <code>item -&gt; System.out.print(item)</code> 这个东西是对一个抽象方法的实现，实际上就是对 <code>accept</code> 这个抽象方法的实现，我以我的理解来尝试复原这个实现，将它变成我们平时见到的普通的方法实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T item)</span> &#123;</span><br><span class="line">    System.out.print(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来就清晰多了，forEach() 方法将这个 Lambda 表达式（<code>item -&gt; System.out.print(item)</code>）解析成了它所需要的参数（<code>Consumer&lt;? super T&gt; action</code>），也就是 Consumer 接口的实现，之后再调用这个方法来遍历List集合。</p>
<p><em>当然具体的遍历方式我们也看到了，底层还是使用的forEach循环来遍历这个集合，所以在这里顺带提一下，除非遍历集合的内容只要一行代码就可以完成，像是我上面这样子，否则使用lambda表达式来遍历集合的话就不是很必要了。因为这并不会让我们的代码变得优雅或者是提高效率，反而平白的增加的可读成本，得不偿失。</em></p>
<blockquote>
<p>思考一个问题：<br><font color = blue>如果有一个方法的代码刚刚好可以实现accept这个抽象接口，能不能直接把这个方法的代码作为accept的实现传递给forEach方法呢？</font></p>
</blockquote>
<p>还是上面的这个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="number">2021</span>);</span><br><span class="line">    list.add(<span class="number">0</span>);</span><br><span class="line">    list.add(<span class="number">5</span>);</span><br><span class="line">    list.add(<span class="number">23</span>);</span><br><span class="line">    list.forEach(System.out::print);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：20210523</span></span><br></pre></td></tr></table></figure>

<p><code>System.out::print</code> 也是一种lambda表达式，在这段代码中，这两种实现方式的效果是完全一样的。</p>
<blockquote>
<p><code>::</code>表示的是方法的引用，实际上就是将<code>System.out</code>对象中的<code>print</code>方法直接作为抽象方法<code>accept</code>的实现传到forEach中去。</p>
</blockquote>
<p>结合这两个例子来看，Lambda 表达式中我们实际上只是传递的一个代码段，而不是接口的实现，实际会自动的根据上下文帮助我们封装成接口的实现以供方法调用，仅此而已。这就是 Lambda 表达式的真面目。</p>
<hr>
<p>除了传递方法的引用进去，lambda表达式还可以直接传递一个构造器。像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 声明两个函数式接口 (此处借鉴 java.util.function.Supplier 函数接口)*/</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Supplier1</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Supplier2</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">get</span><span class="params">(String str)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Main</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;执行无参构造器&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Main</span><span class="params">(String str)</span> &#123; System.out.println(<span class="string">&quot;执行有参构造器&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Supplier1&lt;Main&gt; s1 = Main::<span class="keyword">new</span>;</span><br><span class="line">        Supplier2&lt;Main&gt; s2 = Main::<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">        s1.get();</span><br><span class="line">        s2.get(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 执行无参构造器</span></span><br><span class="line"><span class="comment">// 执行有参构造器</span></span><br></pre></td></tr></table></figure>

<p>上面的代码就是调用了 Main 类中对应的构造器来构建一个 Main 的实例并返回，写法也非常的简单，直接双冒号调用new关键字即可。具体的调用哪一个构造器会根据上下文自动选择跟函数式接口参数对应的上的构造器。</p>
<p>上面的使用 Lambda 表达式创建的 Supplier1 对象和 Supplier2 对象的方式等价于下面这种方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Supplier1&lt;Main&gt; s1 = <span class="keyword">new</span> <span class="title class_">Supplier1</span>&lt;Main&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Main <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Supplier2&lt;Main&gt; s2 = <span class="keyword">new</span> <span class="title class_">Supplier2</span>&lt;Main&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Main <span class="title function_">get</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Main</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>Lambda 表达式中的 this 指向：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Runnable <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; System.out.println(<span class="built_in">this</span>); &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Test&quot;</span>; &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Runnable <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> () -&gt; &#123; System.out.println(<span class="built_in">this</span>); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Main</span> <span class="variable">main</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(main.test1()).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(main.test2()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Main&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Test</span></span><br><span class="line"><span class="comment">// Main</span></span><br></pre></td></tr></table></figure>

<p>借书里的一句话来说明一下 this 的指向：在 Lambda 表达式中，this 的使用并没有任何特殊之处。Lambda 表达式的作用域嵌套在 test2 方法中，与出现在这个方法中的其他位置一样，Lambda  表达式中 this 的语义并没有发生变化。</p>
<p>对于这个实际上很好理解，<font color=blue> Lambda 表达式中的 this 出现在任何地方都跟哪个地方本来的 this 是一样的，并没有因为 Lambda 表达式而发生不同。</font>这实际上也从另外的角度说明了 Lambda 表达式仅仅只是传递了一段代码过去，而没有做其他处理。</p>
<hr>
<p>关于 Lambda 表达式有一个很经典的应用，跟着 Java8 一起来的还有 Stream 流操作，这是一种对于数组、集合等更方便更优雅的操作，Lambda 表达式跟 Stream 流操作配合起来能写出非常棒的代码。关于 Stream 流操作掘金上有一篇文章写的很好，<a href="https://juejin.cn/post/7118991438448164878">吃透JAVA的Stream流操作，多年实践总结</a>。推荐大家都可以读一读。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>高级特性</category>
      </categories>
  </entry>
  <entry>
    <title>选择排序 &amp; 插入排序</title>
    <url>/posts/21500/</url>
    <content><![CDATA[<p>具体的选择排序和插入排序的代码我已经放<a href="https://github.com/wangruipeng-wrp/algorithm-and-data-structure/tree/master/src/Sort">github</a>上了，本文不会针对具体的代码实现展开讨论。更多的是想聊一些在学习这两个算法过程中的自身一些心态的变化。</p>
<span id="more"></span>

<p>作为铺垫，还是简单讲一下插入排序和选择排序</p>
<blockquote>
<p><strong>选择排序：</strong><br>每次都找出一个最小的元素按照顺序排好</p>
</blockquote>
<blockquote>
<p><strong>插入排序：</strong><br>首先假装第一个元素是有序的，然后每次从无序的数组中拿出一个元素插入到有序的数组里面去</p>
</blockquote>
<p>我在学习这两个算法的时候是先学的选择排序，再学的插入排序。在还没有深入理解的情况下，<font color=Blue>我其实想当然的认为选择排序算法的性能就一定是要优于插入排序算法的。</font></p>
<p>我这么想的原因其实也非常简单，选择排序每次循环在做的事情仅仅只是比较两个元素的大小，直到最后找出最小的哪个元素，最后再交换两个元素就可以完成一轮排序，是通过一种比较的方式来实现排序这样的功能。</p>
<p>反过来看插入排序呢，在一开始需要保存待插入的元素，然后再往前一个个的比较，如果比较的元素比待插入的元素要大，那么就覆盖掉他后面的哪个元素。</p>
<p>这么粗浅的看，同样的乱序数组，插入排序和选择排序所使用的比较的次数在极端的情况下（也就是倒序数组的情况下）是相等的。</p>
<p>而选择排序呢，每次比较完成之后仅仅需要一次交换位置的操作即可完成本轮的排序，但是反观插入排序呢，每一次都需要有一个覆盖掉后面元素的动作，直到找到正确的位置插入了才可以完成本轮的排序。</p>
<p>这么一个想法出现在我脑海里之后，我几乎是断定的选择排序在性能上是要优于插入排序的。</p>
<p><font color=Blue>但是，如果现在是一个完全有序的数组来进行排序的呢，或者说是一个近乎有序的数组在排序呢？</font></p>
<p>这个时候选择排序还是必须每次都比较剩下的元素找到最小的哪一个，唯一的不同是交换元素位置的操作变少了。</p>
<p>再看看插入排序呢，每次都只需要比较一下前面的一个元素就好了，交换位置的操作同样变少了。但是有序的情况下，插入排序有着一个非常巨大的优势就是比较的操作也变的很少。</p>
<p><font color=red>于是，当对一个完全有序或者是近乎有序的数组排序时，插入排序的性能是要优于选择排序的。</font></p>
<p>上面是对于选择排序和插入排序在前几天学习的过程中自己对于两者性能之间的一些看法。</p>
<hr>
<p>实际上不仅仅是在这个例子中，在平时中我很多时候也总是会太果断的认为一个事情，直到举一个反例出来之后被啪啪打脸。</p>
<p>对于这样子的情况说的好听一些我认为是对于自己逻辑思维能力的一种莫名的自信，说的直白一些的话实际上是自己的一种无知造成了这样莫名的自信。</p>
<p>我认为这并不是一个好的习惯，今天在这里留下这样的一篇博客，作为一个见证：<br><font color=Blue>希望自己在今后能保持谦虚，保持好学，一点一点的变成一个厉害的人：）</font></p>
<hr>
<p>大家加油：）</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>排序算法</category>
      </categories>
  </entry>
  <entry>
    <title>原型模式</title>
    <url>/posts/54363/</url>
    <content><![CDATA[<p>原型模式简单来说就是以一个已经创建好的对象为原型，使用二进制流的方式复制这个对象。</p>
<span id="more"></span>

<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p><strong>借《设计模式之禅》这本书中一个例子来简述一下原型模式：</strong></p>
<p>先来想想一个业务场景，现在有一家银行想要对它的储户发送一封广告邮件，银行的储户比较多，大概几百万上千万个储户。每个储户发送一封邮件，其中邮件的内容都是一样的，不一样的是邮件的收件人邮箱，收件人称谓等一些属性不同，其他的属性都大同小异。其中将相同的部分抽取成一个邮件模板类。</p>
<p><strong>模板类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Template</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="string">&quot;xxx银行国庆大酬宾！！！&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;把你的钱全部存到我们银行，我们帮你花掉它&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>邮件类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mail</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String subject;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String addresseeAddress;</span><br><span class="line">    <span class="keyword">private</span> String addresseeName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Mail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subject = Template.subject;</span><br><span class="line">        <span class="built_in">this</span>.content = Template.content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>客户端：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Mail</span> <span class="variable">mail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mail</span>();</span><br><span class="line">        <span class="comment">// 发送一百万封邮件</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">1_000_000</span>; i++) &#123;</span><br><span class="line">            mail.setAddresseeAddress(randomAddresseeAddress());</span><br><span class="line">            mail.setAddresseeName(randomAddresseeName());</span><br><span class="line">            sendMail(mail);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码实际上已经能够基本的实现我们想要的功能了，当然这得要有个非常非常重要的前提，那就是这个项目的甲方是一个比较将就的甲方。</p>
<p>看看上面的代码有什么问题，实际上没什么问题，就是慢了点，如果遇到这种百万级别千万级别的发送邮件的场景，使用单线程慢慢发的话可能得发一天甚至还不止。像这样的业务场景是必须使用多线程来发送邮件的，但是如果跟上面一样多个线程公用同一个mail对象的话那线程就不安全了。当然你可以选择创建多个mail对象来提供给每个线程，但是这真的大可不必，<strong>原型模式</strong>就是专门为了解决这样的业务场景而生的。</p>
<p><strong>使用原型模式来改造一下上面邮件类的代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mail</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String subject;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String addresseeAddress;</span><br><span class="line">    <span class="keyword">private</span> String addresseeName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Mail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subject = Template.subject;</span><br><span class="line">        <span class="built_in">this</span>.content = Template.content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>对应的客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">    <span class="type">Mail</span> <span class="variable">mail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mail</span>();</span><br><span class="line">    <span class="comment">// 发送一百万封邮件</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">1_000_000</span>; i++) &#123;</span><br><span class="line">        <span class="type">Mail</span> <span class="variable">cloneMail</span> <span class="operator">=</span> (Mail) mail.clone();</span><br><span class="line">        cloneMail.setAddresseeAddress(randomAddresseeAddress());</span><br><span class="line">        cloneMail.setAddresseeName(randomAddresseeName());</span><br><span class="line">        sendMail(mail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与原来的不同之处就是Mail类实现了覆盖了Object方法中的clone方法，客户端不再使用同一个对象发送邮件，而是通过clone方法获取一个新的对象。之所以不让客户端自己创建一个新对象是因为我们现在演示使用的Mail对象非常简单，如果是在真实的业务场景中，创建一个Mail邮件对象一定是一个相当复杂的过程，创建一个这样的对象对于计算机资源的开销也是非常大的。而现在我们需要创建的是百万甚至是千万级别的这样的对象，这对于资源的开销是相当巨大的。</p>
<p><strong>小结原型模式的适用场景：</strong></p>
<ul>
<li>类初始化需要消耗较多的资源，例如：计算资源、硬件资源等</li>
<li>创建对象的过程非常繁琐，需要准备较多的访问权限，或者是大量的数据</li>
<li>一个对象会提供给其他对象访问，而且各个调用者可能都会修改其中的值</li>
</ul>
<blockquote>
<p>在实际的项目开发中原型模式很少单独出现，一般是和工厂模式一起出现，通过原型模式创建一个对象再由工厂模式将这个对象提供给调用者。</p>
</blockquote>
<h1 id="浅克隆和深克隆"><a href="#浅克隆和深克隆" class="headerlink" title="浅克隆和深克隆"></a>浅克隆和深克隆</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Prototype</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; arrayList;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Prototype</span><span class="params">(ArrayList&lt;String&gt; arrayList)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.arrayList = arrayList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">    ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    arrayList.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    arrayList.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Prototype</span> <span class="variable">prototypeTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Prototype</span>(arrayList);</span><br><span class="line">    <span class="type">Prototype</span> <span class="variable">cloneTest</span> <span class="operator">=</span> (Prototype) prototypeTest.clone();</span><br><span class="line"></span><br><span class="line">    cloneTest.getArrayList().add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(prototypeTest.getArrayList());</span><br><span class="line">    System.out.println(cloneTest.getArrayList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行main方法后输出：</span><br><span class="line">[A, B, C]</span><br><span class="line">[A, B, C]</span><br></pre></td></tr></table></figure>

<p>通过上面的这个例子已经可以可以了解到clone方法仅仅只是克隆了对象的引用而已，而不是克隆了整个对象。通过clone方法得到的对象跟原来的对象中的引用数据类型都是指向同一片内存空间。</p>
<blockquote>
<p>clone方法相当于仅仅只是将这个对象栈内存中的数据复制一份存到一个新的引用类型的变量中而已。具体的栈内存和堆内存的关系在<a href="https://www.wrp.cool/posts/24923/">【JavaScript】数据类型</a>一文中有详细介绍。</p>
</blockquote>
<p>由于对克隆只是克隆了引用对象的地址而已，并没有深入去克隆这个对象中的引用，所以这种克隆方式称之为浅克隆。如果要实现对引用的克隆则需要修改clone方法，使其不仅克隆引用对象的地址，还能够克隆一个新的引用对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">    <span class="type">Prototype</span> <span class="variable">prototype</span> <span class="operator">=</span> (Prototype) <span class="built_in">super</span>.clone();</span><br><span class="line">    <span class="comment">// 克隆引用对象</span></span><br><span class="line">    prototype.arrayList = (ArrayList&lt;String&gt;) <span class="built_in">this</span>.arrayList.clone();</span><br><span class="line">    <span class="keyword">return</span> prototype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对每个需要深拷贝的对象再进行一次单独的克隆即可完成深克隆，此时原型对象和克隆对象之间分别享有两个不同的ArrayList对象，完成了对ArrayList对象的深克隆。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/posts/29125/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>单例模式从名称上就很好理解：一个对象保证在内存中只有一个实例。<br>当然，如果是多线程的话也要保证多个线程在运行的过程当中这个实例只会被创建一次。</p>
<p>单例模式的实现也有两种，懒汉式和饿汉式。从名字上就很好区分，懒汉式就是延迟创建单例对象的一种方式，饿汉式就是即刻创建单例对象的方式。两种实现方式本文都说到。</p>
<span id="more"></span>

<h1 id="单线程中的单例模式"><a href="#单线程中的单例模式" class="headerlink" title="单线程中的单例模式"></a>单线程中的单例模式</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazeSingleInstance</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">LazeSingleInstance</span> <span class="variable">lazeSingleInstance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazeSingleInstance</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazeSingleInstance <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lazeSingleInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            lazeSingleInstance = <span class="keyword">new</span> <span class="title class_">LazeSingleInstance</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazeSingleInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单线程中的单例模式就只是这样子而已，非常简单。设计一个私有的构造函数是为了不让在外部创建这个类的实例，当然对外也需要提供一个可以获取类实例的方法，这也是单例模式中核心的方法，接下来也将围绕这个方法展开讨论。</p>
<p>这也是单例模式中最简单的实现，真正的难点在于多线程中如何保证多个线程运行过程中只创建一个实例。</p>
<h1 id="多线程中的单例模式"><a href="#多线程中的单例模式" class="headerlink" title="多线程中的单例模式"></a>多线程中的单例模式</h1><p>首先复现一个单例模式中可能出现的线程不安全问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LazeSingleInstance <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lazeSingleInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">        lazeSingleInstance = <span class="keyword">new</span> <span class="title class_">LazeSingleInstance</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lazeSingleInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>先介绍一下Java中new一个对象的过程都发生了什么事情：</strong><br>第一步：为这个对象分配内存。<br>第二步：初始化这个对象，也就是初始化对象里面的一些值。<br>第三步：将对象的地址赋值给创建这个对象的变量。</p>
</blockquote>
<p>在上面的这段代码当中，我们假设线程A执行到了第3行的第一步或者是第二步，而这时候刚刚好线程B执行到了第2行，由于线程A还没有为这个对象赋值，所以此时这个对象仍然是null的，那么线程B一样会执行到第三行代码。在这个过程当中，lazeSingleCase对象被创建了两次，违背了单例模式的设计原则。也就是发生了线程不安全的问题。</p>
<p>感兴趣的同学可以去实际的使用两个线程debug一下这段代码。</p>
<h2 id="第一次演进：使用-synchronized-关键字解决线程安全的问题。"><a href="#第一次演进：使用-synchronized-关键字解决线程安全的问题。" class="headerlink" title="第一次演进：使用 synchronized 关键字解决线程安全的问题。"></a>第一次演进：使用 synchronized 关键字解决线程安全的问题。</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazeSingleInstance <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lazeSingleInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">        lazeSingleInstance = <span class="keyword">new</span> <span class="title class_">LazeSingleInstance</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lazeSingleInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 getInstance() 方法上加了 synchronized 关键字之后保证了同一时间内只有一个线程能够执行方法内的代码，这样就解决了上述的线程不安全的问题。</p>
<p>但是 synchronized 关键字是加在 static 修饰的方法上的，这意味着锁住了这个类的class文件，这锁的范围太广了，消耗的资源太多。这显然不是一个好的办法。</p>
<h2 id="第二次演进：将-synchronized-关键字移动至方法内部"><a href="#第二次演进：将-synchronized-关键字移动至方法内部" class="headerlink" title="第二次演进：将 synchronized 关键字移动至方法内部"></a>第二次演进：将 synchronized 关键字移动至方法内部</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LazeSingleInstance <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (LazeSingleInstance.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lazeSingleInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">            lazeSingleInstance = <span class="keyword">new</span> <span class="title class_">LazeSingleInstance</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lazeSingleInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以类锁的形式将创建单例对象的代码锁起来，这也保证了同一段时间内只有一个线程能够执行到创建对象的代码，也同样能够实现单例模式。<br>比起上面将 synchronized 直接加在方法上还得跟其他的加了 LazeSingleInstance.class 类锁的代码去竞争锁的情况在性能上已经是提升了很多了。</p>
<p><strong>思考一个问题：</strong><br>每个调用 getInstance() 方法的线程都得先等待拿到了锁才能够执行，懒汉式单例模式在仅仅只是在第一次调用这个对象时候才需要去创建这个对象，而现在每次都需要去判断对象是否存在，这显然是不合理的。</p>
<h2 id="第三次演进：双重检查锁"><a href="#第三次演进：双重检查锁" class="headerlink" title="第三次演进：双重检查锁"></a>第三次演进：双重检查锁</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LazeSingleInstance <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lazeSingleInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LazeSingleInstance.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lazeSingleInstance == <span class="literal">null</span>) &#123;</span><br><span class="line">                lazeSingleInstance = <span class="keyword">new</span> <span class="title class_">LazeSingleInstance</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lazeSingleInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有兴趣的同学建议先自己分析一下上面的这段代码，这个也是一个比较取巧的一个设计了。</p>
<p>在外面加多一层 if 的判断，这样就不用每次调用 getInstance() 方法就得去等待 synchronized 锁了。<br>至此，双重检查锁也就设计完毕了。</p>
<blockquote>
<p><strong>介绍一个指令重排序的问题</strong><br>jvm 为了能够让 Java 的执行效率能够提高一些，在上面的 new 一个对象的过程，其中的第二步和第三步是有可能会颠倒过来的。也就是先为对象赋上地址值，再初始化这个对象。</p>
<p>看到这里的同学建议思考一个问题：双重检查锁中如果在创建对象的时候发生了指令重排序的问题，可能会导致什么情况。</p>
</blockquote>
<p><strong>答案揭晓：</strong><br>如果是在创建对象的时候先为对象赋上地址值，这个时候对象就已经不是 null 了，那么如果在还没有初始化的情况下，另外一个线程走到了第一个 if 的判断就会直接返回一个还没有初始化的对象。</p>
<h2 id="第四次演进：使用-volatile-关键字"><a href="#第四次演进：使用-volatile-关键字" class="headerlink" title="第四次演进：使用 volatile 关键字"></a>第四次演进：使用 volatile 关键字</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazeSingleInstance lazeSingleInstance;</span><br></pre></td></tr></table></figure>
<p>将这个单例对象使用 volatile 关键字去修饰即可解决指令重排序的问题。具体的 volatile 关键字的作用不久会聊到。<br>在这里先了解到 volatile 关键字可以限制在创建这个对象的时候禁止指令重排序即可。</p>
<h2 id="另外一种解决指令重排序的办法：使用静态内部类实现单例模式"><a href="#另外一种解决指令重排序的办法：使用静态内部类实现单例模式" class="headerlink" title="另外一种解决指令重排序的办法：使用静态内部类实现单例模式"></a>另外一种解决指令重排序的办法：使用静态内部类实现单例模式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazeSingleInstance</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazeSingleInstance</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">LazeSingleInstance</span> <span class="variable">lazeSingleInstance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LazeSingleInstance</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazeSingleInstance <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.lazeSingleInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这其实也是另外的一种实现单例模式的方式。<br>由于Java中每个类对应唯一的Class文件，所以类的静态属性实际上只会随着类的加载而加载，之后就再也不会去创建这个对象了，也就实现了单例模式。<br>Java中类的加载肯定是只有唯一一次的，所以不管在创建这个类的时候有没有发生指令重排序，这个过程对外都是不可见的。也就解决了指令重排序的问题。</p>
<p>上面所说的单例模式都是懒汉式单例模式，可以看到单例对象都是在第一次调用的时候才会去创建的，是一个延迟加载的机制。<br>下面就来讲一下饿汉式单例模式。</p>
<h1 id="饿汉式单例模式"><a href="#饿汉式单例模式" class="headerlink" title="饿汉式单例模式"></a>饿汉式单例模式</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleInstance</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">SingleInstance</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleInstance</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleInstance</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingleInstance <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>饿汉式单例模式实现起来也是比较简单，仅需要在类的初始化的时候直接创建单例对象即可。当然私有的构造函数和提供一个对外访问单例对象的接口还是必须要有的。</p>
<hr>
<p><strong>懒汉式和饿汉式的区别和各自的优缺点：</strong></p>
<ol>
<li>饿汉式中不存在线程安全问题，因为饿汉式随着类的加载而创建单例对象。</li>
<li>懒汉式相比与饿汉式更加能够把资源更好的利用起来，如果一个单例对象在一开始就创建出来但是长期不去使用的话，一直驻留在内存中肯定是要比使用到再去创建要耗费掉一些内存空间的。</li>
<li>当然相比之下我感觉使用静态内部类来实现的单例模式是一种比较好的方式。</li>
</ol>
<hr>
<h1 id="通过反射破坏单例模式"><a href="#通过反射破坏单例模式" class="headerlink" title="通过反射破坏单例模式"></a>通过反射破坏单例模式</h1><p>关于一些反射的知识在<a href="https://blog.wrp.cool/posts/25346/">【Java基础】反射</a>这篇文章中已经说的很详细了，这方面不了解的同学可以再补补习。</p>
<blockquote>
<p>具体的反射如何破坏单例模式的代码这里不再去实现，只做一些原理讲解。不管是懒汉式单例模式还是饿汉式单例模式，都必须得要有一个私有的构造方法，这是为了防止从外部直接new出来单例对象。但这怎么说呢，防君子不防小人吧，如果是通过反射的话很容易能够创建一个新的单例对象出来。而懒汉式单例模式对于反射攻击则是完全没有办法防御的，饿汉式单例模式还能够通过在构造方法做一个判断去防止放射攻击。</p>
</blockquote>
<p><strong>演示一下饿汉式单例模式防止反射攻击：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleInstance</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SingleInstance</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleInstance</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;禁止使用反射创建对象！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingleInstance <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的就是饿汉式防止反射攻击的一种方式，在私有构造方法中判断一下单例对象是否为空，由于饿汉式单例模式是在类加载时直接创建的单例对象，所以一旦通过反射调用私有构造方法的话肯定会抛出异常结束程序运行。</p>
<p>但是没有绝对安全的系统，即使是这样，单例模式还是不够安全的。</p>
<h1 id="使用枚举类防止防止反射攻击"><a href="#使用枚举类防止防止反射攻击" class="headerlink" title="使用枚举类防止防止反射攻击"></a>使用枚举类防止防止反射攻击</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumSingleInstance</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    EnumSingleInstance() &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> EnumSingleInstance.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是通过一个Enum类来实现的单例模式，这也是《Effective Java》这本书中推荐的实现单例的方式。这种实现单例的方式可以有效的防止反射和对象的序列化和反序列化对单例模式造成的破坏。具体的原因呢，笔者现在也还是不大明白，先在这里留个坑吧，以后再补好了。</p>
<p>关于单例模式其实很多学习Java的同学在刚接触Java不久，大概是在学完面向对象之后，应该都会实现一下懒汉式单例模式和饿汉式单例模式。在哪个时候来看单例模式实际上是很简单的一个设计模式，但是单例模式中关于多线程的处理，还有关于Java对象序列化与反序列化的处理，以及如何防止反射破坏单例模式。这些可就一点都不简单了，也说明了越学越深入了吧。</p>
<p>本来还想聊一下单例模式关于Java对象的序列化与反序列化的，但是我自己暂时也还是没学到这一部分，所以呢就也是留个坑在这里吧，等着以后学到了再来补。有兴趣的同学也可以点击文末的“欢迎打扰”一起交流学习。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>建造者模式</title>
    <url>/posts/25434/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>首先来看一下百度百科关于建造者模式的描述。（<a href="https://baike.baidu.com/item/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/3229729?fr=aladdin">建造者模式，百度百科</a>）</p>
<p><strong>实用范围：</strong><br>1、当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。<br>2、当构造过程必须允许被构造的对象有不同表示时。</p>
<p><strong>建造者模式中的4个角色：</strong><br>1、Builder：为创建一个产品对象的各个部件指定抽象接口。<br>2、ConcreteBuilder：实现Builder的接口以构造和装配该产品的各个部件，定义并明确它所创建的表示，并提供一个检索产品的接口。<br>3、Director：构造一个使用Builder接口的对象。<br>4、Product：表示被构造的复杂对象。ConcreteBuilder创建该产品的内部表示并定义它的装配过程，包含定义组成部件的类，包括将这些部件装配成最终产品的接口。</p>
<hr>
<blockquote>
<p>以上是百度百科中关于建造者模式的一些描述，下面说一些我自己的理解。</p>
</blockquote>
<span id="more"></span>

<p><strong>实用范围：</strong><br>1、创建对象部分的代码必须与使用到这个对象的代码解耦。<br>2、一个对象必须有多种不同的装配方式，这不仅仅是简单的参数不同。</p>
<p><strong>建造者模式中的4个角色：</strong><br>1、Product（产品）：要创建的对象，是一个具体的实体类。<br>2、Builder（建造者）：根据创建对象的过程实际抽象出来的接口。<br>3、ConcreteBuilder（具体建造者）：实现builder接口，实际创建对象的类。<br>4、Director（导演）：在完成上面的三个对象的工作之后交由Director类来创建对象，由此达到创建对象的过程与实际使用对象的代码解耦的目的。</p>
<h1 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h1><p>这里实际以创建一个手机对象为例子来用代码描述一下建造者模式</p>
<p><strong>手机类</strong>，对应的是Product角色：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBrand</span><span class="params">(String brand)</span> &#123; <span class="built_in">this</span>.brand = brand; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123; <span class="built_in">this</span>.name = name; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNum</span><span class="params">(String num)</span> &#123; <span class="built_in">this</span>.num = num; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> brand + <span class="string">&quot;Phone&#123;name=&#x27;&quot;</span> + name + <span class="string">&quot;&#x27;, num=&#x27;&quot;</span> + num + <span class="string">&quot;&#x27;&#125;&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>由创建手机的过程抽象出来的抽象类</strong>，对应的是Builder角色：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">PhoneBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">builderPhoneName</span><span class="params">(String name)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">builderPhoneNum</span><span class="params">(String num)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Phone <span class="title function_">makePhone</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>两个实际创建手机类的创建者</strong>，分别创建华为手机和小米手机，对应的是ConcreteBuilder角色：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HUAWEIPhoneBuilder</span> <span class="keyword">extends</span> <span class="title class_">PhoneBuilder</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HUAWEIPhoneBuilder</span><span class="params">()</span> &#123; <span class="built_in">this</span>.phone.setBrand(<span class="string">&quot;HUAWEI&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">builderPhoneName</span><span class="params">(String name)</span> &#123; <span class="built_in">this</span>.phone.setName(name); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">builderPhoneNum</span><span class="params">(String num)</span> &#123; <span class="built_in">this</span>.phone.setNum(num); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">makePhone</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.phone; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MIPhoneBuilder</span> <span class="keyword">extends</span> <span class="title class_">PhoneBuilder</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MIPhoneBuilder</span><span class="params">()</span> &#123; <span class="built_in">this</span>.phone.setBrand(<span class="string">&quot;MI&quot;</span>); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">builderPhoneName</span><span class="params">(String name)</span> &#123; <span class="built_in">this</span>.phone.setName(name); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">builderPhoneNum</span><span class="params">(String num)</span> &#123; <span class="built_in">this</span>.phone.setNum(num); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">makePhone</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="built_in">this</span>.phone; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建手机的类</strong>，对应的是Director角色：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhoneDirector</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PhoneBuilder phoneBuilder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PhoneDirector</span><span class="params">(PhoneBuilder phoneBuilder)</span> &#123; <span class="built_in">this</span>.phoneBuilder = phoneBuilder; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">makePhone</span><span class="params">(String name, String num)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.phoneBuilder.builderPhoneName(name);</span><br><span class="line">        <span class="built_in">this</span>.phoneBuilder.builderPhoneNum(num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.phoneBuilder.makePhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>以上准备工作完成，接下来测试一下效果怎么样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PhoneDirector</span> <span class="variable">HUAWEIDirector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhoneDirector</span>(<span class="keyword">new</span> <span class="title class_">HUAWEIPhoneBuilder</span>());</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">HUAWEIPhone</span> <span class="operator">=</span> HUAWEIDirector.makePhone(<span class="string">&quot;P30&quot;</span>, <span class="string">&quot;135 0000 0000&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">PhoneDirector</span> <span class="variable">MIDirector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhoneDirector</span>(<span class="keyword">new</span> <span class="title class_">MIPhoneBuilder</span>());</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">MIPhone</span> <span class="operator">=</span> MIDirector.makePhone(<span class="string">&quot;MI11&quot;</span>, <span class="string">&quot;135 1111 1111&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(HUAWEIPhone);</span><br><span class="line">        System.out.println(MIPhone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HUAWEIPhone&#123;name=&#x27;P30&#x27;, num=&#x27;135 0000 0000&#x27;&#125;</span><br><span class="line">MIPhone&#123;name=&#x27;MI11&#x27;, num=&#x27;135 1111 1111&#x27;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>类图：</strong>（为了能够更好的看清楚这个结构，这个类图中省略了小米手机类）<br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20210418103856.png" alt="20210418103856"></p>
<p><strong>小结：</strong>（以下两个小点分别对应百度百科实用范围中的两个小点）</p>
<ol>
<li>测试类在使用手机对象时完全没有涉及到创建手机的过程，将创建手机过程与测试类的使用是解耦的。</li>
<li>如果我们需要的对象是一个其他的表示的话，比如我们需要把华为手机换成小米手机，只需要把HUAWEIPhoneBuilder换成MIPhoneBuilder即可。</li>
</ol>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>思考一个问题：如果实际开发中不需要将创建对象的代码与实际使用这个对象的代码分离开呢？也就是仅仅只是需要有多种不同的装配对象的方式。</p>
<p>还是上面的这个例子，将创建对象的逻辑与对象本身绑定在一起，仅仅只剩下一个Product角色。<br>这里假设只是需要一个华为手机。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Phone</span><span class="params">(HUAWEIPhoneBuilder huaweiPhoneBuilder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.brand = huaweiPhoneBuilder.brand;</span><br><span class="line">        <span class="built_in">this</span>.name = huaweiPhoneBuilder.name;</span><br><span class="line">        <span class="built_in">this</span>.num = huaweiPhoneBuilder.num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> brand + <span class="string">&quot;Phone&#123;name=&#x27;&quot;</span> + name + <span class="string">&quot;&#x27;, num=&#x27;&quot;</span> + num + <span class="string">&quot;&#x27;&#125;&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原来的 ConcreteBuilder 具体创建者角色</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">HUAWEIPhoneBuilder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String brand;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> String num;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认创建的手机品牌</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">HUAWEIPhoneBuilder</span><span class="params">()</span> &#123; <span class="built_in">this</span>.brand = <span class="string">&quot;HUAWEI&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> HUAWEIPhoneBuilder <span class="title function_">buildName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> HUAWEIPhoneBuilder <span class="title function_">buildNum</span><span class="params">(String num)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.num = num;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Phone <span class="title function_">build</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Phone</span>(<span class="built_in">this</span>); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">HUAWEIPhone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>.HUAWEIPhoneBuilder().buildName(<span class="string">&quot;P30&quot;</span>).buildNum(<span class="string">&quot;135 0000 0000&quot;</span>).build();</span><br><span class="line">        System.out.println(HUAWEIPhone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HUAWEIPhone&#123;name=&#x27;P30&#x27;, num=&#x27;135 0000 0000&#x27;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>类图：</strong><br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20210418105741.png" alt="20210418105741"></p>
<p><strong>小结：</strong></p>
<ol>
<li>将创建对象的过程与这个对象绑定在一起，以一种链式调用的方式来解决在不同的业务场景下同一个对象的不同的装配方式。</li>
<li>但同时使用这个对象的代码与创建对象的代码也就耦合了。</li>
</ol>
<hr>
<p>上面只需创建华为手机的例子仅仅只是对于前面的一个扩展，这并不能够很好的帮助我们理解什么是对象的不同装配方式，以及如何去使用。<br>下面举一个更加形象的例子来帮助大家去理解建造者模式，比如我现在需要一个只有加法和减法的计算器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> result;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getResult</span><span class="params">()</span> &#123; <span class="keyword">return</span> result; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入基础操作数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Calculator</span><span class="params">(<span class="type">int</span> result)</span> &#123; <span class="built_in">this</span>.result = result; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Calculator <span class="title function_">add</span><span class="params">(<span class="type">int</span> addNum)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.result += addNum;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Calculator <span class="title function_">sub</span><span class="params">(<span class="type">int</span> subNum)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.result -= subNum;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>(<span class="number">10</span>).add(<span class="number">10</span>).sub(<span class="number">5</span>).getResult();</span><br><span class="line">        System.out.println(<span class="string">&quot;result：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">result：15</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>Java：反射</title>
    <url>/posts/25346/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>首先来看一下百度百科中对于Java反射的定义，<a href="https://baike.baidu.com/item/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/6015990?fr=aladdin">JAVA反射机制，百度百科</a></p>
<blockquote>
<p>Java的反射（reflection）机制是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制。反射被视为动态语言的关键。</p>
</blockquote>
<span id="more"></span>
<blockquote>
<p>Java反射机制主要提供了以下功能： 在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象；在运行时判断任意一个类所具有的成员变量和方法；在运行时调用任意一个对象的方法；生成动态代理。</p>
</blockquote>
<blockquote>
<p>有时候我们说某个语言具有很强的动态性，有时候我们会区分动态和静态的不同技术与作法。我们朗朗上口动态绑定（dynamic binding）、动态链接（dynamic linking）、动态加载（dynamic loading）等。然而“动态”一词其实没有绝对而普遍适用的严格定义，有时候甚至像面向对象当初被导入编程领域一样，一人一把号，各吹各的调。</p>
</blockquote>
<blockquote>
<p>一般而言，开发者社群说到动态语言，大致认同的一个定义是：“程序运行时，允许改变程序结构或变量类型，这种语言称为动态语言”。从这个观点看，Perl，Python，Ruby是动态语言，C++，Java，C#不是动态语言。</p>
</blockquote>
<blockquote>
<p>尽管在这样的定义与分类下Java不是动态语言，它却有着一个非常突出的动态相关机制：Reflection。这个字的意思是“反射、映象、倒影”，用在Java身上指的是我们可以于运行时加载、探知、使用编译期间完全未知的classes。换句话说，Java程序可以加载一个运行时才得知名称的class，获悉其完整构造（但不包括methods定义），并生成其对象实体、或对其fields设值、或唤起其methods。这种“看透class”的能力（the ability of the program to examine itself）被称为introspection（内省、内观、反省）。Reflection和introspection是常被并提的两个术语。</p>
</blockquote>
<p>上面这几段话出自百度百科，由此可以看出，Java反射机制的重要性。由于反射机制的存在使得Java语言变身成为一门准动态语言。很多主流框架中也是大量的使用了反射技术，像是我们说的Spring就是基于反射 + 配置 + 工厂的形式实现的。</p>
<h1 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h1><p>想要了解反射机制，首先来了解一个类<code>java.lang.Class</code>反射机制中最重要的一个类，Class类（描述类的类）。</p>
<p><strong>Java中的类：</strong>可以继承某个类，可以实现某一些接口，可以在类中定义类的属性，方法，和构造器。</p>
<p>由此，Class类（描述类的类）主要就是描述了类继承了哪个父类，实现了那些接口，定义了那些方法和属性，以及类中的构造器。</p>
<p><strong>小结：</strong>类的声明、类中的属性和方法、类的构造器是 <code>Class</code> 类主要的描述对象。</p>
<hr>
<p>既然Class类是描述类的类，那么就表明了Class类也是一个Java类，也必须遵守Java中关于类的规范，这一点不会变。</p>
<p>来分析一下Class类，首先看一下构造函数。<br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20200921203210.png" alt="20200921203210"><br>这是jdk1.8中Class类的构造函数，这是一个私有化的构造函数，意味着在外界是不能直接创建Class类的实例的。</p>
<p>实际上，Class类的实例也并不是创建出来的，Class类的实例是JVM在加载每个class字节码文件时自动生成的实例。</p>
<p>每个Class类对应的都是被JVM所加载的一个个class文件，相同的，每个class文件也都有一个唯一与之对应的Class实例。</p>
<h1 id="如何获取Class类的实例"><a href="#如何获取Class类的实例" class="headerlink" title="如何获取Class类的实例"></a>如何获取Class类的实例</h1><p>这里将通过一个User类来演示四种获取Class实例的方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cool.wrp.reflex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 1.类名.class</span></span><br><span class="line">        Class&lt;User&gt; userClass1 = User.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.实例.getClass()</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">userClass2</span> <span class="operator">=</span> user.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.Class.forName(&quot;全限定类名&quot;)</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">userClass3</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;cool.wrp.reflex.User&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> user.getClass().getClassLoader();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">userClass4</span>  <span class="operator">=</span> classLoader.loadClass(<span class="string">&quot;cool.wrp.reflex.User&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(userClass1.hashCode());</span><br><span class="line">        System.out.println(userClass2.hashCode());</span><br><span class="line">        System.out.println(userClass3.hashCode());</span><br><span class="line">        System.out.println(userClass4.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行main方法可以发现，四个Class实例的hashCode都是相同的，这证明了每个class字节码文件都有且仅有唯一一个与之对应的Class实例。</p>
<p>以上的四种方式，我们在实际开发中应该尽可能的使用第一种方式去获得Class类的实例，因为这种方式的效率是最高的。</p>
<h1 id="Class类是怎么描述类的"><a href="#Class类是怎么描述类的" class="headerlink" title="Class类是怎么描述类的"></a>Class类是怎么描述类的</h1><p style="text-indent:2em">
在这里引用 <b>Java核心技术卷一 5.7.4</b> 中的内容来讲述Class类是怎么描述类的。
</p>

<p style="text-indent:2em">
在 java.lang.reflect 包中有三个类 Firld、Method 和 Construct 分别用于描述类的字段、方法和构造器。这三个类都有一个叫做 getName 的方法，用来返回字段、方法或构造器的名称。Field 类还有一个 getType 方法，用来描述字段类型的一个对象，这个对象的类型同样是Class。Method 和 Constructor 类有报告参数类型的方法，Method类还有一个报告返回类型的方法。这三个类都有一个名为 getModifiers 的方法，它将返回一个整数， 用不同 0/1 位描述所使用的修饰符，如 public 和 static。另外，还可以利用 java.lang.refkect 包中的 Modifier 类的静态方法分析 getModifiers 返回的这个整数，例如，可以使用 Modifier 类中的 isPublic、isPrivate 或 isFinal 判断方法或构造器是 public、private 还是 final。我们需要做的就是在 getModifiers 返回的整数上调用 Modifier 类中适当的方法，另外，还可以利用 Modifier.toString 方法将修饰符打印出来。
</p>

<p style="text-indent:2em">
Class 类中的 getFields、getMethods 和 getConstructors 方法将分别返回这个类支持的 <b>公共</b> 字段、方法和构造器的数组，其中包括超类的公共成员。Class 类的 getDeclareFields、getDeclareMethods 和 getDeclaredConstrors方法将分别返回类中声明的全部字段、方法和构造器的数组，其中包括私有成员、包成员和受保护成员，但不包括超类的成员。
</p>

<hr>
<p><strong>来看一个书中的例子加深对这段话的理解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read class name from user input</span></span><br><span class="line">    System.out.println(<span class="string">&quot;class name:&quot;</span>);</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> scanner.next();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print class name and super class name (if != Object)</span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">    <span class="type">Class</span> <span class="variable">supercl</span> <span class="operator">=</span> cl.getSuperclass();</span><br><span class="line">    <span class="type">String</span> <span class="variable">modifiers</span> <span class="operator">=</span> Modifier.toString(cl.getModifiers());</span><br><span class="line">    <span class="keyword">if</span> (modifiers.length() &gt; <span class="number">0</span>)</span><br><span class="line">        System.out.print(modifiers + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    System.out.print(<span class="string">&quot;class &quot;</span> + className);</span><br><span class="line">    <span class="keyword">if</span> (supercl != <span class="literal">null</span> &amp;&amp; supercl != Object.class)</span><br><span class="line">        System.out.print(<span class="string">&quot; extends &quot;</span> + supercl.getName());</span><br><span class="line"></span><br><span class="line">    System.out.print(<span class="string">&quot;\n&#123;\n&quot;</span>);</span><br><span class="line">    printConstructors(cl);</span><br><span class="line">    System.out.println();</span><br><span class="line">    printMethods(cl);</span><br><span class="line">    System.out.println();</span><br><span class="line">    printFields(cl);</span><br><span class="line">    System.out.println(<span class="string">&quot;\n&#125;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单分析一下以上的代码，首先是一个接收用户在控制台的输入，通过scanner对象读取用户从控制台输入的一个全限定类名。之后通过 Class.forName 的形式去获取到用户输入类名对应的Class类对象。获取到Class对象之后再去获取父类和修饰符。</p>
<p>如果需要判断类使用了什么修饰符可以使用 <code>Modifier.isPublic(cl.getModifiers())</code> 来判断类是否被 public 所修饰。以此类推，判断是否被 private 所修饰则使用 <code>isPrivate</code>，是否 final 则 <code>isFinal</code>等等。</p>
<p>另外可以使用 <code>getInterfaces()</code> 方法去获取到一个类所实现的接口有哪些。由于Java是支持多实现的，所以该方法实际上返回的是一个泛型为Class类型的数组，用来描述类所实现的接口。</p>
<blockquote>
<p>以上是Class对象如何描述一个Java类声明的内容，接下来分析Class对象是如何去描述类的构造器、方法和属性的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Prints all constructors of a class</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cl a class</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printConstructors</span><span class="params">(Class cl)</span> &#123;</span><br><span class="line">    Constructor[] constructors = cl.getDeclaredConstructors();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Constructor c : constructors) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> c.getName();</span><br><span class="line">        System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">modifiers</span> <span class="operator">=</span> Modifier.toString(c.getModifiers());</span><br><span class="line">        <span class="keyword">if</span> (modifiers.length() &gt; <span class="number">0</span>) System.out.print(modifiers + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.print(name + <span class="string">&quot;(&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// print parameter type</span></span><br><span class="line">        Class[] paramTypes = c.getParameterTypes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; paramTypes.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>) System.out.print(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">            System.out.print(paramTypes[j].getName());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;);&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Prints all method of a class</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cl a class</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printMethods</span><span class="params">(Class cl)</span> &#123;</span><br><span class="line">    Method[] methods = cl.getDeclaredMethods();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Method m : methods) &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">retType</span> <span class="operator">=</span> m.getReturnType();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> m.getName();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        <span class="comment">// print modifiers, return type and method name</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">modifiers</span> <span class="operator">=</span> Modifier.toString(m.getModifiers());</span><br><span class="line">        <span class="keyword">if</span> (modifiers.length() &gt; <span class="number">0</span>) System.out.print(modifiers + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.print(retType.getName() + <span class="string">&quot; &quot;</span> + name + <span class="string">&quot;(&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// print parameter types</span></span><br><span class="line">        Class[] paramTypes = m.getParameterTypes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; paramTypes.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>) System.out.print(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">            System.out.print(paramTypes[j].getName());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;);&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Prints all fields of a class</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cl a class</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printFields</span><span class="params">(Class cl)</span> &#123;</span><br><span class="line">    Field[] fields = cl.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Field f : fields) &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">type</span> <span class="operator">=</span> f.getType();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> f.getName();</span><br><span class="line">        System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">modifiers</span> <span class="operator">=</span> Modifier.toString(f.getModifiers());</span><br><span class="line">        <span class="keyword">if</span> (modifiers.length() &gt; <span class="number">0</span>) System.out.print(modifiers + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.println(type.getName() + <span class="string">&quot; &quot;</span> + name + <span class="string">&quot;;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有兴趣的同学可以执行一遍以上的代码，可以更清楚的展示Class对象是如何去描述一个类的。</p>
<hr>
<p>书中的这个例子已经是很详细的讲明白了Class类是如何去描述一个类的，但这里还有一点补充，就是<strong>Class类是如何去描述类中的注解的</strong>。</p>
<p>我们使用 <a href="https://blog.wrp.cool/posts/28807/">【Java基础】</a> 注解一文开头的注解例子做演示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(value = &quot;MyAnnotation&#x27;s value&quot;, name = &quot;MyAnnotation&#x27;s name&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TargetClass</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mainn</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Class&lt;?&gt; cl = TargetClass.class;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取注解对象</span></span><br><span class="line">        <span class="type">MyAnnotation</span> <span class="variable">myAnnotation</span> <span class="operator">=</span> cl.getAnnotation(MyAnnotation.class);</span><br><span class="line">        <span class="comment">// 打印注解中的内容</span></span><br><span class="line">        System.out.println(myAnnotation.value());</span><br><span class="line">        System.out.println(myAnnotation.name());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行main方法：<br><code>MyAnnotation&#39;s value</code><br><code>MyAnnotation&#39;s name</code></p>
</blockquote>
<blockquote>
<p>同样的 <code>Constructor、Method、Field</code> 对象也有 <code>getAnnotation</code> 方法。</p>
</blockquote>
<h1 id="Class类是怎么操作类的"><a href="#Class类是怎么操作类的" class="headerlink" title="Class类是怎么操作类的"></a>Class类是怎么操作类的</h1><p>操作类也是分别对应着Java中对类的操作，首先是类的实例化，然后可以<strong>设置类的属性、获取类的属性、调用类的方法</strong>。而属性和方法又分为<strong>公共、私有和静态</strong></p>
<h3 id="类的实例化"><a href="#类的实例化" class="headerlink" title="类的实例化"></a>类的实例化</h3><p>通过反射实例化的类也是需要调用构造器的，构造方法分为有参构造器和无参构造器。</p>
<p>使用反射实例化一个类有两种方式，一个是调用<strong>Class对象的newInstance()方法</strong>，另一个是调用<strong>Constructor对象的newInstance()方法</strong>。</p>
<p><strong>实验环境</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TargetClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TargetClass</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TargetClass</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Class 对象的 newInstance() 方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TargetClass.class.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;main方法运行完毕&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>运行main方法抛出空指针异常</code></p>
<p><strong>Constructor 对象的 newInstance() 方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Class&lt;?&gt; cl = TargetClass.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造器</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cl.getDeclaredConstructor().newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参构造器</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cl.getDeclaredConstructor(String.class).newInstance(<span class="string">&quot;我是有参构造器实例化的对象&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;main方法运行完毕&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行main方法<br><code>抛出由java.lang.NullPointerException引起的java.lang.reflect.InvocationTargetException</code><br>打印：<code>我是有参构造器实例化的对象</code><br>打印：<code>main方法运行完毕</code></p>
</blockquote>
<p><strong>小结：</strong></p>
<ol>
<li><strong>Class 对象的 newInstance() 方法</strong>无法调用有参构造函数，只能调用无参构造器</li>
<li><strong>Class 对象的 newInstance() 方法</strong>无法捕获构造器中的异常，而<strong>Constructor 对象的 newInstance() 方法</strong>会将构造器中的异常封装成 <code>java.lang.reflect.InvocationTargetException</code> 异常</li>
<li>建议使用<strong>Constructor 对象的 newInstance() 方法</strong></li>
</ol>
<hr>
<blockquote>
<p>在这里首先引入一个简单的概念，<strong>显示参数</strong>和<strong>隐式参数</strong>。在这里先简单的理解为调用属性的对象。</p>
</blockquote>
<p><strong>显示参数：</strong>在方法中明确定义的参数为显示参数</p>
<p><strong>隐式参数：</strong>未在方法是定义的，但的确又动态影响到程序运行的“参数”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"></span><br><span class="line">        user.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123; <span class="built_in">this</span>.name = name; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如以上代码 <code>user</code> 对象为隐式参数，实际传入的 <code>&quot;张三&quot;</code> 字符串为显示参数。</p>
<hr>
<h3 id="操作属性"><a href="#操作属性" class="headerlink" title="操作属性"></a>操作属性</h3><p><strong>实验环境</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目标类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TargetClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String pubAttr;</span><br><span class="line">    <span class="keyword">static</span> String staAttr;</span><br><span class="line">    <span class="keyword">private</span> String priAttr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">        Class&lt;?&gt; cl = TargetClass.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化一个对象作为隐式参数</span></span><br><span class="line">        <span class="type">TargetClass</span> <span class="variable">tc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TargetClass</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取属性</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">pubAttr</span> <span class="operator">=</span> cl.getDeclaredField(<span class="string">&quot;pubAttr&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">staAttr</span> <span class="operator">=</span> cl.getDeclaredField(<span class="string">&quot;staAttr&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">priAttr</span> <span class="operator">=</span> cl.getDeclaredField(<span class="string">&quot;priAttr&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>公共属性</strong></p>
<blockquote>
<p>实际上，Java中的非静态属性都是挂载在对应的对象上的。反射也没有例外，所以我们如果想要通过反射去操作一个属性，我们同样是需要给这个属性一个可以挂载的地方，也就是一个对象，这个对象也就是前文提到的隐式参数。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置公共属性的值</span></span><br><span class="line">pubAttr.set(tc, <span class="string">&quot;我是公共属性&quot;</span>);</span><br><span class="line"><span class="comment">// 获取公共属性的值</span></span><br><span class="line">System.out.println(pubAttr.get(tc));</span><br></pre></td></tr></table></figure>
<p><code>输出：我是公共属性</code></p>
<p>上面的两行代码中的tc就是对应的对象挂载的地方。在这里我将其理解为pubAttr属性的隐式参数。</p>
<p><strong>静态属性</strong></p>
<blockquote>
<p>刚刚说的Java中的非静态属性都是挂载在对象上的，而静态属性与Class对象一样是存储在方法区中的。所以不需要挂载的对象，在传参数的时候直接传一个null对象即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置静态属性的值</span></span><br><span class="line">staAttr.set(<span class="literal">null</span>, <span class="string">&quot;我是静态属性&quot;</span>);</span><br><span class="line"><span class="comment">// 获取静态属性的值</span></span><br><span class="line">System.out.println(staAttr.get(<span class="literal">null</span>));</span><br></pre></td></tr></table></figure>
<p><code>输出：我是静态属性</code></p>
<p><strong>私有属性</strong></p>
<blockquote>
<p>Java中类的私有属性是无法通过外部去设置和获取的，而反射可以改变这一点，这同时也正是反射的强大之处。只需要一行代码设置访问权限即可访问类的私有属性。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 授权访问</span></span><br><span class="line">priAttr.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 设置私有属性的值</span></span><br><span class="line">priAttr.set(tc, <span class="string">&quot;我是私有属性&quot;</span>);</span><br><span class="line"><span class="comment">// 获取私有属性的值</span></span><br><span class="line">System.out.println(priAttr.get(tc));</span><br></pre></td></tr></table></figure>
<p><code>输出：我是私有属性</code></p>
<h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><p>操作方法和操作属性实际上差不多，也都分共有、私有、静态方法。不同的是，在获取Method对象时需要指定参数列表，执行Method方法时也需要传入对应方法的参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TargetClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pubMethod</span><span class="params">(String name)</span> &#123; System.out.println(<span class="string">&quot;我是&quot;</span> + name); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staMethod</span><span class="params">(String name)</span> &#123; System.out.println(<span class="string">&quot;我是&quot;</span> + name); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">priMethod</span><span class="params">(String name)</span> &#123; System.out.println(<span class="string">&quot;我是&quot;</span> + name); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reflex</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line">        Class&lt;?&gt; cl = TargetClass.class;</span><br><span class="line"></span><br><span class="line">        <span class="type">TargetClass</span> <span class="variable">tc</span> <span class="operator">=</span> (TargetClass) cl.newInstance();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 获取公共方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">pubMethod</span> <span class="operator">=</span> cl.getDeclaredMethod(<span class="string">&quot;pubMethod&quot;</span>, String.class);</span><br><span class="line">        <span class="comment">// 执行公共方法</span></span><br><span class="line">        pubMethod.invoke(tc, <span class="string">&quot;公共方法&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取静态方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">staMethod</span> <span class="operator">=</span> cl.getDeclaredMethod(<span class="string">&quot;staMethod&quot;</span>, String.class);</span><br><span class="line">        <span class="comment">// 执行静态方法</span></span><br><span class="line">        staMethod.invoke(<span class="literal">null</span>, <span class="string">&quot;静态方法&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取私有方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">priMethod</span> <span class="operator">=</span> cl.getDeclaredMethod(<span class="string">&quot;priMethod&quot;</span>, String.class);</span><br><span class="line">        <span class="comment">// 私有方法授权</span></span><br><span class="line">        priMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 执行私有方法</span></span><br><span class="line">        priMethod.invoke(tc, <span class="string">&quot;私有方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>高级特性</category>
      </categories>
  </entry>
  <entry>
    <title>Java：注解</title>
    <url>/posts/28807/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;我的注解&quot;</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;name&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是Java自定义注解的格式，其中的四个注解就是元注解，也就是我们接下注解部分来的重点。</p>
<span id="more"></span>

<h1 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h1><p>普通的注解就是用来修饰例如变量、方法和类的。而元注解是用来修饰注解的，是修饰注解的注解。下面的四个注解就是元注解。</p>
<p><strong>@Target</strong><br>目标的意思，表示的是注解可以修饰的目标。参数是一个<code>java.lang.annotation.ElementType</code>类型的数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;</span></span><br><span class="line"><span class="meta">        ElementType.TYPE,               // 类、接口、枚举类</span></span><br><span class="line"><span class="meta">        ElementType.FIELD,              // 成员变量、枚举常量</span></span><br><span class="line"><span class="meta">        ElementType.METHOD,             // 成员方法</span></span><br><span class="line"><span class="meta">        ElementType.PARAMETER,          // 方法参数</span></span><br><span class="line"><span class="meta">        ElementType.CONSTRUCTOR,        // 构造方法</span></span><br><span class="line"><span class="meta">        ElementType.LOCAL_VARIABLE,     // 局部变量</span></span><br><span class="line"><span class="meta">        ElementType.ANNOTATION_TYPE,    // 注解类</span></span><br><span class="line"><span class="meta">        ElementType.PACKAGE,            // 包</span></span><br><span class="line"><span class="meta">        ElementType.TYPE_PARAMETER,     // 类型参数，jdk1.8新增</span></span><br><span class="line"><span class="meta">        ElementType.TYPE_USE            // 使用类型的任何地方，jdk1.8新增</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@Retention</strong><br>有点类似于生命周期的意思，表示的是注解在程序中作用的范围，参数是<code>java.lang.annotation.RetentionPolicy</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span>      <span class="comment">// 源文件保留</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.CLASS)</span>       <span class="comment">// 编译后保留</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span>     <span class="comment">// 运行时保留</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@Inherited</strong><br>Inherited注解的作用是：使被它修饰的注解具有继承性（如果某个类使用了被@Inherited修饰的注解，则其子类将自动具有该注解）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyInheritedAnnotation &#123; </span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MyInheritedAnnotation(name=&quot;parent&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Class&lt;Child&gt; child = Child.class;</span><br><span class="line">		<span class="type">MyInheritedAnnotation</span> <span class="variable">annotation</span> <span class="operator">=</span> child.getAnnotation(MyInheritedAnnotation.class);</span><br><span class="line">		System.out.println(annotation.name());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行main方法打印结果：<code>parent</code></p>
<p><strong>@Documented</strong><br>Documented注解的作用是：描述在使用 javadoc 工具为类生成帮助文档时是否要保留其注解信息。</p>
<blockquote>
<p>以上内容参考：<a href="https://blog.csdn.net/pengjunlee/article/details/79683621#meta-annotation%EF%BC%88%E5%85%83%E6%B3%A8%E8%A7%A3%EF%BC%89">JAVA核心知识点–元注解详解</a></p>
</blockquote>
<p><strong>彩蛋：</strong><br>将名称定义成value的值在使用时是可以省略value属性不写的。<br>例如上面定义的<code>MyAnnotation</code>注解，在设置值时<code>value</code>属性是可以省略属性名称的，而<code>name</code>属性则不可以省略属性名称。</p>
<p><code>@MyAnnotation(&quot;value&quot;)</code> 表示指定了value的值<br><code>@MyAnnotation(name = &quot;name&quot;)</code> 表示指定了name的值<br><code>@MyAnnotation(value = &quot;value&quot;, name = &quot;name&quot;)</code> 表示指定了value和name的值，如果指定了多个值则属性名不可以省略</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>高级特性</category>
      </categories>
  </entry>
  <entry>
    <title>Spring基础：依赖注入</title>
    <url>/posts/47506/</url>
    <content><![CDATA[<p><em>依赖注入（Dependency Injection简称DI）</em><br><strong>依赖：</strong>指Bean对象的创建依赖于IOC容器，Bean对象的依赖资源。<br><strong>注入：</strong>指Bean对象所依赖的资源，由容器来设置和装配。</p>
<span id="more"></span>

<h3 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h3><p>构造器注入这里与上文<a href="http://blog.wrp.cool/posts/17371/">【Spring】创建对象</a> 中「通过构造方法创建对象」相同，这里不再赘述。</p>
<h3 id="set方法注入"><a href="#set方法注入" class="headerlink" title="set方法注入"></a>set方法注入</h3><h4 id="基本数据类型和字符串注入"><a href="#基本数据类型和字符串注入" class="headerlink" title="基本数据类型和字符串注入"></a>基本数据类型和字符串注入</h4><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20200831232348.png" alt="20200831232348"></p>
<h4 id="java-util-Properties类注入"><a href="#java-util-Properties类注入" class="headerlink" title="java.util.Properties类注入"></a>java.util.Properties类注入</h4><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20200831232859.png" alt="20200831232859"></p>
<h4 id="注入Bean"><a href="#注入Bean" class="headerlink" title="注入Bean"></a>注入Bean</h4><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20200901203712.png" alt="20200901203712"></p>
<blockquote>
<p>注意上面加了颜色的这句话<code>但是销毁回调允许它参与请求作用域的生命周期。</code><br>这句话的意思是，当Bean被销毁时，这个Bean所注入的其他的Bean并不会被一同销毁，也就是会继续驻留在内存中。如果我们要销毁这个Bean，需要进一步的销毁操作。差不多就像是闭包的意思。</p>
</blockquote>
<h4 id="集合类型的注入"><a href="#集合类型的注入" class="headerlink" title="集合类型的注入"></a>集合类型的注入</h4><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20200901205115.png" alt="20200901205115"></p>
<h4 id="注入空字符串"><a href="#注入空字符串" class="headerlink" title="注入空字符串"></a>注入空字符串</h4><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20200901214249.png" alt="20200901214249"></p>
<h4 id="注入null"><a href="#注入null" class="headerlink" title="注入null"></a>注入null</h4><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20200901214315.png" alt="20200901214315"></p>
<h3 id="p名称空间注入"><a href="#p名称空间注入" class="headerlink" title="p名称空间注入"></a>p名称空间注入</h3><h4 id="普通属性"><a href="#普通属性" class="headerlink" title="普通属性"></a>普通属性</h4><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20200901214537.png" alt="20200901214537"></p>
<h4 id="其他bean引用"><a href="#其他bean引用" class="headerlink" title="其他bean引用"></a>其他bean引用</h4><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20200901214554.png" alt="20200901214554"></p>
<h3 id="c名称空间注入"><a href="#c名称空间注入" class="headerlink" title="c名称空间注入"></a>c名称空间注入</h3><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20200901214656.png" alt="20200901214656"></p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring 基础</category>
      </categories>
  </entry>
  <entry>
    <title>Spring基础：创建对象</title>
    <url>/posts/17371/</url>
    <content><![CDATA[<p>上一篇文章 <a href="http://www.wrp.cool/posts/5741/">【Spring】IOC推导</a> 讲到了Spring会帮我们创建好对象存在IOC容器中，当需要使用的时候只需要去IOC容器中取即可。<br>这篇文章就说一下Spring中创建对象的几种方式。</p>
<h1 id="通过构造方法创建对象"><a href="#通过构造方法创建对象" class="headerlink" title="通过构造方法创建对象"></a>通过构造方法创建对象</h1><p>通过构造方法创建对象是Spring中最普通的一种创建对象的方式了，通过调用类的构造方法去创建这个对象。这种方式创建对象只需要在配置文件中配置即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 默认调用无参构造 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cool.wrp.ioc.User&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 下标的形式调用有参构造 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cool.wrp.ioc.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;user2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 参数类型调用有参构造 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cool.wrp.ioc.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;user3&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 参数名调用有参构造 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user4&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cool.wrp.ioc.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;user4&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="通过静态工厂方法创建对象"><a href="#通过静态工厂方法创建对象" class="headerlink" title="通过静态工厂方法创建对象"></a>通过静态工厂方法创建对象</h1><p>自己编写一个创造类的静态工厂类，然后将这个静态工厂类注册到Spring中去，再告诉Spring要通过这其中的哪个静态方法去创建我们想要的对象，这样子Spring就可以根据我们想要的方式去创建对象了。<br>这样一来是以自己定义的工厂去创建我们想要的类，我们可以在这个类创建类的方法中自由控制创建流程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 教师类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">// 此处由于篇幅限制省略全参构造方法和toString方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学生类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">// 此处由于篇幅限制省略全参构造方法和toString方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工厂类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonFactory</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Teacher类的静态方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Teacher <span class="title function_">getTeacherInstance</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="comment">// 针对创建Teacher类的扩展</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Student类的静态方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title function_">getStudentInstance</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="comment">// 针对创建Student类的扩展</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Student</span>(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 教师类的工厂 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;teacherFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cool.wrp.createObject.PersonFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getTeacherInstance&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 学生类的工厂 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;studentFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cool.wrp.createObject.PersonFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getStudentInstance&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;李四&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 通过静态工厂创建Teacher类</span></span><br><span class="line">        <span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;teacherFactory&quot;</span>, Teacher.class);</span><br><span class="line">        System.out.println(teacher);</span><br><span class="line">        <span class="comment">// 通过静态工厂创建Student类</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;studentFactory&quot;</span>, Student.class);</span><br><span class="line">        System.out.println(student);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>运行测试类，成功输出</code></p>
<h1 id="使用实例工厂方法实例化"><a href="#使用实例工厂方法实例化" class="headerlink" title="使用实例工厂方法实例化"></a>使用实例工厂方法实例化</h1><p>实例工厂相比起静态工厂就是工厂类中创建对象的方法不是静态的，只是普通的成员方法。这样子不能直接调用创建类的静态方法，就必须要在配置文件中注册一下工厂类然后再通过工厂类去调用工厂创建对象的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 教师类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">// 此处由于篇幅限制省略全参构造方法和toString方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学生类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">// 此处由于篇幅限制省略全参构造方法和toString方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工厂类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonFactory</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Teacher类的静态方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Teacher <span class="title function_">getTeacherInstance</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Student类的静态方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">getStudentInstance</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Student</span>(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 教师类的工厂 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;teacherFactory&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;personFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getTeacherInstance&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 学生类的工厂 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;studentFactory&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;personFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getStudentInstance&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;李四&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注册工厂类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;personFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cool.wrp.createObject.PersonFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 通过静态工厂创建Teacher类</span></span><br><span class="line">        <span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;teacherFactory&quot;</span>, Teacher.class);</span><br><span class="line">        System.out.println(teacher);</span><br><span class="line">        <span class="comment">// 通过静态工厂创建Student类</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;studentFactory&quot;</span>, Student.class);</span><br><span class="line">        System.out.println(student);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>运行测试类，成功输出</code></p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring 基础</category>
      </categories>
  </entry>
  <entry>
    <title>Spring基础：Bean的自动装配</title>
    <url>/posts/43228/</url>
    <content><![CDATA[<p>自动装配是使用spring满足bean依赖的一种方法<br>spring会在应用上下文中为某个bean寻找其依赖的bean。<br><em>以上内容出自b站（<a href="https://www.bilibili.com/video/BV1WE411d7Dv?p=3">狂神说Java</a>）</em></p>
<span id="more"></span>

<p><strong>实验环境搭建</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 宠物猫和宠物狗类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;吃鱼&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;吃骨头&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person类，拥有Cat和Dog</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;    </span><br><span class="line">    <span class="keyword">public</span> Cat <span class="title function_">getCat</span><span class="params">()</span> &#123; <span class="keyword">return</span> cat; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCat</span><span class="params">(Cat cat)</span> &#123; <span class="built_in">this</span>.cat = cat; &#125;</span><br><span class="line">    <span class="keyword">public</span> Dog <span class="title function_">getDog</span><span class="params">()</span> &#123; <span class="keyword">return</span> dog; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDog</span><span class="params">(Dog dog)</span> &#123; <span class="built_in">this</span>.dog = dog; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;person&quot;</span>, Person.class);</span><br><span class="line">        person.getCat().eat();</span><br><span class="line">        person.getDog().eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="配置文件方式自动装配"><a href="#配置文件方式自动装配" class="headerlink" title="配置文件方式自动装配"></a>配置文件方式自动装配</h1><h4 id="byName"><a href="#byName" class="headerlink" title="byName"></a>byName</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置文件 --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;spring.Cat&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;spring.Dog&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 此处使用byName方式自动注入依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;spring.Person&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>运行测试类成功输出</code></p>
<p><strong>小结：</strong></p>
<ol>
<li>将查找其类中所有的set方法名，例如setCat，获得将set去掉并且首字母小写的字符串，即cat。</li>
<li>去spring容器中寻找是否有此字符串名称id或者是此字符串名称name的对象，自动注入到该属性中。</li>
</ol>
<h4 id="byType"><a href="#byType" class="headerlink" title="byType"></a>byType</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置文件 --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;spring.Cat&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;spring.Dog&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 此处使用byType方式自动注入属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;spring.Person&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>运行测试类成功输出</code></p>
<p><strong>小结：</strong></p>
<ol>
<li>自动匹配set方法的参数类型，并自动注入。</li>
<li>如果set方法中存在多个参数，则无法注入。</li>
</ol>
<h1 id="注解方式自动装配"><a href="#注解方式自动装配" class="headerlink" title="注解方式自动装配"></a>注解方式自动装配</h1><p>Spring官网开启注解支持的方式</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启注解支持 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        扩展：另外的开启注解支持的方式</span></span><br><span class="line"><span class="comment">        &lt;bean class =&quot;org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor&quot;/&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">name</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;spring.Cat&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">name</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;spring.Dog&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;spring.Person&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h4><blockquote>
<p><code>@Autowired</code>默认使用的注解方式是ByType方式进行注入，如果需要根据名称进行注入的话需要搭配<code>@Qualifier</code>注解一起使用。<code>@Autowired</code>注解其中还有一个布尔值的属性<code>required</code>可以指定是否必须注入。默认值是true必须注入，如果置为false则表示可以非必须注入：<code>(required = false)</code></p>
</blockquote>
<p>将<code>@Autowired</code>注解写在类的成员变量、set方法或者构造器上即可实现自动注入。<br>演示怎么将<code>@Autowired</code>注解在成员变量、set方法、构造器上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 构造器 */</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(Cat cat, Dog dog)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.cat = cat;</span><br><span class="line">    <span class="built_in">this</span>.dog = dog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 成员变量 */</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* set方法 */</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCat</span><span class="params">(Dog dog)</span> &#123; <span class="built_in">this</span>.dog = dog; &#125;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDog</span><span class="params">(Cat cat)</span> &#123; <span class="built_in">this</span>.cat = cat; &#125;</span><br></pre></td></tr></table></figure>
<p><code>以上三种方式运行测试类均可成功输入</code></p>
<p><strong>实际上，Spring官方建议我们使用构造器的方式注入依赖，而不是成员变量注入。</strong></p>
<ol>
<li><p><strong>成员变量注入的方式不能为final修饰的成员变量注入依赖。</strong></p>
</li>
<li><p><strong>IOC容器的解耦。</strong><br>当我们使用IOC容器创建对象时意味着我们把创建对象的这个操作交给了IOC容器，也就是所谓的控制反转。<br>但是如果我们需要脱离IOC容器来创建这个对象呢？<br>答案是如果使用的是成员变量注入的方式则脱离IOC容器之后我们无法创建这个对象。<br>由于是成员变量注入，而成员变量对外又是不可见的，只能通过IOC容器去利用反射机制将依赖注入，所以一旦脱离了IOC容器之后这个类几乎不可用，这直接导致了类与IOC容器的高度耦合。</p>
</li>
<li><p><strong>使用构造器注入的方式能够更好的帮助我们遵守单一职责原则。</strong><br>如果一个类中的依赖过于庞大，那么使用构造器注入的方式参数也会变得很多，而参数变多则是一个很明显的提示，我们需要考虑优化这个类了。</p>
</li>
</ol>
<p>使用set方法注入依赖的话则是一个可选的依赖注入，如果需要这个依赖则注入进来。不需要就不要管它。这种注入方式是一种非必须注入的方式，相对的构造器注入则是一种强制注入的方式了。</p>
<p>在实际的开发中，很多时候都是强制注入的，也就是更需要构造器注入的方式来注入变量。但是如果我们每个类都去维护一个构造方法的话每个构造方法又会带有很多参数，这明显不方便，这里可以使用<code>lombok</code>来维护这个构造方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequiredArgsConstructor(onConstructor = @__(@Autowired))</span> <span class="comment">// 自动生成构造方法的注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UsersMapper usersMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这里会自动生成一个构造方法注入所有的被final修饰的变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ol>
<li>尽量不要使用成员变量的方式注入依赖。</li>
<li>根据具体的业务场景选择构造器注入或是set方法方式的注入</li>
</ol>
<h4 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h4><p>注意：上文提到的另外开启注解的方式不支持@Resource注解。</p>
<ol>
<li>@Resource如有指定的name属性，先按name属性以byName方式查找装配</li>
<li>其次再使用默认的byName方式进行装配</li>
<li>如果以上都不成功，则按byType的方式自动装配</li>
<li>都不成功，则报异常</li>
</ol>
<p><code>@Resource</code>注解也是可以应用在成员变量、构造器、set方法上的，相比起<code>@Autowired</code>注解，是jdk自带的注解而不是Spring提供的，这其中的一个好处是使得程序在依赖注入方面与Spring框架解耦，但我个人觉得并不是很必要。另外一个就是上面提到的注入方式的不同，<code>@Autowired</code>是byType方式而<code>@Resource</code>是先使用byName方式，byName方式注入失败再使用byType方式。还有新版本的jdk已经不再支持<code>@Resource</code>注解了，故了解即可。</p>
<h4 id="Component、-Repository、-Service、-Controller"><a href="#Component、-Repository、-Service、-Controller" class="headerlink" title="@Component、@Repository、@Service、@Controller"></a>@Component、@Repository、@Service、@Controller</h4><p>这些注解是为了让我们更加进一步的简化xml文件中的配置而存在的，将这些注解应用在类上，则可以将该类交由IOC容器去管理。相当于在xml文件中定义了这个类的bean节点。<br>默认使用的id是类名的小驼峰写法，自定义id则只需要指定value属性即可。四个注解的功能都是相同的，之所以有四个只是为了区分开各个类的层级。<code>@Repository</code>、<code>@Service</code>、<code>@Controller</code>这三个注解分别对应MVC三层设计中的<code>dao</code>、<code>service</code>、<code>controller</code>，另外的<code>@Component</code>注解则是使用在一些其他的类中，例如工具类。</p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring 基础</category>
      </categories>
  </entry>
  <entry>
    <title>Spring基础：IOC理论推导</title>
    <url>/posts/5741/</url>
    <content><![CDATA[<p>控制反转IOC（Inversion of Control)，是一种设计思想，DI（依赖注入）是实现IOC的一种方法，也有人认为DI只是IOC的另一种说法。没有IOC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。<br><em>以上内容出自b站（<a href="https://www.bilibili.com/video/BV1WE411d7Dv?p=3">狂神说Java</a>）</em></p>
<hr>
<p><strong>演示传统开发模式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserDao</span> &#123; </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">getUser</span><span class="params">()</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MysqlUserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">IUserDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getUser</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;从MySQL数据库中取出的User对象&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OracleUserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">IUserDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getUser</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;从Oracle数据库中取出来的User对象&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * service </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserService</span> &#123; </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">getUser</span><span class="params">()</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IUserService</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">IUserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MysqlUserDaoImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getUser</span><span class="params">()</span> &#123; </span><br><span class="line">        userDao.getUser(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">IUserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        userService.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小结：</strong><br>传统的开发模式中，各个类之间的耦合度过高，如果在service层中要调用dao层的接口，必须在代码中new一个dao层接口的实现类才可以使用。<br>但是以这样的方式去编写代码一旦需要切换dao层的实现则必须去修改service层的代码，去修改接口的实现类才可以。<br>如果现在需要修改一个dao层的实现类，但是这个实现类在service层中很多地方都去new了的话，修改就会变得非常麻烦。不符合开闭原则的设计思想，也大大提高了代码之间的耦合度。</p>
<blockquote>
<p>此处其实可以使用在上一篇博客 <a href="http://blog.wrp.cool/posts/34268/">【创建型设计模式】工厂模式</a> 中所讲述的工厂模式解决，但本文重点在于IOC，关于工厂模式的内容则不详细展开。</p>
</blockquote>
<hr>
<p><strong>演示IOC开发模式</strong> <em>（此处dao层模式使用传统开发模式中的dao层）</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * service</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IUserService</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IUserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(IUserDao userDao)</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.userDao = userDao; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getUser</span><span class="params">()</span> &#123;</span><br><span class="line">         userDao.getUser(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">IUserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        userService.setUserDao(<span class="keyword">new</span> <span class="title class_">MysqlUserDaoImpl</span>());</span><br><span class="line">        userService.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>小结：</strong><br>IOC开发模式已经从根本上去解决了传统开发模式中的问题，传统开发模式中任何对象都是依赖于程序去控制创建，但是使用了IOC模式进行开发之后，依赖的对象不再需要程序去创建，而是交由用户去自定义。换句话说，service只是提供一个调用处理逻辑的接口出去给用户，而具体要处理的对象则交由用户去创建，从根本上解耦了。</p>
<hr>
<h1 id="Spring中的IOC"><a href="#Spring中的IOC" class="headerlink" title="Spring中的IOC"></a>Spring中的IOC</h1><p>前文已经说过IOC是一种思想而不是一种具体的实现，Spring就是一种IOC的具体实现。</p>
<p><strong>演示Spring IOC</strong> <em>（此处dao层模式使用传统开发模式中的dao层）</em></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注册UserDao --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cool.wrp.ioc.OracleUserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * service</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IUserService</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建spring上下文对象</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        <span class="type">IUserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> (IUserDao) context.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">        userDao.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">IUserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        userService.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上演示的就是一个简单的Spring应用。</p>
<p>Spring是以一种配置加工厂方式来实现IOC，这在Spring中有一个专业的名词叫做IOC容器。Spring的IOC容器通过配置文件去读取要创建的bean。之后通过上下文对象的<code>getBean()</code>方法去获取到我们想要的bean对象。实际上应该将Spring理解为一个巨大的工厂。<br>以上将对象的创建完全交由Spring负责，在客户端中也不需要去传入实际的对象。所谓的控制反转就是将创建对象的这一步动作交给第三方去完成。不需要在程序中去创建对象，也不需要用户去创建对象，而是通过Spring的工厂创建完成之后我们自己根据需要去取出对象来使用。控制就是控制对象的创建，反转就是将控制对象的创建这一步骤反转给Spring。</p>
<h1 id="Bnan的作用域"><a href="#Bnan的作用域" class="headerlink" title="Bnan的作用域"></a>Bnan的作用域</h1><p>Spring官网对Bean作用域的描述<br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20200901215755.png" alt="20200901215755"></p>
<blockquote>
<p>这里我们来聊聊singleton和prototype，单例和原型。另外的几种作用域等以后有用到再研究</p>
</blockquote>
<p>Spring中Bean默认的作用域范围就是单例的，也就是在整个IOC容器中只有一个Bean实例存在，相对应的原型模式就是在IOC容器中存在多个Bean实例的。单例的Bean在创建上下文时就创建了，然后每次去获取的时候都是获取的同一个，而原型的Bean则是当需要用到再去创建，每次需要都会去创建一个新的Bean。</p>
<p><strong>演示单例和原型</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;singletonStu&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cool.wrp.createObject.Student&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;prototypeStu&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cool.wrp.createObject.Student&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);<span class="comment">// 创建singletonStu</span></span><br><span class="line">        <span class="comment">// 演示单例</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;singletonStu&quot;</span>, Student.class);<span class="comment">// 取出singletonStu</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu2</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;singletonStu&quot;</span>, Student.class);<span class="comment">// 取出singletonStu</span></span><br><span class="line">        System.out.println(stu1 == stu2);<span class="comment">// true</span></span><br><span class="line">        <span class="comment">// 演示原型</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu3</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;prototypeStu&quot;</span>, Student.class);<span class="comment">// 创建singletonStu</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu4</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;prototypeStu&quot;</span>, Student.class);<span class="comment">// 创建singletonStu</span></span><br><span class="line">        System.out.println(stu3 == stu4);<span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring 基础</category>
      </categories>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/posts/34268/</url>
    <content><![CDATA[<p><strong>百度百科中对创建型模式的定义：</strong><br>创建型模式旨在将系统与它的对象创建、结合、表示的方式分离。这些设计模式在对象创建的类型、主体、方式、时间等方面提高了系统的灵活性。（<a href="https://baike.baidu.com/item/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/22912595?fr=aladdin">百度百科</a>）</p>
<p><strong>个人理解：</strong><br>某些业务场景中，需要重复的创建相同对象去完成业务逻辑。一旦需要切换成另外的对象的话则需要修改大量代码。而使用创建型设计模式（例如工厂模式）则仅需要修改一处即可。即工厂中创建对象的地方。</p>
<p><strong>本文将讲述的创建型的设计模式有：</strong><br>简单工厂模式、工厂方法模式、抽象工厂模式</p>
<span id="more"></span>

<h1 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h1><p>定义：由一个工厂对象决定创建出哪一种产品的实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 手机类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">extends</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;使用苹果手机打电话&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MI</span> <span class="keyword">extends</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;使用小米手机打电话&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手机工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhoneFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Phone <span class="title function_">getPhone</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;apple&quot;</span>.equalsIgnoreCase(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;mi&quot;</span>.equalsIgnoreCase(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MI</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>客户端不使用工厂类时创建对应的手机</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">apple</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Apple</span>();</span><br><span class="line">        apple.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类图：<br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20200814233625.png" alt="20200814233625"></p>
<p> <strong>小结：</strong><br> 客户端如果在很多地方需要使用到手机类，那么每个地方都必须去new对应的手机类。如果有一天业务逻辑发生变化，需要换一款手机，那么就得在很多地方都去重新new新的手机类。这将会变得非常麻烦，不符合低耦合的设计思想</p>
</li>
<li><p><strong>客户端使用手机工厂类创建对应的手机</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">apple</span> <span class="operator">=</span> PhoneFactory.getPhone(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (apple != <span class="literal">null</span>) &#123;</span><br><span class="line">            apple.create();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类图：<br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20200814233841.png" alt="20200814233841"></p>
<p> <strong>小结：</strong><br> 使用工厂模式可以直接在工厂类中去修改对应的实例，而不需要在每个创建实例的地方都去修改。如果需要修改对应的手机实例则只需要在工厂类中去替换掉对应的实例即可。</p>
<p> <strong>举例：</strong><br> 需求：将原来的苹果手机换成最新的苹果手机。使用工厂模式之后只需要去创建一个最新的苹果手机类继承手机类，再去修改手机工厂类中的实例即可。</p>
</li>
</ul>
<p><strong>缺点：</strong>工厂类职责过于繁重，一旦创建新的手机则需要修改工厂类。违反了开闭原则</p>
<p><strong>改进：</strong>在工厂类中使用反射</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 手机工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhoneFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Phone <span class="title function_">getPhone</span><span class="params">(Class c)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Phone = (Phone) Class.forName(c.getName()).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> PhoneFactory.getPhone(Apple.class);</span><br><span class="line">        <span class="keyword">if</span> (phone != <span class="literal">null</span>) &#123;</span><br><span class="line">            phone.call();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>暂停一会，介绍两个简单的概念。产品等级和产品家族</p>
<blockquote>
<p><strong>产品等级：</strong>产品等级指的是相同类型的产品。<br>比如，我们使用的手机有小米手机、华为手机、苹果手机这些都是同一产品等级。<br><strong>产品家族：</strong>产品家族指的是不同产品等级构成的一组产品。<br>比如，上面的这些手机厂商不仅生产手机还生产电脑，那么小米手机和小米电脑构成一个产品家族，华为手机和华为电脑构成一个产品家族，苹果手机和苹果电脑构成一个产品家族</p>
</blockquote>
<hr>
<h1 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h1><p>定义：工厂方法模式（FACTORY METHOD）是一种常用的类创建型设计模式，此模式的核心精神是封装类中变化的部分，提取其中个性化善变的部分为独立类，通过依赖注入以达到解耦、复用和方便后期维护拓展的目的。它的核心结构有四个角色，分别是抽象工厂；具体工厂；抽象产品；具体产品。（<a href="https://baike.baidu.com/item/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/2361103?fr=aladdin">百度百科</a>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象手机类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 手机具体实现类 - 完成手机具体功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">extends</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;使用苹果手机打电话&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MI</span> <span class="keyword">extends</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;使用小米手机打电话&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">PhoneFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Phone <span class="title function_">getPhone</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象工厂实现类 - 创建具体的手机对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppleFactory</span> <span class="keyword">extends</span> <span class="title class_">PhoneFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">getPhone</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Apple</span>(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MIFactory</span> <span class="keyword">extends</span> <span class="title class_">PhoneFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">getPhone</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MI</span>(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PhoneFactory</span> <span class="variable">phoneFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AppleFactory</span>();</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> phoneFactory.getPhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类图：<br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20200814235206.png" alt="20200814235206"></p>
<p><strong>小结：</strong></p>
<ol>
<li>如果是需要切换具体的实例时只需要在客户端中修改具体的工厂的实例 <code>PhoneFactory phoneFactory = new AppleFactory();</code> 也就是这行代码，修改实现的 <code>AppleFactory()</code> 为新的工厂。</li>
<li>工厂方法模式可以很容易实现对产品等级的扩展，比如现在要新增一个华为手机，只要创建一个华为手机类继承<code>Phone</code>由这个类来实现具体的华为手机功能，再创建一个华为手机的工厂类继承<code>PhoneFactory</code>，实现具体的创建华为手机的工作。扩展产品等级只需要这两步就可以完成了。</li>
<li>如果引入的产品等级过多，则会产生大量的类，不便于阅读代码。</li>
</ol>
<blockquote>
<p>需求：创建一款新的手机HUAWEI，并将原有的苹果手机换成华为手机</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 华为手机类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HUAWEI</span> <span class="keyword">extends</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;使用华为手机打电话&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 华为手机的工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HUAWEIFactory</span> <span class="keyword">extends</span> <span class="title class_">PhoneFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">getPhone</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HUAWEI</span>(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PhoneFactory</span> <span class="variable">phoneFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HUAWEIFactory</span>();</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> phoneFactory.getPhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h1><p>定义：抽象工厂是一种常见的设计模式。此模式为一个产品家族提供了统一的创建接口。当需要这个产品家族的某一系列的时候，可以从抽象工厂中选出相对系的系列来创建一个具体的工厂类别。（<a href="https://baike.baidu.com/item/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/5686668?fr=aladdin">百度百科</a>）</p>
<blockquote>
<p>需求：引入一个新的产品等级（电脑）与原有的手机组合成产品家族，实现对产品家族的扩展</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 产品家族中的各个产品等级抽象类和实现 //</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 电脑抽象类 - 产品等级为电脑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">calculation</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 手机抽象类 - 产品等级为手机</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 华为实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HUAWEIComputer</span> <span class="keyword">extends</span> <span class="title class_">Computer</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calculation</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;使用华为电脑计算&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HUAWEIPhone</span> <span class="keyword">extends</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;使用华为手机打电话&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 小米实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MIComputer</span> <span class="keyword">extends</span> <span class="title class_">Computer</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calculation</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;使用小米电脑计算&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MIPhone</span> <span class="keyword">extends</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;使用小米手机打电话&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 顶层电子产品抽象工厂 - 将以下产品家族统称为电子产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ElectronicProductFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Phone <span class="title function_">getPhone</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Computer <span class="title function_">getComputer</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体的实现工厂 - 实现的是产品家族工厂（比如：华为产品家族、小米产品家族）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HUAWEIFactory</span> <span class="keyword">extends</span> <span class="title class_">ElectronicProductFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">getPhone</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HUAWEIPhone</span>(); &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Computer <span class="title function_">getComputer</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HUAWEIComputer</span>(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MIFactory</span> <span class="keyword">extends</span> <span class="title class_">ElectronicProductFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">getPhone</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MIPhone</span>(); &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Computer <span class="title function_">getComputer</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MIComputer</span>(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ElectronicProductFactory</span> <span class="variable">electronicProductFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MIFactory</span>();</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">miPhone</span> <span class="operator">=</span> electronicProductFactory.getPhone();</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">miComputer</span> <span class="operator">=</span> electronicProductFactory.getComputer();</span><br><span class="line">        miPhone.call();</span><br><span class="line">        miComputer.calculation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类图：<br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20200815223416.png" alt="20200815223416"></p>
<blockquote>
<p>需求：引入新的苹果产品家族，将客户端的小米产品更换为苹果产品</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 苹果工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppleFactory</span> <span class="keyword">extends</span> <span class="title class_">ElectronicProductFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Phone <span class="title function_">getPhone</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApplePhone</span>(); &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Computer <span class="title function_">getComputer</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AppleComputer</span>(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 苹果产品等级实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppleComputer</span> <span class="keyword">extends</span> <span class="title class_">Computer</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calculation</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;使用苹果电脑计算&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplePhone</span> <span class="keyword">extends</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;使用苹果手机打电话&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ElectronicProductFactory</span> <span class="variable">electronicProductFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AppleFactory</span>();</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">miPhone</span> <span class="operator">=</span> electronicProductFactory.getPhone();</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">miComputer</span> <span class="operator">=</span> electronicProductFactory.getComputer();</span><br><span class="line">        miPhone.call();</span><br><span class="line">        miComputer.calculation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小结：</strong></p>
<ol>
<li>抽象工厂针对于共产方法的扩展更方便了产品家族的扩展，如果是在工厂方法中将产品等级组合成产品家族的话需要修改大量的代码，有兴趣的同学可以试试使用工厂方法去将产品等级组合成产品家族。而使用抽象工厂扩展产品家族的话就变得很方便，新增新的产品家族和产品家族工厂即可。</li>
<li>如果在抽象工厂内部的产品家族中要实现对产品等级的扩展则会非常麻烦，需要修改大量的代码，而使用工厂方法去扩展产品等级则非常简单。</li>
</ol>
<p>总结：<br>针对产品等级和产品家族，工厂方法和抽象工厂各有各的优点和缺点，在真实的开发中需要根据实际的业务场景去选择适合的设计模式去完成相应的需求，切记不要为了使用某一种设计模式而过度的设计自己的代码。<br><u>刚刚好的才是最美</u>，代码如此，人生亦是如此。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构：链表</title>
    <url>/posts/29990/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果上一篇文章实现的动态数组，由于底层任然是使用的静态数组，而不是真正意义上的<strong>动态数据结构</strong>的话。那么本文的链表则肯定是一个真真正正意义上的动态的数据结构了。</p>
<span id="more"></span>
<p>我还记得在读书时老师曾经给我们举过一个非常好的例子用于演示链表和数组在增删改查种各自的优缺点。在这里我把它分享出来给大家</p>
<blockquote>
<p>一个班级假设有50个学生，现在使用数组和链表来分别承载这50个学生。<br>然后模拟两种场景来分别对比这两种数据结构的优缺点<br><strong>数组：</strong>将这50个学生按照顺序排号，从0开始到49（这里模拟的是数组的下标）<br><em><strong>像这样 [0, 1, 2, 3, …, 49]</strong></em><br><strong>链表：</strong>将50个学生叫到操场排好队，每个学生去记住自己后面一个学生，记录排第一的同学（链表头）。<br><em><strong>像这样 (0) -&gt; (1) -&gt; (2) -&gt; (3) -&gt; … -&gt; (49)</strong></em><br>原谅我懒得画图。。。</p>
</blockquote>
<p><strong>场景一：</strong>老师在办公室想要叫某个学生到办公室去（模拟数据的查询）<br><strong>数组：</strong>直接在班级表种去查这个学生对应的序号，根据序号就可以很快速的找到这个学生。<br><strong>链表：</strong>由于没有序号，需要一个个学生去查找，首先找到链表头同学，比较是不是老师叫的学生，如果是则去办公室找老师。如果不是，则去找链表头同学所记住的后面一个同学，再进行对比。如果还不是则再去寻找这个同学记忆的下一个同学之后再进行比对，直到找到这个同学为止。</p>
<p><strong>场景二：</strong>班上来了一个新的插班生，插班生必须安排在班级的第一个位置（模拟数据的添加和删除）<br><strong>数组：</strong>由于每个学生的序号都是按照顺序排好的，所以不能直接插入在第一个学生之前，必须是要占用第一个学生的位置。所以要将全部的学生重新排号，插班生排0号，剩下的学生按照原来的号码依次加1往后排序。<br><strong>链表：</strong>让这个插班生去记住第一个同学也就是原理啊的链表头，再成为新的链表头。其他的学生完全不受影响。</p>
<p>通过以上两个场景的展现可以很清晰的看出来链表和数组各自的优缺点在哪里。链表增删快，而数组查询快。</p>
<h1 id="设计节点类"><a href="#设计节点类" class="headerlink" title="设计节点类"></a>设计节点类</h1><p>链表中的数据实际上是一个个的节点，在Java中使用一个节点类（Node）来表示。在节点类中有两个变量，一个是当前节点的值，另一个是指向下一个节点的指针。<br>由此每个节点中都有一个指向下一个节点的指针，最后一个节点指向下一个节点的指针就置为空。以此一节一节的链接起来，也就成了链表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">// 节点本身的值（支持泛型）</span></span><br><span class="line">    <span class="keyword">public</span> E e;</span><br><span class="line">    <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(E e, Node next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.e = e;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(E e)</span> &#123; <span class="built_in">this</span>(e, <span class="literal">null</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> &#123; <span class="built_in">this</span>(<span class="literal">null</span>, <span class="literal">null</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> e.toString(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="设计链表的成员变量和构造方法"><a href="#设计链表的成员变量和构造方法" class="headerlink" title="设计链表的成员变量和构造方法"></a>设计链表的成员变量和构造方法</h1><p>我们先来考虑一下怎么去设计链表类中的成员变量再来看看怎么设计构造函数</p>
<p>首先我们需要一个变量可以表示当前链表中共有多少个节点，也就是链表的大小。size变量是没跑了。<br>另外回顾一下刚刚的例子，在哪个班级中如果老师需要找到一个班级中的某个确定的学生时，第一个找的其实是链表头同学，根据链表头去一个个找下去直到找到为止。<br>所以在我们设计的链表类中需要一个头节点的指针，定义一个<strong>Node变量</strong>作为指针。</p>
<p>刚刚的例子中场景二来一个插班生我们将插班生插在了第一个位置。直接让插班生去记住原来的链表头再将链表头指向插班生。设想一下，如果是插入在链表的中间呢？<br>比如插入在第二个学生的位置。需要插班生去记住原来的第二个同学，再让原来的第一个同学把记忆的第二个同学换成插班生同学。也就是说如果是插入在中间的元素要多一步让前面的同学去记插班生同学，而插入在第一个则不需要。</p>
<p>针对上面的情况我们可以设置一个虚拟的头节点来解决这个问题。这个虚拟的节点来指向我们链表中真正的第一个节点，对外呢，屏蔽这个节点的存在。故此我们将上面决定要定义的<strong>Node变量</strong>改成<strong>dummyHead</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"><span class="keyword">private</span> Node dummyHead; <span class="comment">// 虚拟头节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">    dummyHead = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方便用户传入一个数组将其转换成链表的构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">(E[] arrayE)</span> &#123;</span><br><span class="line">    dummyHead = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    size = arrayE.length;</span><br><span class="line"></span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arrayE.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        cur.next = <span class="keyword">new</span> <span class="title class_">Node</span>(arrayE[i], cur.next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设计两个方便使用的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123; <span class="type">return</span> <span class="variable">size</span> <span class="operator">=</span>= <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>

<h1 id="链表中插入元素"><a href="#链表中插入元素" class="headerlink" title="链表中插入元素"></a>链表中插入元素</h1><p>我们来研究一下前面的例子是怎么在一个班级中插入插班生的。</p>
<blockquote>
<p>首先，得要有一个插班生，这个不用想肯定是必须的，好了，插入功能核心代码的<strong>第一步</strong>也就出来了。<br>然后我们得要去找到插班生要插入的位置，在这里呢我们虚拟一个index（下标）的概念出来，方便用户指定要插入的位置，核心功能的<strong>第二步</strong>也就出来了。<br>找到位置也有插班生之后的问题就是要把插班生插入到班级里面去啦，这个事情要怎么做呢。<br>比方说我现在是要插入到第二个位置去，那么我需要先让插班生去记忆原来的第二个位置的同学，这也是<strong>第三步</strong>。<br>然后让第一个同学不要去记原来的第二个同学了，换成是插班生同学，<strong>第四步</strong>。<br>到此为止，这个插入的动作就完成了。</p>
</blockquote>
<p>将上面的各个步骤以程序的方式重新梳理一遍<br>第一步：创建一个新的节点 <code>new Node()</code><br>第二步：使用一个for循环找到要插入位置的前一个节点和后一个节点<br>第三步：将第一步创建出来的节点的<code>next</code>指针指向第二步找出来的后一个节点<br>第四步：将第二步找出来的前一个节点的<code>next</code>指针指向第一步创建的节点</p>
<p>将上面的逻辑组织一下换成Java语言</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 下标的校验，不属于插入的核心代码</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;index &quot;</span> + index + <span class="string">&quot; 不合法, 当前size = &quot;</span> + size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一步</span></span><br><span class="line">    Node node= <span class="keyword">new</span> <span class="title class_">Node</span>(e);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步：</span></span><br><span class="line">    <span class="comment">// 使用一个prev变量去作为一个中间量去寻找要插入的节点位置</span></span><br><span class="line">    <span class="comment">// 这里的prev就是前一个节点，由于还没有插入，所以prev.next就是要插入的后一个节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        prev = prev.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三步</span></span><br><span class="line">    node.next = prev.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第四步</span></span><br><span class="line">    prev.next = node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护一下size变量</span></span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上便是添加操作的方法，但这还不是最好。</p>
<p>上面的代码虽说是完成了这个添加动作的逻辑，也能够顺顺利利的运行起来，但这还不够优雅。<br>实际上我们可以将第一步、第三步和第四步合并成一行代码<br>创建一个新的节点直接将<code>prev.next</code>赋值给新节点的<code>next</code>，再直接赋值给<code>prev.next</code>。<br>像下面这个样子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;index &quot;</span> + index + <span class="string">&quot; 不合法, 当前size = &quot;</span> + size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        prev = prev.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原来的第一步、第二步和第四步</span></span><br><span class="line">    prev.next = <span class="keyword">new</span> <span class="title class_">Node</span>(e, prev.next);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>插一句题外话<br>其实编写程序，就是像上面这样子一步一步去考虑出这个程序核心代码的步骤。<br>然后再把这个简单的按照程序逻辑梳理一遍，再开始实际编码。也恰恰是这两步才是最关键的，而不是编码，有了梳理完的逻辑实际编码起来码随心动倒还是个挺舒服的过程。<br>最后再审视一遍自己写出来的代码，看看有没有地方可以改进，可以写的更加的优雅一些</p>
</blockquote>
<hr>
<h1 id="删除链表中的元素"><a href="#删除链表中的元素" class="headerlink" title="删除链表中的元素"></a>删除链表中的元素</h1><p>我们来换个方式写删除操作，在前面的添加操作中我们设置了一个虚拟的index表示的是下标，作用是方便用户操作。在删除的这一小节我们不使用这个index我们假设用户能够直到自己要删除的元素，直接传入待删除元素，然后程序将其删除即可。</p>
<p>删除元素实际上就是添加元素的逆向操作，找到待删除节点的前一个节点，将这个节点直接指向待删除元素的后一个节点即可删除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 找到要删除元素的前一个元素</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">    <span class="keyword">while</span>(!prev.next.e.equals(e)) &#123;</span><br><span class="line">        prev = prev.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将要删除元素前一个元素的指针直接指向要删除元素的后一个元素</span></span><br><span class="line">    prev.next = prev.next.next;</span><br><span class="line"></span><br><span class="line">    size--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将上面的代码使用递归的方式写出来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    remove(e, dummyHead);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(E e, Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.next.e.equlas(e)) &#123;</span><br><span class="line">        node.next = node.next.next;</span><br><span class="line">        size --;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    remove(e, node.next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上链表这样的数据结构天然的适合递归，在很多场合都可以使用递归去操作一个链表。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构：动态数组</title>
    <url>/posts/714/</url>
    <content><![CDATA[<p>本文将讲述一个动态数组的实现过程，由于动态数组其实是一种比较简单的数据结构。所以本文将会以代码展示为主，当然，难点也是会重点讲述。</p>
<span id="more"></span>

<h1 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h1><blockquote>
<p>将要实现一个Array类来承载动态数组这种数据结构。动态数组的底层也是使用Java中的静态数组去实现的，之所以动态是因为这其中可以自动的扩容和扩容和缩容的操作。</p>
</blockquote>
<ol>
<li>准备一个静态的数组和一个记录动态数组大小的变量<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> E[] data;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></figure></li>
<li>准备构造方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Array</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    data = (E[]) <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Array</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>设计一些方便用户的方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取数组中元素的个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数组的容量</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCapacity</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> data.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回数组是否为空</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">return</span> <span class="variable">size</span> <span class="operator">=</span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
准备工作结束。</li>
</ol>
<h1 id="二、设计扩容和缩容的方法"><a href="#二、设计扩容和缩容的方法" class="headerlink" title="二、设计扩容和缩容的方法"></a>二、设计扩容和缩容的方法</h1><p>Java中的数组一旦被初始化之后就再也无法改变它的容量了，所以我们只能够是通过创建一个新的数组，在新数组中开辟出我们想要的空间，然后再将原来的数组全部搬到这个新数组中，以此来实现动态数组。严谨一些的话这并不是真正意义上的动态数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现动态的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity 新数组的容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建新数组</span></span><br><span class="line">    E[] newData = (E[]) <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将元素复制到新数组中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        newData[i] = data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将data指向新数组</span></span><br><span class="line">    data = newData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、添加元素"><a href="#三、添加元素" class="headerlink" title="三、添加元素"></a>三、添加元素</h1><p>向数组中的任意位置添加元素，需要将这个位置之后的所有元素都往后挪动一个位置，来腾出这个位置以供新的元素添加进来。<br>重点就是在于这个「挪」的实现，我们需要从最后一个元素开始一个个的往后挪一位，这样才不会覆盖到原有的元素。</p>
<blockquote>
<p>注意：在添加元素的时候我们是有可能会超出现有数组的边界的，不进行处理的话就会抛出下标越界的异常。<br>动态数组就是为了解决这个问题而存在的，自动的判断是否需要扩容操作，为用户屏蔽掉下标越界的问题，用户只管插入而不需要担心容量问题。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向数组中的任意位置添加元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 任意位置的下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 要添加的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;数组下标 &quot;</span> + index + <span class="string">&quot; 不合法, 当前size = &quot;</span> + size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否需要进行扩容操作</span></span><br><span class="line">    <span class="keyword">if</span> (size == data.length) </span><br><span class="line">        resize(data.length * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挪动元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size; i &gt; index; i--) </span><br><span class="line">        data[i] = data[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素，维护size变量</span></span><br><span class="line">    data[index] = e;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设计两个方便用户操作的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向所有元素后添加一个新元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span> &#123; add(size, e); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向所有元素前添加一个新元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span> &#123; add(<span class="number">0</span>, e); &#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、删除元素"><a href="#四、删除元素" class="headerlink" title="四、删除元素"></a>四、删除元素</h1><p>这其实跟添加元素是一样的，只是反过来而已。删除数组中任意位置的元素，需要将这个位置之后的所有元素都往前挪动一个位置。一个个的覆盖掉前面的元素。<br>在这里需要从要删除元素的后一位开始挪，一直往后挪到最后一位元素。</p>
<blockquote>
<p>注意：在删除元素时，如果数组中剩下的空间太多了，这时我们需要触发缩容操作，以免造成太多内存的浪费。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除数组中的任意元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 要删除元素的下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> E 删除的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;数组下标 &quot;</span> + index + <span class="string">&quot; 不合法, 当前size = &quot;</span> + size);</span><br><span class="line">    </span><br><span class="line">    <span class="type">E</span> <span class="variable">removeE</span> <span class="operator">=</span> data[index];</span><br><span class="line">    <span class="comment">// 挪动元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        data[i] = data[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">// 判断是否缩容</span></span><br><span class="line">    <span class="keyword">if</span> (size == data.length / <span class="number">4</span> &amp;&amp; data.length / <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        resize(data.length / <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> removeE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在扩容的时候是扩容成原来数组的两倍的大小，但是缩容时确实缩容成数组的四分之一大小。<br>这是为了防止用户在添加删除元素时刚好是在原来数组容量大小的附近进行的，则不断的会去触发扩容和缩容的操作，而这会更多的消耗资源。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于动态数组，以上的几个方法就是其中最主要的方法了，其他的一些例如查询元素和修改元素相对而言比较简单，也没什么好说的，本文也就省略不提。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>线程安全和死锁</title>
    <url>/posts/10492/</url>
    <content><![CDATA[<h1 id="什么是线程安全？"><a href="#什么是线程安全？" class="headerlink" title="什么是线程安全？"></a>什么是线程安全？</h1><p>当多个线程修改同一个共享变量的时候，如果对该变量修改的结果不能确定，那么称：<strong>该变量线程不安全</strong>。</p>
<p>比如这个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共享变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 对共享变量的修改</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100_000</span>; i++) &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123; &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;num = &quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然最后的打印结果不会跟预期结果一样，两个线程同时对一个变量 num 做十万次 ++ 操作，最后的结果 num 应该是等于二十万才对。</p>
<p>但是上面的程序最终结果都是在 [100_000, 200_000] 这个区间内的，显然与预期结果不符。</p>
<p>为什么不符合预期，其实原因很简单：</p>
<blockquote>
<p>上面代码 <code>num++</code> 的这行语句在执行的时候是有三个步骤的，如下：</p>
<ol>
<li>将 num 的值读到缓存中</li>
<li>将 num 的值加1</li>
<li>将 num 的值写回内存</li>
</ol>
</blockquote>
<p>上述例子中，两个线程同时都在执行 <code>num++</code> 的操作，也就是同时在执行这三个步骤，如果 t1 和 t2 同时都执行了第1步，拿到 num 的值为<code>1</code>；再往下执行第二步，t1 和 t2 都把 num 的值从<code>1</code>加到<code>2</code>；最后 t1 和 t2 再把 num 的值写回内存，此时 num 的值为<code>2</code>。</p>
<p>但也有不出错的情况，那最后 num 的结果就是<code>3</code>，num 最后的值具体是<code>2</code>还是<code>3</code>不好确定，所以称变量 num 线程不安全。</p>
<p><strong>num 的范围：</strong></p>
<p>既然 num 变量线程不安全，但也总是会有一个范围，这个范围由执行出错的“次数”维护。</p>
<p>最大值：如果每次执行都没出错，结果都是确定的两个线程都成功加<code>1</code>，那结果就是 <code>num = 200,000</code>，也就是上述这个例子中num的最大值。</p>
<p>最小值：相反如果每次执行都出错了，两个线程的执行结果总是只保存了一个下来，那结果就是 <code>num = 100,000</code>，也就是上述这个例子中num的最小值。</p>
<h1 id="怎样才能线程安全？"><a href="#怎样才能线程安全？" class="headerlink" title="怎样才能线程安全？"></a>怎样才能线程安全？</h1>]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>Nginx 安装和配置</title>
    <url>/posts/62048/</url>
    <content><![CDATA[<p>记录一些 Nginx 的安装步骤、配置项信息等，主要为了方便自己后续查看，如果能帮到其他人就更好了。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="二进制安装"><a href="#二进制安装" class="headerlink" title="二进制安装"></a>二进制安装</h2><h3 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a>依赖安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install gcc-c++ pcre pcre-devel slib zlib-devel openssl openssl-devel</span><br></pre></td></tr></table></figure>

<h3 id="下载解压"><a href="#下载解压" class="headerlink" title="下载解压"></a>下载解压</h3><p>从官网<a href="http://nginx.org/en/download.html">下载</a> Nginx，各个版本区别：</p>
<ul>
<li>Mainline version：开发版本</li>
<li>Stable version：最新稳定版本</li>
<li>Legacy versions：历史版本</li>
</ul>
<p>推荐大家下载最新稳定版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.20.1.tar.gz</span><br></pre></td></tr></table></figure>

<p>下载完成后解压即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf nginx-1.20.1.tar.gz</span><br></pre></td></tr></table></figure>

<h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><p>首先需要配置安装参数，在安装目录下通过 <code>configure</code> 文件进行配置，如果全部使用默认的配置的话可以直接运行 <code>./configure</code>。</p>
<p><strong>参数说明</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>- - prefix</td>
<td>指定 nginx 安装目录</td>
</tr>
<tr>
<td>- - pid-path</td>
<td>指定 nginx 的pid</td>
</tr>
<tr>
<td>- - lock-path</td>
<td>锁定安装文件，防止而已篡改或者误操作</td>
</tr>
<tr>
<td>- - error-log</td>
<td>错误日志</td>
</tr>
<tr>
<td>- - http-log-path</td>
<td>http 日志</td>
</tr>
<tr>
<td>- - with-http_gzip_static_module</td>
<td>启用 gzip 模块，在线实时压缩输出数据流</td>
</tr>
<tr>
<td>- - http-client-body-temp-path</td>
<td>设定客户端请求的临时目录</td>
</tr>
<tr>
<td>- - http-proxy-temp-path</td>
<td>设定 http 代理临时目录</td>
</tr>
<tr>
<td>- - http-fastcgi-temp-path</td>
<td>设定 fastcgi 临时目录</td>
</tr>
<tr>
<td>- - http-uwsgi-temp-path</td>
<td>设定 uwsgi 临时目录</td>
</tr>
<tr>
<td>- - http-scgi-temp-path</td>
<td>设定 scgil 临时目录</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./configure \</span><br><span class="line">--pid-path=/var/run/nginx.pid \</span><br><span class="line">--error-log-path=/var/log/nginx/error.log \</span><br><span class="line">--http-log-path=/var/log/nginx/access.log</span><br></pre></td></tr></table></figure>

<p>如果配置 https 访问的话，需要在编译时添加 <code>http_v2_module</code> 和 <code>http_ssl_module</code> 这两个模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./configure \</span><br><span class="line">--pid-path=/var/run/nginx.pid \</span><br><span class="line">--error-log-path=/var/log/nginx/error.log \</span><br><span class="line">--http-log-path=/var/log/nginx/access.log \</span><br><span class="line">--with-http_v2_module \</span><br><span class="line">--with-http_ssl_module</span><br></pre></td></tr></table></figure>

<p><strong>编译安装</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make &amp;&amp; make install </span><br></pre></td></tr></table></figure>

<h3 id="启动测试"><a href="#启动测试" class="headerlink" title="启动测试"></a>启动测试</h3><p>在安装目录的 <code>sbin</code> 目录下执行 <code>./ngnix</code> 就可以将 Nginx 的服务成功启动起来。</p>
<p><strong>踩坑提醒：</strong></p>
<ol>
<li><p>如果在配置时是直接运行的 <code>./configure</code> 可能会报 <code>error.log</code> 和 <code>access.log</code> 这两个日志文件找不到，直接按照提示创建这两个文件即可启动 nginx。</p>
</li>
<li><p>如果启动403错误的话，可以查看 nginx 的启动线程是哪个用户然后在配置文件中修改 user 的值为改成哪个用户。</p>
</li>
</ol>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>编辑 <code>/etc/profile</code> 文件，在最后添加以下代码即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=$PATH:&quot;nginx 安装目录&quot;/sbin</span><br></pre></td></tr></table></figure>

<p>保存退出后再执行一下 <code>source /etc/profile</code> 使配置生效。</p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><table>
<thead>
<tr>
<th>说明</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>启动</td>
<td><code>nginx</code></td>
</tr>
<tr>
<td>暴力停止</td>
<td><code>nginx -s stop</code></td>
</tr>
<tr>
<td>平滑停止</td>
<td><code>nginx -s quit</code></td>
</tr>
<tr>
<td>重新加载配置文件</td>
<td><code>nginx -s reload</code></td>
</tr>
<tr>
<td>验证配置文件</td>
<td><code>nginx -t</code></td>
</tr>
</tbody></table>
<h2 id="yum-源安装"><a href="#yum-源安装" class="headerlink" title="yum 源安装"></a>yum 源安装</h2><h3 id="添加-nginx-到-yum-源"><a href="#添加-nginx-到-yum-源" class="headerlink" title="添加 nginx 到 yum 源"></a>添加 nginx 到 yum 源</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br></pre></td></tr></table></figure>

<h3 id="使用-yum-安装-nginx"><a href="#使用-yum-安装-nginx" class="headerlink" title="使用 yum 安装 nginx"></a>使用 yum 安装 nginx</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y nginx</span><br></pre></td></tr></table></figure>

<h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><table>
<thead>
<tr>
<th>说明</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>启动</td>
<td><code>systemctl start nginx</code></td>
</tr>
<tr>
<td>停止</td>
<td><code>systemctl stop nginx</code></td>
</tr>
<tr>
<td>重启</td>
<td><code>systemctl restart nginx</code></td>
</tr>
<tr>
<td>开机启动</td>
<td><code>systemctl enable nginx</code></td>
</tr>
<tr>
<td>查看 nginx 状态</td>
<td><code>systemctl status nginx</code></td>
</tr>
<tr>
<td>指定配置文件启动</td>
<td><code>nginx -c nginx.conf</code></td>
</tr>
</tbody></table>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><ul>
<li>网站文件存放默认目录：<code>/usr/share/nginx/html</code></li>
<li>网站默认站点配置：<code>/etc/nginx/conf.d/default.conf</code></li>
<li>自定义 nginx 站点配置文件存放目录：<code>/etc/nginx/conf.d/</code></li>
<li>nginx 全局配置：<code>/etc/nginx/nginx.conf</code></li>
</ul>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><blockquote>
<p>小操作：<br>为了方便管理，配置可以不直接写入 <code>nginx.conf</code> 文件。在外面写 <code>.conf</code> 配置文件，之后在 <code>nginx.conf</code> 文件中引入 <code>include myconf/*.conf;</code></p>
</blockquote>
<h2 id="运行配置"><a href="#运行配置" class="headerlink" title="运行配置"></a>运行配置</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">user root;                # 指定运行 worker 进程的用户</span><br><span class="line">worker_processes  3;      # worker 进程的数量</span><br><span class="line"></span><br><span class="line"># 日志文件输出配置 可根据日志级别输出到不同的日志文件中</span><br><span class="line"># error_log  logs/error.log;</span><br><span class="line"># error_log  logs/error.log  notice;</span><br><span class="line"># error_log  logs/error.log  info;</span><br><span class="line"></span><br><span class="line">pid  logs/nginx.pid;  # 指定 pid</span><br><span class="line"></span><br><span class="line"># 工作模式</span><br><span class="line">events &#123;</span><br><span class="line">    use epoll;                 # 默认使用 epoll，采用异步非阻塞的处理方式</span><br><span class="line">    worker_connections  1024;  # 每个 worker 进程的客户端最大连接数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="传输配置"><a href="#传输配置" class="headerlink" title="传输配置"></a>传输配置</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    # 导入请求类型</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    # 日志格式，main 为格式的名称，可以通过 main 来指定输出此日志格式。</span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">    # 定义日志输出格式</span><br><span class="line">    access_log  logs/access.log  main;</span><br><span class="line"></span><br><span class="line">    # sendfile 高效传输文件，开启可提升传输性能，</span><br><span class="line">    # 开启后才可以使用 tcp_nopush，当数据累积到一定大小后才发送，提高了效率</span><br><span class="line">    sendfile      on;</span><br><span class="line">    tcp_nopush    on;</span><br><span class="line"></span><br><span class="line">    # 设置客户端与服务端请求的超时时间，保证客户端多次请求的时候不会重复建立新的连接，节约资源资源损耗</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    gzip  on; # 启用 gzip 压缩，静态资源文件压缩后传输会更快一些</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>日志格式：</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>$remote_addr</td>
<td>客户端IP</td>
</tr>
<tr>
<td>$remote_user</td>
<td>远程客户端用户名，一般为：’-‘</td>
</tr>
<tr>
<td>$time_local</td>
<td>时间和时区</td>
</tr>
<tr>
<td>$request</td>
<td>请求的 url 和 method</td>
</tr>
<tr>
<td>$status</td>
<td>响应状态码</td>
</tr>
<tr>
<td>$body_bytes_send</td>
<td>响应客户端内容字节数</td>
</tr>
<tr>
<td>$http_referer</td>
<td>记录用户从哪个链接跳转过来的</td>
</tr>
<tr>
<td>$http_user_agent</td>
<td>用户所使用的代理，一般情况下为浏览器</td>
</tr>
<tr>
<td>$http_x_forwarded_for</td>
<td>通过代理服务器来记录客户端的IP</td>
</tr>
</tbody></table>
<h2 id="虚拟主机配置"><a href="#虚拟主机配置" class="headerlink" title="虚拟主机配置"></a>虚拟主机配置</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># 虚拟主机配置块，位于 http 块中</span><br><span class="line">server &#123;</span><br><span class="line">    listen      80;         # 监听端口</span><br><span class="line">    server_name localhost;  # 请求域名</span><br><span class="line"></span><br><span class="line">    # 设置请求头，一般用于解决跨域问题</span><br><span class="line">    add_header &#x27;Access-Control_Allow_Origin&#x27; *;             # 允许跨域请求的域</span><br><span class="line">    add_header &#x27;Access-Control_Allow_Credentials&#x27; &#x27;true&#x27;;   # 允许带上 cookie 请求</span><br><span class="line">    add_header &#x27;Access-Control_Allow_Methods&#x27; *;            # 允许请求的方法（GET/POST/PUT/DELETE）</span><br><span class="line">    add_header &#x27;Access-Control_Allow_Headers&#x27; *;            # 允许请求的 header</span><br><span class="line"></span><br><span class="line">    # 对源站点进行验证（防盗链）</span><br><span class="line">    valid_referers *.wrp.cool;</span><br><span class="line">    if ($valid_referers) &#123;</span><br><span class="line">        return 403;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 请求路由映射，匹配拦截</span><br><span class="line">    location / &#123;</span><br><span class="line">        root        html;           # 网站根路径（配置负载均衡之后不需要配置根路径）</span><br><span class="line">        index       index.html;     # 默认首页</span><br><span class="line">        expires     10s;            # 设置缓存</span><br><span class="line">        # alias 可以为请求路径配置一个别名</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # ssl 证书配置</span><br><span class="line">    ssl on                              # 开启ssl</span><br><span class="line">    ssl_certificate &quot;ssl证书路径&quot;;       # 配置 ssl 证书</span><br><span class="line">    ssl_certificate_key &quot;ssl证书路径&quot;;   # 配置 ssl 证书密钥</span><br><span class="line">    ssl_session_cache shared:SSL:10m;   # ssl 会话 cache</span><br><span class="line">    ssl_session_timeout 10m;            # ssl 会话超时时间</span><br><span class="line">    </span><br><span class="line">    # 配置加密套件</span><br><span class="line">    ssl_protocols TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>location 的匹配规则：</strong></p>
<ul>
<li><code>空格</code>：普通匹配</li>
<li><code>=</code>：精确匹配</li>
<li><code>~*</code>：匹配正则表达式，不区分大小写</li>
<li><code>~</code>：匹配正则表达式，区分大小写</li>
<li><code>^~</code>：以某个字符路径开头</li>
</ul>
<p><strong>expires 指令</strong></p>
<ul>
<li><code>expires 10s</code>：10s之后过期</li>
<li><code>expires @22h30m</code>：22h30m这个时间点之后过期</li>
<li><code>expires -1h</code>：一个小时之前就过期了</li>
<li><code>expires epoch</code>：关闭缓存</li>
<li><code>expires off</code>：使用浏览器默认缓存</li>
</ul>
<h2 id="负载均衡配置"><a href="#负载均衡配置" class="headerlink" title="负载均衡配置"></a>负载均衡配置</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">    # 负载均衡配置快</span><br><span class="line">    upstream load_balance &#123;</span><br><span class="line">        </span><br><span class="line">        # 使用 ip hash 作为负载均衡算法，使用 ip hash 算法之后不能把服务器直接移除，只能标记为 down</span><br><span class="line">        ip_hash;</span><br><span class="line"></span><br><span class="line">        # 使用 url hash 作为负载均衡算法</span><br><span class="line">        hash $request_uri;</span><br><span class="line"></span><br><span class="line">        # 使用 least_conn 作为负载均衡算法，哪台服务器连接数少就去请求哪台服务器</span><br><span class="line">        least_conn;</span><br><span class="line"></span><br><span class="line">        # 配置上游服务器</span><br><span class="line">        server localhost:81;</span><br><span class="line">        server localhost:82;</span><br><span class="line">        server localhost:83;</span><br><span class="line"></span><br><span class="line">        # 常链接数量，用于提高网络吞吐量，相当于连接池</span><br><span class="line">        keepalive   32;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 将一些负载均衡节点中的静态资源文件缓存在nginx服务器当中</span><br><span class="line">    proxy_cache_path /usr/local/cache # 指令设置缓存保存的目录</span><br><span class="line">    keys_zone=mycache:5m              # 指令设置共享缓存空间的名称和索引信息大小</span><br><span class="line">    max_size=1g                       # 指令指定缓存大小</span><br><span class="line">    inactive=1h                       # 指令指定超过这个时间则清理此缓存</span><br><span class="line">    use_temp_path=off;                # 指令指定临时目录，使用后会影响 nginx 性能</span><br><span class="line"></span><br><span class="line">    # 拦截请求使用负载均衡</span><br><span class="line">    server &#123;</span><br><span class="line">        listen      80;         # 监听端口</span><br><span class="line">        server_name localhost;  # 请求域名</span><br><span class="line"></span><br><span class="line">        proxy_cache mycache;           # 开启并且使用缓存</span><br><span class="line">        proxy_cache_valid 200 304 8h;  # 指定命中缓存返回码</span><br><span class="line"></span><br><span class="line">        # 请求路由映射，匹配拦截</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://load_balance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>upstream 模块参数：</strong></p>
<ul>
<li><code>weight</code>：配置每台服务器的权重</li>
<li><code>max_conns</code>：配置服务器最大连接数，多个 <code>worker</code> 线程可能会超过指定值</li>
<li><code>slow_start</code>：设置服务器权重从零开始至设置值的时间（付费）</li>
<li><code>down</code>：表示该服务器已经宕机</li>
<li><code>backup</code>：表示该服务器为备用机，所有服务器都无法访问才会访问备用机</li>
<li><code>max_fails</code>：最大失败次数，超过这个次数时，默认该服务器已经宕机。</li>
<li><code>fail_timeout</code>：当超过最大失败次数时，经过多少时间去重新访问这台服务器，默认值为10s。</li>
</ul>
<p><strong>以上参数使用示例：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">upstream load_balance &#123;</span><br><span class="line">    server localhost:81 weight=1 max_conns=200 slow_start=60s;</span><br><span class="line">    server localhost:82 weight=2 max_fails=50 file_timeout=10s;</span><br><span class="line">    server localhost:83 down;</span><br><span class="line">    server localhost:84 backup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>代码段记录</category>
      </categories>
  </entry>
  <entry>
    <title>ES6：扩展知识</title>
    <url>/posts/18551/</url>
    <content><![CDATA[<blockquote>
<p>本文将介绍一些关于ES6的比较基础的比较零碎的知识。</p>
</blockquote>
<span id="more"></span>

<h1 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h1><p>模板字符串在字符串拼接方面比起以前要方便很多。模板字符串的语法是一对反引号 ( &#96;&#96; ) </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name : <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">    age : <span class="number">20</span>,</span><br><span class="line"></span><br><span class="line">    <span class="title function_">say1</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我叫 &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;，今年 &#x27;</span> + <span class="variable language_">this</span>.<span class="property">age</span> + <span class="string">&#x27; 岁了&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="title function_">say2</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`我叫 <span class="subst">$&#123; <span class="variable language_">this</span>.name &#125;</span>，今年 <span class="subst">$&#123; <span class="variable language_">this</span>.age &#125;</span> 岁了`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">say1</span>();</span><br><span class="line">obj.<span class="title function_">say2</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上 say1 和 say2 方法打印的效果完全相同</span></span><br></pre></td></tr></table></figure>
<p>顺带说一下 ES6 中一个比较有用的字符串的方法 includes 方法。判断字符串中是否包含了其他字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">includes</span>(<span class="string">&#x27;o W&#x27;</span>));  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="for-of-循环"><a href="#for-of-循环" class="headerlink" title="for-of 循环"></a>for-of 循环</h1><p>for-of 循环类似于 Java 中的 foreach 循环。来看代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;lisi&#x27;</span>, <span class="string">&#x27;wangwu&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> name <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// zhangsan lisi wangwu</span></span><br></pre></td></tr></table></figure>
<p>也可以用来遍历字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> str) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Hello World!</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="unicode表示法"><a href="#unicode表示法" class="headerlink" title="unicode表示法"></a>unicode表示法</h1><p>ES6 之前 unicode 码点仅可以表示的范围是（0000 - ffff）超出这个范围的将无法表示例如 emoji 表情。ES6 中表示 unicode 的语法是 <code>\u&#123;码点&#125;</code>，这样就可以表示超出范围的码点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;\u&#123;1f436&#125;&#x27;</span>); <span class="comment">// 🐶</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p>箭头函数的标志是一个箭头 <code>=&gt;</code> 就是这个样子，箭头函数可以简化函数的书写过程，使得代码更加简洁。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">add1</span> = (<span class="params">a, b</span>) =&gt; a + b;</span><br><span class="line"><span class="keyword">const</span> add2 = <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add1</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="title function_">add2</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// add1 和 add2 执行的效果相同</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>小提示：如果只有一个参数的情况下是可以不用加括弧的哦</p>
</blockquote>
<p>上面的代码中仅仅只是执行一行代码而已，如果需要执行多行代码，那么需要像下面这样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">add1</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line">    a += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> add2 = <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    a += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add1</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="title function_">add2</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样，add1 和 add2 执行效果相同</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>小技巧：如果我们需要执行一个有返回值的函数但是又不需要函数的返回值，可以在箭头函数的函数体前加 void</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">pop</span> = arr =&gt; <span class="keyword">void</span> arr.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">pop</span>(arr));  <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);  <span class="comment">// 1,2 </span></span><br></pre></td></tr></table></figure>

<h2 id="区别普通函数"><a href="#区别普通函数" class="headerlink" title="区别普通函数"></a>区别普通函数</h2><ol>
<li><p>没有 arguments 对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">log</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">log</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 报错：arguments is not defined</span></span><br></pre></td></tr></table></figure>
<p>小技巧：如果需要使用 arguments 对象可以使用 <code>...参数名</code> 的方式来代替，这里的 <code>...</code> 指的是函数的剩余参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">log</span> = (<span class="params">...args</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">log</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 输出 [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>没有专属的 this 对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">    <span class="title function_">say1</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">say2</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">say1</span>(); <span class="comment">// obj 对象</span></span><br><span class="line">obj.<span class="title function_">say2</span>(); <span class="comment">// window 对象</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以将箭头函数的 this 理解为上一级环境中的 this</p>
</blockquote>
<p> 小技巧：在开发中经常需要去在回调函数中去调用上一级的 this 对象，在这种情况下我们要先将上一级的 this 对象保留下来，例如：</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="title function_">getAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> _this = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用计时器模拟回调函数</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            _this.<span class="property">age</span> = <span class="number">20</span>;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(_this.<span class="property">age</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">getAge</span>(); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<p>上面的代码如果使用箭头函数可以省略掉 <code>let _this = this</code> 的这一步</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="title function_">getAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 使用计时器模拟回调函数</span></span><br><span class="line">        <span class="built_in">setTimeout</span>( <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">20</span>;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">getAge</span>(); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="对象的简洁表示法"><a href="#对象的简洁表示法" class="headerlink" title="对象的简洁表示法"></a>对象的简洁表示法</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不使用简洁表示法</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getUserInfo</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">    <span class="keyword">const</span> age = <span class="number">20</span>,</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">name</span>: name,</span><br><span class="line">        <span class="attr">age</span>: age,</span><br><span class="line">        <span class="attr">say</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用简洁表示法</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getUserInfo</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">    <span class="keyword">const</span> age = <span class="number">20</span>,</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name,</span><br><span class="line">        age,</span><br><span class="line">        <span class="title function_">say</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="对象的新方法和新属性"><a href="#对象的新方法和新属性" class="headerlink" title="对象的新方法和新属性"></a>对象的新方法和新属性</h1><h2 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is"></a>Object.is</h2><blockquote>
<p>用来判断两个对象是否相同，与之前的判断主要有以下两个区别</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(+<span class="number">0</span>, -<span class="number">0</span>));     <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+<span class="number">0</span> === -<span class="number">0</span>);             <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>, <span class="title class_">NaN</span>));   <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">NaN</span> === <span class="title class_">NaN</span>);           <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h2><blockquote>
<p>用来合并对象。注意：合并时仅仅是浅拷贝合并，也就是仅拷贝对象在栈内存中的地址。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;, &#123;<span class="attr">b</span>:<span class="number">2</span>&#125;, &#123;<span class="attr">c</span>:<span class="number">3</span>&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj);  <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浅拷贝例子：</span></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(obj1, &#123;<span class="attr">b</span>:<span class="number">2</span>&#125;)</span><br><span class="line"></span><br><span class="line">obj2.<span class="property">a</span> = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1);  <span class="comment">// &#123;a:100, b:2&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="Object-keys、Object-values、Object-entries"><a href="#Object-keys、Object-values、Object-entries" class="headerlink" title="Object.keys、Object.values、Object.entries"></a>Object.keys、Object.values、Object.entries</h2><blockquote>
<p>用来取出对象中的键和值</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">c</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">d</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">e</span>: <span class="number">5</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(obj));      <span class="comment">// [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">values</span>(obj));    <span class="comment">// [1,2,3,4,5]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(obj));   <span class="comment">// [[&#x27;a&#x27;,1], [&#x27;b&#x27;,2], [&#x27;c&#x27;,3], [&#x27;d&#x27;,4], [&#x27;e&#x27;,5]]</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title>线程基础（上）</title>
    <url>/posts/9740/</url>
    <content><![CDATA[<p>介绍线程的一些基础知识，包括：创建线程、启动线程、停止线程</p>
<h1 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h1><p>创建线程就只有两种方式，在 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html">Oracle官方文档</a> 中，明确说明了Java实现线程的方式就只有两种：</p>
<ul>
<li><strong>实现 Runnable 接口</strong></li>
<li><strong>继承 Thread 类</strong></li>
</ul>
<h2 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableStyle</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">RunnableStyle</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程中要做的事情</span></span><br><span class="line">        System.out.println(<span class="string">&quot;用 Runnable 方式实现线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果只是像上面这个例子这么简单的话还可以使用 Lambda 表达式来创建线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableStyle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 线程中要做的事情</span></span><br><span class="line">            System.out.println(<span class="string">&quot;用 Runnable 方式实现线程&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：使用 Lambda 表达式来创建的线程本质上还是属于实现 Runnable 接口的方式来创建线程的，这并不是一种新的创建线程的方式，只是在这种场景下的一种更方便的写法。</p>
</blockquote>
<h2 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadStyle</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadStyle</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程中要做的事情</span></span><br><span class="line">        System.out.println(<span class="string">&quot;用 Thread 方式创建线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note default flat"><p><strong>两种方式比较：</strong></p>
</div>

<p>通常情况下我们需要去创建一个线程的时候会选择实现「实现 Runnable 接口」方式，事实上这种方式确实优于「继承 Thread 类」方式。理由有三，如下：</p>
<ol>
<li><p><strong>程序架构的角度：</strong>创建线程的工作和线程要做的工作应该是分开的，也就是解耦的。实现 Runnable 接口的方式就将线程要执行的代码也就是 run() 方法里面的内容以及创建线程的机制也就是 Thread 类进行分离了，从而解耦。而继承 Thread 类的方式就没有做到这一点。</p>
</li>
<li><p><strong>执行效率的角度：</strong>实现 Runnable 接口的方式可以让我们在后续利用一些线程池之类的工具，减少对资源的损耗。而继承 Thread 方式无法使用这些工具类。</p>
</li>
<li><p><strong>代码设计的角度：</strong>由于 Java 是不支持多继承的，实现接口的方式肯定是优于继承类的方式。</p>
</li>
</ol>
<h2 id="run-方法"><a href="#run-方法" class="headerlink" title="run() 方法"></a>run() 方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// target 为实现 Runnable 接口传入的 Runnable 对象</span></span><br><span class="line">    <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在构造 Thread 类时传入了 Runnable 对象则执行 Runnable 对象的 run 方法，如果没有传入 Runnable 对象则什么都不做。</p>
<p>恰恰也是这三行代码为 Thread 类提供了两种创建线程执行单元的方式。两种创建线程的方式在执行具体的新线程中的代码时都是调用的 Thread 类的 run 方法，新线程要实现的功能也是在 run 方法中去编写的。</p>
<p>实现 Runnable 接口方式也是在 run 方法中调用了在 Runnable 接口中定义的 run 方法，而并不是直接去调用了 Runnable 接口的 run 方法。</p>
<p>继承 Thread 类方式则是通过重写 Thread 类中的 run 方法，在 run 方法中去编写要实现的功能，覆盖掉 Thread 类中的 run 方法，从而使得在调用时执行我们自己编写的新线程的执行单元。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>实现线程的方式只有两种，分别是「实现 Runnable 接口」和「继承 Thread 类」</li>
<li>甚至还能说，创建线程的方式只有一种那就是构造 Thread 类，而 Thread 类中提供了两种实现线程的执行单元的方式<ul>
<li>方式一：实现 Runnable 接口的 run 方法，并把 Runnable 实例传给 Thread 类</li>
<li>方式二：重写 Thread 的 run 方法</li>
</ul>
</li>
</ol>
<hr>
<div class="note default flat"><p><strong>思考题：如果同时使用两种方式会怎么样</strong></p>
</div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;实现 Runnable 接口创建的线程&quot;</span>);</span><br><span class="line">    &#125;) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;继承 Thread 类创建的线程&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果已经对 run 方法的源码理解透彻的话，那么这道题是没有任何难度的。</p>
<p>实现 Runnable 接口方式是的执行单元是需要在 Thread 的 run 方法去调用的，但是我们已经重写了 Thread 中的 run 方法，自然无从去调用 Runnable 对象的执行单元了，也就不会被执行。</p>
<h1 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h1><p>启动线程有且仅有唯一的一种方式：调用 start() 方法。</p>
<h2 id="start-方法"><a href="#start-方法" class="headerlink" title="start() 方法"></a>start() 方法</h2><p>当我们创建完一个线程调用了 start 方法时，这个线程并不会直接执行，而是等待执行，也就是进入了<strong>就绪</strong>状态。（调用 start() –&gt; 线程就绪）</p>
<p>实际上调用 start 方法的这个动作仅仅只是去通知了 JVM：我有一个线程已经准备好执行了，你有空的话帮我执行一下。</p>
<p>至于这个线程将要在什么时刻运行，这并不是我们能够决定的，这得由 CPU 的线程调度器去决定。</p>
<blockquote>
<p>注意：start 方法的调用过程是「一个父线程去调用一个已经创建的子线程的 start 方法」所以 start 方法的执行实际上是会牵扯到父子两个线程的。</p>
</blockquote>
<h2 id="start-方法源码"><a href="#start-方法源码" class="headerlink" title="start() 方法源码"></a>start() 方法源码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 检查线程状态</span></span><br><span class="line">        <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 添加到线程组</span></span><br><span class="line">        group.add(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 调用 start0</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            start0();</span><br><span class="line">            started = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                    group.threadStartFailed(<span class="built_in">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">                <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">                  it will be passed up the call stack */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<div class="note default flat"><p><strong>start() 方法和 run() 方法的区别：</strong></p>
</div>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    thread.run();</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="comment">// Thread-0</span></span><br></pre></td></tr></table></figure>
<p>start 方法是开启一个新的线程去执行代码，而 run 方法还是在本线程之中去执行的，并没有开启新的线程。</p>
<p>实际上 strat 方法和 run 方法从根本上来说就是不同的。start 方法是线程体系中的方法，而 run 方法并不属于线程体系，只是一个执行单元，这两者有着根本上的区别。</p>
<p>执行单元和线程体系本质上并没有太大的关系。线程体系指的是一个线程的创建、启动、死亡等各种状态，而执行单元指的是我们编写的要让这个线程去执行的代码。在程序的设计中这两者应该是解耦的，这也是我们推荐使用实现 Runnable 接口方式去实现一个线程的原因之一。</p>
<h1 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h1><p>我们创建启动一个线程并不难，但线程在运行过程中却不是想停就能停的。</p>
<p>通常线程停止的两种情况：</p>
<ul>
<li>run 方法中的全部代码运行完毕。</li>
<li>线程运行的过程中出现没有捕获的异常。</li>
</ul>
<h2 id="停止线程概述"><a href="#停止线程概述" class="headerlink" title="停止线程概述"></a>停止线程概述</h2><p>如果在运行过程中想要停止线程，我们应该：<strong>使用 interrupt 来通知线程停止，而不是强制停止线程</strong></p>
<p>Java 语言中并没有提供可以让线程安全可靠停止的方法，但是 Java 提供了 interrupt 机制来停止线程，并且最好的停止线程的方式也是使用 interrupt。</p>
<p>interrupt 机制是一种合作机制而不是强制机制。将 interrupt 看作一种通知的形式我认为更准确一些：用一个线程去通知另外一个线程停下来。所以说，线程是否停止的最终决定权在线程本身，作为调用方对于其是否停止这件事是无能为力的。</p>
<blockquote>
<p>这其实可以类比成我们平时在路上驾驶汽车的过程。当红灯亮起来时，实际上也仅能够做到通知路上的汽车停车，然后司机去响应这个红灯，停止汽车。这里的红灯就是通知，司机就是线程。红灯亮起之后，司机可以决定停车等红灯，司机也可以不要停车决定闯红灯，比如正在执行任务的救护车或消防车。</p>
</blockquote>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 是否有通知停止线程，司机看到红灯后的逻辑</span></span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务执行完毕，num 的值：&quot;</span> + num);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    thread.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    thread.interrupt(); <span class="comment">// 通知线程停止</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="阻塞状态下停止线程"><a href="#阻塞状态下停止线程" class="headerlink" title="阻塞状态下停止线程"></a>阻塞状态下停止线程</h2><blockquote>
<p>关于阻塞状态，本文在第四节（线程的生命周期）中会有详细描述。</p>
</blockquote>
<p><strong>代码演示</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                System.out.println(num++);</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务执行完毕，num 的值：&quot;</span> + num);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    thread.start();</span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    thread.interrupt(); <span class="comment">// 通知线程停止</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环条件中并没有判断是否有停止线程，这是因为当<strong>线程处于 sleep 状态时会自动的检测是否有停止线程的通知</strong>，并以 <code>try-catch</code> 的形式体现出来。</p>
<div class="note default no-icon flat"><p>上面的例子有一个有意思的地方：把 try-catch 放到 while 里面去会怎么样？</p>
</div>

<p><strong>代码演示</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            System.out.println(num++);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务执行完毕，num 的值：&quot;</span> + num);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    thread.start();</span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    thread.interrupt(); <span class="comment">// 通知线程停止</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异常被捕获后线程并没有停止，这并不是因为我们在异常处理中“响应”了通知，而是因为在 <strong>sleep 状态中会自动清除停止线程的通知</strong>。</p>
<p>这么说吧，你通知我停下来一次，我就停下来一次，在后面的几次 sleep() 中没有被通知停止，当然就不做什么处理了。</p>
<p><strong>综上：在 sleep 状态中线程会自动检测是否有 <code>interrupt</code> 通知，如果有 <code>interrupt</code> 通知，响应的方式是抛出一个 <code>InterruptedException</code> 异常，并清除这个通知。</strong></p>
<h2 id="优雅响应-interrupt"><a href="#优雅响应-interrupt" class="headerlink" title="优雅响应 interrupt"></a>优雅响应 interrupt</h2><p>实际开发中，run 方法内部经常需要去调用一些其他的方法。如果是在这些被调用的外部方法中有 sleep 这个动作的话，我们在 run 方法中是并不知道线程在什么情况下会 sleep 的。</p>
<p>所以当我们编写一些需要 sleep 的方法时，一定要注意不能够把 interrupt 通知给自己 <strong>消化</strong> 掉，应该要通过一些办法将这个 interrupt 通知反映给 run 方法。比如：传递中断和恢复中断</p>
<p><strong>传递中断（推荐）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            startSleep();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    thread.start();</span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    thread.interrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 InterruptException 抛出</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">startSleep</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 startSleep 方法中，让线程进入 sleep 状态，并将 InterruptException 异常抛出在方法声明中传递给上一级的方法去处理。这样一旦 run 方法调用了 startSleep 就必须去处理 InterruptException 异常。而如果在 sleep 过程中有 Interrupt 通知出现，那么 run 方法的编写者就可以在 catch 语句中去处理这个 Interrupt 通知。</p>
</blockquote>
<p><strong>恢复中断</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 响应通知</span></span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            num++;</span><br><span class="line">            startSleep();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行完毕，num = &quot;</span> + num);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    thread.start();</span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    thread.interrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">startSleep</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="comment">// 处理完自己的中断逻辑后，向上一层调用者传递该中断。</span></span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在某些特定的业务场景中，我们可能必须去处理 InterruptedException 异常。那么就必须要在 catch 块中去再次发出 Interrupt 通知，恢复这个通知。让 run 方法的编写者可以正确的处理 Interrupt 通知。</p>
</blockquote>
<h2 id="sleep-的优雅写法"><a href="#sleep-的优雅写法" class="headerlink" title="sleep() 的优雅写法"></a>sleep() 的优雅写法</h2><p>java.util.concurrent 包下的 TimeUnit 提供了更加优雅的 sleep() 方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        TimeUnit.HOURS.sleep(<span class="number">1</span>);   <span class="comment">// 休眠1个小时</span></span><br><span class="line">        TimeUnit.MINUTES.sleep(<span class="number">1</span>); <span class="comment">// 休眠1分钟</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>); <span class="comment">// 休眠1秒钟</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上使用 TimeUnit 类中的 sleep 方法可以让代码看起来更加舒服。直接休眠对应单位的时间，而不是去手动的计算要休眠的毫秒数。</p>
<p>接下来为您分析 Java 中线程的 <strong>6</strong> 种状态，以及线程的生命周期。</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E7%BA%BF%E7%A8%8B%E7%9A%846%E4%B8%AA%E7%8A%B6%E6%80%81.png" alt="线程的6个状态"></p>
<blockquote>
<p>在这张图片中，包含了线程的所有状态以及每种状态之间的互相转换过程。其中箭头的指向是固定的，单箭头的指向则表明了两个线程的状态是不可逆的，一旦从一端到另一端之后就无法再回去原来的状态。</p>
</blockquote>
<h2 id="NEW、RUNNABLE、TERMINATED"><a href="#NEW、RUNNABLE、TERMINATED" class="headerlink" title="NEW、RUNNABLE、TERMINATED"></a>NEW、RUNNABLE、TERMINATED</h2><ol>
<li><p><strong>新创建（NEW）</strong><br>线程一经创建，也就是去 new 了一个 Thread 类之后，未调用 start 方法之前，这时的线程就是「新创建」的状态</p>
</li>
<li><p><strong>可运行（RUNNABLE）</strong><br>有些地方可能将「可运行」状态称之为「就绪」状态，这两者其实都是「RUNNABLE」状态</p>
<p> 调用 start 方法开始，直到 run 方法中的代码执行完毕之前，如果没有其他的操作使得线程状态跑到上图右边的三种状态中去的话，线程将会一直处于「可运行」状态。</p>
<p> 注意：线程并没有一个「运行」的状态，就算是正在执行 run() 方法的线程状态也是「可运行」状态。</p>
</li>
<li><p><strong>已终止（TERMINATED）</strong><br>当 run 方法的代码执行完毕或者是抛出未处理的异常的时，线程就会处于「已终止」状态中。这个状态也是线程的最终状态，线程一旦进入了这个状态将无法再回到其他的状态中。</p>
<p> NEW、RUNNABLE、TERMINATED 这三种状态都是单向的，是无法返回的。NEW –&gt; RUNNABLE –&gt; TERMINATED</p>
</li>
<li><p><strong>代码演示</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">500</span>)</span><br><span class="line">                <span class="comment">// run() 方法执行中</span></span><br><span class="line">                System.out.println(<span class="string">&quot;thread.state = &quot;</span> + Thread.currentThread().getState());  <span class="comment">// RUNNABLE</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;thread.state = &quot;</span> + thread.getState());  <span class="comment">// NEW</span></span><br><span class="line"></span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(<span class="string">&quot;thread.state = &quot;</span> + thread.getState());  <span class="comment">// RUNNABLE</span></span><br><span class="line"></span><br><span class="line">    thread.join();</span><br><span class="line">    System.out.println(<span class="string">&quot;thread.state = &quot;</span> + thread.getState());  <span class="comment">// TERMINATED</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="BLOCKED、WAITING、TIMED-WAITING"><a href="#BLOCKED、WAITING、TIMED-WAITING" class="headerlink" title="BLOCKED、WAITING、TIMED_WAITING"></a>BLOCKED、WAITING、TIMED_WAITING</h2><ol>
<li><p><strong>被阻塞（BLOCKED）</strong><br>如果线程执行了一个被 synchronize 关键字修饰的代码块，并且这个代码块还处于其他线程的执行之中，这时调用的线程就会处于阻塞的状态，等待其他线程执行完毕后再执行。<br>等待的这个线程在等待的时间内就是处于 <strong>BLOCKED</strong> 状态。</p>
<blockquote>
<p>习惯上来说 BLOCKED、WAITING、TIMED_WAITING 都称之为阻塞状态，而不仅仅是 BLOCKED。</p>
</blockquote>
</li>
<li><p><strong>「等待(WAITING)」和「计时等待(TIMED_WAITING)」</strong><br>当线程阻塞时就会进入等待的状态。其中等待和计时等待非常好理解，有带 time 参数的等待就是计时等待，反之则是等待。</p>
</li>
<li><p><strong>代码演示</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">5</span>); <span class="comment">// 让 t1 和 t2 先跑一会</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;t1 sleep(50) t1.state = &quot;</span>+t1.getState()); <span class="comment">// TIMED_WAITING</span></span><br><span class="line">        System.out.println(<span class="string">&quot;t1 get LOCK，t2 be BLOCKED t2.state = &quot;</span> + t2.getState()); <span class="comment">// BLOCKED</span></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>); <span class="comment">// 进入 wait() 中</span></span><br><span class="line">        System.out.println(<span class="string">&quot;t1 wait(), t1.state = &quot;</span> + t1.getState()); <span class="comment">// WAITING</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>并发</category>
      </categories>
  </entry>
  <entry>
    <title>ES6：解构赋值</title>
    <url>/posts/53099/</url>
    <content><![CDATA[<blockquote>
<p>解构赋值语法是一个 JavaScript 表达式，这使得可以将 <strong>值从数组</strong> 或 <strong>属性从对象</strong> 提取到不同变量中。</p>
</blockquote>
<span id="more"></span>

<h1 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h1><p>数组的解构赋值是有序的，将会按照顺序去匹配</p>
<h4 id="简单的解构赋值"><a href="#简单的解构赋值" class="headerlink" title="简单的解构赋值"></a>简单的解构赋值</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> [a, b, c, d] = arr</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量 a b c d 的值将会对应上数组中的 1 2 3 4</span></span><br></pre></td></tr></table></figure>
<p>在 ES6 之前，「解构赋值」还没出现的时候，想要实现以上功能只能够一个个的去定义 <code>a b c d</code> 这四个变量。因此，「解构赋值」的出现就是为了简化一些代码的编写，实现更加高效的开发。</p>
<h4 id="数组嵌套的解构赋值"><a href="#数组嵌套的解构赋值" class="headerlink" title="数组嵌套的解构赋值"></a>数组嵌套的解构赋值</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, [<span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span><span class="string">&#x27;g&#x27;</span>]]]</span><br><span class="line"><span class="keyword">let</span> [, , [, , [, , g]]] = arr</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量 g 将对应 arr 中的字符 g</span></span><br></pre></td></tr></table></figure>

<h4 id="扩展运算符："><a href="#扩展运算符：" class="headerlink" title="扩展运算符： ..."></a>扩展运算符： <code>...</code></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">const</span> arr3 = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr4 = [...arr1, ...arr2, ...arr3]</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr4 = [1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="comment">// 注意：arr4 将是一个一维数组而不是二维数组</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> [a, b, ...c] = arr</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量 c 将对应数组中 c 之后的所有值组成的新数组</span></span><br><span class="line"><span class="comment">// 注意：这种写法扩展运算符必须放在最后一位</span></span><br></pre></td></tr></table></figure>

<h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> [a, b = <span class="number">2</span>, c, d] = arr</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量 a b c d 将对应成[1, 2, 3, undefined]</span></span><br><span class="line"><span class="comment">// 没有匹配到的值将会默认为 undefined，匹配到 undefined 将会自动赋为默认值</span></span><br></pre></td></tr></table></figure>

<h4 id="数组解构赋值的使用"><a href="#数组解构赋值的使用" class="headerlink" title="数组解构赋值的使用"></a>数组解构赋值的使用</h4><ol>
<li><p><strong>交换变量</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">[a, b] = [b, a];</span><br><span class="line"></span><br><span class="line"><span class="comment">// a = 10</span></span><br><span class="line"><span class="comment">// b = 20</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>接收函数中的数组返回值</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getUserInfo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="literal">true</span>,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">            <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;请求成功&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [status, data, msg] = <span class="title function_">getUserInfo</span>()</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h1 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h1><p>对象的解构赋值是无序的，将直接按照属性名称去匹配</p>
<h4 id="简单的解构赋值-1"><a href="#简单的解构赋值-1" class="headerlink" title="简单的解构赋值"></a>简单的解构赋值</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;name, age&#125; = obj</span><br><span class="line"></span><br><span class="line"><span class="comment">// name : &#x27;zhangsan&#x27;</span></span><br><span class="line"><span class="comment">// age : 18</span></span><br><span class="line"><span class="comment">// 按照属性名称匹配对应的值</span></span><br></pre></td></tr></table></figure>

<h4 id="对象与数组嵌套的解构赋值"><a href="#对象与数组嵌套的解构赋值" class="headerlink" title="对象与数组嵌套的解构赋值"></a>对象与数组嵌套的解构赋值</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">hobby</span>: [&#123;</span><br><span class="line">        <span class="attr">hobbyName</span>: <span class="string">&#x27;听歌&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">hobbyName</span>: <span class="string">&#x27;看电影&#x27;</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">    <span class="attr">hobby</span>:</span><br><span class="line">    [</span><br><span class="line">        &#123; <span class="attr">hobbyName</span>: name1 &#125;,</span><br><span class="line">        &#123; <span class="attr">hobbyName</span>: name2 &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125; = obj</span><br><span class="line"></span><br><span class="line"><span class="comment">// name1: &#x27;听歌&#x27;</span></span><br><span class="line"><span class="comment">// name2: &#x27;看电影&#x27;</span></span><br></pre></td></tr></table></figure>
<p>注意：<code>hobby</code> 后的“:”跟着的是 <code>obj</code> 对象中的 <code>hobby</code> 数组，<code>hobbyName</code> 后的“:”跟着的是为了区分两个同名的 <code>hobbyName</code> 所起的别名</p>
<h4 id="扩展运算符：-1"><a href="#扩展运算符：-1" class="headerlink" title="扩展运算符：..."></a>扩展运算符：<code>...</code></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;name, ...obj1&#125; = obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// obj 对象中的 age 和 sex 属性将会被封装成 obj1 对象</span></span><br><span class="line"><span class="comment">// 注意：这种方式使用的扩展运算符只能够放在最后一位</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj3 = &#123;</span><br><span class="line">    <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;...obj1, ...obj2, ...obj3&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象 obj 中会有 obj1-3 的全部属性</span></span><br><span class="line"><span class="comment">// 注意：如果存在重名属性，后面的会覆盖掉前面的</span></span><br></pre></td></tr></table></figure>

<h4 id="对已经声明的变量进行解构赋值"><a href="#对已经声明的变量进行解构赋值" class="headerlink" title="对已经声明的变量进行解构赋值"></a>对已经声明的变量进行解构赋值</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line">(&#123; age &#125; = obj)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：以上的解构赋值语句如果没有加 () 会被视为是一个作用域而报错</span></span><br></pre></td></tr></table></figure>

<h4 id="默认值-1"><a href="#默认值-1" class="headerlink" title="默认值"></a>默认值</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;name, age = <span class="number">18</span>, sex = <span class="string">&#x27;男&#x27;</span>&#125; = obj</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在匹配时，如果匹配不到对应的属性或者是对应的属性为 undefined 时，将会寻找默认值自动匹配</span></span><br></pre></td></tr></table></figure>

<h4 id="对象解构赋值的使用"><a href="#对象解构赋值的使用" class="headerlink" title="对象解构赋值的使用"></a>对象解构赋值的使用</h4><ol>
<li><p><strong>传递乱序参数和设置默认值</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不使用解构赋值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">AJAX</span>(<span class="params">option</span>) &#123;</span><br><span class="line">    $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">        <span class="attr">url</span>: option.<span class="property">url</span>,</span><br><span class="line">        <span class="attr">type</span>: option.<span class="property">type</span> || <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">        <span class="attr">data</span>: option.<span class="property">data</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用解构赋值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">AJAX</span>(<span class="params"> &#123; url, data, type = <span class="string">&#x27;get&#x27;</span> &#125; </span>) &#123;</span><br><span class="line">    $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">        <span class="attr">url</span>: url,</span><br><span class="line">        <span class="attr">type</span>: type,</span><br><span class="line">        <span class="attr">data</span>: data</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">AJAX</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/getUserInfo&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>获取一个函数中的多个返回值</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getUserInfo</span> (userId) &#123;</span><br><span class="line">    <span class="comment">// ...ajax</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">status</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">data</span>: &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">msg</span>: <span class="string">&#x27;请求成功&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;status, data, msg&#125; = <span class="title function_">getUserInfo</span>(<span class="number">123</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h1><ol>
<li><p><strong>直接取值</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello,World!&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a b c 三个变量将会分别对应字符串 str 的前三个字符</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>扩展运算符：<code>...</code></strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello,World!&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> [a, b, ...c] = str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量 a b 依旧对应前两个字符，变量 c 则对应的是后面的每个字符所组成的数组</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>分割字符串</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello,World!&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> [ ...spStr1 ] = str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的代码效果等同于：let spStr1 = str.split(&#x27;&#x27;);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>提取属性</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello,World!&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> &#123; length &#125; = str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// length = 12</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title>ES6：var、let、const</title>
    <url>/posts/37909/</url>
    <content><![CDATA[<blockquote>
<p>let 这个关键字都是在 ES6 中新出现的，作用与 var 是一样的，可以用来声明变量。const 关键字也是在 ES6 中新出现的，不同的是 const 是用来声明常量。</p>
</blockquote>
<h1 id="let-amp-var"><a href="#let-amp-var" class="headerlink" title="let &amp; var"></a>let &amp; var</h1><h4 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h4><p>「块级作用域」这个概念是在 ES6 中新引入的概念，就是一个 <code>&#123;&#125;</code> 「花括号」而已。所有的花括号之内都是一个单独的块级作用域，但是有一种特殊情况不是，那就是在声明对象的时候字面式声明一个对象的时候不是。</p>
<h4 id="let和var的区别"><a href="#let和var的区别" class="headerlink" title="let和var的区别"></a>let和var的区别</h4><ol>
<li><p>let 和 var 最大的区别就是 <strong>let声明的对象只在当前作用域生效</strong><br>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不能重复声明</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b)</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">20</span> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b)</span><br></pre></td></tr></table></figure>
<p>上面的代码将会直接报错</p>
</li>
<li><p>let 不存在「变量提升」<br>使用 var 关键字声明的变量在执行上下文中会有一个变量提升的现象，但是使用 let 声明的变量将不会出现这个现象，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)  <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b)  <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>暂存死区</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">20</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的这段代码将会直接报错。因为 ES6 中单独的作用域内使用 let 或者是 const 声明的变量将会形成一个封闭的作用域，这直接导致重名的变量无法访问到父级作用域的变量，进而报错。</p>
</li>
</ol>
<h1 id="const-常量"><a href="#const-常量" class="headerlink" title="const 常量"></a>const 常量</h1><ol>
<li><p>声明常量<br>const 声明时与 let 声明并没有什么区别，唯一的区别是使用 const 声明常量时需要在声明的同时初始化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> a <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不能修改<br>声明的既然是常量，那么当然是不允许被修改的。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">10</span></span><br><span class="line">a = <span class="number">20</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p> <strong>如果声明的是一个引用类型的数据，那么它将可以被修改</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>)  <span class="comment">// zhangsan</span></span><br><span class="line"></span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;lisi&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>)  <span class="comment">// lisi</span></span><br></pre></td></tr></table></figure>
<p>实际上 const 声明的常量仅仅只是「锁定」了<strong>栈内存</strong>中的值，而引用数据类型实际存放的地方是在<strong>堆内存</strong>中的。所以对象类型的值是可以被修改的。</p>
<p> 那么我们既然是声明了一个常量的话当然是不希望这个常量能够被修改，如果是一个对象类型的常量的话，我们必须通过 <code>Object.freeze()</code> 这个方法来「冻结」这个对象类型的常量。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>) <span class="comment">// zhangsan</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 冻结</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">freeze</span>(obj)</span><br><span class="line"></span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;lisi&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>) <span class="comment">// zhangsan</span></span><br></pre></td></tr></table></figure>
<p>在上面这个例子中两次的输出都是 <code>zhangsan</code> 这说明了我们并没有修改到 <code>obj</code> 这个对象，这样子就是声明了一个对象类型的常量表了。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>ES6</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript：闭包</title>
    <url>/posts/47023/</url>
    <content><![CDATA[<p>闭包：<strong>「函数」和「函数内部能访问到的变量」（也叫环境）的总和，就是一个闭包。</strong><br>闭包在js面向对象中是一个非常重要的知识点，许多的面向对象的特性都可以通过闭包来体现。</p>
<span id="more"></span>

<h1 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> local = <span class="string">&#x27;变量&#x27;</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(local)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面函数内部的三行代码中，有一个局部变量 <code>local</code>，有一个函数 <code>foo</code> ，<code>foo</code> 里面可以访问到 <code>local</code> 变量。这就是一个闭包，就是这么简单。</p>
<p>其实大家比较熟知的闭包是下面的这种嵌套函数的形式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> local = <span class="number">1</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>)&#123;</span><br><span class="line">    local++</span><br><span class="line">    <span class="keyword">return</span> local</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = <span class="title function_">foo</span>()</span><br><span class="line"><span class="title function_">func</span>()</span><br></pre></td></tr></table></figure>
<p>这里面呢确实有闭包的存在，<code>local</code> 变量和 <code>bar</code> 函数就组成了一个闭包。</p>
<p><strong>那么为什么要嵌套函数呢？</strong></p>
<p>是因为需要局部变量，所以才把 <code>local</code> 放在一个函数里，如果不把 <code>local</code> 放在一个函数里，<code>local</code> 就是一个全局变量了，达不到使用闭包的目的——隐藏变量（等会会讲）。</p>
<p>可能看到「闭包」这个名字，就一定觉得要用什么包起来才行。其实这是翻译问题，闭包的原文是 Closure，跟「包」没有任何关系。</p>
<p>所以函数套函数只是为了造出一个局部变量，<strong>跟闭包无关</strong>。</p>
<p><strong>为什么要 return bar 呢？</strong></p>
<p>因为如果不 <code>return</code>，你就无法使用这个闭包。把 <code>return bar</code> 改成 <code>window.bar = bar</code> 也是一样的，只要让外面可以访问到这个 <code>bar</code> 函数就行了。</p>
<p>所以 <code>return bar</code> 只是为了 <code>bar</code> 能被使用，也<strong>跟闭包无关</strong>。</p>
<hr>
<h1 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h1><p>闭包常常用来「间接访问一个变量」。换句话说，「隐藏一个变量」。</p>
<p>假设我们现在在做一个系统的注册登录功能，在写其中关于「用户年龄」的代码。</p>
<p>如果不使用闭包的话</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">age</span> = <span class="number">18</span> <span class="comment">// 18岁</span></span><br></pre></td></tr></table></figure>

<p>但是这么看起来是非常危险的，因为这将在全局的任何一个地方都可以直接的访问到这个 <code>age</code> 变量，如果不加校验的话，等会要是被修改成 「负数」 怎么办，对吧？</p>
<p>所以，我们不能让别人可以「直接访问」这个 <code>age</code> 变量。</p>
<p>我们需要使用「局部变量」</p>
<p>但是使用了局部变量的话，这个变量的又需要一个全局的作用域。这个时候应该怎么办？</p>
<p>我们可以主动暴露一个访问器（函数），让别人可以「间接访问」</p>
<blockquote>
<p>上面的思考过程其实也就是 闭包 使用函数嵌套形式的由来。</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改年龄，增加1岁</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">addAge</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        age += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改年龄，减少1岁</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">subLives</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (age &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            lives -= <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;没办法再往下修改年龄啦&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>上面这也是一个闭包的例子。使用闭包之后可以更加规范的去管理我们的变量，这也是闭包的意义。总的来说这就是闭包，闭包也仅此而已。</p>
<hr>
<p>其实写到这里之后，可能由于我是学 Java 出身的，立马就想到了 Java 中实体类的封装。来看一段 Java 代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (age &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;年龄必须为正数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简要说明一下上面这段代码：<br>首先声明一个私有化的 <code>age</code> 变量，然后为这个变量提供公有的 <code>get</code> 和 <code>set</code> 方法，可以让外界访问到这个 <code>age</code> 变量。当我们设置这个 <code>age</code> 变量的时候，我们可以在 <code>set</code> 方法中去定义一些规范，保证 <code>age</code> 值的一个正确性。</p>
<p>在我看来，刚刚的闭包的例子与上面的这段 Java 代码实现的是同一个功能。也就是说闭包其实是为了封装变量，只是在这里我们将其称为了隐藏变量，仅此而已。</p>
<blockquote>
<p>参考文章：<br><a href="https://zhuanlan.zhihu.com/p/22486908">「每日一题」JS 中的闭包是什么？</a></p>
</blockquote>
<hr>
<blockquote>
<p>分享一个小经验：<br>编程崇尚的是以简洁优雅为美，<font color=blue>很多时候如果你觉得一个概念很复杂，那么很可能是你理解错了</font></p>
</blockquote>
<p>大家加油：）</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript：创建对象</title>
    <url>/posts/15655/</url>
    <content><![CDATA[<p>这篇博客将会记录一下js中创建对象的几种不同的方式，分别是字面式声明、<code>new</code>关键字声明、构造函数声明、工厂模式声明、原型声明。</p>
<span id="more"></span>

<h1 id="字面式声明"><a href="#字面式声明" class="headerlink" title="字面式声明"></a>字面式声明</h1><p>声明格式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接实例化一个对象</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="attr">run</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;姓名：&quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;年龄：&quot;</span> + <span class="variable language_">this</span>.<span class="property">age</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用属性和函数</span></span><br><span class="line">obj.<span class="property">name</span>;</span><br><span class="line">obj.<span class="property">age</span>;</span><br><span class="line">obj.<span class="title function_">run</span>();</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="new关键字声明"><a href="#new关键字声明" class="headerlink" title="new关键字声明"></a>new关键字声明</h1><p><code>Object</code>对象是所有对象的父类，也称为根类、基类、超类。js中的所有对象都是<code>Object</code>对象的延伸，都是<code>Object</code>的子类。</p>
<p>声明格式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">obj.属性 = 属性值;</span><br><span class="line">obj.属性 = 属性值;</span><br><span class="line">obj.函数 = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a>构造函数创建对象</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">obj</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">run</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;姓名：&quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;年龄：&quot;</span> + <span class="variable language_">this</span>.<span class="property">age</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title function_">obj</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用属性和方法</span></span><br><span class="line">obj.<span class="property">name</span>;</span><br><span class="line">obj.<span class="property">age</span>;</span><br><span class="line">obj.<span class="title function_">run</span>();</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="工厂模式创建对象"><a href="#工厂模式创建对象" class="headerlink" title="工厂模式创建对象"></a>工厂模式创建对象</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个工厂</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createObj</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    obj.<span class="property">name</span> = name;</span><br><span class="line">    obj.<span class="property">age</span> = age;</span><br><span class="line">    obj.<span class="property">run</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;姓名：&quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;年龄：&quot;</span> + <span class="variable language_">this</span>.<span class="property">age</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过工厂实例化对象</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="title function_">createObj</span>(<span class="string">&#x27;zhangsan&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用属性和函数</span></span><br><span class="line">obj.<span class="property">name</span>;</span><br><span class="line">obj.<span class="property">age</span>;</span><br><span class="line">obj.<span class="title function_">run</span>();</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="原型模式创建对象"><a href="#原型模式创建对象" class="headerlink" title="原型模式创建对象"></a>原型模式创建对象</h1><p>概述：声明一个空的函数，再利用<code>prototype</code>去定义属性和函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明空函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用prototype去定义属性和函数</span></span><br><span class="line">fn.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;zhangsan&#x27;</span>;</span><br><span class="line">fn.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line">fn.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">run</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;姓名：&quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;年龄：&quot;</span> + <span class="variable language_">this</span>.<span class="property">age</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title function_">fn</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用属性和方法</span></span><br><span class="line">obj.<span class="property">name</span>;</span><br><span class="line">obj.<span class="property">age</span>;</span><br><span class="line">obj.<span class="title function_">run</span>();</span><br></pre></td></tr></table></figure>

<p>第二种方式：直接使用一个json对象定义属性和函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明空函数</span></span><br><span class="line"><span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用json对象定义属性和函数</span></span><br><span class="line">fn.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">run</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;姓名：&quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;年龄：&quot;</span> + <span class="variable language_">this</span>.<span class="property">age</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title function_">fn</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用属性和方法</span></span><br><span class="line">obj.<span class="property">name</span>;</span><br><span class="line">obj.<span class="property">age</span>;</span><br><span class="line">obj.<span class="title function_">run</span>();</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h1><p>混合模式是<strong>构造模式</strong>混合了<strong>原型模式</strong>一起创建的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Obj</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型添加属性和方法</span></span><br><span class="line"><span class="title class_">Obj</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">run</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;姓名：&quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;年龄：&quot;</span> + <span class="variable language_">this</span>.<span class="property">age</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化对象</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Obj</span>(<span class="string">&#x27;zhangsan&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用属性和方法</span></span><br><span class="line">obj.<span class="property">name</span>;</span><br><span class="line">obj.<span class="property">age</span>;</span><br><span class="line">obj.<span class="title function_">run</span>();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript：垃圾回收机制</title>
    <url>/posts/31440/</url>
    <content><![CDATA[<p>JavaScript有自动收集内存中已经废弃的变量的功能，称为<strong>垃圾回收机制</strong></p>
<span id="more"></span>

<p>js中的局部变量仅在函数的执行过程中存在，一旦函数执行完毕之后局部变量则失去了意义，这个时候就需要去释放掉这个变量，回收内存。</p>
<p>上述的这个动作由js的垃圾收集器来完成。</p>
<p>垃圾收集器原理：找出没用的数据、<strong>打上标记</strong>、<strong>释放内存</strong>、<strong>周期性执行</strong>。</p>
<h2 id="标识无用变量的策略"><a href="#标识无用变量的策略" class="headerlink" title="标识无用变量的策略"></a>标识无用变量的策略</h2><h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><p>当变量进入或者是离开执行环境时，会给变量做上一个标记，周期性的将离开执行环境的变量清除。</p>
<h4 id="引用计数（不常用）"><a href="#引用计数（不常用）" class="headerlink" title="引用计数（不常用）"></a>引用计数（不常用）</h4><p>当一个<strong>堆内存中的对象</strong>被赋值给一个<strong>栈内存中的引用</strong>时，这个对象的计数 +1。<br>如果这个<strong>堆内存中的对象</strong>再次被赋值给一个<strong>栈内存中的引用</strong>时，这个对象的计数再 +1。<br>也就是现在这个对象的计数时2，即两个<strong>栈内存的应用</strong>指向同一个<strong>堆内存的对象</strong>。<br>如果两个<strong>栈内存中的引</strong>用其中一个发生了改变，也就是不再指向这个<strong>堆内存中的对象</strong>了，那么这个<strong>堆内存中的对象</strong>的计数 -1。<br>当这个<strong>堆内存中的对象</strong>的计数 &#x3D;0 的时候，垃圾收集器将释放该对象所占用的内存。</p>
<p><strong>循环引用的问题</strong><br>循环引用就是对象A中包含了一个指向对象B的指针，对象B中包含了一个指向对象A的指针。这样一来两个<strong>堆内存中的对象</strong>的计数都是2，当我们使用完这两个对象之后，垃圾收集器将无法回收这两个变量。需要我们手动的去将这两个对象置为 <code>null</code> 来释放内存。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">ObjA</span> = &#123;&#125;;  <span class="comment">// ObjA计数1</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">ObjB</span> = &#123;&#125;;  <span class="comment">// ObjB计数1</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">ObjA</span>.<span class="property">obj</span> = <span class="title class_">ObjB</span>; <span class="comment">// ObjB计数2</span></span><br><span class="line"><span class="title class_">ObjB</span>.<span class="property">obj</span> = <span class="title class_">ObjA</span>; <span class="comment">// ObjA计数2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动释放内存</span></span><br><span class="line"><span class="title class_">ObjA</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="title class_">ObjB</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript：执行上下文</title>
    <url>/posts/54687/</url>
    <content><![CDATA[<p>执行上下文是js中很重要的一个概念，每次当js程序去调用一个函数时，就会去创建一个对应的执行上下文。我们可以先将执行上下文理解为当前代码执行的环境，这会产生一个作用域的概念，也就是我的上一篇文章所提到的。js引擎会销毁该函数的执行上下文。js程序在执行时每次遇到函数时都会做这样的操作。</p>
<span id="more"></span>

<h1 id="一、执行上下文生命周期"><a href="#一、执行上下文生命周期" class="headerlink" title="一、执行上下文生命周期"></a>一、执行上下文生命周期</h1><p>首先我们还是来对执行上下文有一个深入的了解，当一个函数被调用时，一个对应的执行上下文就会被创建。而一个执行上下文的生命周期可以分为两个阶段。<strong>创建阶段</strong>和<strong>执行阶段</strong></p>
<ul>
<li><strong>创建阶段</strong><br>在这个阶段中，执行上下文会分别创建<strong>变量对象</strong>，建立<strong>作用域链</strong>，以及确定<strong>this</strong>的指向。这些概念接下来都会仔细的说一下。</li>
<li><strong>执行阶段</strong><br>创建完成之后，开始逐行的执行代码。这个时候会完成变量赋值、函数引用、以及执行其他代码。</li>
</ul>
<h1 id="二、区别执行上下文和变量作用域"><a href="#二、区别执行上下文和变量作用域" class="headerlink" title="二、区别执行上下文和变量作用域"></a>二、区别执行上下文和变量作用域</h1><p>在上一篇文章重提到了一个作用域的概念。作用域与执行上下文都是在函数的中的概念，可能会有点冲突，导致理解起来容易混淆，这里有必要区别一下这两个概念。</p>
<p>执行上下文是在函数调用时才去动态的创建，因为不同的调用可能会是完全不同的参数。而变量作用域则是在函数声明时就确定了，跟函数的调用无关，函数在调用时只会去创建执行上下文。相比较而言，变量作用域更像是一个静态的概念，在函数声明时就确定下来的，函数内部的变量只能存活于这个作用域之中，不管是什么样的变量只要是在函数的内部去声明的，就肯定是跑不出函数的作用域中。（这里插一句：函数的参数也是函数的内部变量，存活于函数的作用域之中）而执行上下文呢则是在调用时才会产生的，甚至是在某种特殊的环境下会产生多个执行上下文，例如闭包。</p>
<p><strong>举个例子吧：</strong></p>
<blockquote>
<p>我们平时开的汽车，当这辆汽车被生产出来的时候，其中的功能就已经是确定的了，比如最高能达到多高的时速、最多能坐几个人、能载重多少重量等等，这相当于是确定了作用域。但是在我们实际的使用的时候由于路面环境的不同、用途不同、司机不同等等的原因导致这辆汽车发挥出来的效果也是不用。这就相当于是每次执行的时候都创建了对应的执行上下文。</p>
<p><strong>上面的例子可能有些不太恰当的地方，仅代表个人的理解</strong></p>
</blockquote>
<h1 id="三、执行上下文栈"><a href="#三、执行上下文栈" class="headerlink" title="三、执行上下文栈"></a>三、执行上下文栈</h1><p>在js中函数的调用是有严格的先后顺序的，在一个js程序中正在执行的函数有且仅有一个，另外的函数想要执行必须等待当前函数执行完毕后按照顺序排队执行。如果是一个函数中包含了另外一个函数的执行的话那么需要在执行到<strong>被包含的函数</strong>中时去执行<strong>被包含的函数</strong>，等待被包含的函数<strong>执行完毕</strong>之后才可以继续接着执行下面的内容。这样的执行顺序天然的符合“<strong>栈</strong>”这种后入先出的数据结构。我们来看一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fn函数开始执行&quot;</span>);</span><br><span class="line">    <span class="title function_">fn2</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fn函数执行完毕&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fn2函数开始执行&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fn2函数执行完毕&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>在上面的这段代码中，js引擎首先创建了一个全局的执行上下文。</strong><br>将这个全局执行上下文压入执行上下文栈中。此时的栈结构：<code>栈底 -&gt; 全局 -&gt; 栈顶</code><br><strong>之后开始执行代码，当执行到第12行调用了<code>fn</code>函数的时候，去创建了一个<code>fn</code>的执行上下文。</strong><br>将<code>fn</code>的执行上下文再压入栈。此时的栈结构：<code>栈底 -&gt; 全局 -&gt; fn -&gt; 栈顶</code><br><strong>开始执行<code>fn</code>函数中的代码。执行到第3行的时候调用了<code>fn2</code>，这个时候会去创建一个<code>fn2</code>的执行上下文。</strong><br>将<code>fn2</code>压入栈。此时的栈结构：<code>栈底 -&gt; 全局 -&gt; fn -&gt; fn2 -&gt; 栈顶</code><br><strong>之后开始执行<code>fn2</code>的内容，当函数<code>fn2</code>执行完毕之后，销毁<code>fn2</code>的执行上下文。</strong><br>销毁执行上下文就是将该上下文弹出栈，此时弹出<code>fn2</code>后的栈结构：<code>栈底 -&gt; 全局 -&gt; fn -&gt; 栈顶</code><br><strong>再继续执行函数<code>fn</code>中剩余的部分，当函数<code>fn</code>执行完毕之后销毁了函数<code>fn</code>的执行上下文。</strong><br>弹出<code>fn</code>，此时的栈结构：<code>栈底 -&gt; 全局 -&gt; 栈顶</code><br><strong>等到关闭浏览器窗口的时候会去销毁全局的执行上下文。</strong><br>此时的栈结构：<code>栈底 -&gt;  -&gt;栈顶</code></p>
</blockquote>
<p>上面的这个例子很形象的阐述了函数调用栈是如何去管理执行上下文的执行顺序的。每次在调用函数的时候会去创建一个执行上下文，并将其压入栈顶。而执行的时候也是只执行位于栈顶的函数，执行完毕后将栈顶的函数弹出栈，再接着执行栈顶的函数。按照这个顺序去执行，到最后就只剩下一个全局的执行上下文，关闭浏览器窗口后把最后一个全局上下文弹出栈，之后调用栈为空，也意味着程序执行完毕。</p>
<h1 id="四、作用域链"><a href="#四、作用域链" class="headerlink" title="四、作用域链"></a>四、作用域链</h1><p><strong>我们先来看一段代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;全局的name&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> name1 = <span class="string">&quot;全局的name1&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> name2 = <span class="string">&quot;全局的name2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;fn的name&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> name1 = <span class="string">&quot;fn的name1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> name =<span class="string">&quot;fn2的name&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(name);  <span class="comment">// 输出fn2的name</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(name1); <span class="comment">// 输出fn的name1</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(name2); <span class="comment">// 输出全局的name2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">fn2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure>
<p>这段代码中，很清晰的向我们展示了什么是作用域链。在函数<code>fn2</code>的内部去输出<code>name</code>这个变量，首先是在当前函数的作用域也就是<code>fn2</code>的执行上下文中去寻找<code>name</code>这个变量，找到了之后直接输出。如果找不到，例如变量<code>name1</code>的这种情况，则会去上一级的作用域中去寻找，也就是函数<code>fn</code>的作用域，找到后再输出。如果还是找不到，例如变量<code>name2</code>的情况，那么就会再到上一级的作用域中去寻找，找到后再输出。一级一级的网上去寻找形成了一个链式的操作，称之为<strong>作用域链</strong>。</p>
<p><strong>分析作用域链的形成</strong></p>
<blockquote>
<p>结合一下前文提到过的函数调用栈的概念，一级一级网上去查找变量的这个过程，其实就是在函数调用栈中去一级一级的往栈底的执行上下文去查找。也就是说作用域链是在函数调用栈中由栈顶的执行上下文去往栈底的执行上下文去一级一级的链起来形成的作用域链。</p>
</blockquote>
<h1 id="五、变量对象（Variable-Object，VO）"><a href="#五、变量对象（Variable-Object，VO）" class="headerlink" title="五、变量对象（Variable Object，VO）"></a>五、变量对象（Variable Object，VO）</h1><p>变量对象无非也是一个对象，对象就是为了承载数据而存在的。所以变量对象就是一些数据的载体，只是这个对象我们并不能够去实际的创建出来，看不见摸不着而已。</p>
<h2 id="变量对象的创建"><a href="#变量对象的创建" class="headerlink" title="变量对象的创建"></a>变量对象的创建</h2><ol>
<li>建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。</li>
<li>检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。</li>
<li>检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。这里牵扯到一个变量提升的概念，面试常考。</li>
</ol>
<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>变量提升这个概念其实很好理解，在一个js程序中，使用<code>var</code>关键字声明的变量会在程序执行时提前去<strong>声明</strong>。仅此而已。我们再来看看js程序是如何去声明一个变量的。<code>var name;</code>这样就声明了一个变量名为<code>name</code>的变量。这么声明一个变量的话，变量的值毫无疑问就是一个<code>undefined</code>。总结一下就是：js引擎将使用<code>var</code>声明的变量赋值为<code>undefined</code>放在了程序开始执行的第一步去做了。这个概念就这么简洁明了的解释清楚了。</p>
<p><strong>变量提升的作用：</strong><br>那为什么js引擎要做这个变量提升的事情呢，这个主要还是为了节约CPU开销去考虑的一个事情，因为声明变量是需要去在内存中开辟出一块空间来存放这个变量的。这个动作是比较耗费CPU资源的一个动作，如果在程序中大量的去执行这个动作的话，毫无疑问会对程序执行的效率造成一定的影响。所以将这一类的操作，全部提前一次性的给他完成了，以这样的方式来提升程序的执行效率。</p>
<p><strong>我们结合一个例子来更加清楚的理解一下这个概念：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 输出undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>这是一个简单的例子，很好的展现了变量提升这个概念。首先在全局作用域中，js引擎去搜索了所有<code>var</code>声明的变量，然后在当前的这个作用域中提前声明，再逐行执行代码。也就是说上面的这段代码实际上是下面的这个样子的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 输出undefined</span></span><br><span class="line">a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>这么看来就毫无疑问输出一个<code>undefined</code>了。</p>
<h2 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h2><p>介绍一个很重要的对象，<code>window</code>对象，这是一个内置的全局对象，之所以说这个对象很重要呢是因为我们所声明的一些全局变量都是这个对象下的属性，我们所写的方法也是这个对象的方法。</p>
<p>我个人其实更愿意将这个<code>window</code>对象理解为一个特殊的<strong>变量对象</strong>（一个全局的变量对象）我们来分析一下变量对象在创建的时候都做了什么和<code>widnow</code>对象都有什么。</p>
<ol>
<li>首先创建变量对象的第一步是：建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。<br> <code>window</code>对象做为一个全局的对象，并没有参数传递进来，自然也就没有这一步。</li>
<li>然后第二步是：检查当前执行上下文中的函数声明，在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。<br> 这一步在<code>window</code>对象中是有体现的，因为在js程序中声明的全局函数都是可以直接通过<code>window</code>对象去直接<code>.</code>的调用的。而且<code>window</code>对象还为我们内置了许多的方法可以直接调用，不需要自己手动的去写，封装了一些更方便的工具方法。</li>
<li>最后第三步是：检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。<br> 我们在声明全局的变量时其实就是在声明一个<code>window</code>对象的属性。</li>
</ol>
<p><strong>来看一些简单的例子：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fn&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">name</span> === name); <span class="comment">// 输出true</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">fn</span>(); <span class="comment">// 输出fn</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，定义的全局变量或者是方法，都可以使用<code>windwow</code>去<code>.</code>一下调用出来。甚至是一个没有定义的变量，也可以使用<code>window</code>对象去<code>.</code>出来。在上面作用域的哪个例子中如果使用<code>window</code>对象去调用变量<code>name1</code>的话是不会报错的。我们来看一下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name1 = <span class="string">&quot;lisi&quot;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name);   <span class="comment">// 输出zhangsan</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">name1</span>);  <span class="comment">//输出undefined</span></span><br><span class="line"><span class="title function_">fn</span>();  <span class="comment">// 输出zhangsan</span></span><br></pre></td></tr></table></figure>
<p>我们再来看一个例子，然后分析一下这个<code>window</code>对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name);  <span class="comment">// 输出undefined</span></span><br><span class="line"></span><br><span class="line">conosle.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">name1</span>);  <span class="comment">// 输出undefined</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：上面这个例子需要在IE浏览器中运行才会出效果</strong></p>
<blockquote>
<p>以上是我的一些个人看法，如果有不对的地方，还请在评论区直接指出。</p>
</blockquote>
<h2 id="活动对象（Activation-Object，AO）"><a href="#活动对象（Activation-Object，AO）" class="headerlink" title="活动对象（Activation Object，AO）"></a>活动对象（Activation Object，AO）</h2><p>前文提到的变量对象在执行上下文的<strong>创建阶段</strong>被创建出来，但是这个时候我们是没办法去访问变量对象里面的属性的。<br>但是在执行上下文的<strong>创建阶段</strong>结束后进入<strong>执行阶段</strong>时，变量对象会转变成为活动对象。这是就可以访问里面的属性了。<br>所以，实际上变量对象和活动对象是同一个对象，只是处于执行上下文生命周期的不同阶段而已。</p>
<h1 id="六、this关键字"><a href="#六、this关键字" class="headerlink" title="六、this关键字"></a>六、this关键字</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>首先要说明的一点是：<code>this</code>并不是在定义函数的时候确定的，前文提过，一个执行上下文在创建的阶段最重要的三件事之中其中之一就是确定<code>this</code>的指向，所以<code>this</code>是在执行上下文创建的时候才会去指定的。而执行上下文有全局的还有函数的，因此<code>this</code>可以被剖析为全局的<code>this</code>和函数的<code>this</code>。<br>实际上，如果在一个对象中去定义了一个函数的话，其实是将这个函数在堆内存中声明了一下，再去赋值给对象中的属性，所以在调用这个对象的这个函数的属性的时候其实并不一定是在同一个作用域下去调用的，针对不同的作用域，<code>this</code>的指向也就不同。</p>
<p>我们来看一个例子加深理解：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;zhangsan&#x27;</span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;lisi&#x27;</span>,</span><br><span class="line">  <span class="attr">fn</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">subObj</span>: &#123;</span><br><span class="line">    <span class="attr">fn</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">fn</span>(); <span class="comment">// 输出lisi</span></span><br><span class="line">obj.<span class="property">subObj</span>.<span class="title function_">fn</span>() <span class="comment">// 输出undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> say = obj.<span class="property">subObj</span>.<span class="property">fn</span>;</span><br><span class="line"><span class="title function_">say</span>(); <span class="comment">// 输出zhangsan</span></span><br></pre></td></tr></table></figure>
<p>在上面这个例子中，三个<code>this</code>分别指向三个不同的对象。</p>
<p>第一个<code>obj.fn()</code>直接由<code>obj</code>对象调用，指向的是<code>obj</code>对象。</p>
<p>第二个<code>obj.subObj.fn()</code>由<code>obj</code>对象去调用了<code>subObj</code>对象，再由<code>subObj</code>对象去调用了<code>fn</code>方法，所以实际上是<code>subObj</code>对象去调用了<code>fn</code>方法，所处的也就是<code>sub</code>对象的作用域之中，自然指向的也就是<code>sub</code>对象了。</p>
<p>第三个<code>say</code>对象是由<code>obj.subObj.fn</code>对象赋值而来的，而<code>say</code>对象又是处于全局的作用域下，所以在这里虽然是声明了一个<code>obj.subObj.fn</code>对象，但是所处的作用域确实一个全局作用域，指向的也就是全局中的<code>window</code>对象。</p>
<p>上面这个例子很好的诠释了<code>this</code>这个关键字在不同情况下指向的是完全不同的对象。<strong>谨记一点<code>this</code>关键字是在调用时才能够确定指向的</strong>。</p>
<h3 id="全局中的this"><a href="#全局中的this" class="headerlink" title="全局中的this"></a>全局中的this</h3><p>全局中的<code>this</code>对象非常简单，就是指向了上文提到的<code>window</code>对象，也就是说任何在函数外部的<code>this</code>都是指向了<code>window</code>对象。<br>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === <span class="variable language_">window</span>) <span class="comment">// 输出true</span></span><br></pre></td></tr></table></figure>
<p>上面这个例子中，直接在全局中比较<code>this</code>对象和<code>window</code>对象，结果为true。充分证明了在全局环境中，<code>this</code>指向的就是<code>window</code>对象。</p>
<h3 id="函数中的this"><a href="#函数中的this" class="headerlink" title="函数中的this"></a>函数中的this</h3><ol>
<li><p><strong>普通函数</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>(); <span class="comment">// 输出Window</span></span><br></pre></td></tr></table></figure>
<p>这个很好理解，<code>fn()</code>处于一个全局作用域中由<code>window</code>对象直接调用，所以<code>this</code>指向的是<code>window</code>对象本身。</p>
</li>
<li><p><strong>构造函数</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;zhangsan&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">Fn</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">name</span>); <span class="comment">// 输出zhangsan</span></span><br></pre></td></tr></table></figure>
<p>任何使用<code>new</code>关键字创建出来的都是一个对象，是一个在<strong>堆内存</strong>中的对象，所以在这里<code>this</code>指的是新创建的这个对象。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript：作用域</title>
    <url>/posts/1709/</url>
    <content><![CDATA[<p>js中仅有两种作用域，<strong>全局作用域</strong>和<strong>局部作用域</strong>，<strong>局部作用域</strong>又被称为<strong>函数作用域</strong>。js中没有块级作用域这个概念，块级作用域只在一些其他的语言中才有，比如：Java、C++。作用域的这个概念是由于变量起作用的区域不用才被引出来的，所以作用域又被称为变量作用域。</p>
<h1 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h1><p>先简单了解一下全局变量和局部变量。js可以简单的将在函数外部定义的变量称为全局变量，在函数内定义的变量称为局部变量。变量作用域的概念也因此而生，变量作用域实际就是变量产生作用的区域。全局变量在整个js程序中的任何地方都可以去调用，所以全局变量生存在一个全局作用域中。而局部变量只能够在函数内部去调用，出了函数之后就无法再访问到了，因此局部变量只生存在函数的作用域中。</p>
<blockquote>
<p><strong>注意：在函数内部声明变量时一定要使用显式声明，即使用<code>var</code>关键字声明。如果在函数内部隐式声明一个变量的话，实际声明的是一个全局变量</strong></p>
</blockquote>
<p><strong>来看一个例子：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;zhangsan&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span> ()  &#123;</span><br><span class="line">    <span class="keyword">var</span> name1 = <span class="string">&#x27;lisi&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name);  <span class="comment">// 输出zhangsan</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name1); <span class="comment">// 输出lisi</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// 输出zhangsan</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name1); <span class="comment">// 报错 name1 is not defined</span></span><br></pre></td></tr></table></figure>
<p>这个例子中变量<code>name</code>是一个全局变量能够在程序的任何地方访问到。而变量<code>name1</code>声明在<code>fn</code>函数内部，是一个局部变量，所以仅仅只能在<code>fn</code>内部访问到。在这个例子中有两个作用域，一个是变量<code>name</code>位于的全局作用域，一个是变量<code>name1</code>位于的局部作用域。但是我们并不能够简单的将局部作用域理解为函数的花括号之内，因为js是没有块级作用域这个概念的，我们应该将其理解为函数的作用域。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript：数据类型</title>
    <url>/posts/24923/</url>
    <content><![CDATA[<p>我们所使用的编程语言，不管是js也好或者是其他的一些语言，例如：Java、C++。我们在编写程序的时候实际上都是在对数据进行操作。如果脱离了数据，那么我们编写的程序将变得毫无意义。甚至脱离了数据之后我们将无法编程。由此，数据类型便成了重中之重。</p>
<h1 id="一、js数据类型简介"><a href="#一、js数据类型简介" class="headerlink" title="一、js数据类型简介"></a>一、js数据类型简介</h1><ol>
<li>js的数据类型主要分为两大类，原始类型（即基本数据类型）和对象类型（即引用数据类型）。</li>
<li>js中的基本数据类型可以分为5种：Number、String、Boolean、Undefined、Null。</li>
<li>js中的引用数据类型也就是对象类型Object，主要是Object、Array、Function这几种。</li>
</ol>
<h1 id="二、基本数据类型和引用数据类型的区别"><a href="#二、基本数据类型和引用数据类型的区别" class="headerlink" title="二、基本数据类型和引用数据类型的区别"></a>二、基本数据类型和引用数据类型的区别</h1><p>首先这里需要先简单的介绍一下堆内存和栈内存。计算机的内存中有堆内存和栈内存，栈内存呢是一个一个排列下去的是有序的，也是固定大小的，像是数组一样；而堆内存呢则刚好是与栈内存相反，堆内存中的数据是无序的，也是不固定大小的。</p>
<h2 id="堆栈内存的优缺点"><a href="#堆栈内存的优缺点" class="headerlink" title="堆栈内存的优缺点"></a>堆栈内存的优缺点</h2><p>栈内存由于是有序的所以在查询数据的时候直接按照排序的序号去查的话是比较快的，但是由于固定大小的原因呢，栈内存无法随心所欲的存储数据。堆内存由于不固定大小，所以在其中存储的数据是比较方便的，也就是想怎么存就怎么存，但是因为堆内存中的数据是无序的，所以在查找的时候就是要比较慢一些。  </p>
<blockquote>
<p>总结：就是栈内存优点是查询快，存储不方便；而堆内存则是存储方便，但查询慢。  </p>
</blockquote>
<p><em>这么说可能还是有点不太形象，举个例子吧。栈内存中的空间呢就像是现实生活中的商品房一样，一个一个的房子都是开发商建好的，每个房子的大小是固定的，每个房子也有对应的门牌号，比如某某单元的几零几这样，查找起来呢是比较方便。堆内存呢就像是一栋一栋的独栋别墅一样，没有一个集中的管理，但是大小不固定，可能是有一块地用来建别墅，我今天打算建个100平米的别墅，明天我就可能扩建到200平米了，甚至是再往上多建几层。</em>    </p>
<p>既然堆内存和栈内存有这样的优缺点，那么何不将两者的优点结合起来，在栈内存中存放指向堆内存中的指针。这样可以即查询快又存储数据方便。这样的数据也就是上面说的引用数据类型。我们待会细说。</p>
<h1 id="三、基本数据类型的特点"><a href="#三、基本数据类型的特点" class="headerlink" title="三、基本数据类型的特点"></a>三、基本数据类型的特点</h1><ol>
<li><p>基本数据类型的赋值仅仅只是简单的值传递：<br>如果需要从一个变量向另一个变量去赋一个基本数据类型的值，那么会将其中基本变量的值生成一个副本再将这个副本的值直接传递过去，而不是引用同一个值。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 输出18</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 输出18</span></span><br><span class="line">a++;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 输出19</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 输出18</span></span><br></pre></td></tr></table></figure>
<p>在上述的例子中，一开始先将变量<code>a</code>的值赋给了变量<code>b</code>，这时变量<code>a</code>的值和变量<code>b</code>的值都是18，然后我们再将变量<code>a</code>的值进行<code>++</code>操作，变量<code>a</code>的值变成了19，但是变量<code>b</code>的值任然还是18，由此可见变量<code>a</code>和变量<code>b</code>的值是完全互不相干的，没有关系的。</p>
<p> <em>举个例子吧，就比如我们平时在使用<code>ctrl + c</code>和<code>ctrl + v</code>复制黏贴的时候是一样的，我们复制的文本并不会随着原来文本的改变而改变，同样原来的文本也不会因为被复制的文本的改变而发生任何变化。同理，变量之间的赋值也是一次简单的“<code>ctrl + c</code>和<code>ctrl + v</code>”而已。</em></p>
</li>
<li><p>基本数据类型的值是固定的，无法修改的。比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> anotherStr = str.<span class="title function_">replace</span>(<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str); <span class="comment">// 输出 string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(anotherStr); <span class="comment">// 输出 tring</span></span><br></pre></td></tr></table></figure>
<p>在上面的这个例子中我们可以看到，字符串<code>str</code>的值一直都是<code>string</code>，尽管我们调用的<code>replace</code>方法将其中的<code>s</code>替换成了空字符串，但是实际上的<code>str</code>的值并没有被修改，任然是<code>string</code>。修改后的值传回来了一个新的变量，这个变量的值才是<code>tring</code>，然而这是一个全新的变量跟原来的<code>str</code>并没有什么关系。</p>
<p> <strong>我们再来看一个例子：</strong></p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;zhangsan&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// 输出zhangsan</span></span><br><span class="line">name = <span class="string">&#x27;lisi&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// 输出lisi</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中看起来<code>name</code>的值由“zhangsan”被修改为“lisi”，但其实并不是修改，原来的“zhangsan”还是“zhangsan”，只是被一个新的值“lisi”覆盖掉了而已。</p>
<pre><code>*这么说起来可能不是很形象，举个例子吧。现实生活中我们在画画的时候如果原本的颜色是红色的，但是我们想要将其修改为绿色的话我们是将新的绿色的颜料直接涂抹在原来红色的地方上面，这样在我们看来好像红色被修改为绿色，但红色还是红色只是被覆盖了我们看不到了而已，我们看到的是绿色。在这个例子中也是同理。*
</code></pre>
<h1 id="四、五种基本数据类型详解"><a href="#四、五种基本数据类型详解" class="headerlink" title="四、五种基本数据类型详解"></a>四、五种基本数据类型详解</h1><h2 id="typeof运算符"><a href="#typeof运算符" class="headerlink" title="typeof运算符"></a>typeof运算符</h2><p>我们要检测一种基本数据类型时可以使用typeof运算符去检测，其语法是<code>typeof 变量</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">123</span>);            <span class="comment">// 输出number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">&#x27;string&#x27;</span>);       <span class="comment">// 输出string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">true</span>);           <span class="comment">// 输出boolean</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>);           <span class="comment">// 输出Object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">undefined</span>);      <span class="comment">// 输出undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;);   <span class="comment">// 输出function</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：检测null时返回的是一个Object类型，这是因为null类型其实是一个空的对象应用，也就是一个对象但什么都没有。</p>
</blockquote>
<h2 id="Number-数值类型"><a href="#Number-数值类型" class="headerlink" title="Number(数值类型)"></a>Number(数值类型)</h2><p>在一些强语言中，数值类型可能会分为整数和浮点数，再根据占用的长度去再往下继续分为好几种数据类型，比如Java和C。但是在js中数值类型只有一种就是Number，在定义一个数值类型时加不加小数点都是可以的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> number = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> number); <span class="comment">// 输出number</span></span><br></pre></td></tr></table></figure>
<p>上面的这个例子中为我们展示了如何去定义一个number类型的变量，以及如何去检测一个number变量。<br>js中如果需要表示一个非常大或者是非常小的数字可以使用科学计数法，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">123e+5</span>;  <span class="comment">// 表示的是 12300000</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">123e-5</span>;  <span class="comment">// 表示的是 0.00123</span></span><br></pre></td></tr></table></figure>
<p>js中表示最大的数值是<code>Number.MAX_VALUE</code>，与之对应的是<code>Numver.MIN_VALUE</code>表示的是js中最小的数值。</p>
<p>js中还有一个非常特殊的数值类型，就是NaN(Not A Number)即非数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。例如，在其他编程语言中，任何数值除以0都会导致错误，从而停止代码执行。但在JavaScript中，任何数值除以0会返回NaN，因此不会影响其他代码的执行。</p>
<p>NaN有两个非同寻常的点，一个是任何涉及NaN的操作都会返回NaN，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">NaN</span> + <span class="number">1</span>); <span class="comment">// 输出NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">NaN</span> - <span class="number">1</span>); <span class="comment">// 输出NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">NaN</span> * <span class="number">1</span>); <span class="comment">// 输出NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">NaN</span> / <span class="number">1</span>); <span class="comment">// 输出NaN</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这个特点在多步计算中有可能导致问题，需要特别注意</p>
</blockquote>
<p>另一个是NaN与任何值都不相等，包括NaN本身，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">NaN</span> == <span class="title class_">NaN</span>); <span class="comment">// 输出false</span></span><br></pre></td></tr></table></figure>

<h2 id="String-字符串类型"><a href="#String-字符串类型" class="headerlink" title="String(字符串类型)"></a>String(字符串类型)</h2><p>在js中的字符串类型是需要使用引号引起来的，使用单引号’’或者是双引号””都可以，但是不要混合着用，也不能嵌套使用单双引号。</p>
<p>string类型有些特殊，因为字符串具有可变的大小，所以显然它不能被直接存储在具有固定大小的变量中。由于效率的原因，我们希望JS只复制对字符串的引用，而不是字符串的内容。但是另一方面，字符串在许多方面都和基本类型的表现相似，而字符串是不可变的这一事实（即没法改变一个字符串值的内容），因此可以将字符串看成<strong>行为与基本类型相似的不可变引用类型</strong></p>
<p>如果需要在String类型中输出一些特殊的字符的话可以使用<code>\</code>字符来转义，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我说：\&quot;我想吃西瓜\&quot;&quot;</span>); <span class="comment">// 输出 我说：&quot;我想吃西瓜&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果想输出一个<code>\</code>的话则需要再使用一个<code>\</code>来转义，即<code>\\</code></p>
</blockquote>
<h2 id="Boolean-布尔类型"><a href="#Boolean-布尔类型" class="headerlink" title="Boolean(布尔类型)"></a>Boolean(布尔类型)</h2><p>Boolean类型只有两个值：true表示真和false表示假。<br>虽然Boolean类型的字面值只有两个，但JavaScript中所有类型的值都有与这两个Boolean值等价的值。要将一个值转换为其对应的Boolean值，可以调用类型转换函数Boolean()，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> messageAsBoolean = <span class="title class_">Boolean</span>(message);</span><br></pre></td></tr></table></figure>
<p>在这个例子中，字符串message被转换成了一个Boolean值，该值被保存在messageAsBoolean变量中。可以对任何数据类型的值调用Boolean()函数，而且总会返回一个Boolean值。至于返回的这个值是true还是false，取决于要转换值的数据类型及其实际值。下表给出了各种数据类型及其对象的转换规则。</p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="right">转换成true值</th>
<th align="center">转换成false值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Boolean</td>
<td align="right">true</td>
<td align="center">false</td>
</tr>
<tr>
<td align="left">String</td>
<td align="right">任何非空字符串</td>
<td align="center">“”空字符串</td>
</tr>
<tr>
<td align="left">Number</td>
<td align="right">任何非0数值（包括无穷大）</td>
<td align="center">0和NaN</td>
</tr>
<tr>
<td align="left">Object</td>
<td align="right">任何非空对象</td>
<td align="center">null</td>
</tr>
<tr>
<td align="left">Undefined</td>
<td align="right">不适用</td>
<td align="center">Undefined</td>
</tr>
</tbody></table>
<p><strong>ps：如果需要将一个变量转换成对应的布尔值的话，可以使用<code>!!</code>(两个感叹号)操作符转换。例如：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!message);  <span class="comment">// 输出false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(!!message); <span class="comment">// 输出true</span></span><br></pre></td></tr></table></figure>
<p>使用一个<code>!</code>代表的是取反的操作，即转换为Boolean值之后取的是相反的值，但是再使用多一个<code>!</code>之后呢再将取反的操作再次取反之后就可以得到原来对应的Boolean值</p>
<h2 id="Null-空引用类型"><a href="#Null-空引用类型" class="headerlink" title="Null(空引用类型)"></a>Null(空引用类型)</h2><p>Null类型是只有一个值的特殊数据类型，这个特殊的值就是<code>null</code>代表的是一个空对象，一个空引用。从逻辑角度来看，<code>null</code>值表示一个空对象指针，而这也正是使用<code>typeof</code>操作符检测<code>null</code>时会返回<code>object</code>的原因。</p>
<p>如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为<code>null</code>而不是其他值。这样一来，只要直接检测<code>null</code>值就可以知道相应的变量是否已经保存了一个对象的引用了。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 对obj对象进行的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Undefined-未定义"><a href="#Undefined-未定义" class="headerlink" title="Undefined(未定义)"></a>Undefined(未定义)</h2><p>Undefined类型只有一个值，即特殊的<code>undefined</code>。在使用<code>var</code>声明变量但未对其加以初始化时，这个变量的值就是<code>undefined</code>。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 输出undefined</span></span><br></pre></td></tr></table></figure>

<h1 id="五、引用数据类型"><a href="#五、引用数据类型" class="headerlink" title="五、引用数据类型"></a>五、引用数据类型</h1><h2 id="引用数据类型的介绍"><a href="#引用数据类型的介绍" class="headerlink" title="引用数据类型的介绍"></a>引用数据类型的介绍</h2><p>除了上面介绍的基本数据类型之外，其他的就是引用数据类型了。引用类型统称是Objcet，所有的引用数据类型的数据都是继承自Object的。例如：Array（数组）、Date（日期）、Function（函数）等。这些都是引用数据类型，也都是继承自Object。</p>
<h2 id="引用数据类型的特点"><a href="#引用数据类型的特点" class="headerlink" title="引用数据类型的特点"></a>引用数据类型的特点</h2><ol>
<li><p><strong>引用类型的值是可变的</strong></p>
<p> 引用数据类型跟基本数据类型最大的不同就是内存存放位置的不同，上文提过基本数据类型是存放在<strong>栈内存</strong>中的，引用数据类型则是存放在<strong>堆内存</strong>中的。引用数据类型将堆内存中的地址存放在栈内存中，通过变量标识符去取到地址再进行访问。而堆内存的大小并不是固定的，所以引用数据类型的值是可变的。基于这个特点，我们如果想要在一个引用数据类型中取增加或者是删除一些内容的话也都是可以实现的，我们甚至可以在一个引用中去定义另一个引用，我们来看一个例子：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">&quot;zhangsan&quot;</span>&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>);  <span class="comment">// 输出zhangsan</span></span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&quot;lisi&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>);  <span class="comment">// 输出lisi</span></span><br><span class="line">obj.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">age</span>);   <span class="comment">// 输出18</span></span><br><span class="line">obj.<span class="property">age</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">age</span>);   <span class="comment">// 输出null</span></span><br><span class="line">obj.<span class="property">printObj</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;---&quot;</span> + <span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">printObj</span>(); <span class="comment">// 输出lisi---null</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>引用数据类型的比较是引用的比较</strong></p>
<p> 我们先来看一个例子：</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1 == obj2);   <span class="comment">// 输出false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1 === obj2);  <span class="comment">// 输出false</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>obj1</code>和<code>obj2</code>都是定义了相同的内容，都是<code>&#123;&#125;</code>，但是在比较的时候js却不认为这是两个相同的对象。原因在于声明这两个对象时，会在堆内存中开辟出两块不同的空间去分别存放这两个变量，然后将堆内存存放这两个对象对应的内存地址再去存在栈内存中去。在比较时并不会去比较两个对象具体的区别，而是在栈内存中将地址取出来之后进行比较，如果地址相同都是指向同一块内存的话才会认为是相同的对象，反之则认为是不同的对象。</p>
<pre><code>我们再来看一个例子：
</code></pre>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">name</span>:<span class="string">&quot;zhangsan&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">name</span>); <span class="comment">// 输出zhangsan</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">name</span>); <span class="comment">// 输出zhangsan</span></span><br><span class="line">obj2.<span class="property">name</span> = <span class="string">&quot;lisi&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1.<span class="property">name</span>); <span class="comment">// 输出lisi</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">name</span>); <span class="comment">// 输出lisi</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，首先声明了一个对象<code>obj1</code>再将<code>obj1</code>的值赋给<code>obj2</code>，这时其实是将<code>obj1</code>的地址赋给了<code>obj2</code>，也就是说在栈内存中的<code>obj1</code>和<code>obj2</code>的值是相等的，都是保存的相同的地址，指向的是同一块堆内存中的空间。所以不管是改变了<code>obj1</code>还是改变了<code>obj2</code>其实都是在操作的同一块内存空间，做出来的改变也是相同的，另一个指向这个空间的对象也是会跟随着一起改变。</p>
<ol start="3">
<li><strong>instanceof</strong><br>一个对象如果我们需要去检测它是不是属于某个对象的实例的话，我们需要使用<code>instanceof</code>关键字，语法是<code>实例 instanceof 对象</code>表示这个实例是否属于这个对象。例如：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((&#123;&#125;) <span class="keyword">instanceof</span> <span class="title class_">Object</span>);    <span class="comment">// 输出true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(([]) <span class="keyword">instanceof</span> <span class="title class_">Array</span>);     <span class="comment">// 输出true</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>categories</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>这里</title>
    <url>/here/index.html</url>
    <content><![CDATA[<ul>
<li>人生最重要的是找到自己的热爱，并坚持。</li>
<li>生命的意义在于不断发现美的过程，就像你发现了这朵花，而我发现了你。</li>
<li>以宁静敬重的心敲出的每一行代码，都会以最优雅的方式留存它的美丽。</li>
<li>人们总是喜欢先入为主地评价别人，却不知背后的逻辑也可以很复杂，不知道自己所知道的真的很少。所以，学习是一辈子的事情。</li>
<li>人这一生应该通过阅读、行走、学习、阅人，逐渐解锁更大的地图，看到更亮的世界。其实在二十多岁时，人最应该做的，就是拓展边界、探索未知、去伪存真、求知发问，打破不属于自己的人设。</li>
<li>世界上并没有完美的程序，但我们并不因此而沮丧，因为写程序本来就是一个不断追求完美的过程。<br></li>
</ul>
<hr>
<p>大家加油：）</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/link/index.html</url>
    <content><![CDATA[<hr>
<blockquote>
<p><strong>友链申请滴注意事项：</strong></p>
<ol>
<li>内容持续更新且可以稳定访问</li>
<li>网页整洁无繁杂广告推广</li>
<li>本站会定期清理无法访问的友链，如果更换了链接信息请至评论区留言，谢谢合作</li>
<li>本站会定期查看双方是否互为友链，如果取消本站友链，本站也会将您的友链移除</li>
<li>将本站的友链添加到您的友链，相关信息如下</li>
<li>按照以下格式在以下评论区留言，待博主为您添上友链</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">名称：知更博客</span><br><span class="line">头像链接：https://www.wrp.cool/images/avatar.png</span><br><span class="line">主页链接：https://www.wrp.cool</span><br><span class="line">说明信息：知道要更新，知道要进步</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/about/index.html</url>
    <content><![CDATA[<div class="note success flat"><p><strong>没错，是我了</strong></p>
</div>

<ul>
<li>一个简简单单的小年轻</li>
<li>一个有点小小梦想的小年轻</li>
<li>冲！冲！冲！！！</li>
</ul>
<div class="note success flat"><p><strong>没错，是这个小站了</strong></p>
</div>

<ul>
<li>一个简简单单的博客小站</li>
<li>一个有点小小梦想的博客小站</li>
</ul>
<div class="note success flat"><p><strong>没错，是我微信了</strong></p>
</div>

<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/6ac9184fb440093a91541cc797ec88e.jpg" alt="6ac9184fb440093a91541cc797ec88e"></p>
<blockquote>
<p>座右铭：以宁静敬重的心敲出的每一行代码，都会以最优雅的方式留存它的美丽。</p>
<p align="right">—— 来自一个温柔、浪漫的年轻人</p>
</blockquote>
<hr>
<p>大家加油：）</p>
]]></content>
  </entry>
  <entry>
    <title>标签</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
