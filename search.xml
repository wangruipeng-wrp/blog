<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【ES6】扩展知识</title>
    <url>/posts/18551/</url>
    <content><![CDATA[<blockquote>
<p>本文将介绍一些关于ES6的比较基础的比较零碎的知识。</p>
</blockquote>
<a id="more"></a>

<h1 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h1><p>模板字符串在字符串拼接方面比起以前要方便很多。模板字符串的语法是一对反引号 ( `` ) </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name : <span class="string">'zhangsan'</span>,</span><br><span class="line">    age : <span class="number">20</span>,</span><br><span class="line"></span><br><span class="line">    say1() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'我叫 '</span> + <span class="keyword">this</span>.name + <span class="string">'，今年 '</span> + <span class="keyword">this</span>.age + <span class="string">' 岁了'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    say2() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`我叫 <span class="subst">$&#123; <span class="keyword">this</span>.name &#125;</span>，今年 <span class="subst">$&#123; <span class="keyword">this</span>.age &#125;</span> 岁了`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.say1();</span><br><span class="line">obj.say2();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上 say1 和 say2 方法打印的效果完全相同</span></span><br></pre></td></tr></table></figure>
<p>顺带说一下 ES6 中一个比较有用的字符串的方法 includes 方法。判断字符串中是否包含了其他字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'Hello World!'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.includes(<span class="string">'o W'</span>));  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="for-of-循环"><a href="#for-of-循环" class="headerlink" title="for-of 循环"></a>for-of 循环</h1><p>for-of 循环类似于 Java 中的 foreach 循环。来看代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'zhangsan'</span>, <span class="string">'lisi'</span>, <span class="string">'wangwu'</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> name <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// zhangsan lisi wangwu</span></span><br></pre></td></tr></table></figure>
<p>也可以用来遍历字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'Hello World!'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> str) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Hello World!</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="unicode表示法"><a href="#unicode表示法" class="headerlink" title="unicode表示法"></a>unicode表示法</h1><p>ES6 之前 unicode 码点仅可以表示的范围是（0000 - ffff）超出这个范围的将无法表示例如 emoji 表情。ES6 中表示 unicode 的语法是 <code>\u{码点}</code>，这样就可以表示超出范围的码点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'\u&#123;1f436&#125;'</span>); <span class="comment">// 🐶</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p>箭头函数的标志是一个箭头 <code>=&gt;</code> 就是这个样子，箭头函数可以简化函数的书写过程，使得代码更加简洁。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> add1 = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</span><br><span class="line"><span class="keyword">const</span> add2 = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add1(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">add2(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// add1 和 add2 执行的效果相同</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>小提示：如果只有一个参数的情况下是可以不用加括弧的哦</p>
</blockquote>
<p>上面的代码中仅仅只是执行一行代码而已，如果需要执行多行代码，那么需要像下面这样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> add1 = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    a += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> add2 = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    a += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add1(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">add2(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样，add1 和 add2 执行效果相同</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>小技巧：如果我们需要执行一个有返回值的函数但是又不需要函数的返回值，可以在箭头函数的函数体前加 void</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pop = <span class="function"><span class="params">arr</span> =&gt;</span> <span class="keyword">void</span> arr.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(pop(arr));  <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);  <span class="comment">// 1,2</span></span><br></pre></td></tr></table></figure>

<h2 id="区别普通函数"><a href="#区别普通函数" class="headerlink" title="区别普通函数"></a>区别普通函数</h2><ol>
<li><p>没有 arguments 对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> log = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 报错：arguments is not defined</span></span><br></pre></td></tr></table></figure>
<p>小技巧：如果需要使用 arguments 对象可以使用 <code>...参数名</code> 的方式来代替，这里的 <code>...</code> 指的是函数的剩余参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> log = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 输出 [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>没有专属的 this 对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'zhangsan'</span>,</span><br><span class="line">    say1() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    say2: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.say1(); <span class="comment">// obj 对象</span></span><br><span class="line">obj.say2(); <span class="comment">// window 对象</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以将箭头函数的 this 理解为上一级环境中的 this</p>
</blockquote>
<p> 小技巧：在开发中经常需要去在回调函数中去调用上一级的 this 对象，在这种情况下我们要先将上一级的 this 对象保留下来，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'zhangsan'</span>,</span><br><span class="line">    age: <span class="literal">null</span>,</span><br><span class="line">    getAge() &#123;</span><br><span class="line">        <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用计时器模拟回调函数</span></span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            _this.age = <span class="number">20</span>;</span><br><span class="line">            <span class="built_in">console</span>.log(_this.age);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.getAge(); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<p>上面的代码如果使用箭头函数可以省略掉 <code>let _this = this</code> 的这一步</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'zhangsan'</span>,</span><br><span class="line">    age: <span class="literal">null</span>,</span><br><span class="line">    getAge() &#123;</span><br><span class="line">        <span class="comment">// 使用计时器模拟回调函数</span></span><br><span class="line">        setTimeout( <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.age = <span class="number">20</span>;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.getAge(); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h1 id="对象的简洁表示法"><a href="#对象的简洁表示法" class="headerlink" title="对象的简洁表示法"></a>对象的简洁表示法</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不使用简洁表示法</span></span><br><span class="line"><span class="keyword">const</span> getUserInfo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="string">'zhangsan'</span>,</span><br><span class="line">    <span class="keyword">const</span> age = <span class="number">20</span>,</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        age: age,</span><br><span class="line">        say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="keyword">this</span>.age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用简洁表示法</span></span><br><span class="line"><span class="keyword">const</span> getUserInfo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="string">'zhangsan'</span>,</span><br><span class="line">    <span class="keyword">const</span> age = <span class="number">20</span>,</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name,</span><br><span class="line">        age,</span><br><span class="line">        say() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="keyword">this</span>.age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="对象的新方法和新属性"><a href="#对象的新方法和新属性" class="headerlink" title="对象的新方法和新属性"></a>对象的新方法和新属性</h1><h2 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is"></a>Object.is</h2><blockquote>
<p>用来判断两个对象是否相同，与之前的判断主要有以下两个区别</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>));     <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === <span class="number">-0</span>);             <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>));   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>);           <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h2><blockquote>
<p>用来合并对象。注意：合并时仅仅是浅拷贝合并，也就是仅拷贝对象在栈内存中的地址。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.assign(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;, &#123;<span class="attr">b</span>:<span class="number">2</span>&#125;, &#123;<span class="attr">c</span>:<span class="number">3</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj);  <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浅拷贝例子：</span></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">Object</span>.assign(obj1, &#123;<span class="attr">b</span>:<span class="number">2</span>&#125;)</span><br><span class="line"></span><br><span class="line">obj2.a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj1);  <span class="comment">// &#123;a:100, b:2&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="Object-keys、Object-values、Object-entries"><a href="#Object-keys、Object-values、Object-entries" class="headerlink" title="Object.keys、Object.values、Object.entries"></a>Object.keys、Object.values、Object.entries</h2><blockquote>
<p>用来取出对象中的键和值</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span>,</span><br><span class="line">    c: <span class="number">3</span>,</span><br><span class="line">    d: <span class="number">4</span>,</span><br><span class="line">    e: <span class="number">5</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj));      <span class="comment">// ['a','b','c','d','e']</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(obj));    <span class="comment">// [1,2,3,4,5]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(obj));   <span class="comment">// [['a',1], ['b',2], ['c',3], ['d',4], ['e',5]]</span></span><br></pre></td></tr></table></figure>

<hr>
<p>大家加油：）</p>
]]></content>
      <categories>
        <category>JavaScript基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>【ES6】var、let、const</title>
    <url>/posts/37909/</url>
    <content><![CDATA[<blockquote>
<p>let 这个关键字都是在 ES6 中新出现的，作用与 var 是一样的，可以用来声明变量。const 关键字也是在 ES6 中新出现的，不同的是 const 是用来声明常量。</p>
</blockquote>
<a id="more"></a>


<h1 id="let-amp-var"><a href="#let-amp-var" class="headerlink" title="let &amp; var"></a>let &amp; var</h1><h4 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h4><p>「块级作用域」这个概念是在 ES6 中新引入的概念，就是一个 <code>{}</code> 「花括号」而已。所有的花括号之内都是一个单独的块级作用域，但是有一种特殊情况不是，那就是在声明对象的时候字面式声明一个对象的时候不是。</p>
<h4 id="let和var的区别"><a href="#let和var的区别" class="headerlink" title="let和var的区别"></a>let和var的区别</h4><ol>
<li><p>let 和 var 最大的区别就是 <strong>let声明的对象只在当前作用域生效</strong><br>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不能重复声明</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log(b)</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">20</span> </span><br><span class="line"><span class="built_in">console</span>.log(b)</span><br></pre></td></tr></table></figure>
<p>上面的代码将会直接报错</p>
</li>
<li><p>let 不存在「变量提升」<br>使用 var 关键字声明的变量在执行上下文中会有一个变量提升的现象，但是使用 let 声明的变量将不会出现这个现象，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b)  <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>暂存死区</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">20</span></span><br><span class="line">    <span class="built_in">console</span>.log(a) <span class="comment">// 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的这段代码将会直接报错。因为 ES6 中单独的作用域内使用 let 或者是 const 声明的变量将会形成一个封闭的作用域，这直接导致重名的变量无法访问到父级作用域的变量，进而报错。</p>
</li>
</ol>
<h1 id="const-常量"><a href="#const-常量" class="headerlink" title="const 常量"></a>const 常量</h1><ol>
<li><p>声明常量<br>const 声明时与 let 声明并没有什么区别，唯一的区别是使用 const 声明常量时需要在声明的同时初始化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> a <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不能修改<br>声明的既然是常量，那么当然是不允许被修改的。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">10</span></span><br><span class="line">a = <span class="number">20</span> <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p> <strong>如果声明的是一个引用类型的数据，那么它将可以被修改</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'zhangsan'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name)  <span class="comment">// zhangsan</span></span><br><span class="line"></span><br><span class="line">obj.name = <span class="string">'lisi'</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.name)  <span class="comment">// lisi</span></span><br></pre></td></tr></table></figure>
<p>实际上 const 声明的常量仅仅只是「锁定」了<strong>栈内存</strong>中的值，而引用数据类型实际存放的地方是在<strong>堆内存</strong>中的。所以对象类型的值是可以被修改的。</p>
<p> 那么我们既然是声明了一个常量的话当然是不希望这个常量能够被修改，如果是一个对象类型的常量的话，我们必须通过 <code>Object.freeze()</code> 这个方法来「冻结」这个对象类型的常量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'zhangsan'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name) <span class="comment">// zhangsan</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 冻结</span></span><br><span class="line"><span class="built_in">Object</span>.freeze(obj)</span><br><span class="line"></span><br><span class="line">obj.name = <span class="string">'lisi'</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.name) <span class="comment">// zhangsan</span></span><br></pre></td></tr></table></figure>
<p>在上面这个例子中两次的输出都是 <code>zhangsan</code> 这说明了我们并没有修改到 <code>obj</code> 这个对象，这样子就是声明了一个对象类型的常量表了。</p>
</li>
</ol>
<hr>
<p>大家加油：）</p>
]]></content>
      <categories>
        <category>JavaScript基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>【JavaScript】作用域</title>
    <url>/posts/1709/</url>
    <content><![CDATA[<p>js中仅有两种作用域，<strong>全局作用域</strong>和<strong>局部作用域</strong>，<strong>局部作用域</strong>又被称为<strong>函数作用域</strong>。js中没有块级作用域这个概念，块级作用域只在一些其他的语言中才有，比如：Java、C++。作用域的这个概念是由于变量起作用的区域不用才被引出来的，所以作用域又被称为变量作用域。</p>
<a id="more"></a>

<h1 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h1><p>先简单了解一下全局变量和局部变量。js可以简单的将在函数外部定义的变量称为全局变量，在函数内定义的变量称为局部变量。变量作用域的概念也因此而生，变量作用域实际就是变量产生作用的区域。全局变量在整个js程序中的任何地方都可以去调用，所以全局变量生存在一个全局作用域中。而局部变量只能够在函数内部去调用，出了函数之后就无法再访问到了，因此局部变量只生存在函数的作用域中。</p>
<blockquote>
<p><strong>注意：在函数内部声明变量时一定要使用显式声明，即使用<code>var</code>关键字声明。如果在函数内部隐式声明一个变量的话，实际声明的是一个全局变量</strong></p>
</blockquote>
<p><strong>来看一个例子：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'zhangsan'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>)  </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name1 = <span class="string">'lisi'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(name);  <span class="comment">// 输出zhangsan</span></span><br><span class="line">    <span class="built_in">console</span>.log(name1); <span class="comment">// 输出lisi</span></span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// 输出zhangsan</span></span><br><span class="line"><span class="built_in">console</span>.log(name1); <span class="comment">// 报错 name1 is not defined</span></span><br></pre></td></tr></table></figure>
<p>这个例子中变量<code>name</code>是一个全局变量能够在程序的任何地方访问到。而变量<code>name1</code>声明在<code>fn</code>函数内部，是一个局部变量，所以仅仅只能在<code>fn</code>内部访问到。在这个例子中有两个作用域，一个是变量<code>name</code>位于的全局作用域，一个是变量<code>name1</code>位于的局部作用域。但是我们并不能够简单的将局部作用域理解为函数的花括号之内，因为js是没有块级作用域这个概念的，我们应该将其理解为函数的作用域。</p>
<hr>
<p>大家加油：）</p>
]]></content>
      <categories>
        <category>JavaScript基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>【JavaScript】创建对象</title>
    <url>/posts/15655/</url>
    <content><![CDATA[<p>这篇博客将会记录一下js中创建对象的几种不同的方式，分别是字面式声明、<code>new</code>关键字声明、构造函数声明、工厂模式声明、原型声明。</p>
<a id="more"></a>

<h1 id="字面式声明"><a href="#字面式声明" class="headerlink" title="字面式声明"></a>字面式声明</h1><p>声明格式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接实例化一个对象</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'zhangsan'</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    </span><br><span class="line">    run: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"姓名："</span> + <span class="keyword">this</span>.name + <span class="string">"年龄："</span> + <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用属性和函数</span></span><br><span class="line">obj.name;</span><br><span class="line">obj.age;</span><br><span class="line">obj.run();</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="new关键字声明"><a href="#new关键字声明" class="headerlink" title="new关键字声明"></a>new关键字声明</h1><p><code>Object</code>对象是所有对象的父类，也称为根类、基类、超类。js中的所有对象都是<code>Object</code>对象的延伸，都是<code>Object</code>的子类。</p>
<p>声明格式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.属性 = 属性值;</span><br><span class="line">obj.属性 = 属性值;</span><br><span class="line">obj.函数 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a>构造函数创建对象</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">obj</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.run = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"姓名："</span> + <span class="keyword">this</span>.name + <span class="string">"年龄："</span> + <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> obj();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用属性和方法</span></span><br><span class="line">obj.name;</span><br><span class="line">obj.age;</span><br><span class="line">obj.run();</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="工厂模式创建对象"><a href="#工厂模式创建对象" class="headerlink" title="工厂模式创建对象"></a>工厂模式创建对象</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个工厂</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    obj.name = name;</span><br><span class="line">    obj.age = age;</span><br><span class="line">    obj.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"姓名："</span> + <span class="keyword">this</span>.name + <span class="string">"年龄："</span> + <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过工厂实例化对象</span></span><br><span class="line"><span class="keyword">var</span> obj = createObj(<span class="string">'zhangsan'</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用属性和函数</span></span><br><span class="line">obj.name;</span><br><span class="line">obj.age;</span><br><span class="line">obj.run();</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="原型模式创建对象"><a href="#原型模式创建对象" class="headerlink" title="原型模式创建对象"></a>原型模式创建对象</h1><p>概述：声明一个空的函数，再利用<code>prototype</code>去定义属性和函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明空函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用prototype去定义属性和函数</span></span><br><span class="line">fn.prototype.name = <span class="string">'zhangsan'</span>;</span><br><span class="line">fn.prototype.age = <span class="number">18</span>;</span><br><span class="line">fn.prototype.run = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"姓名："</span> + <span class="keyword">this</span>.name + <span class="string">"年龄："</span> + <span class="keyword">this</span>.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> fn();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用属性和方法</span></span><br><span class="line">obj.name;</span><br><span class="line">obj.age;</span><br><span class="line">obj.run();</span><br></pre></td></tr></table></figure>

<p>第二种方式：直接使用一个json对象定义属性和函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明空函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用json对象定义属性和函数</span></span><br><span class="line">fn.prototype = &#123;</span><br><span class="line">    name: <span class="string">'zhangsan'</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    run: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"姓名："</span> + <span class="keyword">this</span>.name + <span class="string">"年龄："</span> + <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> fn();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用属性和方法</span></span><br><span class="line">obj.name;</span><br><span class="line">obj.age;</span><br><span class="line">obj.run();</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h1><p>混合模式是<strong>构造模式</strong>混合了<strong>原型模式</strong>一起创建的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Obj</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型添加属性和方法</span></span><br><span class="line">Obj.prototype = &#123;</span><br><span class="line">    run: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"姓名："</span> + <span class="keyword">this</span>.name + <span class="string">"年龄："</span> + <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化对象</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Obj(<span class="string">'zhangsan'</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用属性和方法</span></span><br><span class="line">obj.name;</span><br><span class="line">obj.age;</span><br><span class="line">obj.run();</span><br></pre></td></tr></table></figure>

<hr>
<p>大家加油：）</p>
]]></content>
      <categories>
        <category>JavaScript基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>【ES6】解构赋值</title>
    <url>/posts/53099/</url>
    <content><![CDATA[<blockquote>
<p>解构赋值语法是一个 JavaScript 表达式，这使得可以将 <strong>值从数组</strong> 或 <strong>属性从对象</strong> 提取到不同变量中。</p>
</blockquote>
<a id="more"></a>

<h1 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h1><p>数组的解构赋值是有序的，将会按照顺序去匹配</p>
<h4 id="简单的解构赋值"><a href="#简单的解构赋值" class="headerlink" title="简单的解构赋值"></a>简单的解构赋值</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> [a, b, c, d] = arr</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量 a b c d 的值将会对应上数组中的 1 2 3 4</span></span><br></pre></td></tr></table></figure>
<p>在 ES6 之前，「解构赋值」还没出现的时候，想要实现以上功能只能够一个个的去定义 <code>a b c d</code> 这四个变量。因此，「解构赋值」的出现就是为了简化一些代码的编写，实现更加高效的开发。</p>
<h4 id="数组嵌套的解构赋值"><a href="#数组嵌套的解构赋值" class="headerlink" title="数组嵌套的解构赋值"></a>数组嵌套的解构赋值</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, [<span class="string">'c'</span>, <span class="string">'d'</span>, [<span class="string">'e'</span>, <span class="string">'f'</span><span class="string">'g'</span>]]]</span><br><span class="line"><span class="keyword">let</span> [, , [, , [, , g]]] = arr</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量 g 将对应 arr 中的字符 g</span></span><br></pre></td></tr></table></figure>

<h4 id="扩展运算符："><a href="#扩展运算符：" class="headerlink" title="扩展运算符： ..."></a>扩展运算符： <code>...</code></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">const</span> arr3 = [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr4 = [...arr1, ...arr2, ...arr3]</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr4 = [1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="comment">// 注意：arr4 将是一个一维数组而不是二维数组</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> [a, b, ...c] = arr</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量 c 将对应数组中 c 之后的所有值组成的新数组</span></span><br><span class="line"><span class="comment">// 注意：这种写法扩展运算符必须放在最后一位</span></span><br></pre></td></tr></table></figure>

<h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> [a, b = <span class="number">2</span>, c, d] = arr</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量 a b c d 将对应成[1, 2, 3, undefined]</span></span><br><span class="line"><span class="comment">// 没有匹配到的值将会默认为 undefined，匹配到 undefined 将会自动赋为默认值</span></span><br></pre></td></tr></table></figure>

<h4 id="数组解构赋值的使用"><a href="#数组解构赋值的使用" class="headerlink" title="数组解构赋值的使用"></a>数组解构赋值的使用</h4><ol>
<li><p><strong>交换变量</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">[a, b] = [b, a];</span><br><span class="line"></span><br><span class="line"><span class="comment">// a = 10</span></span><br><span class="line"><span class="comment">// b = 20</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>接收函数中的数组返回值</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="literal">true</span>,</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">'zhangsan'</span>,</span><br><span class="line">            age: <span class="number">18</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'请求成功'</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [status, data, msg] = getUserInfo()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h1 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h1><p>对象的解构赋值是无序的，将直接按照属性名称去匹配</p>
<h4 id="简单的解构赋值-1"><a href="#简单的解构赋值-1" class="headerlink" title="简单的解构赋值"></a>简单的解构赋值</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>: <span class="string">'zhangsan'</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;name, age&#125; = obj</span><br><span class="line"></span><br><span class="line"><span class="comment">// name : 'zhangsan'</span></span><br><span class="line"><span class="comment">// age : 18</span></span><br><span class="line"><span class="comment">// 按照属性名称匹配对应的值</span></span><br></pre></td></tr></table></figure>

<h4 id="对象与数组嵌套的解构赋值"><a href="#对象与数组嵌套的解构赋值" class="headerlink" title="对象与数组嵌套的解构赋值"></a>对象与数组嵌套的解构赋值</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'zhangsan'</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    hobby: [&#123;</span><br><span class="line">        hobbyName: <span class="string">'听歌'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        hobbyName: <span class="string">'看电影'</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">    hobby:</span><br><span class="line">    [</span><br><span class="line">        &#123; <span class="attr">hobbyName</span>: name1 &#125;,</span><br><span class="line">        &#123; <span class="attr">hobbyName</span>: name2 &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125; = obj</span><br><span class="line"></span><br><span class="line"><span class="comment">// name1: '听歌'</span></span><br><span class="line"><span class="comment">// name2: '看电影'</span></span><br></pre></td></tr></table></figure>
<p>注意：<code>hobby</code> 后的“:”跟着的是 <code>obj</code> 对象中的 <code>hobby</code> 数组，<code>hobbyName</code> 后的“:”跟着的是为了区分两个同名的 <code>hobbyName</code> 所起的别名</p>
<h4 id="扩展运算符：-1"><a href="#扩展运算符：-1" class="headerlink" title="扩展运算符：..."></a>扩展运算符：<code>...</code></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'zhangsan'</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    sex: <span class="string">'男'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;name, ...obj1&#125; = obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// obj 对象中的 age 和 sex 属性将会被封装成 obj1 对象</span></span><br><span class="line"><span class="comment">// 注意：这种方式使用的扩展运算符只能够放在最后一位</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    name: <span class="string">'zhangsan'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj3 = &#123;</span><br><span class="line">    sex: <span class="string">'男'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;...obj1, ...obj2, ...obj3&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象 obj 中会有 obj1-3 的全部属性</span></span><br><span class="line"><span class="comment">// 注意：如果存在重名属性，后面的会覆盖掉前面的</span></span><br></pre></td></tr></table></figure>

<h4 id="对已经声明的变量进行解构赋值"><a href="#对已经声明的变量进行解构赋值" class="headerlink" title="对已经声明的变量进行解构赋值"></a>对已经声明的变量进行解构赋值</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'zhangsan'</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line">(&#123; age &#125; = obj)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：以上的解构赋值语句如果没有加 () 会被视为是一个作用域而报错</span></span><br></pre></td></tr></table></figure>

<h4 id="默认值-1"><a href="#默认值-1" class="headerlink" title="默认值"></a>默认值</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'zhangsan'</span>,</span><br><span class="line">    age: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;name, age = <span class="number">18</span>, sex = <span class="string">'男'</span>&#125; = obj</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在匹配时，如果匹配不到对应的属性或者是对应的属性为 undefined 时，将会寻找默认值自动匹配</span></span><br></pre></td></tr></table></figure>

<h4 id="对象解构赋值的使用"><a href="#对象解构赋值的使用" class="headerlink" title="对象解构赋值的使用"></a>对象解构赋值的使用</h4><ol>
<li><p><strong>传递乱序参数和设置默认值</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不使用解构赋值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AJAX</span>(<span class="params">option</span>) </span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url: option.url,</span><br><span class="line">        type: option.type || <span class="string">'get'</span>,</span><br><span class="line">        data: option.data</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用解构赋值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AJAX</span>(<span class="params"> &#123; url, data, type = <span class="string">'get'</span> &#125; </span>) </span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url: url,</span><br><span class="line">        type: type,</span><br><span class="line">        data: data</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">AJAX(&#123;</span><br><span class="line">    url: <span class="string">'/getUserInfo'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        id: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>获取一个函数中的多个返回值</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserInfo</span> (<span class="params">userId</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...ajax</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        status: <span class="literal">true</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            name: <span class="string">'zhangsan'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        msg: <span class="string">'请求成功'</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;status, data, msg&#125; = getUserInfo(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h1><ol>
<li><p><strong>直接取值</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"Hello,World!"</span>;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a b c 三个变量将会分别对应字符串 str 的前三个字符</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>扩展运算符：<code>...</code></strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"Hello,World!"</span>;</span><br><span class="line"><span class="keyword">let</span> [a, b, ...c] = str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量 a b 依旧对应前两个字符，变量 c 则对应的是后面的每个字符所组成的数组</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>分割字符串</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"Hello,World!"</span>;</span><br><span class="line"><span class="keyword">let</span> [ ...spStr1 ] = str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的代码效果等同于：let spStr1 = str.split('');</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>提取属性</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"Hello,World!"</span>;</span><br><span class="line"><span class="keyword">let</span> &#123; length &#125; = str;</span><br><span class="line"></span><br><span class="line"><span class="comment">// length = 12</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<p>大家加油：）</p>
]]></content>
      <categories>
        <category>JavaScript基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>【JavaScript】垃圾回收机制</title>
    <url>/posts/31440/</url>
    <content><![CDATA[<p>JavaScript有自动收集内存中已经废弃的变量的功能，称为<strong>垃圾回收机制</strong></p>
<a id="more"></a>

<p>js中的局部变量仅在函数的执行过程中存在，一旦函数执行完毕之后局部变量则失去了意义，这个时候就需要去释放掉这个变量，回收内存。</p>
<p>上述的这个动作由js的垃圾收集器来完成。</p>
<p>垃圾收集器原理：找出没用的数据、<strong>打上标记</strong>、<strong>释放内存</strong>、<strong>周期性执行</strong>。</p>
<h2 id="标识无用变量的策略"><a href="#标识无用变量的策略" class="headerlink" title="标识无用变量的策略"></a>标识无用变量的策略</h2><h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><p>当变量进入或者是离开执行环境时，会给变量做上一个标记，周期性的将离开执行环境的变量清除。</p>
<h4 id="引用计数（不常用）"><a href="#引用计数（不常用）" class="headerlink" title="引用计数（不常用）"></a>引用计数（不常用）</h4><p>当一个<strong>堆内存中的对象</strong>被赋值给一个<strong>栈内存中的引用</strong>时，这个对象的计数 +1。<br>如果这个<strong>堆内存中的对象</strong>再次被赋值给一个<strong>栈内存中的引用</strong>时，这个对象的计数再 +1。<br>也就是现在这个对象的计数时2，即两个<strong>栈内存的应用</strong>指向同一个<strong>堆内存的对象</strong>。<br>如果两个<strong>栈内存中的引</strong>用其中一个发生了改变，也就是不再指向这个<strong>堆内存中的对象</strong>了，那么这个<strong>堆内存中的对象</strong>的计数 -1。<br>当这个<strong>堆内存中的对象</strong>的计数 =0 的时候，垃圾收集器将释放该对象所占用的内存。</p>
<p><strong>循环引用的问题</strong><br>循环引用就是对象A中包含了一个指向对象B的指针，对象B中包含了一个指向对象A的指针。这样一来两个<strong>堆内存中的对象</strong>的计数都是2，当我们使用完这两个对象之后，垃圾收集器将无法回收这两个变量。需要我们手动的去将这两个对象置为 <code>null</code> 来释放内存。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ObjA = &#123;&#125;;  <span class="comment">// ObjA计数1</span></span><br><span class="line"><span class="keyword">var</span> ObjB = &#123;&#125;;  <span class="comment">// ObjB计数1</span></span><br><span class="line"></span><br><span class="line">ObjA.obj = ObjB; <span class="comment">// ObjB计数2</span></span><br><span class="line">ObjB.obj = ObjA; <span class="comment">// ObjA计数2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动释放内存</span></span><br><span class="line">ObjA = <span class="literal">null</span>;</span><br><span class="line">ObjB = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<hr>
<p>大家加油：）</p>
]]></content>
      <categories>
        <category>JavaScript基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title>【JavaScript】执行上下文</title>
    <url>/posts/54687/</url>
    <content><![CDATA[<p>执行上下文是js中很重要的一个概念，每次当js程序去调用一个函数时，就会去创建一个对应的执行上下文。我们可以先将执行上下文理解为当前代码执行的环境，这会产生一个作用域的概念，也就是我的上一篇文章所提到的。js引擎会销毁该函数的执行上下文。js程序在执行时每次遇到函数时都会做这样的操作。</p>
<a id="more"></a>

<h1 id="一、执行上下文生命周期"><a href="#一、执行上下文生命周期" class="headerlink" title="一、执行上下文生命周期"></a>一、执行上下文生命周期</h1><p>首先我们还是来对执行上下文有一个深入的了解，当一个函数被调用时，一个对应的执行上下文就会被创建。而一个执行上下文的生命周期可以分为两个阶段。<strong>创建阶段</strong>和<strong>执行阶段</strong></p>
<ul>
<li><strong>创建阶段</strong><br>在这个阶段中，执行上下文会分别创建<strong>变量对象</strong>，建立<strong>作用域链</strong>，以及确定<strong>this</strong>的指向。这些概念接下来都会仔细的说一下。</li>
<li><strong>执行阶段</strong><br>创建完成之后，开始逐行的执行代码。这个时候会完成变量赋值、函数引用、以及执行其他代码。</li>
</ul>
<h1 id="二、区别执行上下文和变量作用域"><a href="#二、区别执行上下文和变量作用域" class="headerlink" title="二、区别执行上下文和变量作用域"></a>二、区别执行上下文和变量作用域</h1><p>在上一篇文章重提到了一个作用域的概念。作用域与执行上下文都是在函数的中的概念，可能会有点冲突，导致理解起来容易混淆，这里有必要区别一下这两个概念。</p>
<p>执行上下文是在函数调用时才去动态的创建，因为不同的调用可能会是完全不同的参数。而变量作用域则是在函数声明时就确定了，跟函数的调用无关，函数在调用时只会去创建执行上下文。相比较而言，变量作用域更像是一个静态的概念，在函数声明时就确定下来的，函数内部的变量只能存活于这个作用域之中，不管是什么样的变量只要是在函数的内部去声明的，就肯定是跑不出函数的作用域中。（这里插一句：函数的参数也是函数的内部变量，存活于函数的作用域之中）而执行上下文呢则是在调用时才会产生的，甚至是在某种特殊的环境下会产生多个执行上下文，例如闭包。</p>
<p><strong>举个例子吧：</strong></p>
<blockquote>
<p>我们平时开的汽车，当这辆汽车被生产出来的时候，其中的功能就已经是确定的了，比如最高能达到多高的时速、最多能坐几个人、能载重多少重量等等，这相当于是确定了作用域。但是在我们实际的使用的时候由于路面环境的不同、用途不同、司机不同等等的原因导致这辆汽车发挥出来的效果也是不用。这就相当于是每次执行的时候都创建了对应的执行上下文。</p>
<p><strong>上面的例子可能有些不太恰当的地方，仅代表个人的理解</strong></p>
</blockquote>
<h1 id="三、执行上下文栈"><a href="#三、执行上下文栈" class="headerlink" title="三、执行上下文栈"></a>三、执行上下文栈</h1><p>在js中函数的调用是有严格的先后顺序的，在一个js程序中正在执行的函数有且仅有一个，另外的函数想要执行必须等待当前函数执行完毕后按照顺序排队执行。如果是一个函数中包含了另外一个函数的执行的话那么需要在执行到<strong>被包含的函数</strong>中时去执行<strong>被包含的函数</strong>，等待被包含的函数<strong>执行完毕</strong>之后才可以继续接着执行下面的内容。这样的执行顺序天然的符合“<strong>栈</strong>”这种后入先出的数据结构。我们来看一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"fn函数开始执行"</span>);</span><br><span class="line">    fn2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"fn函数执行完毕"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"fn2函数开始执行"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"fn2函数执行完毕"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>在上面的这段代码中，js引擎首先创建了一个全局的执行上下文。</strong><br>将这个全局执行上下文压入执行上下文栈中。此时的栈结构：<code>栈底 -&gt; 全局 -&gt; 栈顶</code><br><strong>之后开始执行代码，当执行到第12行调用了<code>fn</code>函数的时候，去创建了一个<code>fn</code>的执行上下文。</strong><br>将<code>fn</code>的执行上下文再压入栈。此时的栈结构：<code>栈底 -&gt; 全局 -&gt; fn -&gt; 栈顶</code><br><strong>开始执行<code>fn</code>函数中的代码。执行到第3行的时候调用了<code>fn2</code>，这个时候会去创建一个<code>fn2</code>的执行上下文。</strong><br>将<code>fn2</code>压入栈。此时的栈结构：<code>栈底 -&gt; 全局 -&gt; fn -&gt; fn2 -&gt; 栈顶</code><br><strong>之后开始执行<code>fn2</code>的内容，当函数<code>fn2</code>执行完毕之后，销毁<code>fn2</code>的执行上下文。</strong><br>销毁执行上下文就是将该上下文弹出栈，此时弹出<code>fn2</code>后的栈结构：<code>栈底 -&gt; 全局 -&gt; fn -&gt; 栈顶</code><br><strong>再继续执行函数<code>fn</code>中剩余的部分，当函数<code>fn</code>执行完毕之后销毁了函数<code>fn</code>的执行上下文。</strong><br>弹出<code>fn</code>，此时的栈结构：<code>栈底 -&gt; 全局 -&gt; 栈顶</code><br><strong>等到关闭浏览器窗口的时候会去销毁全局的执行上下文。</strong><br>此时的栈结构：<code>栈底 -&gt;  -&gt;栈顶</code></p>
</blockquote>
<p>上面的这个例子很形象的阐述了函数调用栈是如何去管理执行上下文的执行顺序的。每次在调用函数的时候会去创建一个执行上下文，并将其压入栈顶。而执行的时候也是只执行位于栈顶的函数，执行完毕后将栈顶的函数弹出栈，再接着执行栈顶的函数。按照这个顺序去执行，到最后就只剩下一个全局的执行上下文，关闭浏览器窗口后把最后一个全局上下文弹出栈，之后调用栈为空，也意味着程序执行完毕。</p>
<h1 id="四、作用域链"><a href="#四、作用域链" class="headerlink" title="四、作用域链"></a>四、作用域链</h1><p><strong>我们先来看一段代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"全局的name"</span>;</span><br><span class="line"><span class="keyword">var</span> name1 = <span class="string">"全局的name1"</span>;</span><br><span class="line"><span class="keyword">var</span> name2 = <span class="string">"全局的name2"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"fn的name"</span>;</span><br><span class="line">    <span class="keyword">var</span> name1 = <span class="string">"fn的name1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> name =<span class="string">"fn2的name"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(name);  <span class="comment">// 输出fn2的name</span></span><br><span class="line">        <span class="built_in">console</span>.log(name1); <span class="comment">// 输出fn的name1</span></span><br><span class="line">        <span class="built_in">console</span>.log(name2); <span class="comment">// 输出全局的name2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>
<p>这段代码中，很清晰的向我们展示了什么是作用域链。在函数<code>fn2</code>的内部去输出<code>name</code>这个变量，首先是在当前函数的作用域也就是<code>fn2</code>的执行上下文中去寻找<code>name</code>这个变量，找到了之后直接输出。如果找不到，例如变量<code>name1</code>的这种情况，则会去上一级的作用域中去寻找，也就是函数<code>fn</code>的作用域，找到后再输出。如果还是找不到，例如变量<code>name2</code>的情况，那么就会再到上一级的作用域中去寻找，找到后再输出。一级一级的网上去寻找形成了一个链式的操作，称之为<strong>作用域链</strong>。</p>
<p><strong>分析作用域链的形成</strong></p>
<blockquote>
<p>结合一下前文提到过的函数调用栈的概念，一级一级网上去查找变量的这个过程，其实就是在函数调用栈中去一级一级的往栈底的执行上下文去查找。也就是说作用域链是在函数调用栈中由栈顶的执行上下文去往栈底的执行上下文去一级一级的链起来形成的作用域链。</p>
</blockquote>
<h1 id="五、变量对象（Variable-Object，VO）"><a href="#五、变量对象（Variable-Object，VO）" class="headerlink" title="五、变量对象（Variable Object，VO）"></a>五、变量对象（Variable Object，VO）</h1><p>变量对象无非也是一个对象，对象就是为了承载数据而存在的。所以变量对象就是一些数据的载体，只是这个对象我们并不能够去实际的创建出来，看不见摸不着而已。</p>
<h2 id="变量对象的创建"><a href="#变量对象的创建" class="headerlink" title="变量对象的创建"></a>变量对象的创建</h2><ol>
<li>建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。</li>
<li>检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。</li>
<li>检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。这里牵扯到一个变量提升的概念，面试常考。</li>
</ol>
<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>变量提升这个概念其实很好理解，在一个js程序中，使用<code>var</code>关键字声明的变量会在程序执行时提前去<strong>声明</strong>。仅此而已。我们再来看看js程序是如何去声明一个变量的。<code>var name;</code>这样就声明了一个变量名为<code>name</code>的变量。这么声明一个变量的话，变量的值毫无疑问就是一个<code>undefined</code>。总结一下就是：js引擎将使用<code>var</code>声明的变量赋值为<code>undefined</code>放在了程序开始执行的第一步去做了。这个概念就这么简洁明了的解释清楚了。</p>
<p><strong>变量提升的作用：</strong><br>那为什么js引擎要做这个变量提升的事情呢，这个主要还是为了节约CPU开销去考虑的一个事情，因为声明变量是需要去在内存中开辟出一块空间来存放这个变量的。这个动作是比较耗费CPU资源的一个动作，如果在程序中大量的去执行这个动作的话，毫无疑问会对程序执行的效率造成一定的影响。所以将这一类的操作，全部提前一次性的给他完成了，以这样的方式来提升程序的执行效率。</p>
<p><strong>我们结合一个例子来更加清楚的理解一下这个概念：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 输出undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>这是一个简单的例子，很好的展现了变量提升这个概念。首先在全局作用域中，js引擎去搜索了所有<code>var</code>声明的变量，然后在当前的这个作用域中提前声明，再逐行执行代码。也就是说上面的这段代码实际上是下面的这个样子的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 输出undefined</span></span><br><span class="line">a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>这么看来就毫无疑问输出一个<code>undefined</code>了。</p>
<h2 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h2><p>介绍一个很重要的对象，<code>window</code>对象，这是一个内置的全局对象，之所以说这个对象很重要呢是因为我们所声明的一些全局变量都是这个对象下的属性，我们所写的方法也是这个对象的方法。</p>
<p>我个人其实更愿意将这个<code>window</code>对象理解为一个特殊的<strong>变量对象</strong>（一个全局的变量对象）我们来分析一下变量对象在创建的时候都做了什么和<code>widnow</code>对象都有什么。</p>
<ol>
<li>首先创建变量对象的第一步是：建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。<br> <code>window</code>对象做为一个全局的对象，并没有参数传递进来，自然也就没有这一步。</li>
<li>然后第二步是：检查当前执行上下文中的函数声明，在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。<br> 这一步在<code>window</code>对象中是有体现的，因为在js程序中声明的全局函数都是可以直接通过<code>window</code>对象去直接<code>.</code>的调用的。而且<code>window</code>对象还为我们内置了许多的方法可以直接调用，不需要自己手动的去写，封装了一些更方便的工具方法。</li>
<li>最后第三步是：检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。<br> 我们在声明全局的变量时其实就是在声明一个<code>window</code>对象的属性。</li>
</ol>
<p><strong>来看一些简单的例子：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"zhangsan"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"fn"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name === name); <span class="comment">// 输出true</span></span><br><span class="line"><span class="built_in">window</span>.fn(); <span class="comment">// 输出fn</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，定义的全局变量或者是方法，都可以使用<code>windwow</code>去<code>.</code>一下调用出来。甚至是一个没有定义的变量，也可以使用<code>window</code>对象去<code>.</code>出来。在上面作用域的哪个例子中如果使用<code>window</code>对象去调用变量<code>name1</code>的话是不会报错的。我们来看一下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"zhangsan"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name1 = <span class="string">"lisi"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name);   <span class="comment">// 输出zhangsan</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.name1);  <span class="comment">//输出undefined</span></span><br><span class="line">fn();  <span class="comment">// 输出zhangsan</span></span><br></pre></td></tr></table></figure>
<p>我们再来看一个例子，然后分析一下这个<code>window</code>对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"><span class="built_in">console</span>.log(name);  <span class="comment">// 输出undefined</span></span><br><span class="line"></span><br><span class="line">conosle.log(<span class="built_in">window</span>.name1);  <span class="comment">// 输出undefined</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：上面这个例子需要在IE浏览器中运行才会出效果</strong></p>
<blockquote>
<p>以上是我的一些个人看法，如果有不对的地方，还请在评论区直接指出。</p>
</blockquote>
<h2 id="活动对象（Activation-Object，AO）"><a href="#活动对象（Activation-Object，AO）" class="headerlink" title="活动对象（Activation Object，AO）"></a>活动对象（Activation Object，AO）</h2><p>前文提到的变量对象在执行上下文的<strong>创建阶段</strong>被创建出来，但是这个时候我们是没办法去访问变量对象里面的属性的。<br>但是在执行上下文的<strong>创建阶段</strong>结束后进入<strong>执行阶段</strong>时，变量对象会转变成为活动对象。这是就可以访问里面的属性了。<br>所以，实际上变量对象和活动对象是同一个对象，只是处于执行上下文生命周期的不同阶段而已。</p>
<h1 id="六、this关键字"><a href="#六、this关键字" class="headerlink" title="六、this关键字"></a>六、this关键字</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>首先要说明的一点是：<code>this</code>并不是在定义函数的时候确定的，前文提过，一个执行上下文在创建的阶段最重要的三件事之中其中之一就是确定<code>this</code>的指向，所以<code>this</code>是在执行上下文创建的时候才会去指定的。而执行上下文有全局的还有函数的，因此<code>this</code>可以被剖析为全局的<code>this</code>和函数的<code>this</code>。<br>实际上，如果在一个对象中去定义了一个函数的话，其实是将这个函数在堆内存中声明了一下，再去赋值给对象中的属性，所以在调用这个对象的这个函数的属性的时候其实并不一定是在同一个作用域下去调用的，针对不同的作用域，<code>this</code>的指向也就不同。</p>
<p>我们来看一个例子加深理解：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'zhangsan'</span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'lisi'</span>,</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  subObj: &#123;</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.fn(); <span class="comment">// 输出lisi</span></span><br><span class="line">obj.subObj.fn() <span class="comment">// 输出undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> say = obj.subObj.fn;</span><br><span class="line">say(); <span class="comment">// 输出zhangsan</span></span><br></pre></td></tr></table></figure>
<p>在上面这个例子中，三个<code>this</code>分别指向三个不同的对象。</p>
<p>第一个<code>obj.fn()</code>直接由<code>obj</code>对象调用，指向的是<code>obj</code>对象。</p>
<p>第二个<code>obj.subObj.fn()</code>由<code>obj</code>对象去调用了<code>subObj</code>对象，再由<code>subObj</code>对象去调用了<code>fn</code>方法，所以实际上是<code>subObj</code>对象去调用了<code>fn</code>方法，所处的也就是<code>sub</code>对象的作用域之中，自然指向的也就是<code>sub</code>对象了。</p>
<p>第三个<code>say</code>对象是由<code>obj.subObj.fn</code>对象赋值而来的，而<code>say</code>对象又是处于全局的作用域下，所以在这里虽然是声明了一个<code>obj.subObj.fn</code>对象，但是所处的作用域确实一个全局作用域，指向的也就是全局中的<code>window</code>对象。</p>
<p>上面这个例子很好的诠释了<code>this</code>这个关键字在不同情况下指向的是完全不同的对象。<strong>谨记一点<code>this</code>关键字是在调用时才能够确定指向的</strong>。</p>
<h3 id="全局中的this"><a href="#全局中的this" class="headerlink" title="全局中的this"></a>全局中的this</h3><p>全局中的<code>this</code>对象非常简单，就是指向了上文提到的<code>window</code>对象，也就是说任何在函数外部的<code>this</code>都是指向了<code>window</code>对象。<br>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>) <span class="comment">// 输出true</span></span><br></pre></td></tr></table></figure>
<p>上面这个例子中，直接在全局中比较<code>this</code>对象和<code>window</code>对象，结果为true。充分证明了在全局环境中，<code>this</code>指向的就是<code>window</code>对象。</p>
<h3 id="函数中的this"><a href="#函数中的this" class="headerlink" title="函数中的this"></a>函数中的this</h3><ol>
<li><p><strong>普通函数</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(); <span class="comment">// 输出Window</span></span><br></pre></td></tr></table></figure>
<p>这个很好理解，<code>fn()</code>处于一个全局作用域中由<code>window</code>对象直接调用，所以<code>this</code>指向的是<code>window</code>对象本身。</p>
</li>
<li><p><strong>构造函数</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'zhangsan'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Fn();</span><br><span class="line"><span class="built_in">console</span>.log(a.name); <span class="comment">// 输出zhangsan</span></span><br></pre></td></tr></table></figure>
<p>任何使用<code>new</code>关键字创建出来的都是一个对象，是一个在<strong>堆内存</strong>中的对象，所以在这里<code>this</code>指的是新创建的这个对象。</p>
</li>
</ol>
<hr>
<p>大家加油：）</p>
]]></content>
      <categories>
        <category>JavaScript基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>【JavaScript】数据类型</title>
    <url>/posts/24923/</url>
    <content><![CDATA[<p>我们所使用的编程语言，不管是js也好或者是其他的一些语言，例如：Java、C++。我们在编写程序的时候实际上都是在对数据进行操作。如果脱离了数据，那么我们编写的程序将变得毫无意义。甚至脱离了数据之后我们将无法编程。由此，数据类型便成了重中之重。</p>
<a id="more"></a>

<h1 id="一、js数据类型简介"><a href="#一、js数据类型简介" class="headerlink" title="一、js数据类型简介"></a>一、js数据类型简介</h1><ol>
<li>js的数据类型主要分为两大类，原始类型（即基本数据类型）和对象类型（即引用数据类型）。</li>
<li>js中的基本数据类型可以分为5种：Number、String、Boolean、Undefined、Null。</li>
<li>js中的引用数据类型也就是对象类型Object，主要是Object、Array、Function这几种。</li>
</ol>
<h1 id="二、基本数据类型和引用数据类型的区别"><a href="#二、基本数据类型和引用数据类型的区别" class="headerlink" title="二、基本数据类型和引用数据类型的区别"></a>二、基本数据类型和引用数据类型的区别</h1><p>首先这里需要先简单的介绍一下堆内存和栈内存。计算机的内存中有堆内存和栈内存，栈内存呢是一个一个排列下去的是有序的，也是固定大小的，像是数组一样；而堆内存呢则刚好是与栈内存相反，堆内存中的数据是无序的，也是不固定大小的。</p>
<h2 id="堆栈内存的优缺点"><a href="#堆栈内存的优缺点" class="headerlink" title="堆栈内存的优缺点"></a>堆栈内存的优缺点</h2><p>栈内存由于是有序的所以在查询数据的时候直接按照排序的序号去查的话是比较快的，但是由于固定大小的原因呢，栈内存无法随心所欲的存储数据。堆内存由于不固定大小，所以在其中存储的数据是比较方便的，也就是想怎么存就怎么存，但是因为堆内存中的数据是无序的，所以在查找的时候就是要比较慢一些。  </p>
<blockquote>
<p>总结：就是栈内存优点是查询快，存储不方便；而堆内存则是存储方便，但查询慢。  </p>
</blockquote>
<p><em>这么说可能还是有点不太形象，举个例子吧。栈内存中的空间呢就像是现实生活中的商品房一样，一个一个的房子都是开发商建好的，每个房子的大小是固定的，每个房子也有对应的门牌号，比如某某单元的几零几这样，查找起来呢是比较方便。堆内存呢就像是一栋一栋的独栋别墅一样，没有一个集中的管理，但是大小不固定，可能是有一块地用来建别墅，我今天打算建个100平米的别墅，明天我就可能扩建到200平米了，甚至是再往上多建几层。</em>    </p>
<p>既然堆内存和栈内存有这样的优缺点，那么何不将两者的优点结合起来，在栈内存中存放指向堆内存中的指针。这样可以即查询快又存储数据方便。这样的数据也就是上面说的引用数据类型。我们待会细说。</p>
<h1 id="三、基本数据类型的特点"><a href="#三、基本数据类型的特点" class="headerlink" title="三、基本数据类型的特点"></a>三、基本数据类型的特点</h1><ol>
<li><p>基本数据类型的赋值仅仅只是简单的值传递：<br>如果需要从一个变量向另一个变量去赋一个基本数据类型的值，那么会将其中基本变量的值生成一个副本再将这个副本的值直接传递过去，而不是引用同一个值。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 输出18</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 输出18</span></span><br><span class="line">a++;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 输出19</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 输出18</span></span><br></pre></td></tr></table></figure>
<p>在上述的例子中，一开始先将变量<code>a</code>的值赋给了变量<code>b</code>，这时变量<code>a</code>的值和变量<code>b</code>的值都是18，然后我们再将变量<code>a</code>的值进行<code>++</code>操作，变量<code>a</code>的值变成了19，但是变量<code>b</code>的值任然还是18，由此可见变量<code>a</code>和变量<code>b</code>的值是完全互不相干的，没有关系的。</p>
<p> <em>举个例子吧，就比如我们平时在使用<code>ctrl + c</code>和<code>ctrl + v</code>复制黏贴的时候是一样的，我们复制的文本并不会随着原来文本的改变而改变，同样原来的文本也不会因为被复制的文本的改变而发生任何变化。同理，变量之间的赋值也是一次简单的“<code>ctrl + c</code>和<code>ctrl + v</code>”而已。</em></p>
</li>
<li><p>基本数据类型的值是固定的，无法修改的。比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'string'</span>;</span><br><span class="line"><span class="keyword">var</span> anotherStr = str.replace(<span class="string">'s'</span>,<span class="string">''</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 输出 string</span></span><br><span class="line"><span class="built_in">console</span>.log(anotherStr); <span class="comment">// 输出 tring</span></span><br></pre></td></tr></table></figure>
<p>在上面的这个例子中我们可以看到，字符串<code>str</code>的值一直都是<code>string</code>，尽管我们调用的<code>replace</code>方法将其中的<code>s</code>替换成了空字符串，但是实际上的<code>str</code>的值并没有被修改，任然是<code>string</code>。修改后的值传回来了一个新的变量，这个变量的值才是<code>tring</code>，然而这是一个全新的变量跟原来的<code>str</code>并没有什么关系。</p>
<p> <strong>我们再来看一个例子：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'zhangsan'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// 输出zhangsan</span></span><br><span class="line">name = <span class="string">'lisi'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// 输出lisi</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中看起来<code>name</code>的值由“zhangsan”被修改为“lisi”，但其实并不是修改，原来的“zhangsan”还是“zhangsan”，只是被一个新的值“lisi”覆盖掉了而已。</p>
<p> <em>这么说起来可能不是很形象，举个例子吧。现实生活中我们在画画的时候如果原本的颜色是红色的，但是我们想要将其修改为绿色的话我们是将新的绿色的颜料直接涂抹在原来红色的地方上面，这样在我们看来好像红色被修改为绿色，但红色还是红色只是被覆盖了我们看不到了而已，我们看到的是绿色。在这个例子中也是同理。</em></p>
</li>
</ol>
<h1 id="四、五种基本数据类型详解"><a href="#四、五种基本数据类型详解" class="headerlink" title="四、五种基本数据类型详解"></a>四、五种基本数据类型详解</h1><h2 id="typeof运算符"><a href="#typeof运算符" class="headerlink" title="typeof运算符"></a>typeof运算符</h2><p>我们要检测一种基本数据类型时可以使用typeof运算符去检测，其语法是<code>typeof 变量</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">123</span>);            <span class="comment">// 输出number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">'string'</span>);       <span class="comment">// 输出string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>);           <span class="comment">// 输出boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>);           <span class="comment">// 输出Object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>);      <span class="comment">// 输出undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);   <span class="comment">// 输出function</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：检测null时返回的是一个Object类型，这是因为null类型其实是一个空的对象应用，也就是一个对象但什么都没有。</p>
</blockquote>
<h2 id="Number-数值类型"><a href="#Number-数值类型" class="headerlink" title="Number(数值类型)"></a>Number(数值类型)</h2><p>在一些强语言中，数值类型可能会分为整数和浮点数，再根据占用的长度去再往下继续分为好几种数据类型，比如Java和C。但是在js中数值类型只有一种就是Number，在定义一个数值类型时加不加小数点都是可以的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> number = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> number); <span class="comment">// 输出number</span></span><br></pre></td></tr></table></figure>
<p>上面的这个例子中为我们展示了如何去定义一个number类型的变量，以及如何去检测一个number变量。<br>js中如果需要表示一个非常大或者是非常小的数字可以使用科学计数法，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">123e+5</span>;  <span class="comment">// 表示的是 12300000</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">123e-5</span>;  <span class="comment">// 表示的是 0.00123</span></span><br></pre></td></tr></table></figure>
<p>js中表示最大的数值是<code>Number.MAX_VALUE</code>，与之对应的是<code>Numver.MIN_VALUE</code>表示的是js中最小的数值。</p>
<p>js中还有一个非常特殊的数值类型，就是NaN(Not A Number)即非数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。例如，在其他编程语言中，任何数值除以0都会导致错误，从而停止代码执行。但在JavaScript中，任何数值除以0会返回NaN，因此不会影响其他代码的执行。</p>
<p>NaN有两个非同寻常的点，一个是任何涉及NaN的操作都会返回NaN，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> + <span class="number">1</span>); <span class="comment">// 输出NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> - <span class="number">1</span>); <span class="comment">// 输出NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> * <span class="number">1</span>); <span class="comment">// 输出NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> / <span class="number">1</span>); <span class="comment">// 输出NaN</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这个特点在多步计算中有可能导致问题，需要特别注意</p>
</blockquote>
<p>另一个是NaN与任何值都不相等，包括NaN本身，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> == <span class="literal">NaN</span>); <span class="comment">// 输出false</span></span><br></pre></td></tr></table></figure>

<h2 id="String-字符串类型"><a href="#String-字符串类型" class="headerlink" title="String(字符串类型)"></a>String(字符串类型)</h2><p>在js中的字符串类型是需要使用引号引起来的，使用单引号’’或者是双引号””都可以，但是不要混合着用，也不能嵌套使用单双引号。</p>
<p>string类型有些特殊，因为字符串具有可变的大小，所以显然它不能被直接存储在具有固定大小的变量中。由于效率的原因，我们希望JS只复制对字符串的引用，而不是字符串的内容。但是另一方面，字符串在许多方面都和基本类型的表现相似，而字符串是不可变的这一事实（即没法改变一个字符串值的内容），因此可以将字符串看成<strong>行为与基本类型相似的不可变引用类型</strong></p>
<p>如果需要在String类型中输出一些特殊的字符的话可以使用<code>\</code>字符来转义，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"我说：\"我想吃西瓜\""</span>); <span class="comment">// 输出 我说："我想吃西瓜"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果想输出一个<code>\</code>的话则需要再使用一个<code>\</code>来转义，即<code>\\</code></p>
</blockquote>
<h2 id="Boolean-布尔类型"><a href="#Boolean-布尔类型" class="headerlink" title="Boolean(布尔类型)"></a>Boolean(布尔类型)</h2><p>Boolean类型只有两个值：true表示真和false表示假。<br>虽然Boolean类型的字面值只有两个，但JavaScript中所有类型的值都有与这两个Boolean值等价的值。要将一个值转换为其对应的Boolean值，可以调用类型转换函数Boolean()，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="keyword">var</span> messageAsBoolean = <span class="built_in">Boolean</span>(message);</span><br></pre></td></tr></table></figure>
<p>在这个例子中，字符串message被转换成了一个Boolean值，该值被保存在messageAsBoolean变量中。可以对任何数据类型的值调用Boolean()函数，而且总会返回一个Boolean值。至于返回的这个值是true还是false，取决于要转换值的数据类型及其实际值。下表给出了各种数据类型及其对象的转换规则。</p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="right">转换成true值</th>
<th align="center">转换成false值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Boolean</td>
<td align="right">true</td>
<td align="center">false</td>
</tr>
<tr>
<td align="left">String</td>
<td align="right">任何非空字符串</td>
<td align="center">“”空字符串</td>
</tr>
<tr>
<td align="left">Number</td>
<td align="right">任何非0数值（包括无穷大）</td>
<td align="center">0和NaN</td>
</tr>
<tr>
<td align="left">Object</td>
<td align="right">任何非空对象</td>
<td align="center">null</td>
</tr>
<tr>
<td align="left">Undefined</td>
<td align="right">不适用</td>
<td align="center">Undefined</td>
</tr>
</tbody></table>
<p><strong>ps：如果需要将一个变量转换成对应的布尔值的话，可以使用<code>!!</code>(两个感叹号)操作符转换。例如：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(!message);  <span class="comment">// 输出false</span></span><br><span class="line"><span class="built_in">console</span>.log(!!message); <span class="comment">// 输出true</span></span><br></pre></td></tr></table></figure>
<p>使用一个<code>!</code>代表的是取反的操作，即转换为Boolean值之后取的是相反的值，但是再使用多一个<code>!</code>之后呢再将取反的操作再次取反之后就可以得到原来对应的Boolean值</p>
<h2 id="Null-空引用类型"><a href="#Null-空引用类型" class="headerlink" title="Null(空引用类型)"></a>Null(空引用类型)</h2><p>Null类型是只有一个值的特殊数据类型，这个特殊的值就是<code>null</code>代表的是一个空对象，一个空引用。从逻辑角度来看，<code>null</code>值表示一个空对象指针，而这也正是使用<code>typeof</code>操作符检测<code>null</code>时会返回<code>object</code>的原因。</p>
<p>如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为<code>null</code>而不是其他值。这样一来，只要直接检测<code>null</code>值就可以知道相应的变量是否已经保存了一个对象的引用了。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 对obj对象进行的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Undefined-未定义"><a href="#Undefined-未定义" class="headerlink" title="Undefined(未定义)"></a>Undefined(未定义)</h2><p>Undefined类型只有一个值，即特殊的<code>undefined</code>。在使用<code>var</code>声明变量但未对其加以初始化时，这个变量的值就是<code>undefined</code>。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 输出undefined</span></span><br></pre></td></tr></table></figure>

<h1 id="五、引用数据类型"><a href="#五、引用数据类型" class="headerlink" title="五、引用数据类型"></a>五、引用数据类型</h1><h2 id="引用数据类型的介绍"><a href="#引用数据类型的介绍" class="headerlink" title="引用数据类型的介绍"></a>引用数据类型的介绍</h2><p>除了上面介绍的基本数据类型之外，其他的就是引用数据类型了。引用类型统称是Objcet，所有的引用数据类型的数据都是继承自Object的。例如：Array（数组）、Date（日期）、Function（函数）等。这些都是引用数据类型，也都是继承自Object。</p>
<h2 id="引用数据类型的特点"><a href="#引用数据类型的特点" class="headerlink" title="引用数据类型的特点"></a>引用数据类型的特点</h2><ol>
<li><p><strong>引用类型的值是可变的</strong></p>
<p> 引用数据类型跟基本数据类型最大的不同就是内存存放位置的不同，上文提过基本数据类型是存放在<strong>栈内存</strong>中的，引用数据类型则是存放在<strong>堆内存</strong>中的。引用数据类型将堆内存中的地址存放在栈内存中，通过变量标识符去取到地址再进行访问。而堆内存的大小并不是固定的，所以引用数据类型的值是可变的。基于这个特点，我们如果想要在一个引用数据类型中取增加或者是删除一些内容的话也都是可以实现的，我们甚至可以在一个引用中去定义另一个引用，我们来看一个例子：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">"zhangsan"</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name);  <span class="comment">// 输出zhangsan</span></span><br><span class="line">obj.name = <span class="string">"lisi"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name);  <span class="comment">// 输出lisi</span></span><br><span class="line">obj.age = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.age);   <span class="comment">// 输出18</span></span><br><span class="line">obj.age = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.age);   <span class="comment">// 输出null</span></span><br><span class="line">obj.printObj = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">"---"</span> + <span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line">obj.printObj(); <span class="comment">// 输出lisi---null</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>引用数据类型的比较是引用的比较</strong></p>
<p> 我们先来看一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj1 == obj2);   <span class="comment">// 输出false</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1 === obj2);  <span class="comment">// 输出false</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>obj1</code>和<code>obj2</code>都是定义了相同的内容，都是<code>{}</code>，但是在比较的时候js却不认为这是两个相同的对象。原因在于声明这两个对象时，会在堆内存中开辟出两块不同的空间去分别存放这两个变量，然后将堆内存存放这两个对象对应的内存地址再去存在栈内存中去。在比较时并不会去比较两个对象具体的区别，而是在栈内存中将地址取出来之后进行比较，如果地址相同都是指向同一块内存的话才会认为是相同的对象，反之则认为是不同的对象。</p>
<p> 我们再来看一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">name</span>:<span class="string">"zhangsan"</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1;</span><br><span class="line"><span class="built_in">console</span>.log(obj1.name); <span class="comment">// 输出zhangsan</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.name); <span class="comment">// 输出zhangsan</span></span><br><span class="line">obj2.name = <span class="string">"lisi"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1.name); <span class="comment">// 输出lisi</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.name); <span class="comment">// 输出lisi</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，首先声明了一个对象<code>obj1</code>再将<code>obj1</code>的值赋给<code>obj2</code>，这时其实是将<code>obj1</code>的地址赋给了<code>obj2</code>，也就是说在栈内存中的<code>obj1</code>和<code>obj2</code>的值是相等的，都是保存的相同的地址，指向的是同一块堆内存中的空间。所以不管是改变了<code>obj1</code>还是改变了<code>obj2</code>其实都是在操作的同一块内存空间，做出来的改变也是相同的，另一个指向这个空间的对象也是会跟随着一起改变。</p>
</li>
<li><p><strong>instanceof</strong><br>一个对象如果我们需要去检测它是不是属于某个对象的实例的话，我们需要使用<code>instanceof</code>关键字，语法是<code>实例 instanceof 对象</code>表示这个实例是否属于这个对象。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((&#123;&#125;) <span class="keyword">instanceof</span> <span class="built_in">Object</span>);    <span class="comment">// 输出true</span></span><br><span class="line"><span class="built_in">console</span>.log(([]) <span class="keyword">instanceof</span> <span class="built_in">Array</span>);     <span class="comment">// 输出true</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<p>大家加油：）</p>
]]></content>
      <categories>
        <category>JavaScript基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>【JavaScript】闭包</title>
    <url>/posts/47023/</url>
    <content><![CDATA[<p>闭包：<strong>「函数」和「函数内部能访问到的变量」（也叫环境）的总和，就是一个闭包。</strong><br>闭包在js面向对象中是一个非常重要的知识点，许多的面向对象的特性都可以通过闭包来体现。</p>
<a id="more"></a>

<blockquote>
<p>本文摘抄自 <a href="https://zhuanlan.zhihu.com/p/22486908" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/22486908</a></p>
</blockquote>
<h1 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> local = <span class="string">'变量'</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(local)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面函数内部的三行代码中，有一个局部变量 <code>local</code>，有一个函数 <code>foo</code> ，<code>foo</code> 里面可以访问到 <code>local</code> 变量。这就是一个闭包，就是这么简单。</p>
<p>其实大家比较熟知的闭包是下面的这种嵌套函数的形式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> local = <span class="number">1</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    local++</span><br><span class="line">    <span class="keyword">return</span> local</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = foo()</span><br><span class="line">func()</span><br></pre></td></tr></table></figure>
<p>这里面呢确实有闭包的存在，<code>local</code> 变量和 <code>bar</code> 函数就组成了一个闭包。</p>
<p><strong>那么为什么要嵌套函数呢？</strong></p>
<p>是因为需要局部变量，所以才把 <code>local</code> 放在一个函数里，如果不把 <code>local</code> 放在一个函数里，<code>local</code> 就是一个全局变量了，达不到使用闭包的目的——隐藏变量（等会会讲）。</p>
<p>可能看到「闭包」这个名字，就一定觉得要用什么包起来才行。其实这是翻译问题，闭包的原文是 Closure，跟「包」没有任何关系。</p>
<p>所以函数套函数只是为了造出一个局部变量，<strong>跟闭包无关</strong>。</p>
<p><strong>为什么要 return bar 呢？</strong></p>
<p>因为如果不 <code>return</code>，你就无法使用这个闭包。把 <code>return bar</code> 改成 <code>window.bar = bar</code> 也是一样的，只要让外面可以访问到这个 <code>bar</code> 函数就行了。</p>
<p>所以 <code>return bar</code> 只是为了 <code>bar</code> 能被使用，也<strong>跟闭包无关</strong>。</p>
<hr>
<h1 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h1><p>闭包常常用来「间接访问一个变量」。换句话说，「隐藏一个变量」。</p>
<p>假设我们现在在做一个系统的注册登录功能，在写其中关于「用户年龄」的代码。</p>
<p>如果不使用闭包的话</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.age = <span class="number">18</span> <span class="comment">// 18岁</span></span><br></pre></td></tr></table></figure>

<p>但是这么看起来是非常危险的，因为这将在全局的任何一个地方都可以直接的访问到这个 <code>age</code> 变量，如果不加校验的话，等会要是被修改成 「负数」 怎么办，对吧？</p>
<p>所以，我们不能让别人可以「直接访问」这个 <code>age</code> 变量。</p>
<p>我们需要使用「局部变量」</p>
<p>但是使用了局部变量的话，这个变量的又需要一个全局的作用域。这个时候应该怎么办？</p>
<p>我们可以主动暴露一个访问器（函数），让别人可以「间接访问」</p>
<blockquote>
<p>上面的思考过程其实也就是 闭包 使用函数嵌套形式的由来。</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改年龄，增加1岁</span></span><br><span class="line">    <span class="built_in">window</span>.addAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        age += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改年龄，减少1岁</span></span><br><span class="line">    <span class="built_in">window</span>.subLives = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (age &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            lives -= <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'没办法再往下修改年龄啦'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>上面这也是一个闭包的例子。使用闭包之后可以更加规范的去管理我们的变量，这也是闭包的意义。总的来说这就是闭包，闭包也仅此而已。</p>
<hr>
<p>其实写到这里之后，可能由于我是学 Java 出身的，立马就想到了 Java 中实体类的封装。来看一段 Java 代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (age &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"年龄必须为正数"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简要说明一下上面这段代码：<br>首先声明一个私有化的 <code>age</code> 变量，然后为这个变量提供公有的 <code>get</code> 和 <code>set</code> 方法，可以让外界访问到这个 <code>age</code> 变量。当我们设置这个 <code>age</code> 变量的时候，我们可以在 <code>set</code> 方法中去定义一些规范，保证 <code>age</code> 值的一个正确性。</p>
<p>在我看来，刚刚的闭包的例子与上面的这段 Java 代码实现的是同一个功能。也就是说闭包其实是为了封装变量，只是在这里我们将其称为了隐藏变量，仅此而已。</p>
<blockquote>
<p>分享一个小经验：<br>编程崇尚的是以简洁优雅为美，很多时候<br><strong>如果你觉得一个概念很复杂，那么很可能是你理解错了</strong></p>
</blockquote>
<hr>
<p>大家加油：）</p>
]]></content>
      <categories>
        <category>JavaScript基础</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>封装</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java并发】join()方法</title>
    <url>/posts/50308/</url>
    <content><![CDATA[<blockquote>
<p>join方法的主要作用是同步。在主线程中去创建并启动一个线程，再调用这个线程的join方法之后，会使得两个线程原本是并行关系变成串行关系，也就是主线程将会等待子线程执行完毕之后再继续执行。</p>
</blockquote>
<a id="more"></a>
<p>注意：join方法可以传入一个long类型的参数，表示过了多少毫秒之后两个线程将由串行关系再次转变成并行关系。但如果传入的参数是0的话，表示的是永久等待，也就是主线程将会等待直到子线程执行完毕之后再次执行，相当于不传参数的join方法。</p>
<p><strong>代码演示：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子线程"</span> + Thread.currentThread().getName() + <span class="string">"开始执行"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"子线程"</span> + Thread.currentThread().getName() + <span class="string">"执行完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test());</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test());</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(<span class="string">"所有子线程执行完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main方法执行结果</span></span><br><span class="line">子线程Thread-<span class="number">1</span>执行完毕</span><br><span class="line">子线程Thread-<span class="number">0</span>执行完毕</span><br><span class="line">所有子线程执行完毕</span><br></pre></td></tr></table></figure>
<p>上面的代码如果将两个线程执行join方法的那行代码注释掉，则执行结果为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">所有子线程执行完毕</span><br><span class="line">子线程Thread-<span class="number">0</span>执行完毕</span><br><span class="line">子线程Thread-<span class="number">1</span>执行完毕</span><br></pre></td></tr></table></figure>
<p>很明显，join方法的调用会使得主线程去等待子线程执行完毕之后再重新执行代码。</p>
<h1 id="join期间被中断"><a href="#join期间被中断" class="headerlink" title="join期间被中断"></a>join期间被中断</h1><p>一个有意思的问题：</p>
<blockquote>
<p>如果主线程调用子线程的join方法后，在子线程执行的期间，有interrupt通知进入了，怎么办？</p>
</blockquote>
<p>针对上面的问题，我再重申一下本文开篇关于join方法作用的介绍。「<strong>主线程将会等待调用了join方法的子线程执行完毕后再继续执行</strong>」<br>实际上，是主线程在等待子线程执行完毕，也就是说陷入阻塞状态的是主线程而不是子线程。<br>所以关于上面的问题如果有interrupt通知进入了主线程将会抛出一个InterruptedException来响应这个interrupt通知。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Thread mainThread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        mainThread.interrupt();</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        thread.join();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"线程被中断了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main方法执行结果</span></span><br><span class="line">main线程被中断了</span><br></pre></td></tr></table></figure>
<p>启动一个子线程并调用join方法，这时主线程就在等待子线程的执行完毕，然后子线程去中断了主线程。也就是中断了一个正在<strong>因join方法陷入阻塞</strong>的线程，那么此时我们中断的是这个陷入阻塞的线程，而不是正在执行的子线程。</p>
<h1 id="join期间的线程状态"><a href="#join期间的线程状态" class="headerlink" title="join期间的线程状态"></a>join期间的线程状态</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Thread mainThread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(mainThread.getState());</span><br><span class="line">        System.out.println(Thread.currentThread().getState());</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">    thread.join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main方法执行结果</span></span><br><span class="line">WAITING</span><br><span class="line">RUNNABLE</span><br></pre></td></tr></table></figure>
<p>在子线程中去打印主线程和子线程各自的状态，明显调用了join方法的主线程被阻塞了是WAITING状态，而正在运行的子线程则是RUNNABLE状态。</p>
<h1 id="join方法分析"><a href="#join方法分析" class="headerlink" title="join方法分析"></a>join方法分析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面是Thread类中的join方法源码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    join(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可知，join方法实际上还是调用了wait方法的。如果没有传入时间参数，则是调用了<code>wait(0)</code>这个方法，代表永久等待，直到被唤醒。<br>有意思的是这其中并没有看到notify或者是notifyAll方法，也就是并没有线程去唤醒这个等待子线程执行完毕的主线程，但是当子线程执行完毕之后，这确确实实被唤醒了。<br>我们知道，主线程被唤醒的条件是子线程执行完毕，又知道线程执行完毕只有两种情况，一是run方法运行结束，二是抛出了运行时异常。<br>至此，答案水落石出，当线程执行完毕时，将会去执行notifyAll方法唤醒其他的线程。</p>
<blockquote>
<p>注意：我们并不提倡使用Thread类的实例作为synchronized的锁对象原因也是在此，因为这可能会破坏原有的wait-notify结构。</p>
</blockquote>
<hr>
<p>大家加油：）</p>
]]></content>
  </entry>
  <entry>
    <title>【Java并发】Synchronized关键字</title>
    <url>/posts/10492/</url>
    <content><![CDATA[<p><strong>一句话说明 Synchronized 关键字的作用：</strong></p>
<blockquote>
<p>能够保证在 <strong>「同一时刻」</strong> 最多只有 <strong>「一个」</strong> 线程执行该段代码，以达到保证 <strong>「并发安全」</strong> 的效果</p>
</blockquote>
<a id="more"></a>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h4 id="地位"><a href="#地位" class="headerlink" title="地位"></a>地位</h4><ul>
<li>Synchronized 是 Java 的关键字，被 Java 语言原生支持</li>
<li>是最基本的互斥同步手段</li>
<li>并发编程中的必学内容</li>
</ul>
<h4 id="线程不安全的后果"><a href="#线程不安全的后果" class="headerlink" title="线程不安全的后果"></a>线程不安全的后果</h4><p>我们来演示一个“消失的请求”的小例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runnable</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; syn(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        <span class="comment">// 两个join方法是为了保证两个线程能够执行完毕</span></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        <span class="comment">// 介绍一下另一种方式保证两个线程能够执行完毕</span></span><br><span class="line">        <span class="comment">// while (thread1.isAlive() || thread2.isAlive()) &#123; &#125;</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 方法执行结果：178233</span></span><br></pre></td></tr></table></figure>
<p>很明显，如果是两个线程同时在竞争一个资源并且没有加 synchronized 关键字的修饰的话就会出现这样数据错误的情况。<br>实际上，上面代码 <code>i++</code> 的这行语句在执行的时候是有三个步骤的。</p>
<ul>
<li><strong>步骤一：</strong>将 i 的值读到内存中</li>
<li><strong>步骤二：</strong>将 i 的值加1</li>
<li><strong>步骤三：</strong>将 i 的值写回去</li>
</ul>
<p>但是现在有两个线程在同时执行这三个步骤，比如在 <code>i=10</code> 的时候线程 <code>thread1</code> 执行了<strong>步骤一</strong>，此时线程 <code>thread2</code> 也执行了 <strong>步骤一</strong>，那么线程 <code>thread2</code> 拿到的 <code>i</code> 的值也是10，然后这两个线程正常执行<strong>步骤二</strong>和<strong>步骤三</strong>这样子就会导致两个线程同时将 <code>i</code> 的值从 10 加到 11。这就是线程不安全的后果，本文介绍的 Synchronized 关键字的作用就是为了解决这样的问题而存在的。</p>
<h1 id="Synchronized-关键字的用法"><a href="#Synchronized-关键字的用法" class="headerlink" title="Synchronized 关键字的用法"></a>Synchronized 关键字的用法</h1><p>既然上面的例子已经是出现了这样的问题，那么接下来就介绍一下如何使用 Synchronized 关键字来解决类似的问题。将以下几个例子的 syn 方法应用在上面「线程不安全的后果」中即可解决“消失的请求”的问题</p>
<blockquote>
<p>实际上，我们可以将 Synchronized 关键字理解成「<strong>锁</strong>」的概念，当一个线程去获取一些要执行的资源的时候，我们就把这个资源的锁给这个线程，线程拿到锁了便可以执行。这时候如果其他线程也想要获取这个执行资源的话，由于拿不到锁便无法执行，只能是陷入 BLOKCKED 阻塞状态。从而保证了线程安全<br>但是，Java 为 Synchronized 关键字提供了几种不同的加锁的方式，我们可以根据具体的业务场景选择使用不同的方式来加锁。依据使用方式的不同，在这里将其分为 <strong>对象锁</strong> 和 <strong>类锁</strong></p>
</blockquote>
<h3 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h3><p>synchronized 修饰普通方法和代码块的形式都称之为对象锁。<br>以下是我的个人理解：</p>
<ul>
<li><strong>代码块</strong><br> 修饰代码块的形式是需要我们为这个代码块去手动的指定一个对象作为锁传进去的，线程想要执行代码块中的代码就必须要拿到这把锁也就是我们指定的对象才可以执行。</li>
<li><strong>普通方法</strong><br> 我认为普通方法和代码块的形式实际上原理相同，Java 中我们在调用普通方法时是这样的：<code>Object.method()</code> 是通过类对象去调用的方法，这里的类对象实际上就是传入的锁，如果是通过相同的对象去调用这个方法，那么就需要拿到这个对象作为的锁才可以调用这个方法，在这里也就是将这个对象作为了锁，因此将 synchronized 关键字的这种方式分类在对象锁之下。</li>
</ul>
<h5 id="同步代码块形式"><a href="#同步代码块形式" class="headerlink" title="同步代码块形式"></a>同步代码块形式</h5><p>同步代码块的形式就是直接把 synchronized 关键字加在代码块上，并且指定一个对象作为锁。这样当线程访问代码块时就可以拿到这个对象作为锁，其他线程再想访问就拿不到这个对象了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main 方法执行结果：20000</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>扩展：一个方法中可以有多个同步代码块，并且使用不同的锁对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object lock1 = <span class="keyword">new</span> Object();</span><br><span class="line">Object lock2 = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"  lock1 开始执行"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"  lock1 执行完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"  lock2 开始执行"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"  lock2 执行完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line">Thread-<span class="number">0</span>  lock1 开始执行</span><br><span class="line">Thread-<span class="number">0</span>  lock1 执行完毕</span><br><span class="line">Thread-<span class="number">0</span>  lock2 开始执行</span><br><span class="line">Thread-<span class="number">1</span>  lock1 开始执行</span><br><span class="line">Thread-<span class="number">0</span>  lock2 执行完毕</span><br><span class="line">Thread-<span class="number">1</span>  lock1 执行完毕</span><br><span class="line">Thread-<span class="number">1</span>  lock2 开始执行</span><br><span class="line">Thread-<span class="number">1</span>  lock2 执行完毕</span><br></pre></td></tr></table></figure>

<h5 id="普通方法形式"><a href="#普通方法形式" class="headerlink" title="普通方法形式"></a>普通方法形式</h5><p>直接将 synchronized 关键字加在普通方法上（以调用方法的对象作为锁，也就是 <code>this</code> ），这样这个方法就是只能同时被一个线程执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 方法执行结果：200000</span></span><br></pre></td></tr></table></figure>

<h3 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a>类锁</h3><p>synchronized 修饰静态方法和修饰代码块时指定（*.class）对象都称之为类锁<br>以下是我的个人理解：</p>
<ul>
<li><strong>静态方法</strong><br> Java 中一个类的静态方法只会随着类的加载而加载，在创建类对象时是不会加载静态方法的。这意味着一个类的静态方法在内存中只有一份，这与类的实例无关。当 synchronized 修饰了静态方法时，这个静态方法是在同一个时间内是绝对只会有一个线程在执行的。这与修饰普通方法的对象锁不同，对象锁的话是将调用方法的对象作为锁的，如果执行这个对象的方法被阻塞时，可以再新建一个对象去执行这个方法。而修饰静态方法的类锁是不同的，由于静态方法在内存中只有一份，所以<strong>在同一时间段内只能有一个线程执行</strong></li>
<li><strong>指定（*.class）对象</strong><br> 首先必须明白一个概念，Java 中的类无论被实例化多少次 <code>class</code> 对象都始终只有一个，所以修饰代码块时指定一个 <code>类名.class</code> 的类对象作为锁传入的话，那么由于锁在内存中的唯一性，那么这个代码块也是<strong>在同一时间段内只能有一个线程执行的</strong>。同样的这与对象锁中指定对象的形式不同，指定一个对象作为锁的话，在阻塞时实际上也可以通过重新创建一个对象来执行代码块中的代码。</li>
</ul>
<h5 id="静态方法形式"><a href="#静态方法形式" class="headerlink" title="静态方法形式"></a>静态方法形式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 方法执行结果：200000</span></span><br></pre></td></tr></table></figure>

<h5 id="指定（-class）对象的形式"><a href="#指定（-class）对象的形式" class="headerlink" title="指定（*.class）对象的形式"></a>指定（*.class）对象的形式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Runnable<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 方法执行结果：200000</span></span><br></pre></td></tr></table></figure>

<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><blockquote>
<p>synchronized 关键字就是将指定的对象作为锁去保护某一段代码的机制，这个指定的对象可以是普通对象也可以是类对象。根据指定的对象的功能不同可以分为对象锁和类锁，对象锁和类锁的区别就是在内存中，类锁是只有一个的，而对象锁可以创建多个，从而在某种特定的条件下可能在同一个时间段内多个线程都在执行同一个方法。</p>
</blockquote>
<h1 id="多线程访问同步方法的7种情况"><a href="#多线程访问同步方法的7种情况" class="headerlink" title="多线程访问同步方法的7种情况"></a>多线程访问同步方法的7种情况</h1><ol>
<li><p>两个线程同时访问<strong>一个对象</strong>的同步方法<br> 同一个对象同一个锁，先访问先执行，后访问被阻塞</p>
</li>
<li><p>两个线程访问的是<strong>两个对象</strong>的同步方法<br> 两个对象两个锁，两个线程各一个，各自执行，互不干扰</p>
</li>
<li><p>两个线程访问的是 synchronized 的静态方法<br> 静态方法持类锁，两个线程一个锁，先访问先执行，后访问阻塞</p>
</li>
<li><p>同时访问<strong>同步</strong>方法与<strong>非同步</strong>方法<br> 非同步方法的执行并不受同步方法的影响</p>
</li>
<li><p>访问同一个对象的<strong>不同的</strong>普通同步方法<br> 普通同步方法默认以 <code>this</code> 作为锁对象，所以同个对象同个锁，先访问先执行，后访问被阻塞</p>
</li>
<li><p>同时访问<strong>静态</strong> synchronized 和<strong>非静态</strong> synchronized 方法<br> 静态方法用类锁，非静态方法用对象锁，两个线程各一个，各自执行，互不干扰</p>
</li>
<li><p>方法抛出<strong>异常</strong>后，会释放<strong>锁</strong><br> 代码演示：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runnable</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread().getName().equals(<span class="string">"Thread-0"</span>)) &#123;</span><br><span class="line">            method1();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            method2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"   开始执行"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"   开始执行"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"   执行完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 方法执行结果：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Thread-0   开始执行</span></span><br><span class="line"><span class="comment">// 等待3秒...</span></span><br><span class="line"><span class="comment">Exception in thread "Thread-0" java.lang.RuntimeException</span></span><br><span class="line"><span class="comment">    at createthreads.Runnable.method1(Runnable.java:29)</span></span><br><span class="line"><span class="comment">    at createthreads.Runnable.run(Runnable.java:16)</span></span><br><span class="line"><span class="comment">    at java.lang.Thread.run(Thread.java:748)</span></span><br><span class="line"><span class="comment">Thread-1   开始执行</span></span><br><span class="line"><span class="comment">Thread-1   执行完毕</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="小结：-1"><a href="#小结：-1" class="headerlink" title="小结："></a>小结：</h3><ol>
<li>一把锁只能同时被一个线程获取，没有拿到锁的线程必须等待。</li>
<li>每个实例都对应自己的一把锁，不同实例之间互不影响。</li>
<li>锁对象是是 <code>*.class</code> 以及 synchronized 修饰的是 static 方法的时候，所有对象共用一把锁。</li>
<li>无论方法正常执行完毕或者方法抛出异常，都会释放锁。</li>
</ol>
<h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><h3 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h3><ul>
<li><strong>概念</strong>：指的是同一线程的外层函数获取锁之后，内层函数可以直接再次获取该锁。</li>
<li><strong>好处</strong>：避免死锁，提升封装性。</li>
</ul>
<p>可重入的意思是，当前获得锁的线程去再次调用被 synchronized 修饰的方法时，可以把当前已经获得的锁直接传递给该方法。这样的机制的好处是可以避免死锁的发生，也就是当前方法在等待的锁正好是自己已经获得的锁，陷入死循环不断等待。另一个好处是提升封装性，由于可传入的性质，避免了在调用其他方法时的解锁和加锁步骤，简化了并发编程的难度。</p>
<p><strong>示例：三个可重入场景</strong></p>
<blockquote>
<p>递归调用被 synchronized 关键字修饰的方法</p>
</blockquote>
<blockquote>
<p>在 synchronized 方法中调用另外一个 synchronized 方法（必须使用同一个锁）</p>
</blockquote>
<blockquote>
<p>子类 synchronized 方法中调用父类 synchronized 方法</p>
</blockquote>
<h3 id="不可中断"><a href="#不可中断" class="headerlink" title="不可中断"></a>不可中断</h3><p>当线程访问一个拿不到锁的 synchronized 方法时，只能是被阻塞。直到别的线程释放锁为止，如果别的线程永远不释放锁的话，那么就只能永远等待下去。</p>
<hr>
<p>参考：<br><a href="https://www.cnblogs.com/wpf-7/p/9639671.html" target="_blank" rel="noopener">https://www.cnblogs.com/wpf-7/p/9639671.html</a></p>
<p>大家加油：）</p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>synchronized</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java并发】停止线程</title>
    <url>/posts/41050/</url>
    <content><![CDATA[<p>正所谓上山容易下山难。我们创建启动一个线程并不是很困难，但是如何正确的停止一个线程就并不是那么简单。因为如果没有正确停止的线程的话，线程将继续消耗计算机的资源，对性能造成严重的损耗。</p>
<a id="more"></a>

<h1 id="一、停止线程原理"><a href="#一、停止线程原理" class="headerlink" title="一、停止线程原理"></a>一、停止线程原理</h1><blockquote>
<p><strong>原理概述：使用 interrupt 来通知线程停止，而不是强制停止线程</strong></p>
</blockquote>
<p>通常线程停止的两种情况：</p>
<ol>
<li>run 方法中的全部代码运行完毕。</li>
<li>线程运行的过程中出现没有捕获的异常。</li>
</ol>
<p>实际上 Java 语言中并没有提供可以让线程安全可靠停止的方法，但是 Java 提供了 interrupt 机制来停止线程。<br><strong>注意：interrupt 机制是一种合作机制而不是强制机制。将 interrupt 看作一种通知的形式我认为更准确一些「用一个线程去通知另外一个线程停止下来」</strong></p>
<p>其实在 Java 语言中，最好的停止线程的方式也是使用 interrupt 这种方式</p>
<p>如果我们想要去停止一个线程最多也就仅能做到去通知这个线程停止，而最终决定要不要停止的权利还是在要停止的线程本身</p>
<p>在我们通知线程停止之后，由被通知停止的线程来响应这个停止通知，再最终决定是否停止，如果线程不想要停止的话，我们是一点办法都没有的，这就是原理概述后半句「而不是强制停止线程」的含义</p>
<blockquote>
<p>这其实可以类比成我们平时在路上驾驶汽车的过程。当红灯亮起来时，实际上也仅能够做到通知路上的汽车停车，然后司机去响应这个红灯，停止汽车。这里的红灯就是通知，司机就是线程。红灯亮起之后，司机可以决定停车等红灯，司机也可以不要停车决定闯红灯，比如正在执行任务的救护车或消防车。</p>
</blockquote>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 循环条件：是否有通知停止线程</span></span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            System.out.println(num++);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"任务执行完毕，num 的值："</span> + num);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    thread.start();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通知线程停止</span></span><br><span class="line">    thread.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、阻塞状态下停止线程"><a href="#二、阻塞状态下停止线程" class="headerlink" title="二、阻塞状态下停止线程"></a>二、阻塞状态下停止线程</h1><blockquote>
<p>关于阻塞状态的描述，可以看 <a href="https://blog.wrp.cool/posts/43936/" target="_blank" rel="noopener">线程生命周期</a> 这篇文章</p>
</blockquote>
<p>以下使用 sleep 方法来使线程进入阻塞状态</p>
<ol>
<li><p><strong>迭代中 sleep</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (num &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                System.out.println(num++);</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"任务执行完毕，num 的值："</span> + num);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    thread.start();</span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知线程停止</span></span><br><span class="line">    thread.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 循环条件中并没有判断是否有停止线程，这是因为当<strong>线程处于 sleep 状态时会自动的检测是否有停止线程的通知</strong>。</p>
</li>
<li><p><strong>迭代中捕获异常</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (num &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            System.out.println(num++);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"任务执行完毕，num 的值："</span> + num);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    thread.start();</span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知线程停止</span></span><br><span class="line">    thread.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  异常被捕获后线程并没有停止，这并不是因为我们在异常处理中“响应”了通知，而是因为在 <strong>sleep 状态中会自动清除停止线程的通知</strong></p>
</li>
</ol>
<p><strong>综上：在 sleep 状态中线程会自动检测是否有 <code>interrupt</code> 通知，如果有 <code>interrupt</code> 通知，响应的方式是抛出一个 <code>InterruptedException</code> 异常，并清除这个通知。</strong></p>
<h1 id="三、实际编码中的阻塞状态下该如何响应-interrupt"><a href="#三、实际编码中的阻塞状态下该如何响应-interrupt" class="headerlink" title="三、实际编码中的阻塞状态下该如何响应 interrupt"></a>三、实际编码中的阻塞状态下该如何响应 interrupt</h1><p>实际编码的过程中，大多数时候在 run 方法内部是需要去调用一些外部的方法的。那么如果是在这些被调用的外部方法中有 sleep 这个动作的话，我们在 run 方法中是并不知道线程在什么情况下会 sleep 的。所以当我们编写一些需要 sleep 的方法时，一定要注意不能够把 interrupt 通知给自己 <strong>“消化”</strong> 掉，应该要通过一些办法将这个 interrupt 通知反映给 run 方法。比如：传递中断和恢复中断</p>
<h3 id="传递中断（推荐）"><a href="#传递中断（推荐）" class="headerlink" title="传递中断（推荐）"></a>传递中断（推荐）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            startSleep();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 处理 Interrupt 通知</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    thread.start();</span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知线程停止</span></span><br><span class="line">    thread.interrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 InterruptException 抛出</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startSleep</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 startSleep 方法中，让线程进入 sleep 状态，并将 InterruptException 异常抛出在方法声明中传递给上一级的方法去处理。这样一旦 run 方法调用了 startSleep 就必须去处理 InterruptException 异常。而如果在 sleep 过程中有 Interrupt 通知出现，那么 run 方法的编写者就可以在 catch 语句中去处理这个 Interrupt 通知。</p>
</blockquote>
<h3 id="恢复中断"><a href="#恢复中断" class="headerlink" title="恢复中断"></a>恢复中断</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 响应通知</span></span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            System.out.println(num++);</span><br><span class="line">            startSleep();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"执行完毕，num = "</span> + num);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    thread.start();</span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知线程停止</span></span><br><span class="line">    thread.interrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startSleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="comment">// 恢复中断</span></span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在某些特定的业务场景中，我们可能必须去处理 InterruptedException 异常。那么就必须要在 catch 块中去再次发出 Interrupt 通知，恢复这个通知。让 run 方法的编写者可以正确的处理 Interrupt 通知。</p>
</blockquote>
<h1 id="四、彩蛋：介绍-sleep-方法的优雅写法"><a href="#四、彩蛋：介绍-sleep-方法的优雅写法" class="headerlink" title="四、彩蛋：介绍 sleep 方法的优雅写法"></a>四、彩蛋：介绍 sleep 方法的优雅写法</h1><p>以上讲了那么多的关于 sleep 方法的内容，那么看来一个 sleep 方法的一个优雅的写法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TimeUnit.HOURS.sleep(<span class="number">1</span>);   <span class="comment">// 休眠1个小时</span></span><br><span class="line">        TimeUnit.MINUTES.sleep(<span class="number">1</span>); <span class="comment">// 休眠1分钟</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>); <span class="comment">// 休眠1秒钟</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上使用 TimeUnit 类中的 sleep 方法可以让代码看起来更加舒服。直接休眠对应单位的时间，而不是去手动的计算要休眠的毫秒数。</p>
<hr>
<p>大家加油：）</p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java并发】创建线程</title>
    <url>/posts/9740/</url>
    <content><![CDATA[<blockquote>
<p>本文将介绍Java中创建线程的两种方式，以及两种方式的优缺点的比较。</p>
</blockquote>
<a id="more"></a>

<h1 id="一、实现线程的两种方式"><a href="#一、实现线程的两种方式" class="headerlink" title="一、实现线程的两种方式"></a>一、实现线程的两种方式</h1><p>在 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html" target="_blank" rel="noopener">Oracle官方文档</a> 中，明确说明了Java实现线程的方式就只有两种。一种是 <strong>实现 Runnable 接口</strong>，另一种是 <strong>继承 Thread 类</strong></p>
<ol>
<li><p><strong>实现 Runnable 接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用 Runnable 方式创建线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableStyle</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建新线程</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunnableStyle());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行线程</span></span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新线程中要做的事情</span></span><br><span class="line">        System.out.println(<span class="string">"用 Runnable 方式实现线程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>继承 Thread 类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用 Thread 创建线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadStyle</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建线程</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> ThreadStyle();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行线程</span></span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程中要做的事情</span></span><br><span class="line">        System.out.println(<span class="string">"用 Thread 方式创建线程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="二、两种实现方式的比较"><a href="#二、两种实现方式的比较" class="headerlink" title="二、两种实现方式的比较"></a>二、两种实现方式的比较</h1><p>通常情况下我们需要去创建一个线程的时候会选择实现<strong>Runnable 接口</strong>的方式，事实上 「实现 Runnable 接口」 的方式确实优于 「继承 Thread 类」 的方式。</p>
<ol>
<li><p><strong>程序架构的角度</strong><br>创建线程的工作和线程要做的工作应该是分开的，也就是解耦的。<strong>实现 Runnable 接口</strong> 的方式就将线程要执行的代码也就是 <code>run</code> 方法里面的内容以及创建线程的机制也就是 <code>Thread</code> 类进行分离了，从而解耦。而 <strong>继承 Thread 类</strong> 的方式就没有做到这一点。</p>
</li>
<li><p><strong>执行效率的角度</strong><br> <strong>实现 Runnable 接口</strong> 的方式也是优于 <strong>继承 Thread 类</strong> 的方式的。如果使用 <strong>继承 Thread 类</strong> 的方式去创建线程每次新建一个任务时都要去创建一个新的线程，而创建线程的消耗是比较大的。<strong>实现 Runnable 接口</strong> 的方式可以让我们在后续利用一些线程池之类的工具，减少对资源的损耗。</p>
</li>
<li><p><strong>代码设计的角度</strong><br>由于 Java 是不支持多继承的，实现接口的方式肯定是优于继承类的方式。</p>
</li>
</ol>
<h1 id="三、run-方法源码"><a href="#三、run-方法源码" class="headerlink" title="三、run 方法源码"></a>三、run 方法源码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// target 为实现 Runnable 接口传入的 Runnable 对象</span></span><br></pre></td></tr></table></figure>
<p>以上便是 Thread 类中 run 方法的全部代码，非常的精简。如果在构造 Thread 类时传入了 Runnable 对象则执行 Runnable 对象的 run 方法，如果没有传入 Runnable 对象则什么都不做。</p>
<p>恰恰也是这三行代码为 Thread 类提供了两种创建线程执行单元的方式，也就是我们上面一直在讨论的方式。实际上两种创建线程的方式在执行具体的新线程中的代码时都是调用的 Thread 类的 run 方法，新线程要实现的功能也是在 run 方法中去编写的。</p>
<p><strong>「实现 Runnable 接口」</strong>的方式也是在 run 方法中调用了在 Runnable 接口中定义的 run 方法，而并不是直接去调用了 Runnable 接口的 run 方法。</p>
<p><strong>「继承 Thread 类」</strong>的方式则是通过重写 Thread 类中的 run 方法，在 run 方法中去编写要实现的功能，覆盖掉 Thread 类中的 run 方法，从而使得在调用时执行我们自己编写的新线程的执行单元。</p>
<h1 id="思考题：如果同时使用两种方式会怎么样"><a href="#思考题：如果同时使用两种方式会怎么样" class="headerlink" title="思考题：如果同时使用两种方式会怎么样"></a>思考题：如果同时使用两种方式会怎么样</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"实现 Runnable 接口创建的线程"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"继承 Thread 类创建的线程"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// 继承 Thread 类创建的线程</span></span><br></pre></td></tr></table></figure>
<p>如果已经对 run 方法的源码理解透彻的话，那么这道题是没有任何难度的。</p>
<p>「实现 Runnable 接口」的方式是的执行单元是需要在 Thread 的 run 方法去调用的，但是我们已经重写了 Thread 中的 run 方法，自然无从去调用 Runnable 对象的执行单元了，也就不会被执行。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>实现线程的方式只有两种，分别是「实现 Runnable 接口」和「继承 Thread 类」</li>
<li>准确的讲，创建线程的方式只有一种那就是构造 Thread 类，而 Thread 类中提供了两种实现线程的执行单元的方式<ul>
<li>方式一：实现 Runnable 接口的 run 方法，并把 Runnable 实例传给 Thread 类</li>
<li>方式二：重写 Thread 的 run 方法</li>
</ul>
</li>
</ol>
<hr>
<p>大家加油：）</p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java并发】wait()、notify()、notifyAll()</title>
    <url>/posts/29010/</url>
    <content><![CDATA[<p><code>wait()、notify()和notifyAll()</code> 这三个方法都是属于 Object 类的方法，这也就意味着在 Java 中的任何对象都可以调用这三个方法。<br>同时这三个方法也是被 「volatile 和 final 修饰的方法」也就是没办法看到源码和重写。<br>Object 作为所有类的基类，其地位不言而喻。而这三个方法能被定义在 Object 中自然也是非常重要的方法，借由这三个方法的配合可以使得多线程可以更好的配合、协同工作。</p>
<a id="more"></a>

<h1 id="方法详解"><a href="#方法详解" class="headerlink" title="方法详解"></a>方法详解</h1><h2 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h2><p>想要执行 wait 方法必须要在 synchronized 方法或者是代码块中才可以执行，执行 wait方法会使得当前线程释放掉 monitor 锁，强迫当前线程进入阻塞状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (Object) &#123;</span><br><span class="line">    object.wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想要唤醒当前线程则必须是另外的一个线程去调用了 notiify 并且刚刚好唤醒的是本线程，或者是直接调用 notifyAll。</p>
<blockquote>
<p>假如现在有四个线程在运行，其中线程A、B、C都调用了<code>wait()</code>在等待同一个monitor锁，而线程D持有这个monitor锁。那么如果现在线程D调用了<code>notify()</code>方法，则会随机的从前面的线程A、B、C中去唤醒一个线程，如果调用的是<code>notifyAll()</code>方法的话，则会将线程A、B、C全部唤醒</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"开始执行"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    object.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"再次获取到monitor锁"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                object.notify();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"已经执行了 notify 方法"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread1 thread1 = <span class="keyword">new</span> Thread1();</span><br><span class="line">        Thread2 thread2 = <span class="keyword">new</span> Thread2();</span><br><span class="line">        thread1.start();</span><br><span class="line">        Thread.sleep(<span class="number">5</span>);</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main方法运行结果</span></span><br><span class="line">Thread-<span class="number">0</span>开始执行</span><br><span class="line">Thread-<span class="number">1</span>已经执行了 notify 方法</span><br><span class="line">Thread-<span class="number">0</span>再次获取到monitor锁</span><br></pre></td></tr></table></figure>
<p>上面的这段代码就可以说明<code>wait()</code>方法和<code>notify</code>方法的执行过程。<br>首先是Thread-0线程执行<code>wait()</code>方法<strong>释放monitor锁之后</strong>进入等待状态，之后Thread-1线程执行了<code>notify()</code>方法去唤醒了Thread-0线程。<br>此时Thread-0线程已经是被唤醒的状态，但是并没有继续往下执行，这是因为没有获得monitor锁，唤醒Thread-0线程的Thread-1线程还没有释放这把锁。<br>等待Thread-1线程执行完毕也就是打印了「Thread-1已经执行了 notify 方法」这句语句之后，Thread-1线程执行完毕，释放monitor锁之后，Thread-0线程再次获取monitor锁之后开始执行剩余代码。</p>
<p>注意：</p>
<ol>
<li>调用<code>wait()</code>方法的线程会主动释放monitor锁，上面的代码也正是因为Thread-0主动释放掉了monitor锁之后，Thread-1才可以执行</li>
<li>当休息的线程被唤醒时并不是直接执行的，而是需要重新去竞争对应的锁，获取到锁之后才可以执行</li>
</ol>
<hr>
<p>大家加油：）</p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java并发】启动线程</title>
    <url>/posts/25097/</url>
    <content><![CDATA[<blockquote>
<p>本文将会介绍 Java 中如何正确的启动线程。以及对比一下 start 方法和 run 方法的区别</p>
</blockquote>
<a id="more"></a>

<p><strong>首先直接抛出启动线程的正确姿势：start 方法！！！</strong></p>
<h1 id="start-方法"><a href="#start-方法" class="headerlink" title="start 方法"></a>start 方法</h1><h4 id="含义（启动新线程）"><a href="#含义（启动新线程）" class="headerlink" title="含义（启动新线程）"></a>含义（启动新线程）</h4><p>当我们创建完一个线程调用了 start 方法时，这个线程并<strong>不会直接执行</strong>，而是<strong>等待执行</strong>，也就是进入了<strong>就绪</strong>状态。</p>
<p>实际上调用 start 方法的这个动作仅仅只是去通知了 JVM 「我有一个线程已经准备好执行了，你有空的话帮我执行一下」</p>
<p>至于这个线程将要在什么时刻运行，这并不是我们能够决定的，这得由 CPU 的线程调度器去决定。</p>
<blockquote>
<p>注意：start 方法的调用过程是「一个父线程去调用一个已经创建的子线程的 start 方法」所以 start 方法的执行实际上是会牵扯到父子两个线程的。</p>
</blockquote>
<h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * This method is not invoked for the main method thread or "system"</span></span><br><span class="line"><span class="comment">         * group threads created/set up by the VM. Any new functionality added</span></span><br><span class="line"><span class="comment">         * to this method in the future may have to also be added to the VM.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * A zero status value corresponds to state "NEW".</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">////////////////////</span></span><br><span class="line">        <span class="comment">// 1. 检查线程状态 //</span></span><br><span class="line">        <span class="comment">////////////////////</span></span><br><span class="line">        <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">         * so that it can be added to the group's list of threads</span></span><br><span class="line"><span class="comment">         * and the group's unstarted count can be decremented. */</span></span><br><span class="line">        <span class="comment">////////////////////</span></span><br><span class="line">        <span class="comment">// 2. 添加到线程组 //</span></span><br><span class="line">        <span class="comment">////////////////////</span></span><br><span class="line">        group.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">////////////////////</span></span><br><span class="line">        <span class="comment">// 3. 调用start0  //</span></span><br><span class="line">        <span class="comment">////////////////////</span></span><br><span class="line">        <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            start0();</span><br><span class="line">            started = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                    group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">                <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">                  it will be passed up the call stack */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="start-方法和-run-方法"><a href="#start-方法和-run-方法" class="headerlink" title="start 方法和 run 方法"></a>start 方法和 run 方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Runnable runnable = () -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line"></span><br><span class="line">    thread.run();</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="comment">// Thread-0</span></span><br></pre></td></tr></table></figure>
<p>以上的代码已经很明确的向我们展示了不同之处了，start 方法是开启一个新的线程去执行代码，而 run 方法还是在本线程之中去执行的，并没有开启新的线程。</p>
<p>实际上 strat 方法和 run 方法从根本上来说就是不同的。start 方法是线程体系中的方法，而 run 方法并不属于线程体系，只是一个执行单元，这两者有着根本上的区别。</p>
<p>执行单元和线程体系本质上并没有太大的关系。线程体系指的是一个线程的创建、启动、死亡等各种状态，而执行单元指的是我们编写的要让这个线程去执行的代码。在程序的设计中这两者应该是解耦的，这也是我们推荐使用「实现 Runnable 接口」的方式去实现一个线程的原因之一。</p>
<hr>
<p>大家加油：）</p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】动态数组</title>
    <url>/posts/714/</url>
    <content><![CDATA[<p>本文将讲述一个动态数组的实现过程，由于动态数组其实是一种比较简单的数据结构。所以本文将会以代码展示为主，当然，难点也是会重点讲述。有什么不明白的地方可以在评论区提问。</p>
<a id="more"></a>

<h1 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h1><blockquote>
<p>将要实现一个Array类来承载动态数组这种数据结构。动态数组的底层也是使用Java中的静态数组去实现的，之所以动态是因为这其中可以自动的扩容和扩容和缩容的操作。</p>
</blockquote>
<ol>
<li>准备一个静态的数组和一个记录动态数组大小的变量<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> E[] data;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure></li>
<li>准备构造方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Array</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    data = (E[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Array</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>设计一些方便用户的方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取数组中元素的个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数组的容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回数组是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
准备工作结束。</li>
</ol>
<h1 id="二、设计扩容和缩容的方法"><a href="#二、设计扩容和缩容的方法" class="headerlink" title="二、设计扩容和缩容的方法"></a>二、设计扩容和缩容的方法</h1><p>Java种的数组一旦被初始化之后就再也无法改变它的容量了，所以我们只能够是通过创建一个新的数组，在新数组中开辟出我们想要的空间，然后再将原来的数组全部搬到这个新数组中，以此来实现动态数组。严谨一些的话这并不是真正意义上的动态数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现动态的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity 新数组的容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建新数组</span></span><br><span class="line">    E[] newData = (E[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将元素复制到新数组中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        newData[i] = data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将data指向新数组</span></span><br><span class="line">    data = newData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、添加元素"><a href="#三、添加元素" class="headerlink" title="三、添加元素"></a>三、添加元素</h1><p>向数组中的任意位置添加元素，需要将这个位置之后的所有元素都往后挪动一个位置，来腾出这个位置以供新的元素添加进来。<br>重点就是在于这个「挪」的实现，我们需要从最后一个元素开始一个个的往后挪一位，这样才不会覆盖到原有的元素。</p>
<blockquote>
<p>注意：在添加元素的时候我们是有可能会超出现有数组的边界的，不进行处理的话就会抛出下标越界的异常。<br>动态数组就是为了解决这个问题而存在的，自动的判断是否需要扩容操作，为用户屏蔽掉下标越界的问题，用户只管插入而不需要担心容量问题。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向数组中的任意位置添加元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 任意位置的下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 要添加的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"数组下标 "</span> + index + <span class="string">" 不合法, 当前size = "</span> + size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否需要进行扩容操作</span></span><br><span class="line">    <span class="keyword">if</span> (size == data.length) </span><br><span class="line">        resize(data.length * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挪动元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size; i &gt; index; i--) </span><br><span class="line">        data[i] = data[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素，维护size变量</span></span><br><span class="line">    data[index] = e;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设计两个方便用户操作的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向所有元素后添加一个新元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123; add(size, e); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向所有元素前添加一个新元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123; add(<span class="number">0</span>, e); &#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、删除元素"><a href="#四、删除元素" class="headerlink" title="四、删除元素"></a>四、删除元素</h1><p>这其实跟添加元素是一样的，只是反过来而已。删除数组中任意位置的元素，需要将这个位置之后的所有元素都往前挪动一个位置。一个个的覆盖掉前面的元素。<br>在这里需要从要删除元素的后一位开始挪，一直往后挪到最后一位元素。</p>
<blockquote>
<p>注意：在删除元素时，如果数组中剩下的空间太多了，这时我们需要触发缩容操作，以免造成太多内存的浪费。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除数组中的任意元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 要删除元素的下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> E 删除的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"数组下标 "</span> + index + <span class="string">" 不合法, 当前size = "</span> + size);</span><br><span class="line">    </span><br><span class="line">    E removeE = data[index];</span><br><span class="line">    <span class="comment">// 挪动元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        data[i] = data[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">// 判断是否缩容</span></span><br><span class="line">    <span class="keyword">if</span> (size == data.length / <span class="number">4</span> &amp;&amp; data.length / <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        resize(data.length / <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> removeE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在扩容的时候是扩容成原来数组的两倍的大小，但是缩容时确实缩容成数组的四分之一大小。<br>这是为了防止用户在添加删除元素时刚好是在原来数组容量大小的附近进行的，则不断的会去触发扩容和缩容的操作，而这会更多的消耗资源。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="关于动态数组，以上的几个方法就是其中最主要的方法了，其他的一些例如查询元素和修改元素相对而言比较简单，也没什么好说的，本文也就省略不提。"><a href="#关于动态数组，以上的几个方法就是其中最主要的方法了，其他的一些例如查询元素和修改元素相对而言比较简单，也没什么好说的，本文也就省略不提。" class="headerlink" title="关于动态数组，以上的几个方法就是其中最主要的方法了，其他的一些例如查询元素和修改元素相对而言比较简单，也没什么好说的，本文也就省略不提。"></a>关于动态数组，以上的几个方法就是其中最主要的方法了，其他的一些例如查询元素和修改元素相对而言比较简单，也没什么好说的，本文也就省略不提。</h2><p>大家加油：）</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
        <tag>动态数组</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java并发练习】两个线程交替打印0~100</title>
    <url>/posts/45104/</url>
    <content><![CDATA[<blockquote>
<p>题目：<br>实现两个线程交替打印0~100，其中一个线程专门打印奇数，另一个线程专门打印偶数。</p>
</blockquote>
<blockquote>
<p><strong>分析题目：</strong><br>题目关键字：<strong>两个线程</strong>、<strong>交替</strong>、<strong>0~100</strong>、<strong>专门打印奇数</strong>、<strong>专门打印偶数</strong></p>
</blockquote>
<a id="more"></a>

<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol>
<li>首先创建两个线程</li>
<li>交替打印证明线程之间需要协同配合、考虑 synchronized、wait-notify</li>
</ol>
<h1 id="使用-sychronized"><a href="#使用-sychronized" class="headerlink" title="使用 sychronized"></a>使用 sychronized</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印奇数的线程</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span>(count &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + count++);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">"奇数"</span>).start();</span><br><span class="line">    <span class="comment">// 打印偶数的线程</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span>(count &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + count++);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">"偶数"</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用 synchronized 的方法虽然也是能够完成题目的要求，但是效率上略差一些。<br>main 方法中的逻辑是，先判断是否满足打印 0~100 的要求，如果满足则进入同步代码块中，此时两个线程将会竞争同一把锁 <code>lock</code><br>竞争到锁的线程将判断是否满足打印条件，如果满足则打印，否则直接跳出，紧接着同步代码块执行完毕释放锁，两个线程重新进入竞争锁的步骤<br>如果在这个时候其中一个线程接连多次竞争到锁，但是却因为不满足打印条件而再次直接释放锁，这就是无意义的性能浪费</p>
</blockquote>
<h1 id="使用-wait-notify"><a href="#使用-wait-notify" class="headerlink" title="使用 wait-notify"></a>使用 wait-notify</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (count &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="comment">// 获取锁证明是符合打印条件，直接打印</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + count++);</span><br><span class="line">                <span class="comment">// 唤醒另外的线程</span></span><br><span class="line">                lock.notify();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 判断是否打印到最后的数字了，如果还没有则中断，把锁让给另外的线程去打印</span></span><br><span class="line">                    <span class="comment">// 做这层判断是为了预防在打印到最后一个数字时，中断后另外的线程已经执行完毕，而无法唤醒</span></span><br><span class="line">                    <span class="keyword">if</span> (count &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">new</span> Thread(test, <span class="string">"偶数"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(test,<span class="string">"奇数"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用 wait-notify 不需要去判断是否符合奇偶数的打印条件，而是当拿到锁则证明肯定是符合打印条件的，直接打印<br>打印完唤醒另外的线程准备执行下一次的打印，再中断本线程让渡锁</p>
</blockquote>
<hr>
<p>大家加油：）</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>线程</tag>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java并发】多线程异常处理器</title>
    <url>/posts/29598/</url>
    <content><![CDATA[<p>我们平时在处理异常的时候，如果是主线程抛出了一个未处理的异常，那么我们可以轻松的使用 <code>try-catch</code> 捕获这个异常。但是如果这个异常是在子线程中抛出的，那么主线程实际上对于子线程的异常是不敏感的，虽然可以正常的抛出，但是却很难去发现。就算是在主线程中使用 <code>try-catch</code> 去捕获子线程的异常那也是没用的，因为 <code>try-catch</code> 只会捕获本线程中的异常。</p>
<a id="more"></a>
<p>简单对比一下主线程和子线程之间抛异常的不同之处：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"我是子线程抛出来的异常"</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">5000</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"我是主线程抛出来的异常"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码就可以清晰的展现这个问题。我们使用一个for循环来模拟程序的正常执行过程，这其中，子线程的异常大概是在控制台打印到500的时候抛出来，但这完全不会影响到主线程的正常执行，但是主线程的异常却每次都准确的在程序打印到5000的时候去抛出来，然后程序终止运行。如果是在真实的开发环境中，子线程抛出来的异常并不会被主线程捕获并处理，而在茫茫的日志文件中，我们想要去发现子线程的异常，简直是大海捞针。今天的主题就是要来说一说如何去处理子线程中的异常。</p>
<p>演示「主线程」<strong>无法捕获</strong>「子线程」中的异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test(),<span class="string">"线程1"</span>).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test(),<span class="string">"线程2"</span>).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test(),<span class="string">"线程3"</span>).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test(),<span class="string">"线程4"</span>).start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"捕获了异常"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"子线程抛出的异常"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面演示的在主线程中使用 <code>try-catch</code> 去捕获异常也是无法处理的，但是把 <code>try-catch</code> 放到子线程中去就可以处理这个异常了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"我是子线程抛出来的异常"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeExeception e) &#123;</span><br><span class="line">            <span class="comment">// 处理异常逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">5000</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"我是主线程抛出来的异常"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像上面这样在子线程中使用 <code>try-catch</code> 去捕获异常这是解决问题的办法之一。这也不可避免的带来一个弊端，那就是我们需要在每个run方法中都手动的去编写 <code>try-catch</code> 来处理异常，而且我们也不知道具体可能出现什么类型的异常。我们有更好的办法——UncaughtExceptionHandler</p>
<h1 id="Thread类中的接口UncaughtExceptionHandler"><a href="#Thread类中的接口UncaughtExceptionHandler" class="headerlink" title="Thread类中的接口UncaughtExceptionHandler"></a>Thread类中的接口UncaughtExceptionHandler</h1><p>java.lang 包中有一个ThreadGroup的类实现了这个接口，这里就简单的称之为线程的异常处理器。我们来看看这处理了什么内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口中仅定义了这一个方法，以下是实现类</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    通过接口的参数我们大致可以猜出，当子线程中抛出异常时，将会通过某种方式（个人猜测是反射）回调这个方法</span></span><br><span class="line"><span class="comment">    也清晰明了的告诉了我们是哪个线程抛出的哪个异常</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        parent 的定义：private final ThreadGroup parent;</span></span><br><span class="line"><span class="comment">        首先检查是否存在一个父线程的这个异常处理器，如果存在则调用父线程的异常处理器进行处理，这里是一个递归的操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        parent.uncaughtException(t, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            当调用完毕发现并没有一个可以处理异常的处理器之后</span></span><br><span class="line"><span class="comment">            尝试获取全局的异常处理器“这里的 ueh”</span></span><br><span class="line"><span class="comment">            如果存在一个全局的异常处理器，则使用这个处理器处理异常</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Thread.UncaughtExceptionHandler ueh =</span><br><span class="line">            Thread.getDefaultUncaughtExceptionHandler();</span><br><span class="line">        <span class="keyword">if</span> (ueh != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ueh.uncaughtException(t, e);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(e <span class="keyword">instanceof</span> ThreadDeath)) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                不存在的情况，直接将异常的堆栈信息打印出来</span></span><br><span class="line"><span class="comment">                也就是本文开头子线程中抛出的“我是子线程抛出来的异常”</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            System.err.print(<span class="string">"Exception in thread \""</span></span><br><span class="line">                            + t.getName() + <span class="string">"\" "</span>);</span><br><span class="line">            e.printStackTrace(System.err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完这个线程处理器之后来看看要如何实现这个线程处理器</p>
<ul>
<li><p>首先我们需要编写一个类实现 Thread.UncaughtExceptionHandler 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUncaughtExceptionHandler</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyUncaughtExceptionHandler</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">"已经成功捕获了异常。抛出异常的线程是："</span> + t.getName() + <span class="string">"。抛出的异常是："</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>其次我们需要将自己编写的异常处理器织入到主线程中，让它自动去处理子线程的异常。（这里使用开篇中「演示主线程中无法捕获子线程中的异常」的例子并作对比）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> MyUncaughtExceptionHandler(<span class="string">"线程异常处理器"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test(),<span class="string">"线程1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test(),<span class="string">"线程2"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test(),<span class="string">"线程3"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test(),<span class="string">"线程4"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"子线程抛出的异常"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main方法执行结果</span></span><br><span class="line">线程异常处理器已经成功捕获了异常。抛出异常的线程是：线程<span class="number">1</span>。抛出的异常是：java.lang.RuntimeException: 子线程抛出的异常</span><br><span class="line">线程异常处理器已经成功捕获了异常。抛出异常的线程是：线程<span class="number">2</span>。抛出的异常是：java.lang.RuntimeException: 子线程抛出的异常</span><br><span class="line">线程异常处理器已经成功捕获了异常。抛出异常的线程是：线程<span class="number">3</span>。抛出的异常是：java.lang.RuntimeException: 子线程抛出的异常</span><br><span class="line">线程异常处理器已经成功捕获了异常。抛出异常的线程是：线程<span class="number">4</span>。抛出的异常是：java.lang.RuntimeException: 子线程抛出的异常</span><br></pre></td></tr></table></figure>

<p>  至此，多线程异常处理器介绍完毕。</p>
</li>
</ul>
<hr>
<blockquote>
<p>插一句题外话，我认为本文的例子中很形象的向我们展示了线程的工作过程。线程在执行期间是互相不打扰的，各自干着各自的事情，这期间并不会互相影响。就像是一个团队在协同工作一样，每个人都是一个独立的线程，各自在完成自己的工作，并不会互相打扰。每个线程领取到自己的任务（run方法）之后，等待开始执行（调用start方法）。之后便是一直闷头干下去，直到把工作做完（run方法执行完毕）</p>
</blockquote>
<p>大家加油：）</p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>线程</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java并发】线程生命周期</title>
    <url>/posts/43936/</url>
    <content><![CDATA[<blockquote>
<p>本文将分析 Java 中线程的 <strong>6</strong> 种状态，以及线程的生命周期。</p>
</blockquote>
<a id="more"></a>

<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E7%BA%BF%E7%A8%8B%E7%9A%846%E4%B8%AA%E7%8A%B6%E6%80%81.png" alt="线程的6个状态"></p>
<blockquote>
<p>在这张图片中，包含了线程的所有状态以及每种状态之间的互相转换过程。其中箭头的指向是固定的，单箭头的指向则表明了两个线程的状态是不可逆的，一旦从一端到另一端之后就无法再回去原来的状态。</p>
</blockquote>
<h1 id="图片左边的三种状态"><a href="#图片左边的三种状态" class="headerlink" title="图片左边的三种状态"></a>图片左边的三种状态</h1><ol>
<li><p><strong>新创建（NEW）</strong><br>线程一经创建，也就是去 new 了一个 Thread 类之后，未调用 start 方法之前，这时的线程就是「新创建」的状态</p>
</li>
<li><p><strong>可运行（RUNNABLE）</strong><br>有些地方可能将「可运行」状态称之为「就绪」状态，这两者其实都是「RUNNABLE」状态<br>线程创建完毕之后，调用 start 方法开始，直到 run 方法中的代码执行完毕之前，如果没有其他的操作使得线程状态跑到上图右边的三种状态中去的话，线程将会一直处于「可运行」状态。</p>
<blockquote>
<p>值得注意的是，线程并没有一个「运行」的状态，就算是正在执行 run 方法的线程状态也是「可运行」状态。</p>
</blockquote>
</li>
<li><p><strong>已终止（TERMINATED）</strong><br>当 run 方法的代码执行完毕或者是抛出未处理的异常的时，线程就会处于「已终止」状态中。这个状态也是线程的最终状态，线程一旦进入了这个状态将无法再回到其他的状态中。</p>
</li>
<li><p><strong>代码演示</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新创建</span></span><br><span class="line">    System.out.println(thread.getState());  <span class="comment">// NEW</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 start 方法开始执行</span></span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(thread.getState());  <span class="comment">// RUNNABLE</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// run 方法执行中</span></span><br><span class="line">    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">    System.out.println(thread.getState());  <span class="comment">// RUNNABLE</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行完毕</span></span><br><span class="line">    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    System.out.println(thread.getState());  <span class="comment">// TERMINATED</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="图片右边的三种状态（阻塞状态）"><a href="#图片右边的三种状态（阻塞状态）" class="headerlink" title="图片右边的三种状态（阻塞状态）"></a>图片右边的三种状态（阻塞状态）</h1><ol>
<li><p><strong>被阻塞（BLOCKED）</strong><br>如果线程执行了一个被 synchronize 关键字修饰的代码块，并且这个代码块还处于其他线程的执行之中，这时调用的线程就会处于阻塞的状态，等待其他线程执行完毕后再执行。<br>等待的这个线程在等待的时间内就是处于 <strong>BLOCKED</strong> 状态。</p>
</li>
<li><p><strong>「等待(WAITING)」和「计时等待(TIMED_WAITING)」</strong><br>当线程阻塞时就会进入等待的状态。其中等待和计时等待非常好理解，有带 time 参数的等待就是计时等待，反之则是等待。</p>
</li>
<li><p><strong>代码演示</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runnable</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable();</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处睡眠 5ms 是因为将线程启动后首先是一个 RUNNABLE 的状态</span></span><br><span class="line">        <span class="comment">// 由于我的 CPU 的执行速度太快，thread1 还没有走到 syn 方法就被打印状态了，所以看不到效果</span></span><br><span class="line">        Thread.sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处的睡眠同上，主要也是一个 CPU 速度过快的问题</span></span><br><span class="line">        Thread.sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(thread1.getState()); <span class="comment">// TIMED_WAITING，因为正在执行 syn 方法中的 sleep(1000)</span></span><br><span class="line">        System.out.println(thread2.getState()); <span class="comment">// BLOCKED，因为 syn 方法正在被 thread1 执行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处睡眠 1500ms 是为了让 syn 方法执行到 wait() 中</span></span><br><span class="line">        Thread.sleep(<span class="number">1500</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(thread1.getState()); <span class="comment">// WAITING，因为此时 syn 方法已经执行到 wait() 了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        syn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>阻塞状态</strong><br>一般习惯而言，将图片右边的三种状态（BLOCKED、WAITING、TIMED_WAITING）都称之为阻塞状态，而不仅仅是 BLOCKED。</p>
</li>
</ol>
<hr>
<p>大家加油：）</p>
]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程</tag>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title>【数据结构】链表</title>
    <url>/posts/29990/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果上一篇文章实现的动态数组，由于底层任然是使用的静态数组，而不是真正意义上的<strong>动态数据结构</strong>的话。那么本文的链表则肯定是一个真真正正意义上的动态的数据结构了。</p>
<a id="more"></a>
<p>我还记得在读书时老师曾经给我们举过一个非常好的例子用于演示链表和数组在增删改查种各自的优缺点。在这里我把它分享出来给大家</p>
<blockquote>
<p>一个班级假设有50个学生，现在使用数组和链表来分别承载这50个学生。<br>然后模拟两种场景来分别对比这两种数据结构的优缺点<br><strong>数组：</strong>将这50个学生按照顺序排号，从0开始到49（这里模拟的是数组的下标）<br><strong><em>像这样 [0, 1, 2, 3, …, 49]</em></strong><br><strong>链表：</strong>将50个学生叫到操场排好队，每个学生去记住自己后面一个学生，记录排第一的同学（链表头）。<br><strong><em>像这样 (0) -&gt; (1) -&gt; (2) -&gt; (3) -&gt; … -&gt; (49)</em></strong><br>原谅我懒得画图。。。</p>
</blockquote>
<p><strong>场景一：</strong>老师在办公室想要叫某个学生到办公室去（模拟数据的查询）<br><strong>数组：</strong>直接在班级表种去查这个学生对应的序号，根据序号就可以很快速的找到这个学生。<br><strong>链表：</strong>由于没有序号，需要一个个学生去查找，首先找到链表头同学，比较是不是老师叫的学生，如果是则去办公室找老师。如果不是，则去找链表头同学所记住的后面一个同学，再进行对比。如果还不是则再去寻找这个同学记忆的下一个同学之后再进行比对，直到找到这个同学为止。</p>
<p><strong>场景二：</strong>班上来了一个新的插班生，插班生必须安排在班级的第一个位置（模拟数据的添加和删除）<br><strong>数组：</strong>由于每个学生的序号都是按照顺序排好的，所以不能直接插入在第一个学生之前，必须是要占用第一个学生的位置。所以要将全部的学生重新排号，插班生排0号，剩下的学生按照原来的号码依次加1往后排序。<br><strong>链表：</strong>让这个插班生去记住第一个同学也就是原理啊的链表头，再成为新的链表头。其他的学生完全不受影响。</p>
<p>通过以上两个场景的展现可以很清晰的看出来链表和数组各自的优缺点在哪里。链表增删快，而数组查询快。</p>
<h1 id="设计节点类"><a href="#设计节点类" class="headerlink" title="设计节点类"></a>设计节点类</h1><p>链表中的数据实际上是一个个的节点，在Java中使用一个节点类（Node）来表示。在节点类中有两个变量，一个是当前节点的值，另一个是指向下一个节点的指针。<br>由此每个节点中都有一个指向下一个节点的指针，最后一个节点指向下一个节点的指针就置为空。以此一节一节的链接起来，也就成了链表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 节点本身的值（支持泛型）</span></span><br><span class="line">    <span class="keyword">public</span> E e;</span><br><span class="line">    <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e, Node next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.e = e;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e)</span> </span>&#123; <span class="keyword">this</span>(e, <span class="keyword">null</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">null</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> e.toString(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="设计链表的成员变量和构造方法"><a href="#设计链表的成员变量和构造方法" class="headerlink" title="设计链表的成员变量和构造方法"></a>设计链表的成员变量和构造方法</h1><p>我们先来考虑一下怎么去设计链表类中的成员变量再来看看怎么设计构造函数</p>
<p>首先我们需要一个变量可以表示当前链表中共有多少个节点，也就是链表的大小。size变量是没跑了。<br>另外回顾一下刚刚的例子，在哪个班级中如果老师需要找到一个班级中的某个确定的学生时，第一个找的其实是链表头同学，根据链表头去一个个找下去直到找到为止。<br>所以在我们设计的链表类中需要一个头节点的指针，定义一个<strong>Node变量</strong>作为指针。</p>
<p>刚刚的例子中场景二来一个插班生我们将插班生插在了第一个位置。直接让插班生去记住原来的链表头再将链表头指向插班生。设想一下，如果是插入在链表的中间呢？<br>比如插入在第二个学生的位置。需要插班生去记住原来的第二个同学，再让原来的第一个同学把记忆的第二个同学换成插班生同学。也就是说如果是插入在中间的元素要多一步让前面的同学去记插班生同学，而插入在第一个则不需要。</p>
<p>针对上面的情况我们可以设置一个虚拟的头节点来解决这个问题。这个虚拟的节点来指向我们链表中真正的第一个节点，对外呢，屏蔽这个节点的存在。故此我们将上面决定要定义的<strong>Node变量</strong>改成<strong>dummyHead</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">private</span> Node dummyHead; <span class="comment">// 虚拟头节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dummyHead = <span class="keyword">new</span> Node(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方便用户传入一个数组将其转换成链表的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(E[] arrayE)</span> </span>&#123;</span><br><span class="line">    dummyHead = <span class="keyword">new</span> Node(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    size = arrayE.length;</span><br><span class="line"></span><br><span class="line">    Node cur = dummyHead;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arrayE.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        cur.next = <span class="keyword">new</span> Node(arrayE[i], cur.next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设计两个方便使用的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> size == <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>

<h1 id="链表中插入元素"><a href="#链表中插入元素" class="headerlink" title="链表中插入元素"></a>链表中插入元素</h1><p>我们来研究一下前面的例子是怎么在一个班级中插入插班生的。</p>
<blockquote>
<p>首先，得要有一个插班生，这个不用想肯定是必须的，好了，插入功能核心代码的<strong>第一步</strong>也就出来了。<br>然后我们得要去找到插班生要插入的位置，在这里呢我们虚拟一个index（下标）的概念出来，方便用户指定要插入的位置，核心功能的<strong>第二步</strong>也就出来了。<br>找到位置也有插班生之后的问题就是要把插班生插入到班级里面去啦，这个事情要怎么做呢。<br>比方说我现在是要插入到第二个位置去，那么我需要先让插班生去记忆原来的第二个位置的同学，这也是<strong>第三步</strong>。<br>然后让第一个同学不要去记原来的第二个同学了，换成是插班生同学，<strong>第四步</strong>。<br>到此为止，这个插入的动作就完成了。</p>
</blockquote>
<p>将上面的各个步骤以程序的方式重新梳理一遍<br>第一步：创建一个新的节点 <code>new Node()</code><br>第二步：使用一个for循环找到要插入位置的前一个节点和后一个节点<br>第三步：将第一步创建出来的节点的<code>next</code>指针指向第二步找出来的后一个节点<br>第四步：将第二步找出来的前一个节点的<code>next</code>指针指向第一步创建的节点</p>
<p>将上面的逻辑组织一下换成Java语言</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下标的校验，不属于插入的核心代码</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"index "</span> + index + <span class="string">" 不合法, 当前size = "</span> + size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一步</span></span><br><span class="line">    Node node= <span class="keyword">new</span> Node(e);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步：</span></span><br><span class="line">    <span class="comment">// 使用一个prev变量去作为一个中间量去寻找要插入的节点位置</span></span><br><span class="line">    <span class="comment">// 这里的prev就是前一个节点，由于还没有插入，所以prev.next就是要插入的后一个节点</span></span><br><span class="line">    Node prev = dummyHead;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        prev = prev.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三步</span></span><br><span class="line">    node.next = prev.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第四步</span></span><br><span class="line">    prev.next = node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护一下size变量</span></span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上便是添加操作的方法，但这还不是最好。</p>
<p>上面的代码虽说是完成了这个添加动作的逻辑，也能够顺顺利利的运行起来，但这还不够优雅。<br>实际上我们可以将第一步、第三步和第四步合并成一行代码<br>创建一个新的节点直接将<code>prev.next</code>赋值给新节点的<code>next</code>，再直接赋值给<code>prev.next</code>。<br>像下面这个样子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"index "</span> + index + <span class="string">" 不合法, 当前size = "</span> + size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node prev = dummyHead;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        prev = prev.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原来的第一步、第二步和第四步</span></span><br><span class="line">    prev.next = <span class="keyword">new</span> Node(e, prev.next);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>插一句题外话<br>其实编写程序，就是像上面这样子一步一步去考虑出这个程序核心代码的步骤。<br>然后再把这个简单的按照程序逻辑梳理一遍，再开始实际编码。也恰恰是这两步才是最关键的，而不是编码，有了梳理完的逻辑实际编码起来码随心动倒还是个挺舒服的过程。<br>最后再审视一遍自己写出来的代码，看看有没有地方可以改进，可以写的更加的优雅一些</p>
</blockquote>
<hr>
<h1 id="删除链表中的元素"><a href="#删除链表中的元素" class="headerlink" title="删除链表中的元素"></a>删除链表中的元素</h1><p>删除元素的话也就是添加元素的逆向操作，这里比如需要在链表中删除4号同学，那么直接让3号同学去记忆5号同学，这样一来原来的5号同学就变成了4号同学。<br>以此类推，4号同学就成功的在队伍中退出了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到要删除元素的前一个元素</span></span><br><span class="line">    Node prev = dummyHead;</span><br><span class="line">    <span class="keyword">while</span>(!prev.next.e.equals(e)) &#123;</span><br><span class="line">        prev = prev.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将要删除元素前一个元素的指针直接指向要删除元素的后一个元素</span></span><br><span class="line">    prev.next = prev.next.next;</span><br><span class="line"></span><br><span class="line">    size--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>【随笔01】Linux 切换阿里云 yum 源</title>
    <url>/posts/40578/</url>
    <content><![CDATA[<blockquote>
<p>记录点滴，分享世界。Hello World！：）</p>
</blockquote>
<a id="more"></a>

<p><a href="https://developer.aliyun.com/mirror" target="_blank" rel="noopener" title="阿里云官方文档">阿里云官方文档</a><br>百度搜索「阿里巴巴开源镜像站」也可以搜到阿里云的官方文档。</p>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20200709204009.png" alt="20200709204009"></p>
<h3 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h3><ol>
<li><p><strong>备份</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo.backup</span><br></pre></td></tr></table></figure></li>
<li><p><strong>下载新的 CentOS-Base.repo 到 /etc/yum.repos.d/</strong></p>
<p> <strong>CentOS 6</strong></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-6.repo</span><br></pre></td></tr></table></figure>
<p> 或者</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-6.repo</span><br></pre></td></tr></table></figure>

<p> <strong>CentOS7</strong></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repo</span><br></pre></td></tr></table></figure>
<p> 或者</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repo</span><br></pre></td></tr></table></figure>

<p> <strong>CentOS8</strong></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-8.repo</span><br></pre></td></tr></table></figure>
<p> 或者</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-8.repo</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>运行 <code>yum makecache</code> 生成缓存</strong></p>
</li>
</ol>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>Linux</tag>
        <tag>阿里云</tag>
        <tag>yum</tag>
      </tags>
  </entry>
  <entry>
    <title>【随笔02】Linux 安装 Nginx</title>
    <url>/posts/62048/</url>
    <content><![CDATA[<blockquote>
<p>记录点滴，分享世界。Hello World！：）</p>
</blockquote>
<a id="more"></a>

<p>首先需要安装 Nginx 的依赖包</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum -y install gcc pcre-devel zlib-devel openssl openssl-devel</span><br></pre></td></tr></table></figure>

<h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><h4 id="1-下载-Nginx-到-Linux-系统中"><a href="#1-下载-Nginx-到-Linux-系统中" class="headerlink" title="1.下载 Nginx 到 Linux 系统中"></a>1.下载 Nginx 到 Linux 系统中</h4><p>在 <a href="https://nginx.org/download/" target="_blank" rel="noopener">Nginx官网</a> 中选择自己合适的压缩包后使用 wget 下载。<br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20200708203138.png" alt="20200708203138"></p>
<h4 id="2-解压安装包"><a href="#2-解压安装包" class="headerlink" title="2.解压安装包"></a>2.解压安装包</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf nginx-1.9.9.tar.gz</span><br></pre></td></tr></table></figure>
<p>解压完成之后下载部分就结束了，可以进行安装</p>
<h4 id="3-编译"><a href="#3-编译" class="headerlink" title="3.编译"></a>3.编译</h4><p>首先进入 Nginx 的安装目录下，也就是刚刚解压的目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;nginx-1.9.9</span><br></pre></td></tr></table></figure>

<p>直接编译，运行 <code>configure</code> 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure</span><br></pre></td></tr></table></figure>

<p>如果配置 https 访问则需要在编译时添加 <code>http_v2_module</code> 和 <code>http_ssl_module</code> 这两个模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure --with-http_v2_module --with-http_ssl_module</span><br></pre></td></tr></table></figure>

<h4 id="4-安装"><a href="#4-安装" class="headerlink" title="4.安装"></a>4.安装</h4><p>直接在 Nginx 的安装目录中执行以下两个命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>至此，Nginx 就算是安装成功了，进入 <code>sbin</code> 目录下执行 <code>./ngnix</code> 就可以将 Nginx 的服务成功启动起来。<br>在有些环境下可能会报两个日志文件找不到，直接创建这两个文件即可</p>
<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>编辑 <code>/etc/profile</code> 文件，在最后添加以下代码即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin</span><br></pre></td></tr></table></figure>
<p>其中，要将 Nginx 的安装目录改为刚刚安装的目录</p>
<h4 id="5-常用命令"><a href="#5-常用命令" class="headerlink" title="5.常用命令"></a>5.常用命令</h4><p>启动 Nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure>
<p>停止 Nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -s stop</span><br></pre></td></tr></table></figure>
<p>重启 Nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>

<h2 id="6-常用配置"><a href="#6-常用配置" class="headerlink" title="6.常用配置"></a>6.常用配置</h2><p>Nginx 的配置文件都放在 conf 目录下，其中最重要的就是 <code>nginx.conf</code> 配置文件。</p>
<p>为了使配置文件看起来更加舒服一些，我们选择把一些站点配置写到外面来，而不是直接写入 <code>nginx.conf</code> 文件中</p>
<p>在 conf 文件夹下创建一个 hosts 文件夹，之后将一些站点配置以 域名.conf 的形式写成新的文件保存在 hosts 文件夹中</p>
<p>之后在 nginx.conf 文件的 http 的大括号内引入自己写的配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include hosts&#x2F;*.conf;</span><br></pre></td></tr></table></figure>
<p>注意最后面要加分号 <code>;</code> </p>
<p>以上仅为本人习惯</p>
<h4 id="配置静态网站"><a href="#配置静态网站" class="headerlink" title="配置静态网站"></a>配置静态网站</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    listen 443 ssl http2;</span><br><span class="line">    server_name 你的域名;</span><br><span class="line"></span><br><span class="line">    ssl_certificate &quot;ssl证书 fullchain.crt 文件的位置&quot;;</span><br><span class="line">    ssl_certificate_key &quot;ssl证书 private.pem 文件的位置&quot;;</span><br><span class="line">    ssl_protocols TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    ssl_session_cache shared:SSL:10m;</span><br><span class="line">    ssl_session_timeout 10m;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root 要转发的目录;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>大家加油：）</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>Linux</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>【随笔03】IDEA多线程调试</title>
    <url>/posts/29198/</url>
    <content><![CDATA[<blockquote>
<p>记录点滴，分享世界。Hello World！：） </p>
</blockquote>
<a id="more"></a>

<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20200710230014.png" alt="20200710230014"></p>
<ol>
<li><strong>在以上代码断点处点击鼠标右键</strong></li>
</ol>
<p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20200710230202.png" alt="20200710230202"></p>
<ol start="2">
<li><p><strong>选择 Thread 后点击 Done</strong><br>All 在进入断点后会将整个 JVM 虚拟机停下来<br>Thread 仅会停止进入断点的线程</p>
</li>
<li><p><strong>接着选择 debug 模式启动 main 方法</strong><br>进入断点后的 debug 窗口如下<br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20200710230742.png" alt="20200710230742">在 frames 标签中可以通过下拉列表选择要执行的线程，接着就像平时一样一步一步的让代码走下去就可以啦</p>
</li>
<li><p><strong>查看线程状态</strong><br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20200710232211.png" alt="20200710232211"><br>首先点击到 Tread 类中的 run 方法里面去，再点击 Debugger Console 标签栏最右边的像一个计算器一样的哪个按钮，弹出一个 Evaluate 框出来可以调用当前线程的一些方法，其中 <code>getState()</code> 方法就可以查看线程状态啦</p>
</li>
</ol>
<hr>
<p>大家加油：）</p>
]]></content>
  </entry>
  <entry>
    <title>【随笔04】资料链接</title>
    <url>/posts/32657/</url>
    <content><![CDATA[<blockquote>
<p>记录点滴，分享世界。Hello，World！</p>
</blockquote>
<a id="more"></a>

<h1 id="Redis资料相关连接"><a href="#Redis资料相关连接" class="headerlink" title="Redis资料相关连接"></a>Redis资料相关连接</h1><p><a href="https://redis.io" target="_blank" rel="noopener">Redis官网</a><br><a href="https://redis.cn" target="_blank" rel="noopener">Redis中文网</a><br><a href="https://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="noopener">Redis菜鸟教程</a><br><a href="http://download.redis.io/releases/" target="_blank" rel="noopener">Redis下载地址（Linux）</a><br><a href="https://github.com/tporadowski/redis/releases" target="_blank" rel="noopener">Redis下载地址（Window）</a></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
</search>
