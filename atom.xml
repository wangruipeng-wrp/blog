<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>知更</title>
  
  <subtitle>知道要更新，知道要进步</subtitle>
  <link href="https://www.wrp.cool/atom.xml" rel="self"/>
  
  <link href="https://www.wrp.cool/"/>
  <updated>2022-09-09T11:22:36.385Z</updated>
  <id>https://www.wrp.cool/</id>
  
  <author>
    <name>码小瑞</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Security</title>
    <link href="https://www.wrp.cool/posts/28582/"/>
    <id>https://www.wrp.cool/posts/28582/</id>
    <published>2022-09-06T03:38:08.000Z</published>
    <updated>2022-09-09T11:22:36.385Z</updated>
    
    <content type="html"><![CDATA[<p>关于 Spring Security 的文章网上有很多，B站也有很多教程，我都看过一些，但感觉对这部分的知识还不是很牢固。网上的大部分文章主要都是从后端的用户认证开始讲起的，一上来就是这些比较偏向实用部分的内容我觉得不是很好理解，还有很多巨长的类名方法名等等，这并不是在说网上的这些文章写的不好，毕竟本文也是一篇前人栽树，后人乘凉的文章。但是写这篇文章的初衷是想要从一个简单的小例子入手，解释清楚那些巨长的类名方法名都是干嘛的，应该怎么使用。</p><p>Spring Security 的一些介绍就不多说了，直接一个小 demo 走起，这个 demo 力争简洁，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入账号：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入密码：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> sc.next();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 开始认证    </span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">AuthenticationManager</span> <span class="variable">am</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SampleAuthenticationManager</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1、封装一个 UsernamePasswordAuthenticationToken 对象</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Authentication</span> <span class="variable">unAuth</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(username, password);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、经过 AuthenticationManager 的认证，如果认证失败会抛出一个 AuthenticationException 错误</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Authentication</span> <span class="variable">auth</span> <span class="operator">=</span> am.authenticate(unAuth);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、将这个认证过的 Authentication 填入 SecurityContext 里面</span></span><br><span class="line">            SecurityContextHolder.getContext().setAuthentication(auth);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;认证失败：&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 SecurityContext 中取出 Authentication</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Authentication</span> <span class="variable">auth</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        System.out.println(<span class="string">&quot;认证成功！&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;输入的账号：&quot;</span> + auth.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;输入的密码：&quot;</span> + auth.getCredentials());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现一个简单 AuthenticationManager 用于认证</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SampleAuthenticationManager</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键认证部分</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Authentication <span class="title function_">authenticate</span><span class="params">(Authentication auth)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> auth.getName();</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> (String) auth.getCredentials(); <span class="comment">// getCredentials 返回的是密码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (username == <span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(username))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadCredentialsException</span>(<span class="string">&quot;账号不能为空&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (password == <span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(password))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadCredentialsException</span>(<span class="string">&quot;密码不能为空&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 认证成功，创建认证成功对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(auth.getName(), auth.getCredentials());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring Security 主要的两个功能是认证和鉴权。这两个功能组合起来就能完成用户登录的需求，也就是一个系统中最基础最重要的模块。根据不同系统的需求，用户认证的工作可能会很繁琐。具体的认证步骤由程序员自行编写，Spring Security 的策略是把每个认证步骤串联起来成为一整个认证流程。上面的这个 demo 仅仅是一个简单的账号密码判空操作而已。主要是说明了怎么编写认证步骤。</p><h1 id="重要组件"><a href="#重要组件" class="headerlink" title="重要组件"></a>重要组件</h1><ul><li>Authentication：认证对象接口，定义了认证对象的数据形式。</li><li>AuthenticationManager：认证工作的上层接口，用于校验 <code>Authentication</code>，返回一个认证完成后的 <code>Authentication</code> 对象。</li><li>SecurityContext：上下文对象，<code>Authentication</code> 对象会放在里面。&#x2F;&#x2F; TODO 怎么让 Authentication 到处流通的。</li><li>SecurityContextHolder：用于拿到上下文对象的静态工具类。</li></ul><h2 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h2><p>Authentication 只是定义了一种在 Spring Security 进行认证过的数据的数据形式应该是怎么样的，要有权限，要有密码，要有身份信息，要有额外信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Authentication</span> <span class="keyword">extends</span> <span class="title class_">Principal</span>, Serializable &#123;</span><br><span class="line">    <span class="comment">// 获取用户权限列表</span></span><br><span class="line">    Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities();</span><br><span class="line">    <span class="comment">// 获取证明用户认证的信息，通常情况下获取到的是密码等信息。</span></span><br><span class="line">    Object <span class="title function_">getCredentials</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 获取用户的额外信息，（这部分信息可以是我们的用户表中的信息）。</span></span><br><span class="line">    Object <span class="title function_">getDetails</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 获取用户身份信息，在未认证的情况下获取到的是用户名，在已认证的情况下获取到的是 UserDetails。</span></span><br><span class="line">    Object <span class="title function_">getPrincipal</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 获取当前 Authentication 是否已认证。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAuthenticated</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 设置当前 Authentication 是否已认证（true or false）。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setAuthenticated</span><span class="params">(<span class="type">boolean</span> var1)</span> <span class="keyword">throws</span> IllegalArgumentException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AuthenticationManager"><a href="#AuthenticationManager" class="headerlink" title="AuthenticationManager"></a>AuthenticationManager</h2><p><code>AuthenticationManager</code> 定义了一个认证方法，它将一个未认证的 <code>Authentication</code> 传入，返回一个已认证的 <code>Authentication</code>，默认使用的实现类为：<code>ProviderManager</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AuthenticationManager</span> &#123;</span><br><span class="line">    <span class="comment">// 认证方法</span></span><br><span class="line">    Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span> </span><br><span class="line">        <span class="keyword">throws</span> AuthenticationException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SecurityContext"><a href="#SecurityContext" class="headerlink" title="SecurityContext"></a>SecurityContext</h2><p>上下文对象，认证后的数据就放在这里面，这个接口里面只有两个方法，其主要作用就是 get or set <code>Authentication</code>。接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SecurityContext</span> <span class="keyword">extends</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    Authentication <span class="title function_">getAuthentication</span><span class="params">()</span>; <span class="comment">// 获取Authentication对象</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setAuthentication</span><span class="params">(Authentication authentication)</span>; <span class="comment">// 放入Authentication对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SecurityContextHolder"><a href="#SecurityContextHolder" class="headerlink" title="SecurityContextHolder"></a>SecurityContextHolder</h2><p>可以说是 <code>SecurityContext</code> 的工具类，用于 get or set or clear <code>SecurityContext</code>，默认会把数据都存储到当前线程中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityContextHolder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clearContext</span><span class="params">()</span> &#123;</span><br><span class="line">        strategy.clearContext(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SecurityContext <span class="title function_">getContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> strategy.getContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setContext</span><span class="params">(SecurityContext context)</span> &#123;</span><br><span class="line">        strategy.setContext(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>由这四个组件组成的认证流程就是：</p><ol><li>将登录请求的身份信息封装成未认证的 <code>Authentication</code></li><li>将未认证的 <code>Authentication</code> 交由 <code>AuthenticationManager</code> 实行认证</li><li><code>AuthenticationManager</code> 认证完成返回认证后的 <code>Authentication</code></li><li>将认证过的 <code>Authentication</code> 放入 <code>SecurityContext</code></li></ol><p>上面的这四个组件就是 Spring Security 当中最重要的几个组件，Spring Security 其他的内容也是围绕这几个组件展开的。</p><h1 id="ProviderManager"><a href="#ProviderManager" class="headerlink" title="ProviderManager"></a>ProviderManager</h1><p>ProviderManager 是 AuthenticationManager 的默认实现类，由它衍生出来了 AuthenticationProvider 接口。</p><p>原来的一个 AuthenticationManager 只做一次认证工作，但是 ProviderManager 把多个认证工作放在一个集合中，遍历取出每个认证对象一次次做认证工作，只要有一次通过了，就认为这次认证是成功的。在 ProviderManager 中把认证工作封装成了 AuthenticationProvider。</p><div class="note default flat"><p><strong>AuthenticationProvider：</strong></p></div><p>认证提供者，服务于 ProviderManager 类，由实现了这个接口的对象组成一个集合，在 ProviderManager 中遍历取出认证 Authentication。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AuthenticationProvider</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 认证</span></span><br><span class="line">    Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span></span><br><span class="line">            <span class="keyword">throws</span> AuthenticationException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否支持当前的 Authentication 对象</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class&lt;?&gt; authentication)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProviderManager 这个类的代码比较复杂，摘一些跟它认证流程有关的代码出来看看，以下代码在源码的基础上有做改动，主要是为了方便看一些</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 构造方法之一，传入一个个的 AuthenticationProvider 对象</span></span><br><span class="line"><span class="comment"> * 待会就拿这些对象来认证。</span></span><br><span class="line"><span class="comment"> * parent 对象传入 null，parent 相当于是一个兜底的 AuthenticationManager，</span></span><br><span class="line"><span class="comment"> * 如果所有的 AuthenticationProvider 认证都没通过，则使用 parent 做一次认证。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ProviderManager</span><span class="params">(AuthenticationProvider... providers)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(Arrays.asList(providers), (AuthenticationManager)<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Authentication</span>&gt; toTest = authentication.getClass();</span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">parentResult</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次取出 provider 认证 authentication</span></span><br><span class="line">    <span class="keyword">for</span>(AuthenticationProvider provider : <span class="built_in">this</span>.getProviders()) &#123;</span><br><span class="line">        <span class="comment">// provider 不能支持 authentication，直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> (!provider.supports(toTest))  <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用 provider 进行认证</span></span><br><span class="line">            result = provider.authenticate(authentication);</span><br><span class="line">            <span class="comment">// 认证通过</span></span><br><span class="line">            <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.copyDetails(authentication, result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InternalAuthenticationServiceException | AccountStatusException | AuthenticationException e) &#123;</span><br><span class="line">            <span class="comment">// 某次异常处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// providers 认证失败，尝试使用 parent 认证</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.parent != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = parentResult = <span class="built_in">this</span>.parent.authenticate(authentication);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ProviderNotFoundException | AuthenticationException e) &#123;</span><br><span class="line">            <span class="comment">// 异常处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 认证成功，擦除密码信息</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.eraseCredentialsAfterAuthentication &amp;&amp; result <span class="keyword">instanceof</span> CredentialsContainer) &#123;</span><br><span class="line">            ((CredentialsContainer)result).eraseCredentials();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发布认证成功事件</span></span><br><span class="line">        <span class="keyword">if</span> (parentResult == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.eventPublisher.publishAuthenticationSuccess(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// 执行至此，说明 providers 和 parent 都没认证成功，包装异常信息抛出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码如果觉得比较复杂也可以不看，只需知道 ProviderManager 类的认证流程即可。</p><h1 id="DaoAuthenticationProvider"><a href="#DaoAuthenticationProvider" class="headerlink" title="DaoAuthenticationProvider"></a>DaoAuthenticationProvider</h1><p>DaoAuthenticationProvider 就是 AuthenticationProvider 的最常实现类，顾名思义，Dao 正是数据访问层的缩写，也暗示了这个身份认证器的实现思路。</p><p>按照我们最直观的思路，怎么去认证一个用户呢？</p><p>用户前台提交了用户名和密码，而数据库中保存了用户名和密码，认证便是负责比对同一个用户名，提交的密码和保存的密码是否相同便是了。</p><p>在 Spring Security 中。提交的用户名和密码，被封装成了 UsernamePasswordAuthenticationToken，而根据用户名加载用户的任务则是交给了 UserDetailsService。</p><h2 id="UserDetailsService"><a href="#UserDetailsService" class="headerlink" title="UserDetailsService"></a>UserDetailsService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line">    <span class="comment">// 查询用户，去哪里查询自己实现，一般是数据库。</span></span><br><span class="line">    UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要我们自己编写一个类实现 UserDetailsService 接口，在数据库中查询出登录的用户，将其包装成 UserDetails 对象返回。</p><p>这个接口的实现类写完需要在 Spring Security 配置中注册我们自己写的实现类，否则 Spring Security 是不知道你实现了这个接口的。</p><h2 id="UserDetails"><a href="#UserDetails" class="headerlink" title="UserDetails"></a>UserDetails</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDetails</span> <span class="keyword">extends</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// 当前认证用户的权限列表</span></span><br><span class="line">    Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities();</span><br><span class="line">    <span class="comment">// 当前认证用户密码</span></span><br><span class="line">    String <span class="title function_">getPassword</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 当前认证用户用户名</span></span><br><span class="line">    String <span class="title function_">getUsername</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 账户是否没过期</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 账户是否没被锁定（可以用来做黑名单）</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 账户凭据是否没过期</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 账户是否启用</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是一个接口，用来包装对应的数据库查出来的我们自己的 User 对象，包装完之后交给 Spring Security 去判断当前认证的用户账号情况。</p><h2 id="DaoAuthenticationProvider-比对密码"><a href="#DaoAuthenticationProvider-比对密码" class="headerlink" title="DaoAuthenticationProvider 比对密码"></a>DaoAuthenticationProvider 比对密码</h2><p>以下代码从源码中来，又跟源码不大一样，为了好看一些，有做删减。</p><p><strong>先从数据库加载用户：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> UserDetails <span class="title function_">retrieveUser</span><span class="params">(String username, UsernamePasswordAuthenticationToken authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">loadedUser</span> <span class="operator">=</span> <span class="built_in">this</span>.getUserDetailsService().loadUserByUsername(username);</span><br><span class="line">        <span class="keyword">if</span> (loadedUser == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 找不到直接报错，</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> loadedUser;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UsernameNotFoundException | InternalAuthenticationServiceException | Exception e) &#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>比对密码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">additionalAuthenticationChecks</span><span class="params">(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    <span class="keyword">if</span> (authentication.getCredentials() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 前台没传密码，直接报错</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">presentedPassword</span> <span class="operator">=</span> authentication.getCredentials().toString();</span><br><span class="line">        <span class="comment">// 比对密码，passwordEncoder 是需要注册的密码器。</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.passwordEncoder.matches(presentedPassword, userDetails.getPassword())) &#123;</span><br><span class="line">            <span class="comment">// 密码不匹配，直接报错</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PasswordEncoder：</strong>是一个接口，用来定义一些密码器的，Spring Security 提供了多种不同的密码策略，需要选择一种密码策略，在配置文件中注册。通常使用 BCryptPasswordEncoder。</p><div class="note default flat"><p><strong>小结：</strong></p></div><ol><li>顶层接口，一切的开始：AuthenticationManager，用于管理认证的每一个环节。</li><li>Authentication：认证对象，所有的一切都是为它服务的，放在 SecurityContext 中传来传去的。每一个认证环节的开始和结束都是它。</li><li>ProviderManager：AuthenticationManager 最重要的实现类，那也就是最重要的一个认证环节。</li><li>ProviderManager 把自己的认证工作委托给了多个 AuthenticationProvider，只要有一个认证成功了就认为是成功的。</li><li>AuthenticationManager 和 ProviderManager 的职责是不同的，主要就是它们的认证策略不同。</li><li>具体的登录密码比对工作交给了 DaoAuthenticationProvider，这也是 ProviderManager 最重要的一个 AuthenticationProvider。</li><li>通常需要实现 UserDetailsService 和 UserDetails，DaoAuthenticationProvider 根据这两个对象来校验密码。</li></ol><p>写这篇文章的目的主要是学习 Spring Security 的过程中有很多的不理解的地方，很多类名都特别长，长的又差不多，感觉很难理解。所以想要写一篇文章来帮助自己巩固这部分的知识，这篇文章的一些内容也是在网上其他文章中出现过的。</p><p>推荐一个 GitHub 上的一个 Spring Security 的仓库，写的真的不错：<a href="https://github.com/rookie-ricardo/spring-boot-learning-demo">向大佬学习</a></p><hr><p>本来鉴权部分应该是要单独的写一篇文章来总结的，但是看了看 Spring Security 的动态鉴权，看是看的明白个大概，就是道行太浅还用不上这么高级的东西。这里就先简单的介绍一下简单的鉴权方案吧。</p><p>有需要动态鉴权的同学也可以先看看这两篇文章，顺带一提，大佬写的文章真的不错。</p><ul><li><a href="https://zhuanlan.zhihu.com/p/365515214">Spring Security 鉴权流程</a></li><li><a href="https://juejin.cn/post/6847902222668431368">SpringSecurity动态鉴权流程解析</a></li></ul><p><strong>鉴权策略：</strong></p><ol><li>在 SecurityConfig 配置文件中手动开启 <code>@EnableGlobalMethodSecurity(prePostEnabled = true)</code></li><li>在 UserDetailService.loadUserByUsername 方法中查询出用户所具有的全部权限</li><li>将权限封装在 UserDetail.getAuthorities() 方法中供 Spring Security 获取</li><li>在每个需要授权的 API 上加上 <code>@PreAuthorize(&quot;hasAuthority(&#39;权限值&#39;)&quot;)</code> 注解</li><li>如果用户权限列表有该接口对应权限值就能访问对应接口</li></ol><hr><blockquote><p><strong>前人栽树：</strong></p><ul><li><a href="https://zhuanlan.zhihu.com/p/365513384">Spring Security 认证流程</a></li><li><a href="https://juejin.cn/post/6846687598442708999">SpringSecurity+JWT认证流程解析</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于 Spring Security 的文章网上有很多，B站也有很多教程，我都看过一些，但感觉对这部分的知识还不是很牢固。网上的大部分文章主要都是从后端的用户认证开始讲起的，一上来就是这些比较偏向实用部分的内容我觉得不是很好理解，还有很多巨长的类名方法名等等，这并不是在说网</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JWT 工具类封装</title>
    <link href="https://www.wrp.cool/posts/64951/"/>
    <id>https://www.wrp.cool/posts/64951/</id>
    <published>2022-09-05T11:04:10.000Z</published>
    <updated>2022-09-08T15:30:33.011Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1><p>JWT（Json Web Token）是一种用于用户认证的技术，前端携带 JWT 访问后端服务器，后端服务器可以解析 JWT 判断是否由本服务器签发，以及解析出一些简单的数据后可以拿到本次请求的用户。引入 JWT 主要为了解决传统 session 验证的弊端，session 认证的弊端：</p><ol><li>Session 保存在服务器中，用户数增加对服务器开销造成一定压力。</li><li>Session 保存在服务器物理内存中，对分布式不友好。</li><li>依赖 Cookie，对于非浏览器的客户端、手机移动端等不适用。</li><li>客户端 Cookie 泄漏会导致服务器不安全。</li><li>由于依赖 Cookie，所以无法跨域。</li></ol><p>JWT 的优势：</p><ol><li>简洁、数据量小、传输速度快</li><li>存储在客户端，原则上是跨语言的，支持任何 web 形式。</li><li>不依赖 Cookie 和 Session，对分布式友好。</li><li>容易跨域，对单点登录友好。</li><li>对手机移动端适用。</li></ol><p>JWT 认证流程图：</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/JWT%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B.png" alt="JWT认证流程"></p><h2 id="JWT-结构"><a href="#JWT-结构" class="headerlink" title="JWT 结构"></a>JWT 结构</h2><p>JWT 分成三个部分，每个部分都是一个字符串，中间由 <code>.</code> 隔开。</p><ul><li>Header：头部，标记加密的算法</li><li>Payload：负载，存放具体数据</li><li>Signature：签名，由 “Header + Payload + 服务器本地密钥” 经 MD5 加密后的值。</li></ul><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>Header 是一个描述 JWT 元数据的 JSON 对象，alg 属性表示签名使用的算法，默认为 HMAC SHA256（写为HS256）；typ 属性表示令牌的类型，JWT 令牌统一写为 JWT。最后，使用 Base64 URL 算法将上述 JSON 对象转换为字符串保存。一般是下面这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h3><p>有效载荷部分，是 JWT 的主体内容部分，也是一个 JSON 对象，包含需要传递的数据，可以存放自定义数据。JWT 指定七个默认字段供选择</p><ol><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ol><p>注意：此部分内容未加密，不能存放敏感信息。</p><h3 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h3><p>signature 是签证信息，该签证信息是通过 <code>header</code> 和 <code>payload</code>，加上 <code>secret</code>，通过算法加密生成。</p><h1 id="JWTUtil"><a href="#JWTUtil" class="headerlink" title="JWTUtil"></a>JWTUtil</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入 JWT 依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.auth0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>java-jwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.auth0.jwt.JWT;</span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.JWTCreator;</span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.algorithms.Algorithm;</span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.exceptions.JWTDecodeException;</span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.interfaces.DecodedJWT;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JWTUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可从 application.yml 中获取</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">SECRET</span> <span class="operator">=</span> <span class="string">&quot;maxiaorui&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成用户 Token</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map     存放在 token 的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expires 过期时间（单位：秒）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generateUserToken</span><span class="params">(Map&lt;String, String&gt; map, Integer expires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> JWTCreator.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> JWT.create();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// payload</span></span><br><span class="line">        map.forEach(builder::withClaim);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定过期时间</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">expiresAt</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        expiresAt.add(Calendar.SECOND, expires);</span><br><span class="line">        builder.withExpiresAt(expiresAt.getTime());</span><br><span class="line"></span><br><span class="line"><span class="comment">//        builder.withIssuer(&quot;issuer&quot;);                       // 签发人</span></span><br><span class="line"><span class="comment">//        builder.withSubject(&quot;subject&quot;);                     // 主题</span></span><br><span class="line"><span class="comment">//        builder.withAudience(&quot;audience1&quot;, &quot;audience2&quot;);     // 受众</span></span><br><span class="line"><span class="comment">//        builder.withNotBefore(new Date());                  // 生效时间</span></span><br><span class="line"><span class="comment">//        builder.withIssuedAt(new Date());                   // 签发时间</span></span><br><span class="line"><span class="comment">//        builder.withJWTId(&quot;jti&quot;);                           // 编号</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成原始 Token，此处可对 payload 数据做混淆</span></span><br><span class="line">        <span class="keyword">return</span> builder.sign(Algorithm.HMAC256(SECRET));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验用户 Token</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token 用户 Token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> DecodedJWT</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DecodedJWT <span class="title function_">verify</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(token))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JWTDecodeException</span>(<span class="string">&quot;Token 无效&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果在生成 Token 的时候做了混淆此处应该解析混淆</span></span><br><span class="line">        <span class="keyword">return</span> JWT.require(Algorithm.HMAC256(SECRET)).build().verify(token);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 DecodedJWT 中解析 payload：<code>DecodedJWT.getClaims();</code></p><p>解析可能出现的异常：</p><ul><li>JWTDecodeException：header、payload 被修改会出现的异常</li><li>SignatureVerificationException：签名不匹配异常</li><li>TokenExpiredException：令牌过期异常</li><li>AlgorithmMismatchException：算法不匹配异常</li></ul><hr><p>说句题外话，有没有发现 JWT 的前面总是会加 <code>Bearer</code> 这个单词？？？</p><p>那么加了能干嘛呢，不加行不行呢？？</p><p>别问，问就是规范，至于什么规范？<a href="https://www.google.com/">谷歌</a>、<a href="https://www.bing.com/">必应</a>、<a href="https://www.baidu.com/">百度</a></p><blockquote><p><strong>前人栽树：</strong></p><ul><li><a href="https://cnodejs.org/topic/5b0c4a7b8a4f51e140d942fc">一篇文章告诉你JWT的实现原理</a></li><li><a href="https://www.cnblogs.com/johnvwan/p/15557287.html">JWT分布式场景应用解析 </a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">关于 JWT 的介绍包括简介、原理、使用场景等网上有很多文章写的都非常好，本文不会过多赘述，主要记录 JWT 工具类的封装。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Java并发：volatile</title>
    <link href="https://www.wrp.cool/posts/63338/"/>
    <id>https://www.wrp.cool/posts/63338/</id>
    <published>2022-08-25T07:26:42.000Z</published>
    <updated>2022-08-26T09:26:51.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="volatile-的特性"><a href="#volatile-的特性" class="headerlink" title="volatile 的特性"></a>volatile 的特性</h1><p>当我们声明共享变量为 volatile 后，对这个变量的读&#x2F;写将会很特别。理解 volatile特性的一个好方法是把对 volatile 变量的单个读&#x2F;写，看成是使用同一个锁对这些单个读&#x2F;写操作做了同步。下面我们通过具体的示例来说明，请看下面的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileFeaturesExample</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">vl</span> <span class="operator">=</span> <span class="number">0L</span>; <span class="comment">//使用 volatile 声明 64 位的 long 型变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">long</span> l)</span> &#123;</span><br><span class="line">        vl = l; <span class="comment">//单个 volatile 变量的写</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getAndIncrement</span> <span class="params">()</span> &#123;</span><br><span class="line">        vl++; <span class="comment">//复合（多个）volatile 变量的读/写</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vl; <span class="comment">//单个 volatile 变量的读</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设有多个线程分别调用上面程序的三个方法，这个程序在语义上和下面程序等价：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileFeaturesExample</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">vl</span> <span class="operator">=</span> <span class="number">0L</span>; <span class="comment">// 64 位的 long 型普通变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">long</span> l)</span> &#123; <span class="comment">//对单个的普通变量的写用同一个锁同步</span></span><br><span class="line">        vl = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getAndIncrement</span> <span class="params">()</span> &#123; <span class="comment">//普通方法调用</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> get(); <span class="comment">//调用已同步的读方法</span></span><br><span class="line">        temp += <span class="number">1L</span>; <span class="comment">//普通写操作</span></span><br><span class="line">        set(temp); <span class="comment">//调用已同步的写方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">get</span><span class="params">()</span> &#123; <span class="comment">//对单个的普通变量的读用同一个锁同步</span></span><br><span class="line">        <span class="keyword">return</span> vl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面示例程序所示，对一个 volatile 变量的单个读&#x2F;写操作，与对一个普通变量的读&#x2F;写操作使用同一个锁来同步，它们之间的执行效果相同。</p><p>锁的 happens-before 规则保证释放锁和获取锁的两个线程之间的内存可见性，这意味着对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入。</p><p>锁的语义决定了临界区代码的执行具有原子性。这意味着即使是 64 位的 long 型和 double 型变量，只要它是 volatile 变量，对该变量的读写就将具有原子性。如果是多个 volatile 操作或类似于 volatile++ 这种复合操作，这些操作整体上不具有原子性。</p><p>简而言之，volatile 变量自身具有下列特性：</p><ul><li>可见性。对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入。</li><li>原子性：对任意单个 volatile 变量的读&#x2F;写具有原子性，但类似于 volatile++ 这种复合操作不具有原子性。</li></ul><h1 id="volatile-写-读建立的-happens-before-关系"><a href="#volatile-写-读建立的-happens-before-关系" class="headerlink" title="volatile 写-读建立的 happens before 关系"></a>volatile 写-读建立的 happens before 关系</h1><p>上面讲的是 volatile 变量自身的特性，对程序员来说，volatile 对线程的内存可见性的影响比 volatile 自身的特性更为重要，也更需要我们去关注。</p><p>从内存语义的角度来说，volatile 的写-读与锁的释放-获取有相同的内存效果：volatile 写和锁的释放有相同的内存语义；volatile 读与锁的获取有相同的内存语义。</p><p>请看下面使用 volatile 变量的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileExample</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">        a = <span class="number">1</span>;          <span class="comment">//1</span></span><br><span class="line">        flag = <span class="literal">true</span>;    <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;     <span class="comment">//3</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a;  <span class="comment">//4</span></span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设线程 A 执行 writer()方法之后，线程 B 执行 reader()方法。根据 happens before 规则，这个过程建立的 happens before 关系可以分为两类：</p><ol><li>根据程序次序规则，1 happens before 2; 3 happens before 4。</li><li>根据 volatile 规则，2 happens before 3。</li><li>根据 happens before 的传递性规则，1 happens before 4。</li></ol><p>上述 happens before 关系的图形化表现形式如下：</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/volatile-1.png" alt="volatile-1"></p><p>在上图中，每一个箭头链接的两个节点，代表了一个 happens before 关系。黑色箭头表示程序顺序规则；橙色箭头表示 volatile 规则；蓝色箭头表示组合这些规则后提供的 happens before 保证。</p><p>这里 A 线程写一个 volatile 变量后，B 线程读同一个 volatile 变量。A 线程在写volatile 变量之前所有可见的共享变量，在 B 线程读同一个 volatile 变量后，将立即变得对 B 线程可见。</p><h1 id="volatile-写的内存语义"><a href="#volatile-写的内存语义" class="headerlink" title="volatile 写的内存语义"></a>volatile 写的内存语义</h1><blockquote><p>当写一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量值刷新到主内存。</p></blockquote><p>以上面示例程序 VolatileExample 为例，假设线程 A 首先执行 writer()方法，随后线程 B 执行 reader()方法，初始时两个线程的本地内存中的 flag 和 a 都是初始状态。下图是线程 A 执行 volatile 写后，共享变量的状态示意图：</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/volatile-2.png" alt="volatile-2"></p><p>如上图所示，线程 A 在写 flag 变量后，本地内存 A 中被线程 A 更新过的两个共享变量的值被刷新到主内存中。此时，本地内存 A 和主内存中的共享变量的值是一致的。</p><h1 id="volatile-读的内存语义"><a href="#volatile-读的内存语义" class="headerlink" title="volatile 读的内存语义"></a>volatile 读的内存语义</h1><blockquote><p>当读一个 volatile 变量时，JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</p></blockquote><p>当读一个 volatile 变量时，JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</p><p>下面是线程 B 读同一个 volatile 变量后，共享变量的状态示意图：</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/volatile-3.png" alt="volatile-3"></p><p>如上图所示，在读 flag 变量后，本地内存 B 包含的值已经被置为无效。此时，线程 B 必须从主内存中读取共享变量。线程 B 的读取操作将导致本地内存 B 与主内存中的共享变量的值也变成一致的了。</p><p>如果我们把 volatile 写和 volatile 读这两个步骤综合起来看的话，在读线程 B 读一个 volatile 变量后，写线程 A 在写这个 volatile 变量之前所有可见的共享变量的值都将立即变得对读线程 B 可见。</p><div class="note default flat"><p><strong>volatile 读写内存语义总结：</strong></p></div><ul><li>线程 A 写一个 volatile 变量，实质上是线程 A 向接下来将要读这个 volatile 变量的某个线程发出了（其对共享变量所在修改的）消息。</li><li>线程 B 读一个 volatile 变量，实质上是线程 B 接收了之前某个线程发出的（在写这个 volatile 变量之前对共享变量所做修改的）消息。</li><li>线程 A 写一个 volatile 变量，随后线程 B 读这个 volatile 变量，这个过程实质上是线程 A 通过主内存向线程 B 发送消息。</li></ul><hr><blockquote><p><strong>巨人的肩膀：</strong></p><ul><li><a href="https://www.infoq.cn/minibook/java_memory_model">深入理解Java内存模型</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">volatile 读：直接从主内存读；volatile 写：立即刷新到主内存。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Java并发：重排序规则</title>
    <link href="https://www.wrp.cool/posts/41133/"/>
    <id>https://www.wrp.cool/posts/41133/</id>
    <published>2022-08-25T02:17:57.000Z</published>
    <updated>2022-08-26T13:17:23.126Z</updated>
    
    <content type="html"><![CDATA[<p>关于重排序的一些概念性问题在<a href="https://www.wrp.cool/posts/41498/#%E6%9C%89%E5%BA%8F%E6%80%A7%E6%98%AF%E6%80%8E%E4%B9%88%E4%BA%A7%E7%94%9F%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E7%9A%84">Java 内存模型（JMM）</a>中 <em>「有序性是怎么产生并发问题的」</em> 一节有详细介绍。</p><p>程序最终的执行顺序是由 CPU 处理的，做为 Java 程序员更应该关心的是重排序的结果，而不是重排序的过程。</p><p>具体的在什么情况下会发生重排序，又是按照一个什么样的规则去重排序，这些问题应该交给 CPU 去处理，我们应该关心的是我们写的程序被重排序后是怎么样的。</p><h1 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h1><p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分下列三种类型：</p><table><thead><tr><th align="left">名称</th><th align="left">代码示例</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">写后读</td><td align="left">a &#x3D; 1;b &#x3D; a;</td><td align="left">写一个变量之后，再读这个位置。</td></tr><tr><td align="left">写后写</td><td align="left">a &#x3D; 1;a &#x3D; 2;</td><td align="left">写一个变量之后，再写这个变量。</td></tr><tr><td align="left">读后写</td><td align="left">a &#x3D; b;b &#x3D; 1;</td><td align="left">读一个变量之后，再写这个变量。</td></tr></tbody></table><p>上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。</p><p>前面提到过，编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。</p><blockquote><p>注意：这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</p></blockquote><h1 id="as-if-serial-语义"><a href="#as-if-serial-语义" class="headerlink" title="as-if-serial 语义"></a>as-if-serial 语义</h1><p>as-if-serial 语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。</p><p>为了遵守 as-if-serial 语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。为了具体说明，请看下面计算圆面积的代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">pi</span>   <span class="operator">=</span> <span class="number">3.14</span>;         <span class="comment">//A</span></span><br><span class="line"><span class="type">double</span> <span class="variable">r</span>    <span class="operator">=</span> <span class="number">1.0</span>;          <span class="comment">//B</span></span><br><span class="line"><span class="type">double</span> <span class="variable">area</span> <span class="operator">=</span> pi * r * r;   <span class="comment">//C</span></span><br></pre></td></tr></table></figure><p>上面三个操作的数据依赖关系如下图所示：</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E9%87%8D%E6%8E%92%E5%BA%8F%E6%95%B0%E6%8D%AE%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB.png" alt="重排序数据依赖关系"></p><p>如上图所示，A 和 C 之间存在数据依赖关系，同时 B 和 C 之间也存在数据依赖关系。因此在最终执行的指令序列中，C 不能被重排序到 A 和 B 的前面（C 排到 A 和 B 的前面，程序的结果将会被改变）。但 A 和 B 之间没有数据依赖关系，编译器和处理器可以重排序 A 和 B 之间的执行顺序。下图是该程序的两种执行顺序：</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E9%87%8D%E6%8E%92%E5%BA%8F%E5%90%8E%E5%8F%AF%E8%83%BD%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB.png" alt="重排序后可能的依赖关系"></p><p>as-if-serial 语义把单线程程序保护了起来，遵守 as-if-serial 语义的编译器，runtime 和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。as-if-serial 语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。</p><h1 id="程序顺序规则"><a href="#程序顺序规则" class="headerlink" title="程序顺序规则"></a>程序顺序规则</h1><p>根据 happens- before 的程序顺序规则，上面计算圆的面积的示例代码存在三个 happens- before 关系：</p><ul><li>A happens- before B；</li><li>B happens- before C；</li><li>A happens- before C；</li></ul><p>这里的第 3 个 happens- before 关系，是根据 happens- before 的传递性推导出来的。</p><p>这里 A happens-before B，但实际执行时 B 却可以排在 A 之前执行（看上面的重排序后的执行顺序）。实际上如果 A happens-before B，JMM 并不要求 A 一定要在 B 之前执行。JMM 仅仅要求前一个操作（执行的结果）对后一个操作可见。这里操作 A 的执行结果不需要对操作 B 可见；而且重排序操作 A 和操作 B 后的执行结果，与操作 A 和操作 B 按 happens-before 顺序执行的结果一致。在这种情况下，JMM 会认为这种重排序并不非法（not illegal），JMM 允许这种重排序。</p><p>在计算机中，软件技术和硬件技术有一个共同的目标：在不改变程序执行结果的前提下，尽可能的开发并行度。编译器和处理器遵从这一目标，从 happens- before 的定义我们可以看出，JMM 同样遵从这一目标。</p><h1 id="重排序对多线程的影响"><a href="#重排序对多线程的影响" class="headerlink" title="重排序对多线程的影响"></a>重排序对多线程的影响</h1><p>现在让我们来看看，重排序是否会改变多线程程序的执行结果。请看下面的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReorderExample</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">        a = <span class="number">1</span>;                   <span class="comment">//1</span></span><br><span class="line">        flag = <span class="literal">true</span>;             <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;                <span class="comment">//3</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>  a * a;        <span class="comment">//4</span></span><br><span class="line">            ……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flag 变量是个标记，用来标识变量 a 是否已被写入。这里假设有两个线程 A 和 B，A 首先执行 writer() 方法，随后 B 线程接着执行 reader() 方法。线程 B 在执行操作 4 时，能否看到线程 A 在操作 1 对共享变量 a 的写入？</p><p>答案是：不一定能看到。</p><p>由于操作 1 和操作 2 没有数据依赖关系，编译器和处理器可以对这两个操作重排序；同样，操作 3 和操作 4 没有数据依赖关系，编译器和处理器也可以对这两个操作重排序。让我们先来看看，当操作 1 和操作 2 重排序时，可能会产生什么效果? 请看下面的程序执行时序图：</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/java-jmm-8.png" alt="java-jmm-8"></p><p>如上图所示，操作 1 和操作 2 做了重排序。程序执行时，线程 A 首先写标记变量 flag，随后线程 B 读这个变量。由于条件判断为真，线程 B 将读取变量 a。此时，变量 a 还根本没有被线程 A 写入，在这里多线程程序的语义被重排序破坏了！</p><p>下面再让我们看看，当操作 3 和操作 4 重排序时会产生什么效果（借助这个重排序，可以顺便说明控制依赖性）。下面是操作 3 和操作 4 重排序后，程序的执行时序图：</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/java-jmm-9.png" alt="java-jmm-9"></p><p>在程序中，操作 3 和操作 4 存在控制依赖关系。当代码中存在控制依赖性时，会影响指令序列执行的并行度。为此，编译器和处理器会采用猜测（Speculation）执行来克服控制相关性对并行度的影响。以处理器的猜测执行为例，执行线程 B 的处理器可以提前读取并计算 a*a，然后把计算结果临时保存到一个名为重排序缓冲（reorder buffer ROB）的硬件缓存中。当接下来操作 3 的条件判断为真时，就把该计算结果写入变量 i 中。</p><p>从图中我们可以看出，猜测执行实质上对操作 3 和 4 做了重排序。重排序在这里破坏了多线程程序的语义！</p><p>在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是 as-if-serial 语义允许对存在控制依赖的操作做重排序的原因）；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。</p><blockquote><p>虽然重排序的一些具体的发生过程并不是我们关心的重点，但作为程序员，求知好学也是应该的不是吗。下面的部分不感兴趣的同学跳过即可。</p></blockquote><h1 id="为什么会发生重排序"><a href="#为什么会发生重排序" class="headerlink" title="为什么会发生重排序"></a>为什么会发生重排序</h1><p>重排序分为真重排序和伪重排序，真重排序就像是在<a href="https://www.wrp.cool/posts/41498/">Java 内存模型（JMM）</a>中的 <em>「有序性是怎么产生并发问题的」</em> 所介绍的：<strong>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。</strong>伪重排序正是接下来所要介绍的：</p><blockquote><p>由于现代的处理器使用写缓冲区来临时保存向内存写入的数据，这对内存操作的执行顺序产生重要的影响。</p></blockquote><p><strong>写缓冲区的优点：</strong></p><ul><li>保证指令流水线持续运行，可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟</li><li>通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用</li></ul><p><strong>写缓冲区的缺点：</strong>每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读&#x2F;写操作的执行顺序，不一定与内存实际发生的读&#x2F;写操作顺序一致！请看下面示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Processor A</span></span><br><span class="line">a = <span class="number">1</span>; <span class="comment">//A1  </span></span><br><span class="line">x = b; <span class="comment">//A2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Processor B</span></span><br><span class="line">b = <span class="number">2</span>; <span class="comment">//B1  </span></span><br><span class="line">y = a; <span class="comment">//B2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始状态：a = b = 0；处理器允许执行后得到结果：x = y = 0</span></span><br></pre></td></tr></table></figure><p>假设处理器 A 和处理器 B 按程序的顺序并行执行内存访问，最终却可能得到 x &#x3D; y &#x3D; 0 的结果。具体的原因如下图所示：</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E4%BC%AA%E9%87%8D%E6%8E%92%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="伪重排序执行时序图"></p><p>以下面的这种时序执行时，程序就会得到 x &#x3D; y &#x3D; 0 的结果：</p><ol><li>处理器 A 和处理器 B 同时把共享变量写入自己的写缓冲区（A1，B1）</li><li>处理器 A 和处理器 B 同时从内存中读取另一个共享变量（A2，B2）</li><li>处理器 A 和处理器 B 刷自己写缓冲区中的脏数据到内存中（A3，B3）</li></ol><p>从内存操作实际发生的顺序来看，直到处理器 A 执行 A3 来刷新自己的写缓存区，写操作 A1 才算真正执行了。虽然处理器 A 执行内存操作的顺序为：A1-&gt;A2，但内存操作实际发生的顺序却是：A2-&gt;A1。此时，处理器 A 的内存操作顺序被重排序了（处理器 B 的情况和处理器 A 一样，这里就不赘述了）。</p><p>这里的关键是，由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。</p><p>为了保证内存可见性，java 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM 把内存屏障指令分为下列四类：</p><table><thead><tr><th align="left">屏障类型</th><th align="left">指令示例</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">LoadLoad Barriers</td><td align="left">Load1; LoadLoad; Load2</td><td align="left">确保 Load1 数据装载，之前于 Load2 及所有后续装载指令的装载。</td></tr><tr><td align="left">StoreStore Barriers</td><td align="left">Store1; StoreStore; Store2</td><td align="left">确保 Store1 数据对其他处理器可见（刷新到内存），之前于 Store2 及所有后续存储指令的存储。</td></tr><tr><td align="left">LoadStore Barriers</td><td align="left">Load1; LoadStore; Store2</td><td align="left">确保 Load1 数据装载，之前于 Store2 及所有后续的存储指令刷新到内存。</td></tr><tr><td align="left">StoreLoad Barriers</td><td align="left">Store1; StoreLoad; Load2</td><td align="left">确保 Store1 数据对其他处理器可见（刷新到内存），之前于 Load2 及所有后续装载指令的装载。</td></tr></tbody></table><p>StoreLoad Barriers 会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。</p><p>StoreLoad Barriers 是一个“全能型”的屏障，它同时具有其他三个屏障的效果。现代的多处理器大都支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（buffer fully flush）。</p><hr><blockquote><p><strong>巨人的肩膀：</strong></p><ul><li><a href="https://www.infoq.cn/minibook/java_memory_model">深入理解Java内存模型</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">程序最终的执行顺序是由 CPU 处理的，做为 Java 程序员更应该关心的是重排序的结果，而不是重排序的过程。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Java并发：线程的执行结果和异常</title>
    <link href="https://www.wrp.cool/posts/62788/"/>
    <id>https://www.wrp.cool/posts/62788/</id>
    <published>2022-08-06T17:54:46.000Z</published>
    <updated>2022-08-27T08:43:31.928Z</updated>
    
    <content type="html"><![CDATA[<p>由于 Runnable 和 Thread 之间的解耦设计，导致 Thread 在运行 Runnable 时其实是无法感知到 Runnable 内部的运行逻辑的，Thread 无法知道这个线程执行完了是否需要处理返回值，是否会抛出什么异常等等</p><p>例如线程池，线程池中的 Thread 根本不知道会传进来一个什么样的 Runnable，对于 Thread 而言，只关注执行上的逻辑，而不关注 Runnable 内部的逻辑。</p><p>这样的设计是优秀的，但如果需要处理线程中的异常或者需要返回值来做后续的一些操作就不方便了。如果需要子线程的返回值才能继续后面的操作，可以先去做一些别的事情，等子线程执行完毕之后拿到返回值了再继续这部分逻辑。</p><h1 id="利用-Thread-UncaughtExceptionHandler-捕获异常"><a href="#利用-Thread-UncaughtExceptionHandler-捕获异常" class="headerlink" title="利用 Thread.UncaughtExceptionHandler 捕获异常"></a>利用 Thread.UncaughtExceptionHandler 捕获异常</h1><p>如果主线程抛出一个异常，可以直接使用 <code>try-catch</code> 捕获处理这个异常。如果异常是子线程中抛出的，那么主线程对这个异常并不敏感，无法直接捕获处理这个异常。虽然在控制台能看到异常信息，但是这个异常信息是子线程输出的，主线程并无法感知到这个异常，之所以能在控制台看到异常信息，是因为主线程与子线程共用了同一个控制台。</p><p>如果看不明白上面这段话，你可以跑一下这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;我是子线程抛出来的异常&quot;</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">5000</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;我是主线程抛出来的异常&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                System.out.println(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于主线程的异常，可以直接使用 <code>try-catch</code> 来捕获处理。对于子线程的异常，每次抛出异常的时机都不相同，主线程无法知道什么时候子线程会抛出异常，更无法捕获处理子线程中的异常。</p><blockquote><p>其实这个例子也很形象的向我们展示了线程的工作过程：每个线程在执行期间是互不打扰的，自己干自己的事情。每个线程在领取到自己的任务（run方法）之后，等待被分配资源开始执行（start方法）之后便是一直闷头干下去，直到把工作做完（run方法执行完毕）</p></blockquote><p>这样就要求子线程必须能够自行处理异常，也就是在子线程内部使用 <code>try-catch</code> 来处理异常。但子线程不一定能够处理自己的异常，有些异常需要向外通知父线程，让父线程去执行对应的处理逻辑。</p><blockquote><p>这样看来，子线程更像是父线程的一个方法：异常可以在方法中使用 <code>try-catch</code> 自行处理，也可以标记在方法签名上向外抛出。</p></blockquote><p>针对需要通知父线程处理的异常，可以使用 <strong>Thread.UncaughtExceptionHandler</strong> 这个接口来接收并处理异常。</p><p>这个接口的使用方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义的线程异常处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MyUncaughtExceptionHandler</span> <span class="keyword">implements</span> <span class="title class_">Thread</span>.UncaughtExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyUncaughtExceptionHandler</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;：成功捕获了异常。抛出异常的线程是：&quot;</span> + t.getName() + <span class="string">&quot;。抛出的异常是：&quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 设置为默认异常处理器</span></span><br><span class="line">    <span class="comment">// MyUncaughtExceptionHandler --&gt; Thread.defaultUncaughtExceptionHandler</span></span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> <span class="title class_">MyUncaughtExceptionHandler</span>(<span class="string">&quot;默认的线程异常处理器&quot;</span>));</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>()).start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置为线程专用的异常处理器</span></span><br><span class="line">    <span class="comment">// MyUncaughtExceptionHandler --&gt; t.uncaughtExceptionHandler</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>(), <span class="string">&quot;Thread-0&quot;</span>);</span><br><span class="line">    t.setUncaughtExceptionHandler(<span class="keyword">new</span> <span class="title class_">MyUncaughtExceptionHandler</span>(<span class="string">&quot;为 Thread-0 专门设置的异常处理器&quot;</span>));</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Task 抛出的异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先创建一个类实现 <code>Thread.UncaughtExceptionHandler</code> 作为自定义的线程异常处理器，再根据需要设置为默认的异常处理器，或者是为每个线程单独设置的异常处理器。</p><p>如果没有单独设置异常处理器也没有设置默认的异常处理器，那么调用 <code>ThreadGroup</code> 类对异常做处理，该类实现了 <code>Thread.UncaughtExceptionHandler</code> 接口，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 首先检查是否存在父线程组，如果存在则调用父线程组的异常处理器进行处理，这里是一个递归的操作</span></span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">        parent.uncaughtException(t, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取全局异常处理器</span></span><br><span class="line">        Thread.<span class="type">UncaughtExceptionHandler</span> <span class="variable">ueh</span> <span class="operator">=</span> Thread.getDefaultUncaughtExceptionHandler();</span><br><span class="line">        <span class="comment">// 尝试使用全局异常处理器处理</span></span><br><span class="line">        <span class="keyword">if</span> (ueh != <span class="literal">null</span>) &#123;</span><br><span class="line">            ueh.uncaughtException(t, e);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(e <span class="keyword">instanceof</span> ThreadDeath)) &#123;</span><br><span class="line">            <span class="comment">// 不存在全局异常处理器，直接将异常的堆栈信息打印出来</span></span><br><span class="line">            System.err.print(<span class="string">&quot;Exception in thread \&quot;&quot;</span> + t.getName() + <span class="string">&quot;\&quot; &quot;</span>);</span><br><span class="line">            e.printStackTrace(System.err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="利用-Future-获取线程执行结果和处理异常"><a href="#利用-Future-获取线程执行结果和处理异常" class="headerlink" title="利用 Future 获取线程执行结果和处理异常"></a>利用 Future 获取线程执行结果和处理异常</h1><p><strong>简介：</strong></p><p>如果当前任务需要另外的某一个任务执行完毕获取到返回值后才能继续执行，但是这个另外的任务又比较耗时，那么可以使用 Future 类将这个任务的返回结果包装起来，然后当前线程先去做点其他的事情，等到 Future 拿到结果之后再执行那部分的逻辑。这个被包装的对象就是 <code>Callable</code>。</p><p><strong>简而言之：</strong>如果有个很耗时的方法的需要执行，那么先开个线程让它执行，当前线程先做点其他的事情，不要一直在哪里傻等</p><p><strong>Callable 介绍：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Callable 是一个接口，跟 Runnable 一样用来包装要执行的任务，不同的是 Callable 接口可以拥有返回值和向外抛出异常。</p><div class="note modern primary no-icon flat"><p><strong>Future 的使用：</strong></p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">final</span> Future&lt;Integer&gt; future = service.submit(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get 方法的行为取决于 Callable 任务的状态，只有以下五种情况：</p><ol><li>任务正常完成：gei 方法会立即返回结果</li><li>任务尚未完成（可能是还没开始或执行中）：get将阻塞直到任务完成并返回结果</li><li>任务执行过程中抛出 Exception：get方法会抛出 ExecutionException<br>这里的异常是 call 方法产生的异常，不管 call 方法抛出了什么样的异常都会被 get 方法接收到，但是 get 方法只会抛出 ExecutionException 异常。</li><li>任务被取消：get 方法会抛出 CancellationException</li><li>任务超时：get 方法有一个重载方法，可以传入延迟时间，如果时间到了还没有获得结果，get方法就会抛出 TimeOutException。</li></ol><p><strong>Future 的其他方法介绍：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 尝试取消任务，如果任务已经完成、已取消或其他原因无法取消，则失败。 </span></span><br><span class="line"><span class="comment">     * 1、如果任务还没开始执行，则该任务不应该运行 </span></span><br><span class="line"><span class="comment">     * 2、如果任务已经开始执行，由参数mayInterruptIfRunning来决定执行该任务的线程是否应该被中断，这只是终止任务的一种尝试。</span></span><br><span class="line"><span class="comment">          若mayInterruptIfRunning为true，则会立即中断执行任务的线程并返回true</span></span><br><span class="line"><span class="comment">          若mayInterruptIfRunning为false，则会返回true且不会中断任务执行线程。</span></span><br><span class="line"><span class="comment">     * 3、调用这个方法后，以后对isDone方法调用都返回true。 </span></span><br><span class="line"><span class="comment">     * 4、如果这个方法返回true,以后对isCancelled返回true。 </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 判断任务是否被取消了，如果调用了cancel()则返回true </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 如果任务完成，则返回ture </span></span><br><span class="line"><span class="comment">     * 任务完成包含正常终止、异常、取消任务。在这些情况下都返回true </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note modern primary no-icon flat"><p><strong>FutureTask 的使用：</strong></p></div><p>上面的例子使用的是线程池的 submit 方法创建 Future 对象，现在介绍一种由普通线程创建的 Future 对象：FutureTask。</p><p>Thread 类是只能传入 Runnable 方法去执行的，而现在又需要一个 Future 对象，显而易见的我们需要一个类同时实现 Future 和 Runnable 对象。</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/FutureTask%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="FutureTask类关系图"></p><p>这个类的使用方式也很简单，需要 Runnable 对象的时候就把它当 Runnable 去用，需要 Future 的时候就把它当 Future 去用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>巨人的肩膀：</strong></p><p><a href="https://www.51cto.com/article/633900.html">并发编程之Future&amp;FutureTask深入解析</a></p>]]></content>
    
    
    <summary type="html">处理线程执行过程中抛出的异常以及返回的结果。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Java并发：AQS</title>
    <link href="https://www.wrp.cool/posts/38839/"/>
    <id>https://www.wrp.cool/posts/38839/</id>
    <published>2022-08-06T13:54:00.000Z</published>
    <updated>2022-08-31T15:17:22.388Z</updated>
    
    <content type="html"><![CDATA[<p>AQS 的全称是：AbstractQueuedSynchronizer（抽象队列同步器）j.u.c 包下所提供的一系列同步器，也是在 AQS 的帮助下实现的，比如 CountDownLatch、ReentrantLock、Semaphore、CyclicBarrier 等。</p><p>同步器都会有一个内部类继承自 AQS 并且重写 AQS 中的一些方法以定制化一些更具特征的功能，一般这个内部类被命名为 Sync。以 Sync 为工具对外提供一些操纵的接口，以此实现自定义同步器。</p><p>同步器都拥有让线程陷入阻塞以及唤醒阻塞线程继续执行的能力，之间的区别只是阻塞、唤醒线程的时机、方法、形式不同而已。也正是这些同步器提供了 Java 强大的并发能力。</p><p>所以其实这些同步器都必须具备共同的能力：<strong>阻塞、唤醒线程的能力。这项能力由 LockSupport 类提供。</strong></p><h1 id="LockSupport-的-park-和-unpark"><a href="#LockSupport-的-park-和-unpark" class="headerlink" title="LockSupport 的 park 和 unpark"></a>LockSupport 的 park 和 unpark</h1><p>LockSupport 类位于 <code>java.util.concurrent.locks</code> 包下，这个类中包含了 park 和 unpark 方法。park 方法可以阻塞当前线程一直到 unpark 方法被调用，unpark 方法也可以提前被调用。但是 unpark 方法是没有被计数的，也就是说提前调用多次 unpark 只会解除后续的一次 park 操作。另外 LockSupport 类是作用在线程上而不是同步器上的，一个线程在新的同步器上调用 park 操作可能会直接返回，因为在此之前可能还有剩余的 unpark 操作。</p><p><strong>使用示例，先 park 再 unpark</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;卧槽，我阻塞了。。。&quot;</span>);</span><br><span class="line">        LockSupport.park();</span><br><span class="line">        System.out.println(<span class="string">&quot;还好醒过来了。。吓死我了md&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">1</span>); <span class="comment">// 让 t1 跑一会</span></span><br><span class="line">    System.out.println(<span class="string">&quot;没事，我来将你唤醒。&quot;</span>);</span><br><span class="line">    LockSupport.unpark(t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用示例，先 unpark 再 park</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;这次我先将你唤醒！&quot;</span>);</span><br><span class="line">    LockSupport.unpark(Thread.currentThread());</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;先唤醒再阻塞。&quot;</span>);</span><br><span class="line">    LockSupport.park();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;醒过来了。。&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LockSupport 类中其他阻塞线程的方法：</strong></p><ul><li>void park(Object blocker)</li><li>void parkNanos(long nanos)</li><li>void parkNanos(Object blocker, long nanos)</li><li>void parkUntil(long deadline)</li><li>void parkUntil(Object blocker, long deadline)</li><li>blocker：记录导致线程阻塞的对象，方便故障排查</li><li>nanos：阻塞当前线程，最长不超过 nanos 纳秒，或者被 unpark 唤醒</li><li>deadline：阻塞当前线程直到 deadline 之前，或者被 unpark 唤醒</li></ul><h1 id="AQS-概述"><a href="#AQS-概述" class="headerlink" title="AQS 概述"></a>AQS 概述</h1><p>开头提到的同步器都必须实现以下两个功能：</p><ul><li>同步资源的管理（例如：CountDownLatch 的倒数、锁的获取和释放），以及同步资源的更新和检查操作。</li><li>至少有一个方法导致调用线程在同步状态已经被获取时阻塞，以及在其他线程改变这个同步状态时解除阻塞等。</li></ul><p>实现这两个功能需要两个操作：acquire（申请同步资源）、release（释放同步资源），AQS 提供了这两个方法。</p><ul><li><strong>acquire：</strong>尝试申请同步资源，失败阻塞调用的线程，直到同步资源允许其继续执行。例如：ReentrantLock.lock()、CountDownLatch.await() 等方法</li><li><strong>release：</strong>释放当前线程所持有的同步资源，使得一或多个被 acquire 阻塞的线程继续执行。例如：ReentrantLock.unlock()、CountDownLatch.countDown() 等方法。</li></ul><p>AQS 并没有对自定义同步器的同步方法做统一的定义，因此在不同的同步器中 acquire 和 release 的名称可能有所不同，例如：Lock.lock、Semaphore.acquire、CountDownLatch.await、FutureTask.get 他们都是 acquire 方法的体现，而比如 Lock.unlock 则是 release 的体现了。</p><p>AQS 背后的基本思想其实很简单，acquire 操作如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (拿不到同步资源) &#123;</span><br><span class="line">    进入阻塞队列排队;</span><br><span class="line">    或者不排队，直接返回;</span><br><span class="line">&#125;</span><br><span class="line">拿到同步资源了，退出排队;</span><br></pre></td></tr></table></figure><p>release 操作如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">释放同步资源;</span><br><span class="line"><span class="keyword">if</span> (同步资源充足，允许被阻塞的线程获取)</span><br><span class="line">    唤醒能获取同步资源的线程;</span><br></pre></td></tr></table></figure><p>为了实现 acquire 和 release 操作，需要以下的三个基本组件的相互协作：</p><ul><li>同步状态的原子性管理</li><li>线程的阻塞与唤醒被阻塞的线程</li><li>线程排队的队列管理</li></ul><p>同时实现这三个功能是可以做到的，但是无法应对各种各样的同步需求，比如在互斥锁中同一时刻只允许有一个线程持有锁，而共享锁则允许同一时刻有多个线程持有锁、以及各种同步器之间的特性无法同时实现。AQS 实际上是将这些组件共同的部分（例如：acquire 和 release）提取出来了，而其他的同步器继承 AQS 来做一些个性化实现。</p><blockquote><p>这也是 Java 继承的一种应用，将公共部分提取出来作为父类，再由子类继承父类去做一些个性化定制。只是在自定义同步器中对 AQS 的继承跟常规继承还有点区别。这里的继承更像是一种组合的操作，而不是对 AQS 的扩展。</p></blockquote><h1 id="同步资源"><a href="#同步资源" class="headerlink" title="同步资源"></a>同步资源</h1><p><strong>概述：</strong>同步资源表示的是当前线程是否满足继续执行条件。这个条件更像是一个许可证，拿到执行许可证才能继续执行。所以你可以把同步资源理解为执行许可证。</p><p><strong>表示：</strong>AQS 使用 state 属性（int 32位）来设置同步资源，并暴露出 <code>getState</code>、<code>setState</code> 以及 <code>compareAndSet</code> 操作来读取和更新这个属性，这些方法都依赖于 j.u.c.atomic 包的支持。</p><p>AQS 并不维护同步资源的值，仅为其提供维护方法，具体如何对同步资源调配将有继承自 AQS 的同步器自行处理。同步器仅需实现对同步资源的获取与释放方法即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等）AQS 在顶层已经实现好了，同步器主要实现也仅能实现以下的几种方法：</p><ul><li><strong>isHeldExclusively()：</strong>该线程是否正在独占资源。只有用到condition才需要去实现它。</li><li><strong>tryAcquire(int)：</strong>独占方式。尝试获取资源，成功则返回true，失败则返回false。</li><li><strong>tryRelease(int)：</strong>独占方式。尝试释放资源，成功则返回true，失败则返回false。</li><li><strong>tryAcquireShared(int)：</strong>共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li><strong>tryReleaseShared(int)：</strong>共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li></ul><p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现 tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared 中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如 ReentrantReadWriteLock。</p><h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><p>整个框架的关键就是如何管理被阻塞的线程的队列，该队列是严格的 FIFO 队列，因此，框架不支持基于优先级的同步。</p><p>其实这里称之为队列我认为不是很准确，从数据结构的角度它更像是一个双端链表，可能从 FIFO 的特性来说它才更像是一个队列吧。</p><p>既然是双向链表，那么就只需要关注其节点的数据结构以及如何组织节点即可。</p><p>先看一下节点的数据结构，至于如何组织节点将在分析 acquire、release 的时候做具体介绍，其实也就是介绍节点的创建时机、以及怎样入队出队的时机。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">// 标识节点当前是共享模式还是独占模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// waitStatus 字段的值，下面会介绍</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程等待状态，取值在上面</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line">    <span class="comment">// 前驱节点的引用</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="comment">// 后继节点的引用</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="comment">// 这个就是线程本尊</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 Node 节点类很明显就是一个标准双端链表的节点类，有 prev、next 指向前驱和后继节点，thread 当然就是具体的线程，waitStatus 当然就是线程在队列中的状态了。</p><blockquote><ul><li><strong>CANCELLED：</strong>表示当前结点已取消调度。当 timeout 或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。</li><li><strong>SIGNAL：</strong>表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为 SIGNAL。</li><li><strong>CONDITION：</strong>表示结点等待在 Condition 上，当其他线程调用了 Condition 的 signal() 方法后，CONDITION 状态的结点将从等待队列转移到同步队列中，等待获取同步锁。</li><li><strong>PROPAGATE：</strong>共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。</li><li><strong>0：</strong>新结点入队时的默认状态。</li></ul></blockquote><p>注意：负值表示结点处于有效等待状态，而正值表示结点已被取消。所以源码中很多地方用 <code>&gt;0</code>、<code>&lt;0</code> 来判断结点的状态是否正常。</p><h1 id="AQS-结构"><a href="#AQS-结构" class="headerlink" title="AQS 结构"></a>AQS 结构</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头结点，你直接把它当做 当前持有锁的线程 可能是最好理解的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个链表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步资源状态，这个字段将由继承 AQS 的自定义同步器维护</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表当前持有独占锁的线程，继承自 AbstractOwnableSynchronizer</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br></pre></td></tr></table></figure><p>整个 AQS 维护了一个 state（同步资源）和一个阻塞队列，当多线程竞争同步资源被阻塞的线程会进入此队列排队。他们之间的关系如下：</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/AQS-1.png" alt="AQS-1"></p><hr><blockquote><p><strong>小结：</strong></p><p>AQS 是被抽象出来作为各个同步器最重要的工具 Sync 类的父类而存在的。AQS 定义了同步资源 state 属性，并且为其提供维护方法。同步器通过维护同步资源来调用 AQS 中对线程的阻塞入队&#x2F;唤醒出队等操作。</p></blockquote><p>关于 AQS 的概念性介绍就到这里，关于最重要的 acquire 和 release 方法会再单独开一篇文章做详解。</p><hr><blockquote><p><strong>巨人的肩膀：</strong></p><ul><li><a href="https://www.cnblogs.com/dennyzhangdd/p/7218510.html">《The java.util.concurrent Synchronizer Framework》 JUC同步器框架（AQS框架）原文翻译</a></li><li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer">一行一行源码分析清楚AbstractQueuedSynchronizer</a></li><li><a href="https://www.cnblogs.com/waterystone/p/4920797.html">Java并发之AQS详解</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">Java 并发之魂：AQS。地位不用多说，各种并发同步工具背后都是基于 AQS 实现的，比如 CountDownLatch、ReentrantLock、Semaphore、CyclicBarrier 等。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Java并发：线程协同</title>
    <link href="https://www.wrp.cool/posts/30379/"/>
    <id>https://www.wrp.cool/posts/30379/</id>
    <published>2022-08-04T14:02:10.000Z</published>
    <updated>2022-08-29T02:59:23.798Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲述控制并发流程的工具类，包括：CountDownLatch、Semaphore、CyclicBarrier、Condition。这些工具类的作用就是帮助程序员更容易控制线程之间的合作，让线程互相配合，以满足业务逻辑，比如让线程A等待线程B执行完毕后再执行的排队策略、或者是让多个线程等待到某个时刻再同时从某个阶段开始执行的合作策略。</p><h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><blockquote><p>中文名：倒计时门栓，举个例子可以类比成一个门锁，一旦门打开了，门外面等待的人就会一拥而入。而 CountDownLatch 就是用一个倒计时做为门锁，一旦计数到0，就把门锁打开，等待执行的线程就会在此时刻一起开始执行。</p></blockquote><p><strong>构造方法：</strong></p><ul><li><code>public CountDownLatch(int count)</code> 参数 count 为要倒数的值</li></ul><p><strong>重要方法：</strong></p><ul><li><code>public void await() throws InterruptedException</code><ul><li>等待，线程调用此方法后被挂起，等待直到 count 值为0才开始执行</li></ul></li><li><code>public boolean await(long timeout, TimeUnit unit)</code><ul><li>超时等待，线程调用此方法后会被挂起，在设置的最长等待时间之前如果倒计时结束则返回 true 并在倒计时结束时刻开始执行后续代码，到达最长等待时间之后则返回 false 并开始执行后续代码</li></ul></li><li><code>public void countDown()</code><ul><li>将 count 值减1，直到为0时，等待的线程才会被唤醒。</li></ul></li></ul><p><strong>CountDownLatch 使用示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(Math.abs(r.nextInt() % <span class="number">1000</span>));</span><br><span class="line">                latch.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;门锁打开了，开始执行，此刻时间是：&quot;</span> + System.currentTimeMillis());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    latch.countDown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 十个线程的开始执行时间都是相同的</span></span><br></pre></td></tr></table></figure><h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><blockquote><p>可以理解为：运行许可证。拿到 Semaphore 资源的线程才可以往下运行，运行完毕之后必须归还 Semaphore 资源。可以用来保护一些比较稀缺的资源，保证了同一时刻最多只有有限个线程在使用这些稀缺资源。</p></blockquote><p><strong>构造方法：</strong></p><ul><li><code>public Semaphore(int permits, boolean fair)</code><ul><li>permits：运行许可证数量</li><li>fair：是否使用公平锁策略</li></ul></li></ul><p><strong>重要方法：</strong></p><ul><li><code>public void acquire() throws InterruptedException</code><ul><li>申请许可证，如果暂时没许可证则陷入阻塞。</li></ul></li><li><code>public boolean tryAcquire()</code><ul><li>尝试申请许可证，看看现在有没有空闲的许可证，如果有的话直接获取，没有则去做别的事情。</li></ul></li><li><code>public void release()</code><ul><li>释放许可证，将用完的许可证放回去。必须在 finally 代码块中调用</li></ul></li></ul><p>以上摘抄了几个比较重要的方法出来说明，Semaphore 类中还有一些其他的方法能更灵活使用，包括设置阻塞超时、一次性获取多个许可证、一次性释放多个许可证等。</p><p><strong>Semaphore 使用示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Semaphore</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                s.acquire();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 申请到了许可证，往下执行&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;释放许可证&quot;</span>);</span><br><span class="line">                s.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Thread-&quot;</span> + i).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><blockquote><p>可以类比为春游时候的大巴车，等待人满发车。就是约定好一个数字（<em>大巴车的载客数</em>），先到的线程等待后到的线程（<em>先上车的同学等待后上车的同学</em>），等到线程数满足约定数量之后（<em>全部同学到齐</em>）全部开始执行（<em>发车</em>）。</p></blockquote><p><strong>构造方法：</strong></p><ul><li><code>public CyclicBarrier(int parties, Runnable barrierAction)</code><ul><li>parties：提前约定好等待线程的数量</li><li>barrierAction：等待所有线程到齐后执行的线程</li></ul></li></ul><p><strong>重要方法：</strong></p><ul><li><code>public int await() throws InterruptedException, BrokenBarrierException</code><ul><li>先到的线程开始等待后面的线程来了之后一起执行</li></ul></li><li><code>public int await(long timeout, TimeUnit unit) throws InterruptedException, BrokenBarrierException, TimeoutException</code><ul><li>设置超时的等待，超时抛出 TimeoutException</li></ul></li><li><code>public void reset()</code><ul><li>放弃正在等待中的线程，开始新一轮等待</li></ul></li></ul><div class="note primary modern no-icon flat"><p><strong>抛出 BrokenBarrierException 的3种情况：</strong></p></div><ol><li>其他等待的线程被中断</li><li>其他等待的线程超时</li><li>其他线程调用 CyclicBarrier.reset() 方法</li></ol><p><strong>CyclicBarrier 使用示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">CyclicBarrier</span> <span class="variable">cb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">5</span>, () -&gt; System.out.println(<span class="string">&quot;大巴发车&quot;</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>(i, cb), <span class="string">&quot;Thread-&quot;</span> + i).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier cb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Task</span><span class="params">(<span class="type">int</span> id, CyclicBarrier cb)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.cb = cb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread-&quot;</span> + id + <span class="string">&quot; 准备前往大巴车&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(Math.abs(r.nextInt() % <span class="number">10000</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread-&quot;</span> + id + <span class="string">&quot; 已经上大巴车了，开始等待其他同学到达&quot;</span>);</span><br><span class="line">            cb.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread-&quot;</span> + id + <span class="string">&quot;所乘坐的大巴车出发！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p><strong>CountDownLatch 和 CyclicBarrier 的区别：</strong></p><ol><li><strong>可重用性不同：</strong>CountDownLatch 在倒数到0并出发门栓打开后，就不能再次使用了，只能创建新的实例；而 CyclicBarrier 可以重复使用。</li><li><strong>作用不同：</strong>CyclicBarrier 要等到固定数量的线程都到达了栅栏位置才能继续执行，而 CountDownLatch 只需要等待计数器倒数至0。</li><li>CyclicBarrier 是线程之间的交互行为，重点在协作的线程；<br>CountDownLatch 是倒数事件的行为，重点在倒数的事件。</li></ol></blockquote><p><strong>CountDownLatch 的应用场景：</strong>有一个任务想要往下执行，但必须要等到其他的任务执行完毕后才可以继续往下执行。假如我们这个想要继续往下执行的任务调用一个CountDownLatch对象的await()方法，其他的任务执行完自己的任务后调用同一个CountDownLatch对象上的countDown()方法，这个调用await()方法的任务将一直阻塞等待，直到这个CountDownLatch对象的计数值减到0为止。</p><p><strong>CyclicBarrier 的应用场景：</strong>CyclicBarrier 可以构造一个栅栏，当某一个线程执行到栅栏前，它就会开始等待，直到所有线程都到达栅栏前，那么该栅栏就会打开，所有线程再统一出发，继续执行剩下的任务。</p><h1 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h1><blockquote><p>条件对象。是 Object 中的 wait()、notify()、notifyAll() 这几个方法的升级版（避免了 synchronized 的使用），不同的是这里的锁使用的是 ReentrantLock，而不是 monitor 锁。<br>关于 Object 中的 wait()、notify()、notifyAll() 这几个方法具体可以查看<a href="https://www.wrp.cool/posts/29010/">这里</a></p></blockquote><p><strong>创建 Condition 对象：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">c</span> <span class="operator">=</span> lock.newCondition();</span><br></pre></td></tr></table></figure><div class="note info modern no-icon flat"><p><strong>Condition 中与 Object 三个方法的对应：</strong></p></div><table><thead><tr><th align="left">Object</th><th align="left">Condition</th></tr></thead><tbody><tr><td align="left">wait()</td><td align="left">await()</td></tr><tr><td align="left">notify()</td><td align="left">signal()</td></tr><tr><td align="left">notifyAll()</td><td align="left">signalAll()</td></tr></tbody></table><p><strong>Condition 使用的示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个线程交替打印 1-100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (count &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                c.signal();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;输出：&quot;</span> + String.format(<span class="string">&quot;%03d&quot;</span>, count++));</span><br><span class="line">                <span class="keyword">if</span> (count &lt;= <span class="number">100</span>)</span><br><span class="line">                    c.awaitUninterruptibly();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;奇数线程&quot;</span>).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;偶数线程&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的这个交替打印 1-100 的例子，还可以使用 synchronized 来实现，只是效率上较差了一些。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> count;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 打印奇数的线程</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (count &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + count++);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;奇数&quot;</span>).start();</span><br><span class="line">    <span class="comment">// 打印偶数的线程</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (count &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + count++);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;偶数&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个场景下使用 synchronized 的效率较差的原因是：竞争到锁的线程将判断是否满足打印条件，如果满足则打印，否则直接跳出，紧接着同步代码块执行完毕释放锁，两个线程重新进入竞争锁的步骤，如果在这个时候其中一个线程接连多次竞争到锁，但是却因为不满足打印条件而再次直接释放锁，这就是无意义的浪费</p>]]></content>
    
    
    <summary type="html">讲述线程之间的协同运行，包括：CountDownLatch、Semaphore、CyclicBarrier、Condition</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Java并发：并发容器</title>
    <link href="https://www.wrp.cool/posts/3103/"/>
    <id>https://www.wrp.cool/posts/3103/</id>
    <published>2022-08-04T13:50:58.000Z</published>
    <updated>2022-09-03T15:52:20.610Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>看并发容器的发展历史其实也反映了一个软件的发展历史，很明显大多数软件在研发的初期都是比较粗糙的，这也是由市场的性质所决定的，前期如果投入了过多的时间跟精力，那么一旦这款软件不被市场所接受，那全都白费了。并发容器的发展历程跟这如出一辙。</p></blockquote><p>早期的 jdk 中的并发容器只有 Vector 和 Hashtable，初期的设计这两种并发容器的效率并不理想，这两个并发容器的实现和早期的 ArrayList 和 HashMap 几乎一样，只是在其中的一些可能会导致并发不安全的方法上加了 synchronized 关键字用来同步。将 synchronized 加在方法上等于是锁住了整个实例对象。这样的设计是方便了开发人员，几乎是最少的成本实现了并发容器的功能，但是效率上就堪忧了。</p><p>再到后来的 Collections 提供的同步工具类：<code>Collections.synchronizedList(new ArrayList&lt;&gt;())</code>。这种方式来创建并发容器，实际上也只是把 synchronized 从方法签名上转移到了方法内部。锁的粒度更细了一些，但也不是那么优秀。</p><p>这两种方式虽然都不是很优秀，但也是一个发展的过程。接下来才是正文。</p><div class="note default flat"><p><strong>为什么普通容器不安全</strong></p></div><p>普通容器没有对写操作和扩容做同步操作，如果多个线程同时写到了同一个位置或者扩容的话，只有一个线程的修改能被保存下来。原理就像是不安全的 <code>i++</code> 一样。</p><p>甚至在 HashMap 中多线程同时扩容还会造成 <code>自己.next = 自己</code> 造成 CPU100% 的情况。具体情况可以参考<a href="https://coolshell.cn/articles/9606.html">这篇文章</a></p><h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><p>Java8 中 的 ConcurrentHashMap 数据结构示意图：</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8-1.png" alt="并发容器-1"></p><p>第一排被框起来的一个个小方块就是 Node 节点类，这里要跟 Java7 的 Segment 区分好，jdk1.7 的 Segment 通过继承 ReentrantLock 来加锁，也就是每次锁住的是一个 Segment 实例，相当于是所有的 Segment 加起来才是完整的 ConcurrentHashMap，在一定程度上提高了并发度。一开始我认为 Java8 的 Node 跟 Java7 的 Segment 一样是不可扩容的，但这里的 Node 是可以扩容的，要区分开。</p><p>正常来说数据都是存放在 Node 数组里面的，如果发生了 hash 冲突，那会从 Node 往后再拉一个链表出来，把冲突的数据放在后面。当这个链表的长度达到 8 并且 Node 数组的长度超过 64，那么就会把链表转换成红黑树来存储冲突数据。</p><p>概括一下 ConcurrentHashMap 中的数据结构为：<code>数组 + 链表 + 红黑树</code></p><h2 id="put-方法流程"><a href="#put-方法流程" class="headerlink" title="put() 方法流程"></a>put() 方法流程</h2><p>方法定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来要分析的内容，onlyIfAbsent：元素是否可重复</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先就是一些常规流程，比如判空、获取新元素 hash 值、以及记录链表长度用于后面判断是否需要链表转红黑树操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line"><span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>根据前面的 ConcurrentHashMap 的数据结构，put() 方法添加的新元素可能会：</p><ul><li>落在 Node 节点上；</li><li>落在 Node 拉出来的链表上；</li><li>落在由链表转换的红黑树上。</li></ul><h3 id="新元素落在-Node-上"><a href="#新元素落在-Node-上" class="headerlink" title="新元素落在 Node 上"></a>新元素落在 Node 上</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自旋，确保肯定能插入成功</span></span><br><span class="line"><span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">    Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">    <span class="comment">// 找到 hash 对应位置的 Node 发现为 null，于是此次 put() 操作应该创建新 Node</span></span><br><span class="line">    <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// CAS 把新 Node 放进去</span></span><br><span class="line">        <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 数据落在链表或者红黑树上的情况，下面的分析将从此处开始</span></span><br><span class="line">        <span class="comment">// 数据落地后判断是否将链表转换成红黑树，该部分分析从此处开始</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h3 id="新元素落在链表上"><a href="#新元素落在链表上" class="headerlink" title="新元素落在链表上"></a>新元素落在链表上</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从此处开始才锁起来，锁的对象是被操作的整个 Node 节点</span></span><br><span class="line"><span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">    <span class="comment">/* 因为刚刚没有锁起来，在这里可能刚刚拿到的 f 节点已经被改了</span></span><br><span class="line"><span class="comment">     * 再做一次判断看看有没有被改，如果被改了那就自旋重来一次 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 关于这里的这个 if 说一点点点我自己的想法吧，</span></span><br><span class="line"><span class="comment">     * 如果是我写这个 if 我会这么写：if (tabAt(tab, i) != f) continue;</span></span><br><span class="line"><span class="comment">     * 首先这么写可以少一层缩进，代码上看起来会舒服一些</span></span><br><span class="line"><span class="comment">     * 另外下面还有一个判断是否要转换成红黑树的操作，直接 continue 的话可以少一次判断，</span></span><br><span class="line"><span class="comment">     * 少这一次判断不是为了省这一点点的判断的性能，而是此时如果其他线程增加了节点导致需要转换红黑树，</span></span><br><span class="line"><span class="comment">     * 那么哪个判断就进去了，虽然 treeifyBin() 方法也是线程安全的，但本来这不该是当前线程去做的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">        <span class="comment">// fh：头节点的 hash 值，大于 0 说明是链表</span></span><br><span class="line">        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            binCount = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 循环找到链表最后一个位置</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                K ek;</span><br><span class="line">                <span class="comment">// 找到了重复的键，判断是否覆盖</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                    oldVal = e.val;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                        e.val = value;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                <span class="comment">// 走到了链表尾，将新元素挂在链表尾部。</span></span><br><span class="line">                <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数据落在红黑树的情况，下面的分析将从此处开始</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="新元素落在红黑树上"><a href="#新元素落在红黑树上" class="headerlink" title="新元素落在红黑树上"></a>新元素落在红黑树上</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头节点是红黑树节点</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">    Node&lt;K,V&gt; p;</span><br><span class="line">    binCount = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 调用红黑树的插值方法插入新节点</span></span><br><span class="line">    <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        oldVal = p.val;</span><br><span class="line">        <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">            p.val = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="是否链转红"><a href="#是否链转红" class="headerlink" title="是否链转红"></a>是否链转红</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表长度超过8转换成红黑树</span></span><br><span class="line"><span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">        <span class="comment">// 走到这里还不一定会转换成红黑树</span></span><br><span class="line">        <span class="comment">// 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树</span></span><br><span class="line">        treeifyBin(tab, i);</span><br><span class="line">    <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> oldVal;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note default flat"><p><strong>为什么链表转红黑树的阈值是8？</strong></p></div><p>根据泊松分布，如果 hash 函数的设计没问题的话，链表长度超过8的概率还不足千万分之一，已经是及其小的概率了。千万不要觉得8这个数字不是那么大就觉得 ConcurrentHashMap 会经常发生链表转红黑树的情况。</p><h3 id="put-流程小结"><a href="#put-流程小结" class="headerlink" title="put() 流程小结"></a>put() 流程小结</h3><ol><li>准备工作：判断 key value 不为空、计算 hash 值等。</li><li>如果：新元素落在新节点上。那么：CAS 新增节点。</li><li>如果：新元素落在链表上。那么：遍历链表插入新元素。</li><li>如果：新元素落在红黑树上。那么：调用红黑树方法插入新节点。</li><li>判断是否需要将链表转换为红黑树</li></ol><p>关于整个 put() 方法的工作流程这里还只是很表面的分析，这里还有几个重量级问题：第一个是初始化，第二个是扩容，第三个是帮助数据迁移。</p><h2 id="get-方法流程"><a href="#get-方法流程" class="headerlink" title="get() 方法流程"></a>get() 方法流程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 ConcurrentHashMap 是否已经初始化完毕，以及对应位置的元素是否已经添加</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 头节点是不是我们想要的节点</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果头结点的 hash 小于 0，说明 正在扩容，或者该位置是红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// find 方法根据 e 的具体实现（ForwardingNode 或 TreeBin）而调用对应方法</span></span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 不是红黑树也不是头节点，那肯定是链表，遍历取出即可</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>get() 流程小结：</strong></p><ol><li>计算 hash 值</li><li>如果：值在 Node 节点中。那么：直接返回。</li><li>如果：正在扩容或者值在红黑树中。那么：调用对应方法找到 val 返回</li><li>如果：都不是。那么：肯定是链表，遍历返回 val</li><li>找不到，返回 null</li></ol><h1 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h1><p>先简单介绍一下 Cpoy On Write 思想吧。Cpoy On Write 就是一种写时复制的操作，字面上意思也很明确：写操作复制。执行写入操作时先复制一份副本，在副本上写入，再将指针指向被修改的副本。优点是在读取的时候不需要加锁，并且读写冲突不会抢锁，仅在写写冲突的时候会抢锁。缺点也很明显，多线程同时写的话会对内存造成比较大的压力；并且保证不了数据的实施一致性，只能保证数据的最终一致性，因为读操作拿到的数据可能不是最新的数据。</p><p>其多线程并发安全由内部数据不可变保证，不可变指的是每次修改都是在副本上修改，所以读取的数据永远不会改变。</p><div class="note default flat"><p><strong>Cpoy On Write 在迭代中的应用：</strong></p></div><p>一些没有 Cpoy On Write 能力的集合（ArrayList）在迭代的时候会发生什么事情：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">    <span class="keyword">for</span> (Integer i : list) </span><br><span class="line">        list.add(<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 方法抛出异常：</span></span><br><span class="line"><span class="comment">// java.util.ConcurrentModificationException</span></span><br></pre></td></tr></table></figure><p>抛出异常的原因也很简单，ArrayList 不允许在迭代的过程中新增或者删除元素。为什么不允许呢？</p><p>因为迭代的过程中新增或删除元素会导致迭代访问元素顺序错乱或者死循环跟下标越界问题。比如：访问到第5个元素的时候把第1个元素删了，此时所有元素往前移了一个位置，那原来的第六个元素的访问就被跳过了。</p><p>foreach 循环依赖了由 ArrayList 提供的 Iterator 对象。Iterator 对象维护了一个 expectedModCount 变量，这个变量记录了 Iterator 对象初始化时 ArrayList 发生了多少次增加或删除元素的操作，ArrayList 每次增加或删除元素都会维护 modCount 变量。于是每次迭代调用 iterator.next() 时都会检查 expectedModCount 与 modCount 是否相等，不相等则抛出 java.util.ConcurrentModificationException 异常。</p><p>上面的代码如果使用 CopyOnWriteArrayList 实现就不会抛出此异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">    <span class="keyword">for</span> (Integer i : list) &#123;</span><br><span class="line">        list.add(<span class="number">6</span>);</span><br><span class="line">        System.out.print(i + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(<span class="string">&quot;\n&quot;</span> + list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 方法输出：</span></span><br><span class="line"><span class="comment">// 1  2  3  4  5  </span></span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6, 6, 6, 6, 6]</span></span><br></pre></td></tr></table></figure><p>结果也是很明显，符合 Copy On Write 原则。新增元素时在副本上增加，不会影响到正在迭代的数据，指针切换后仍然遍历的是旧数据。</p><h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><p>阻塞队列（BlockingQueue）通常用于一个线程生产对象，而另外一个线程消费这些对象的场景。下图是对这个原理的阐述：</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="阻塞队列示意图"></p><p>在这个示意图中，<code>Thread 1</code> 代表生产线程，<code>Thread 2</code> 代表了消费线程。</p><p>生产线程将会持续生产新对象放到阻塞队列中，直到队列达到它所能容纳的临界点。达到临界点再往队列插入新对象时会发生阻塞，直到消费线程从队列中拿走一个对象。消费线程会一直在阻塞队列中拿出对象，如果队列为空的话，消费线程会发生阻塞，直到一个生产线程往队列中插入一个新对象。</p><p>每当有新对象入队时就会唤醒一个消费者线程；每当有一个对象出队时就会唤醒一个生产者线程。</p><div class="note default flat"><p><strong>使用示例：ArrayBlockingQueue</strong></p></div><p>ArrayBlockingQueue 是一个有界的阻塞队列，也是一个 FIFO 队列，其底层由一个不可扩容的数组实现，意味着同一时间能够存储元素数量是有上限的，数组容易在初始化时设定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(BlockingQueue&lt;Integer&gt; queue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.put(<span class="number">1</span>);</span><br><span class="line">            queue.put(<span class="number">2</span>);</span><br><span class="line">            queue.put(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(BlockingQueue&lt;Integer&gt; queue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(queue.take());</span><br><span class="line">            System.out.println(queue.take());</span><br><span class="line">            System.out.println(queue.take());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(queue);</span><br><span class="line">    <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(queue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(producer).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(consumer).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一些其他阻塞队列在实际开发中应当视情况选择合适的队列使用比如：延迟队列 DelayQueue、链阻塞队列 LinkedBlockingQueue、具有优先级的阻塞队列 PriorityBlockingQueue、同步队列 SynchronousQueue 等等。</p><hr><blockquote><p><strong>巨人的肩膀：</strong></p><ul><li><a href="https://www.javadoop.com/post/hashmap">Java7&#x2F;8 中的 HashMap 和 ConcurrentHashMap 全解析</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">从并发容器的发展历史开始，优秀如 ConcurrentHashMap 这样的代码绝不是一朝一夕就可以完成的。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Java并发：final</title>
    <link href="https://www.wrp.cool/posts/38583/"/>
    <id>https://www.wrp.cool/posts/38583/</id>
    <published>2022-08-04T13:50:40.000Z</published>
    <updated>2022-08-26T13:02:01.173Z</updated>
    
    <content type="html"><![CDATA[<p>final 是一个在 Java 基础阶段就会学到的关键字，首先回顾一下 final 的基本用法，再进一步深入了解 final 在并发中的应用。</p><h1 id="final-基本用法"><a href="#final-基本用法" class="headerlink" title="final 基本用法"></a>final 基本用法</h1><h2 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a>修饰类</h2><p>当某个类的整体定义为 final 时，就表明了你不能打算继承该类，而且也不允许别人这么做。即这个类是不能有子类的。</p><p>注意：final 类中的所有方法都隐式为 final，因为无法覆盖他们，所以在 final 类中给任何方法添加 final 关键字是没有任何意义的。</p><div class="note default flat"><p><strong>那么怎么扩展 final 类呢？</strong></p></div><p>设计模式中最重要的两种关系，一种是继承&#x2F;实现；另外一种是组合关系。所以当遇到不能用继承的（final 修饰的类），应该考虑用组合，如下代码大概写个组合实现的意思：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String innerString;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...init &amp; other methods</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 支持老的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> innerString.length(); <span class="comment">// 通过innerString调用老的方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加新方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toMyString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h2><p>final 修饰的方法不能被重写，不过重写的前提是继承，如果 final 修饰的方法同时又是 private 的将会导致子类无法重写此方法，子类可以定义相同的方法名和参数，该方法将成为子类的新方法，而不是继承自父类的方法。</p><p>final 方法虽然不能被重写，但是可以被重载的，如下代码是正确的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">finalFunction</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">finalFunction</span><span class="params">(String name)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类中所有的 private 方法都是隐式 final 的，由于子类看不到父类的 private 方法，所以也就不能重写它。在代码中仍然能够对 private 方法添加 final 修饰符，但是这并没有什么用处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;func from A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;func from B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        a.func(); <span class="comment">// 编译错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修饰参数"><a href="#修饰参数" class="headerlink" title="修饰参数"></a>修饰参数</h2><p>final 修饰的参数不能被改变，被 final 修饰的基本数据类型的参数其值不能被改变，被 final 修饰的引用数据类型的参数其地址不能被改变，但对象内部的数据可以被改变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finalDemo</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> i, <span class="keyword">final</span> User user)</span> &#123;</span><br><span class="line">    user.name = <span class="string">&quot;zhangsan&quot;</span>; <span class="comment">// 正确</span></span><br><span class="line">    i = <span class="number">10</span>;                 <span class="comment">// 错误</span></span><br><span class="line">    user = <span class="keyword">new</span> <span class="title class_">User</span>();      <span class="comment">// 错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h2><p><strong>被 final 修饰的属性不一定都是编译器常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">//编译期常量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">J</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非编译期常量</span></span><br><span class="line">    <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> r.nextInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>k</code> 的值由随机数对象决定，所以不是所有的 final 修饰的字段都是编译期常量，只是 <code>k</code> 的值在被初始化后无法被更改。</p><p><strong>static final 变量</strong></p><p>一个既是static又是final 的字段只占据一段不能改变的存储空间，它必须在定义的时候进行赋值，否则编译器将不予通过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> r.nextInt(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">k2</span> <span class="operator">=</span> r.nextInt(<span class="number">10</span>); </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;k=&quot;</span>+t1.k+<span class="string">&quot; k2=&quot;</span>+t1.k2);</span><br><span class="line">        <span class="type">Test</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;k=&quot;</span>+t2.k+<span class="string">&quot; k2=&quot;</span>+t2.k2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码某次输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k=6 k2=5</span><br><span class="line">k=1 k2=5</span><br></pre></td></tr></table></figure><p>对于不同的对象<code>k</code>的值是不同的，但是<code>k2</code>的值却是相同的，这是为什么呢？<br>因为 static 关键字所修饰的字段并不属于一个对象，而是属于这个类的。也可简单的理解为 static final 所修饰的字段仅占据内存的一个一份空间，一旦被初始化之后便不会被更改。</p><hr><p>对于 final 的基本用法就介绍到这里，接下来介绍 final 在并发中的应用：</p><h1 id="final-域的重排序规则"><a href="#final-域的重排序规则" class="headerlink" title="final 域的重排序规则"></a>final 域的重排序规则</h1><ol><li>在构造函数内对一个 final 域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li><li>初次读一个包含 final 域的对象的引用，与随后初次读这个 final 域，这两个操作之间不能重排序。</li></ol><p><strong>写 final 域的重排序规则：</strong></p><ul><li>JMM 禁止编译器把 final 域的写重排序到构造函数之外。</li><li>编译器会在 final 域的写之后，构造函数 return 之前，插入一个 StoreStore 屏障。这个屏障禁止处理器把 final 域的写重排序到构造函数之外。</li></ul><p><strong>读 final 域的重排序规则：</strong></p><ul><li>在一个线程中，初次读对象引用与初次读该对象包含的 final 域，JMM 禁止处<br>理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读 final 域操作的前面插入一个 LoadLoad 屏障。</li></ul><blockquote><p><strong>巨人的肩膀：</strong></p><ul><li><a href="https://www.infoq.cn/minibook/java_memory_model">深入理解Java内存模型</a></li><li><a href="https://pdai.tech/md/java/thread/java-thread-x-key-final.html">关键字: final详解</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">final 是一个在 Java 基础阶段就会学到的关键字，首先回顾一下 final 的基本用法，再进一步深入了解 final 在并发中的应用。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Java并发：Unsafe、CAS和原子类</title>
    <link href="https://www.wrp.cool/posts/61146/"/>
    <id>https://www.wrp.cool/posts/61146/</id>
    <published>2022-08-04T13:50:18.000Z</published>
    <updated>2022-09-02T09:31:27.820Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我在网上看到一些文章写着：CAS 是一种自旋锁。这是一种错误的观念，CAS 跟自旋其实没什么关系，只是当 CAS 失败的时候通常会使用自旋补偿罢了。换句话说，自旋是 CAS 的一种常见的补偿操作，二者并无直接关系。</p></blockquote><p>我个人认为程序员对于 CAS 这样的一种工具其实不应该是仅仅当作工具去看待，更多的是要掌握 CAS 这种思想，并且运用到实际开发中。比如在商品下单的库存校验部分就可以用到 CAS 思想。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">set</span> reserve <span class="operator">=</span> reserve <span class="operator">-</span> #&#123;buyCount&#125; <span class="keyword">from</span> goods <span class="keyword">where</span> reserve <span class="operator">&gt;=</span> #&#123;buyCount&#125;</span><br></pre></td></tr></table></figure><p>由于单条 SQL 执行的时候具有原子性，就算是秒杀的时候也不会导致库存不足的情况出现，这也是 CAS 的一种体现。</p><p>这也印证了 CAS 和自旋并无直接关系，此处的 CAS 失败应该直接通知用户库存不足，而不是做自旋等待。</p><hr><p>Java 中 CAS 由 Unsafe 类实现，原子类是对 CAS 的包装，对外屏蔽了 Unsafe 类，以及提供一些方便的操作。</p><p>CAS 的全称为 Compare-And-Swap ，直译就是对比交换。是一条 CPU 的原子指令（cmpxchg 指令），其作用是让 CPU 先进行比较两个值是否相等，然后原子地更新某个位置的值。就是说 CAS 是靠硬件实现的，JVM 只是封装了汇编调用，那些 java.util.concurrent.atomic.* 类便是使用了这些封装后的接口，这些接口的提供者就是 Unsafe。</p><p>CAS 操作需要输入两个数值，一个旧值（期望操作前的值）和一个新值，在操作期间先比较下在旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。CAS 操作是原子性的，所以多线程并发使用 CAS 更新数据时，可以不使用锁。JDK 中大量使用了 CAS 来更新数据而防止加锁（synchronized 重量级锁）来保持原子更新。</p><h1 id="Unsafe-类"><a href="#Unsafe-类" class="headerlink" title="Unsafe 类"></a>Unsafe 类</h1><p>Unsafe 是位于 sun.misc 包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升 Java 运行效率、增强 Java 语言底层资源操作能力方面起到了很大的作用。但由于 Unsafe 类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用 Unsafe 类会使得程序出错的概率变大，使得 Java 这种安全的语言变得不再“安全”，因此对 Unsafe 的使用一定要慎重。</p><p>Unsafe 类的设计者并不希望 Unsafe 被轻易的使用，尽管 Unsafe 里面的方法都是 public 的，但是并没有办法使用它们，JDK API 文档也没有提供任何关于这个类的方法的解释。总而言之，对于 Unsafe 类的使用都是受限制的，只有授信的代码才能获得该类的实例，当然 JDK 库里面的类是可以随意使用的。</p><p>Unsafe 类是单例实现的，提供静态方法 getUnsafe 获取 Unsafe 实例，当且仅当调用 getUnsafe 方法的类为引导类加载器所加载时才合法，否则抛出 SecurityException 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Unsafe</span> &#123;</span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe theUnsafe;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Unsafe</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">var0</span> <span class="operator">=</span> Reflection.getCallerClass();</span><br><span class="line">        <span class="comment">// 仅在引导类加载器`BootstrapClassLoader`加载时才合法</span></span><br><span class="line">        <span class="keyword">if</span>(!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;    </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(<span class="string">&quot;Unsafe&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> theUnsafe;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要获取 Unsafe 类实例有以下两种实现方案：</p><p>通过反射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Unsafe <span class="title function_">reflectGetUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> (Unsafe) field.get(<span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">        log.error(e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从getUnsafe方法的使用限制条件出发，通过Java命令行命令-Xbootclasspath&#x2F;a把调用Unsafe相关方法的类A所在jar包路径追加到默认的bootstrap路径中，使得A被引导类加载器加载，从而通过Unsafe.getUnsafe方法安全的获取Unsafe实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xbootclasspath/a: $&#123;path&#125; // path 为调用 Unsafe 相关方法的类所在 jar 包路径 </span><br></pre></td></tr></table></figure><h1 id="Unsafe-对-CAS-的实现"><a href="#Unsafe-对-CAS-的实现" class="headerlink" title="Unsafe 对 CAS 的实现"></a>Unsafe 对 CAS 的实现</h1><p>Unsafe 类中只有三个跟 CAS 有关的方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CAS 实现</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o             包含要修改字段的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> offset        要修改字段在该对象中的内存偏移量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expected      期望值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> update        更新值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>              更新成功 ? true : false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapObject</span><span class="params">(Object o, <span class="type">long</span> offset, Object expected, Object update)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> expected, <span class="type">int</span> update)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapLong</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">long</span> expected, <span class="type">long</span> update)</span>;</span><br></pre></td></tr></table></figure><p>写一个小例子演示怎么使用 Unsafe 的 CAS 操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException &#123;</span><br><span class="line">    <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> reflectGetUnsafe();</span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    u.setId(<span class="number">1001L</span>);</span><br><span class="line">    u.setName(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    u.setAge(<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Field</span> <span class="variable">id</span> <span class="operator">=</span> User.class.getDeclaredField(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">    <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> User.class.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="type">Field</span> <span class="variable">age</span> <span class="operator">=</span> User.class.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">idOffset</span> <span class="operator">=</span> unsafe.objectFieldOffset(id);</span><br><span class="line">    <span class="type">long</span> <span class="variable">nameOffset</span> <span class="operator">=</span> unsafe.objectFieldOffset(name);</span><br><span class="line">    <span class="type">long</span> <span class="variable">ageOffset</span> <span class="operator">=</span> unsafe.objectFieldOffset(age);</span><br><span class="line"></span><br><span class="line">    unsafe.compareAndSwapLong(u, idOffset, <span class="number">1001L</span>, <span class="number">1002L</span>);</span><br><span class="line">    unsafe.compareAndSwapObject(u, nameOffset, <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">    unsafe.compareAndSwapInt(u, ageOffset, <span class="number">18</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// User&#123;id=1002, name=&#x27;lisi&#x27;, age=20&#125;</span></span><br></pre></td></tr></table></figure><div class="note default flat"><p><strong>CAS 存在的问题：</strong></p></div><ol><li><p><strong>ABA 问题</strong><br>因为 CAS 需要在操作值的时候，检查值有没有发生变化，比如没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用 CAS 进行检查时则会发现它的值没有发生变化，但是实际上却变化了。</p><p>ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么 A-&gt;B-&gt;A 就会变成 1A-&gt;2B-&gt;3A。</p></li><li><p><strong>自旋开销过大</strong><br> 自旋CAS如果长时间不成功，会给 CPU 带来非常大的执行开销。</p></li><li><p><strong>只能够保证一个变量的原子操作</strong><br>当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁。</p><p>从 Java 1.5 开始，JDK 提供了 AtomicReference 类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行 CAS 操作。</p></li></ol><h1 id="原子类对-CAS-的包装"><a href="#原子类对-CAS-的包装" class="headerlink" title="原子类对 CAS 的包装"></a>原子类对 CAS 的包装</h1><p>原子类是 JUC 为我们提供的方便程序员使用 CAS 的工具类，位于 java.util.concurrent.atomic 包，该包下的所有类都是原子类。</p><p>接下来将把该包下的原子类分为：</p><ul><li>基本数据类型原子类，以 <code>AtomicInteger</code> 为代表</li><li>数组类型原子类，以 <code>AtomicIntegerArray</code> 为代表</li><li>引用类型原子类，以 <code>AtomicReference</code> 为代表</li><li>原子更新字段类，以 <code>AtomicIntegerFieldUpdater</code> 为代表</li></ul><p>以及解决了 ABA 问题的原子类：<code>AtomicStampedReference</code>，还有 JDK8 新增的 Adder 和 Accumulator</p><h2 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h2><p>AtomicInteger 的构造过程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unsafe 类实例，Unsafe CAS 所需要的偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态加载 value 字段相对当前对象的“起始地址”的偏移量</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset(AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被包装的 int 值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AtomicInteger</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AtomicInteger</span><span class="params">(<span class="type">int</span> initialValue)</span> &#123; value = initialValue; &#125;</span><br></pre></td></tr></table></figure><p><strong>常用 API：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> <span class="comment">// 获取当前的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> <span class="comment">// CAS 更新，expect：预期值，update：更新值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span> <span class="comment">// 获取当前的值，并设置新的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> <span class="comment">// 获取当前的值，并自增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">()</span> <span class="comment">// 获取当前的值，并自减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span> <span class="comment">// 获取当前的值，并加上预期的值</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">lazySet</span><span class="params">(<span class="type">int</span> newValue)</span> <span class="comment">// 最终会设置成 newValue,使用 lazySet 设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span><br></pre></td></tr></table></figure><p>常用 API 具体的使用方法这里就不展开了，JDK API 文档里面都有，其实现原理也比较好理解。</p><h2 id="AtomicIntegerArray"><a href="#AtomicIntegerArray" class="headerlink" title="AtomicIntegerArray"></a>AtomicIntegerArray</h2><blockquote><p>数组中的每个元素都具备原子性。</p></blockquote><p><strong>常用方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> expect, <span class="type">int</span> update)</span> <span class="comment">// CAS 更新，i：数组下标</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">// 获取下标i的元素</span></span><br></pre></td></tr></table></figure><p><strong>常用方法演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AtomicIntegerArray</span> <span class="variable">array</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    array.compareAndSet(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    System.out.println(array.get(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h2 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h2><blockquote><p>使对象具备原子性的修改</p></blockquote><p><strong>常用方法：</strong>compareAndSet(V expect, V update)，与前文相同。</p><p><strong>常用方法演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line">    AtomicReference&lt;User&gt; atomicUser = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(u1);</span><br><span class="line">    System.out.println(atomicUser.get());</span><br><span class="line">    atomicUser.compareAndSet(u1, u2);</span><br><span class="line">    System.out.println(atomicUser.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// User&#123;name=&#x27;zhangsan&#x27;&#125;</span></span><br><span class="line"><span class="comment">// User&#123;name=&#x27;lisi&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p><strong>两个注意点：</strong></p><ol><li>AtomicArray 能够使数组中的每个元素都具有原子性，AtomicReference 可不是让对象里面的每个属性都具有原子性，仅仅是这个对象在修改的时候具有原子性。</li><li>对于 AtomicReference 的使用，可能这里会有一个误区，认为 AtomicReference 对于一个对象的包装好像没什么用处。看完上面的例子之后可能认为不使用 AtomicReference 而直接让 <code>u1 = u2</code> 好像也能达到同样的效果，针对上面的这个例子这确实没错。<strong>但是 <code>u1 = u2</code> 这不是一个原子操作！</strong>具体原因在<a href="https://www.wrp.cool/posts/41498/">Java 内存模型（JMM）</a>的 <em>「JMM 怎么解决原子性问题」</em> 小节中有具体介绍。</li></ol><p>在开篇的时候提到了 CAS 常常会采用自旋来做为失败补偿机制，在这里演示一个 CAS 自旋锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CASSpinLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; casSpinLock = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="keyword">while</span> (!casSpinLock.compareAndSet(<span class="literal">null</span>, current)) &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        sign.compareAndSet(current, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AtomicIntegerFieldUpdater"><a href="#AtomicIntegerFieldUpdater" class="headerlink" title="AtomicIntegerFieldUpdater"></a>AtomicIntegerFieldUpdater</h2><blockquote><p>将一个对象中的某个属性升级为具有原子能力的属性</p></blockquote><p><strong>使用场景：</strong></p><ol><li>在特定场景下才需要某个字段具有原子能力，如果一开始将该对象设计为原子对象，会给内存一定的压力。</li><li>为做不到线程安全的类设置原子能力。</li></ol><p>原子更新字段类的使用与前面的其他原子类有一些不同，主要就是在创建实例对象的时候不同，使用方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    AtomicIntegerFieldUpdater&lt;Data&gt; atomicDataI = AtomicIntegerFieldUpdater.newUpdater(Data.class, <span class="string">&quot;i&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>(<span class="number">0</span>);</span><br><span class="line">    atomicDataI.compareAndSet(data, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    System.out.println(atomicDataI.get(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Data</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意点：</strong></p><ol><li>原子更新字段类是将该字段升级为原子字段，这并不是针对某个对象的升级，而是针对于类的升级，被升级类的全部实例对象都可以使用该原子字段。</li><li>创建后与一般的原子类使用无异。</li></ol><h2 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h2><blockquote><p>需要手动为每次 CAS 更新操作维护一个版本号，以此来解决 ABA 问题。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line">    AtomicStampedReference&lt;User&gt; atomicUser = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(u1, <span class="number">1</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        atomicUser.compareAndSet(u1, u2, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        atomicUser.compareAndSet(u2, u1, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">    t.join();</span><br><span class="line"></span><br><span class="line">    System.out.println(atomicUser.compareAndSet(u1, u2, <span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    System.out.println(atomicUser.compareAndSet(u1, u2, <span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p><code>AtomicStampedFieldUpdater</code> 网上看到很多文章都提到这个类说是啥带版本号原子更新字段啥的，但是在 oracle 文档却没有找到该类，可能是灵异事件吧。</p></blockquote><h2 id="Adder-和-Accumulator"><a href="#Adder-和-Accumulator" class="headerlink" title="Adder 和 Accumulator"></a>Adder 和 Accumulator</h2><p><code>LongAdder</code>、<code>LongAccumulator</code>、<code>DoubleAdder</code>、<code>DoubleAccumulator</code>，这四个类是在 JDK8 中新增的，接下来将主要分析 LongAdder 这个类，其他的几个类都差不多。引入 LongAdder 主要是为了优化 AtomicLong 在多线程并发情况下的效率，其背后的原理也是空间换时间。</p><p>AtomicLong 相对于 LongAdder 的缺点：速度慢，在多线程的情况下竞争同一个变量 <code>value</code> 导致出现大量线程自旋的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">LongAdder</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAdder</span>();</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        service.submit(<span class="keyword">new</span> <span class="title class_">Task</span>(counter));</span><br><span class="line">    &#125;</span><br><span class="line">    service.shutdown();</span><br><span class="line">    <span class="keyword">while</span> (!service.isTerminated()) &#123; &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    System.out.println(counter.sum());</span><br><span class="line">    System.out.println(<span class="string">&quot;LongAdder耗时：&quot;</span> + (end - start));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LongAdder counter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Task</span><span class="params">(LongAdder counter)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.counter = counter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            counter.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我的电脑上这段代码耗时大概是在 100ms 左右。同样的代码如果使用 AtomicLong 实现大概需要 1000ms 左右。二者在多线程的情况下差距十分明显。</p><p>LongAdder 的原理是：在最初无竞争时，只更新 base 的值，当有多线程竞争时通过分段的思想，让不同的线程更新不同的段，最后把这些段相加就得到了完整的 LongAdder 存储的值。</p><div class="note modern default no-icon flat"><p><strong>LongAdder 重要方法：</strong></p></div><p><strong>add(long x) 方法：</strong>使用它可以使LongAdder中存储的值增加x，x可为正可为负。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">long</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// as是Striped64中的cells属性</span></span><br><span class="line">    <span class="comment">// b是Striped64中的base属性</span></span><br><span class="line">    <span class="comment">// v是当前线程hash到的Cell中存储的值</span></span><br><span class="line">    <span class="comment">// m是cells的长度减1，hash时作为掩码使用</span></span><br><span class="line">    <span class="comment">// a是当前线程hash到的Cell</span></span><br><span class="line">    Cell[] as; <span class="type">long</span> b, v; <span class="type">int</span> m; Cell a;</span><br><span class="line">    <span class="comment">// 条件1：cells不为空，说明出现过竞争，cells已经创建</span></span><br><span class="line">    <span class="comment">// 条件2：cas操作base失败，说明其它线程先一步修改了base，正在出现竞争</span></span><br><span class="line">    <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">        <span class="comment">// true表示当前竞争还不激烈</span></span><br><span class="line">        <span class="comment">// false表示竞争激烈，多个线程hash到同一个Cell，可能要扩容</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 条件1：cells为空，说明正在出现竞争，上面是从条件2过来的</span></span><br><span class="line">        <span class="comment">// 条件2：应该不会出现</span></span><br><span class="line">        <span class="comment">// 条件3：当前线程所在的Cell为空，说明当前线程还没有更新过Cell，应初始化一个Cell</span></span><br><span class="line">        <span class="comment">// 条件4：更新当前线程所在的Cell失败，说明现在竞争很激烈，多个线程hash到了同一个Cell，应扩容</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            <span class="comment">// getProbe()方法返回的是线程中的threadLocalRandomProbe字段</span></span><br><span class="line">            <span class="comment">// 它是通过随机数生成的一个值，对于一个确定的线程这个值是固定的</span></span><br><span class="line">            <span class="comment">// 除非刻意修改它</span></span><br><span class="line">            (a = as[getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">            !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line">            <span class="comment">// 调用Striped64中的方法处理</span></span><br><span class="line">            longAccumulate(x, <span class="literal">null</span>, uncontended);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>最初无竞争时只更新base</li><li>直到更新base失败时，创建cells数组</li><li>当多个线程竞争同一个Cell比较激烈时，可能要扩容</li></ol><blockquote><p>请注意，这里的 casBase() 方法失败后，采用的是数组缓解多线程竞争的策略，再一次印证了自旋跟 CAS 没啥必须的关系。</p></blockquote><blockquote><p>具体的 longAccumulate 方法分析可以转至 <a href="https://zhuanlan.zhihu.com/p/65520633">死磕 java并发包之LongAdder源码分析</a> 进行具体了解。大佬写的很好，是我道行不够，看不明白。</p></blockquote><p><strong>sum()方法：</strong>获取LongAdder中真正存储的值的大小，通过把base和所有段相加得到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    <span class="comment">// sum初始等于base</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> base;</span><br><span class="line">    <span class="comment">// 如果cells不为空</span></span><br><span class="line">    <span class="keyword">if</span> (as != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历所有的Cell</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="comment">// 如果所在的Cell不为空，就把它的value累加到sum中</span></span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="literal">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回sum</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 sum() 方法是把base和所有段的值相加得到，那么，这里有一个问题，如果前面已经累加到 sum 上的 Cell 的 value 有修改，不是就没法计算到了么？</p><p>答案确实如此，所以 LongAdder 可以说不是强一致性的，它是最终一致性的。</p><hr><blockquote><p><strong>巨人的肩膀：</strong></p><ul><li><a href="https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html">Java魔法类：Unsafe应用解析</a></li><li><a href="https://pdai.tech/md/java/thread/java-thread-x-juc-AtomicInteger.html">JUC原子类：CAS, Unsafe和原子类详解</a></li><li><a href="https://zhuanlan.zhihu.com/p/65520633">死磕 java并发包之LongAdder源码分析</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">Java 中 CAS 由 Unsafe 类实现，原子类是对 CAS 的包装，对外屏蔽了 Unsafe 类，以及提供一些方便的操作。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Java并发：内存模型（JMM）</title>
    <link href="https://www.wrp.cool/posts/41498/"/>
    <id>https://www.wrp.cool/posts/41498/</id>
    <published>2022-07-26T16:49:31.000Z</published>
    <updated>2022-08-30T05:56:43.618Z</updated>
    
    <content type="html"><![CDATA[<p>并发问题产生的三大根源是「原子性」「可见性」「有序性」，引入 Java 内存模型就是为了解决这三个问题。</p><h1 id="并发问题是怎么产生的"><a href="#并发问题是怎么产生的" class="headerlink" title="并发问题是怎么产生的"></a>并发问题是怎么产生的</h1><div class="note default flat"><p><strong>为什么需要多线程？</strong></p></div><p>众所周知，CPU、内存、I&#x2F;O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为：</p><ul><li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I&#x2F;O 设备的速度差异；&#x2F;&#x2F; 导致 <code>原子性</code> 问题 </li><li>CPU 增加了缓存，以均衡与内存的速度差异；&#x2F;&#x2F; 导致 <code>可见性</code> 问题</li><li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用；&#x2F;&#x2F; 导致 <code>有序性</code> 问题</li></ul><h2 id="原子性是怎么产生并发问题的"><a href="#原子性是怎么产生并发问题的" class="headerlink" title="原子性是怎么产生并发问题的"></a>原子性是怎么产生并发问题的</h2><blockquote><p>原子性问题由分时复用引起</p></blockquote><p>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程1执行</span></span><br><span class="line">i += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程2执行</span></span><br><span class="line">i += <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这里需要注意的是：<code>i += 1</code> 需要三条 CPU 指令 </p><ol><li>将变量 i 从内存读取到 CPU寄存器； </li><li>在CPU寄存器中执行 i + 1 操作；</li><li>将最后的结果i写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。</li></ol><p>由于CPU分时复用（线程切换）的存在，线程1执行了第一条指令后，就切换到线程2执行，假如线程2执行了这三条指令后，再切换会线程1执行后续两条指令，将造成最后写到内存中的i值是2而不是3。</p><h2 id="可见性是怎么产生并发问题的"><a href="#可见性是怎么产生并发问题的" class="headerlink" title="可见性是怎么产生并发问题的"></a>可见性是怎么产生并发问题的</h2><blockquote><p>可见性问题由 CPU 缓存引起</p></blockquote><p>可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1执行的代码</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">i = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2执行的代码</span></span><br><span class="line">j = i;</span><br></pre></td></tr></table></figure><p>假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i &#x3D;10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。</p><p>此时线程2执行 j &#x3D; i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10。</p><p>这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p><h2 id="有序性是怎么产生并发问题的"><a href="#有序性是怎么产生并发问题的" class="headerlink" title="有序性是怎么产生并发问题的"></a>有序性是怎么产生并发问题的</h2><blockquote><p>有序性问题由重排序引起</p></blockquote><p>有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">i = <span class="number">1</span>;        <span class="comment">//语句1  </span></span><br><span class="line">flag = <span class="literal">true</span>;  <span class="comment">//语句2</span></span><br></pre></td></tr></table></figure><p>上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗? 不一定，为什么呢? 这里可能会发生指令重排序（Instruction Reorder）。</p><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</p><ul><li>编译器优化的重排序。编译器在不改变单线程程序语义（as-if-serial 语义）的前提下，可以重新安排语句的执行顺序。</li><li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li>内存系统的重排序。由于处理器使用缓存和读 &#x2F; 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ul><p>从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E9%87%8D%E6%8E%92%E5%BA%8F%E4%BB%8E%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%B0%E6%8C%87%E4%BB%A4%E5%BA%8F%E5%88%97%E6%89%80%E7%BB%8F%E5%8E%86%E6%AD%A5%E9%AA%A4.png" alt="重排序从源代码到指令序列所经历步骤"></p><p>上述的 1 属于编译器重排序，2 和 3 属于处理器重排序，这些重排序都可能会导致多线程程序出现内存可见性问题。</p><ul><li>对于编译器重排序，JMM 的编译器重排序规则会禁止特定类型的编译器重排序。</li><li>对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序。</li></ul><blockquote><p>不管是编译器重排序还是处理器重排序都可以帮助提升程序性能，只是这样的重排序在特定的情况下可能会让代码变得不可靠，所以 JMM 要求在特定情况下是禁止重排序的，此处并非一昧禁止重排序。</p></blockquote><p>同样的，JMM 也不是一昧允许重排序，那么：<strong>重排序的规则是什么？</strong><br>由于篇幅问题此处不做展开，感兴趣的同学请移步：<a href="https://www.wrp.cool/posts/41133/">重排序所遵循的规则</a></p><h1 id="JMM-是怎么解决并发问题的"><a href="#JMM-是怎么解决并发问题的" class="headerlink" title="JMM 是怎么解决并发问题的"></a>JMM 是怎么解决并发问题的</h1><ul><li><strong>JMM 为我们提供了什么工具来解决并发问题？</strong></li><li>JMM 为我们提供了 synchronized、final、volatile、Lock锁、Happens-Before 规则。利用好这些工具能帮我们解决并发问题。</li></ul><h2 id="JMM-怎么解决原子性问题"><a href="#JMM-怎么解决原子性问题" class="headerlink" title="JMM 怎么解决原子性问题"></a>JMM 怎么解决原子性问题</h2><blockquote><p>JMM 要求对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。 </p></blockquote><p>请分析以下哪些操作是原子性操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span>;     <span class="comment">// 语句1：直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中</span></span><br><span class="line">y = x;      <span class="comment">// 语句2：包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</span></span><br><span class="line">x++;        <span class="comment">// 语句3：x++包括3个操作：读取x的值，进行加1操作，写入新的值。</span></span><br><span class="line">x = x + <span class="number">1</span>;  <span class="comment">// 语句4：同语句3</span></span><br></pre></td></tr></table></figure><p>上面4个语句只有语句1的操作具备原子性。</p><p>也就是说，只有简单的读取、赋值（必须是将数字赋值给某个变量）才是原子操作。变量之间的相互赋值不是原子操作。</p><blockquote><p>从上面可以看出，JMM 只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过 synchronized 和 Lock 来实现。由于 synchronized 和 Lock 能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p></blockquote><h2 id="JMM-怎么解决可见性问题"><a href="#JMM-怎么解决可见性问题" class="headerlink" title="JMM 怎么解决可见性问题"></a>JMM 怎么解决可见性问题</h2><p>JMM 提供了 volatile 关键字来保证可见性。</p><p>当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p><p>由于篇幅问题此处不对 volatile 做展开，感兴趣的同学请移步<a href="https://www.wrp.cool/posts/63338/">Java并发：volatile</a></p><p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p><blockquote><p>另外，synchronized 和 Lock 也能够保证可见性，synchronized 和 Lock 能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p></blockquote><h2 id="JMM-怎么解决有序性问题"><a href="#JMM-怎么解决有序性问题" class="headerlink" title="JMM 怎么解决有序性问题"></a>JMM 怎么解决有序性问题</h2><p>JMM 提供了 Happens-Before 规则在一定程度上保证了有序性</p><p>一个 happens-before 规则通常对应于多个编译器重排序规则和处理器重排序规则。对于 java 程序员来说，happens-before 规则简单易懂，它避免程序员为了理解 JMM 提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现。 </p><div class="note simple default no-icon flat"><p><strong>规则一：程序顺序规则</strong><br>在一个线程中，按照代码的顺序，前面的操作 Happens-Before 于后面的任意操作。</p></div><p>在这条规则下可能会有一个疑问：<strong>既然指令可以重排序又怎么保证程序顺序规则？</strong></p><blockquote><p>以 Happens-Before 的角度回答这个问题：</p></blockquote><p>JMM 通过 Happens-Before 关系向开发人员提供<strong>跨越线程</strong>的内存可见性保证。</p><p>如果一个操作的执行结果对另外一个操作可见，那么这两个操作之间必然存在 Happens-Before 管理。</p><p>其次，Happens-Before 关系只是描述结果的可见性，并不表示指令执行的先后顺序，也就是说只要不对结果产生影响，仍然允许指令的重排序。</p><blockquote><p>以重排序的角度回答这个问题：</p></blockquote><p>在程序顺序规则下，JMM 并不是不允许重排序，JMM 仅仅要求前一个操作（执行的结果）对后一个操作可见。</p><p>假设根据程序顺序规则有 A Happens-Before B 如果操作A的结果不需要对操作B可见，并且操作A和操作B重排序前后的执行结果一致；</p><p>在这种情况下 JMM 会认为这种重排序并不非法，JMM 允许这种重排序。</p><div class="note simple default no-icon flat"><p><strong>规则二：volatile变量规则</strong><br>对一个 volatile 变量的写操作，Happens-Before 于后续对这个变量的读操作。</p></div><p>也就是说对一个 volatile 变量而言，肯定不会发生可见性问题。</p><p>因为 volatile 写完会被立即刷回主内存中，而读操作发生在这之后，那么每次读取都会读取到最新值。</p><div class="note simple default no-icon flat"><p><strong>规则三：传递规则</strong><br>如果A Happens-Before B，并且B Happens-Before C，则A Happens-Before C。</p></div><p>这个规则比较简单，此处不做展开。</p><div class="note simple default no-icon flat"><p><strong>规则四：锁定规则</strong><br>对一个锁的解锁操作 Happens-Before 于后续对这个锁的加锁操作。</p></div><p>这个很好理解，同一把锁的情况下，肯定是要先解锁才能再次上锁。已经锁了的情况下总不能再锁一次吧。</p><div class="note simple default no-icon flat"><p><strong>规则五：线程启动规则</strong><br>如果线程A调用线程B的 start() 方法来启动线程B，则 start() 操作 Happens-Before 于线程B中的任意操作。</p></div><p>我们也可以这样理解线程启动规则：线程A启动线程B之后，线程B能够看到线程A在启动线程B之前的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在线程A中初始化线程B</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="comment">//此处的变量x的值是多少呢？答案是100</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//线程A在启动线程B之前将共享变量x的值修改为100</span></span><br><span class="line">x = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//启动线程B</span></span><br><span class="line">threadB.start();</span><br></pre></td></tr></table></figure><p>上述代码是在线程A中执行的一个代码片段，根据线程启动规则，线程A启动线程B之后，线程B能够看到线程A在启动线程B之前的操作，在线程B中访问到的x变量的值为100。</p><div class="note simple default no-icon flat"><p><strong>规则六：线程终结规则</strong><br>线程A等待线程B完成（在线程A中调用线程B的 join() 方法实现），当线程B完成后（线程A调用线程B的 join() 方法返回），则线程A能够访问到线程B对共享变量的操作。</p></div><p>我们也可以这样理解线程终结规则：线程A的 join() 方法返回之后，线程A能看到线程B的所有操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//在线程B中，将共享变量x的值修改为100</span></span><br><span class="line">        x = <span class="number">100</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//在线程A中启动线程B</span></span><br><span class="line">    t.start();</span><br><span class="line">    <span class="comment">//在线程A中等待线程B执行完成</span></span><br><span class="line">    t.join();</span><br><span class="line">    <span class="comment">//此处访问共享变量x的值为100</span></span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note simple default no-icon flat"><p><strong>规则七：线程中断规则</strong><br>对线程 interrupt() 方法的调用 Happens-Before 于被中断线程的代码检测到中断事件的发生。</p></div><p>我们也可以这样理解线程中断规则：在 InterruptedException 的 catch 代码块中能够看到调用 interrupt() 方法之前的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在线程A中将x变量的值初始化为0</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//在线程A中初始化线程B</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="comment">//线程B检测自己是否被中断</span></span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted())&#123; &#125;</span><br><span class="line">        <span class="comment">//如果线程B被中断，则此时X的值为100</span></span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//在线程A中启动线程B</span></span><br><span class="line">    threadB.start();</span><br><span class="line">    <span class="comment">//在线程A中将共享变量X的值修改为100</span></span><br><span class="line">    x = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//在线程A中中断线程B</span></span><br><span class="line">    threadB.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note simple default no-icon flat"><p><strong>规则八：对象终结规则</strong><br>一个对象的初始化完成 Happens-Before 于它的 finalize() 方法的开始。</p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">TestThread</span><span class="params">()</span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;构造方法&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对象销毁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">TestThread</span>();</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p><strong>巨人的肩膀：</strong></p><ul><li><a href="https://pdai.tech/md/java/thread/java-thread-x-theorty.html">Java 并发 - 理论基础</a></li><li><a href="https://www.infoq.cn/minibook/java_memory_model">深入理解Java内存模型</a></li><li><a href="https://cloud.tencent.com/developer/article/1734515">何为Happens-Before原则？这次彻底懂了！</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">并发问题产生的三大根源是「原子性」「可见性」「有序性」，引入 Java 内存模型就是为了解决这三个问题。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Java并发：锁分类和介绍</title>
    <link href="https://www.wrp.cool/posts/40896/"/>
    <id>https://www.wrp.cool/posts/40896/</id>
    <published>2022-07-18T12:04:39.000Z</published>
    <updated>2022-08-30T05:50:55.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lock-接口"><a href="#Lock-接口" class="headerlink" title="Lock 接口"></a>Lock 接口</h1><p>Lock 并不是用于替代 synchronized 的，而是当使用 synchronized 不合适或者不满足要求的时候，为业务提供高级功能的。</p><div class="note info simple no-icon flat"><p><strong>synchronized 的缺点：</strong></p></div><ul><li><strong>效率低：</strong>锁的释放情况比较少、试图获取锁不能设定超时、不能中断一个正在试图获取锁的线程</li><li><strong>不够灵活：</strong>加锁和释放锁的时机单一、每个锁仅有单一的对象</li><li><strong>无法知道是否成功获取到锁：</strong>如果拿到锁了，我们也不知道，拿不到锁只能阻塞</li></ul><div class="note info simple no-icon flat"><p><strong>Lock 接口中的重要方法：</strong></p></div><ul><li><strong>void lock();</strong><ul><li>获取锁，如果拿不到锁，就阻塞</li><li>不会像 synchronized 一样在异常的时候自动释放锁</li><li>必须在 finally 中释放锁，以保证异常时锁一定被释放</li><li>阻塞不能被中断，一旦陷入死锁，就会永久等待</li></ul></li><li><strong>void lockInterruptibly() throws InterruptedException;</strong><ul><li>与 lock() 一样，但在等待锁的过程中可被中断</li></ul></li><li><strong>boolean tryLock();</strong><ul><li>尝试获取锁，获取成功返回 true，获取失败返回 false</li><li>该方法立即返回，不会阻塞</li></ul></li><li><strong>boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</strong><ul><li>与 tryLock() 相同，但可以设置超时时间，在超时时间阻塞</li></ul></li><li><strong>void unlock();</strong><ul><li>释放锁</li></ul></li></ul><div class="note primary modern"><p><strong>锁的分类思维导图：</strong></p></div><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/Java%E9%94%81%E5%88%86%E7%B1%BB%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.png" alt="Java锁分类思维导图"></p><h1 id="悲观锁-VS-乐观锁"><a href="#悲观锁-VS-乐观锁" class="headerlink" title="悲观锁 VS 乐观锁"></a>悲观锁 VS 乐观锁</h1><p>乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。</p><div class="note primary simple no-icon flat"><p><strong>为什么会出现乐观锁：</strong></p></div><ol><li>悲观锁的阻塞和唤醒带来的性能损耗</li><li>悲观锁可能会出现死锁</li><li>悲观锁可能会出现线程优先级反转，优先级低的线程拿到锁之后不释放，优先级高的线程反而需要等待优先级低的线程释放锁</li></ol><div class="note primary simple no-icon flat"><p>针对同一个数据的并发操作，<strong>悲观锁与乐观锁有以下不同：</strong></p></div><ul><li><strong>悲观锁：</strong>悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。</li><li><strong>乐观锁：</strong>乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。</li></ul><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81.png" alt="乐观锁和悲观锁"></p><ul><li>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。</li><li>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</li></ul><h1 id="公平锁-VS-非公平锁"><a href="#公平锁-VS-非公平锁" class="headerlink" title="公平锁 VS 非公平锁"></a>公平锁 VS 非公平锁</h1><blockquote><p><strong>为什么会出现非公平锁？</strong><br>避免唤醒线程带来的 CPU 开销，以及避免了线程唤醒期间带来的无线程持有锁导致的资源浪费。</p><ul><li><strong>例如：</strong></li><li>线程A 释放锁 线程B 准备获取锁</li><li>CPU 开始唤醒 线程B</li><li>线程C 申请获取锁</li><li>将锁先给 线程C，线程C 执行完之后再将锁还给 线程B</li></ul><p>线程B 可能会稍微等待一会，但是在此期间保证锁一直都有线程使用，没有浪费。并且 CPU 不必唤醒 线程C，节省了一次线程唤醒带来的开销。</p></blockquote><ul><li><p><strong>公平锁：</strong></p><ul><li>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。</li><li>优点：等待锁的线程不会饿死。</li><li>缺点：整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</li></ul></li><li><p><strong>非公平锁：</strong></p><ul><li>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。</li><li>优点：可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。</li><li>缺点：是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</li></ul></li></ul><blockquote><p>假设有一口水井，有管理员看守，管理员有一把锁，只有拿到锁的人才能够打水，打完水要把锁还给管理员。每个过来打水的人都要管理员的允许并拿到锁之后才能去打水，如果前面有人正在打水，那么这个想要打水的人就必须排队。管理员会查看下一个要去打水的人是不是队伍里排最前面的人，如果是的话，才会给你锁让你去打水；如果你不是排第一的人，就必须去队尾排队，这就是公平锁。</p></blockquote><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E5%85%AC%E5%B9%B3%E9%94%81%E6%BC%94%E7%A4%BA.png" alt="公平锁演示"></p><blockquote><p>对于非公平锁，管理员对打水的人没有要求。即使等待队伍里有排队等待的人，但如果在上一个人刚打完水把锁还给管理员而且管理员还没有允许等待队伍里下一个人去打水时，刚好来了一个插队的人，这个插队的人是可以直接从管理员那里拿到锁去打水，不需要排队，原本排队等待的人只能继续等待。</p></blockquote><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E6%BC%94%E7%A4%BA.png" alt="非公平锁演示"></p><h1 id="共享锁-VS-独占锁"><a href="#共享锁-VS-独占锁" class="headerlink" title="共享锁 VS 独占锁"></a>共享锁 VS 独占锁</h1><p>共享锁也成为读锁，指的是该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。顾名思义共享锁在各个线程之间是共享的，只要是读请求的线程都能够同时持有这把锁。</p><p>独享锁也叫排他锁、写锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是独享锁。</p><p>共享锁和独占锁在 Java 中经典的应用就是在 ReentrantReadWriteLock 这个类中了，深入到这个类的源码中发现这个类还实现了公平锁与非公平锁，在非公平锁的情况下就会有一个问题：<strong>想要获取写锁的线程可能会被饿死。</strong></p><blockquote><p><strong>为什么？</strong><br>非公平锁是可以插队的，如果当前有一个线程持有了读锁，一个需要写锁的线程正在排队；此时又来了一个需要读锁的线程，那么该线程可以直接持有读锁；但是哪个需要写锁的线程获取锁的时间就又要等待第二个持有读锁的线程执释放锁才能获取到锁；如果后面源源不断的出现需要读锁的线程，这些线程都能够直接持有读锁，那么哪个需要写锁的线程就会被饿死。长时间得不到执行。</p></blockquote><p>为了保证非公平锁的效率和避免出现写锁线程被饿死的情况，在非公平情况下肯定要对获取读锁做出一些限制。</p><div class="note modern primary flat"><p><strong>ReentrantReadWriteLock 非公平锁源码：</strong></p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">8159625535654395037L</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">writerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 写锁在任何情况下都可以插队</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">readerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/* 为了避免需要写锁的线程被饿死的情况</span></span><br><span class="line"><span class="comment">         * 仅当等待队列头的线程是等待写锁的线程，阻塞当前读线程</span></span><br><span class="line"><span class="comment">         * 有一定的概率出现这种情况，因为如果队首线程是等待读锁的线程</span></span><br><span class="line"><span class="comment">         * 而等待写锁的线程排在后面一点，当队首的读线程还没拿到锁的情况下</span></span><br><span class="line"><span class="comment">         * 新来的读锁线程还是可以插队的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="可重入锁-VS-不可重入锁"><a href="#可重入锁-VS-不可重入锁" class="headerlink" title="可重入锁 VS 不可重入锁"></a>可重入锁 VS 不可重入锁</h1><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。下面用示例代码来进行分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法1执行...&quot;</span>);</span><br><span class="line">        doOthers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doOthers</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法2执行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，类中的两个方法都是被内置锁 synchronized 修饰的，doSomething() 方法中调用 doOthers() 方法。因为内置锁是可重入的，所以同一个线程在调用 doOthers() 时可以直接获得当前对象的锁，进入 doOthers() 进行操作。</p><p>如果是一个不可重入锁，那么当前线程在调用 doOthers() 之前需要将执行 doSomething() 时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。</p><div class="note primary simple no-icon flat"><p><strong>可重入举例：</strong></p></div><p>有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E5%8F%AF%E9%87%8D%E5%85%A5%E6%BC%94%E7%A4%BA.png" alt="可重入演示"></p><div class="note primary simple no-icon flat"><p><strong>可重入举例：</strong></p></div><p>管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E6%BC%94%E7%A4%BA.png" alt="不可重入演示"></p><h1 id="自旋锁-VS-适应性自旋锁"><a href="#自旋锁-VS-适应性自旋锁" class="headerlink" title="自旋锁 VS 适应性自旋锁"></a>自旋锁 VS 适应性自旋锁</h1><blockquote><p><strong>自旋锁：</strong></p><p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p><p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p><p>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p></blockquote><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E8%87%AA%E6%97%8B%E9%94%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="自旋锁工作流程图"></p><p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。</p><p>自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">    <span class="type">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>巨人的肩膀：</strong></p><ul><li><a href="https://tech.meituan.com/2018/11/15/java-lock.html">不可不说的Java“锁”事</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">锁是一种工具，用于控制对共享资源的访问。</summary>
    
    
    
    <category term="Java" scheme="https://www.wrp.cool/categories/Java/"/>
    
    <category term="并发" scheme="https://www.wrp.cool/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发：ThreadLocal</title>
    <link href="https://www.wrp.cool/posts/12951/"/>
    <id>https://www.wrp.cool/posts/12951/</id>
    <published>2022-07-16T06:58:24.000Z</published>
    <updated>2022-08-29T07:41:04.616Z</updated>
    
    <content type="html"><![CDATA[<p>在线程池中必不可免的需要面对线程安全问题，在并发执行同一个任务的情况下，肯定需要访问到一些公共的对象，也就是会出现多个线程访问同一个对象的情况，这就涉及到了线程安全的问题。</p><p>这个时候就需要为线程池中的每一个线程都准备一个单独的变量供线程池中的每个线程去使用了。</p><div class="note warning modern no-icon flat"><p>于是：ThreadLocal 登场了。</p></div><p>说说我的理解吧，我认为 ThreadLocal 其实是一个封装的工具，可以使用 ThreadLocal 将线程池中各个线程都要访问到的对象封装起来，之后各个线程去访问被包装对象的时候，ThreadLocal 会生成一个这个对象的副本，也就是重新创建这个对象给线程去使用，以此将每个线程隔离开来，使得每个线程都能够拥有独属于自己的对象。</p><p>基于 ThreadLocal 为每个线程设置独享对象的特性，可以衍生出两个用法：</p><ul><li>隔离共享对象，用于保证线程安全</li><li>设置线程内的全局变量，在同一个线程内免去了参数传递的麻烦</li></ul><h1 id="ThreadLocal-用法一：隔离对象，保证线程安全"><a href="#ThreadLocal-用法一：隔离对象，保证线程安全" class="headerlink" title="ThreadLocal 用法一：隔离对象，保证线程安全"></a>ThreadLocal 用法一：隔离对象，保证线程安全</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateUtils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;DateFormat&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;DateFormat&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> DateFormat <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面的代码的简写形式</span></span><br><span class="line">    <span class="comment">// public static final ThreadLocal&lt;DateFormat&gt; threadLocal = ThreadLocal.withInitial(() -&gt; new SimpleDateFormat(&quot;yyyy-MM-dd&quot;));</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用方式</span></span><br><span class="line">        <span class="type">DateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> DateUtils.threadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 SimpleDateFormat 对象并不是线程安全的，如果在线程池中需要用到 SimpleDateFormat 对象的话，是不能让所有线程共用同一个对象的，那样会出现线程不安全问题。但如果线程每次运行都创建一个新的 SimpleDateFormat 对象的话，那么又太浪费资源了。</p><p>实际上这里还有一个解决方式：把用到 SimpleDateFormat 对象的地方都抽取出来加上 synchronized 关键字，把 SimpleDateFormat 对象给锁上，但是每个线程要使用的时候又都要去排队，这也并不是一个好方法，特别是线程池在执行的情况下，并发量很大，排队的时间就会很长。</p><blockquote><p>使用 ThreadLocal 之后是一个什么样的流程呢？</p></blockquote><ol><li>线程需要使用 SimpleDateFormat 对象</li><li>调用 initialValue() 方法，生成一个 SimpleDateFormat 对象</li><li>给到需要的线程去使用，之后再保存在线程中，下次再要用了直接拿出来就可以了</li><li>也就是一个懒加载的方式</li></ol><h1 id="ThreadLocal-用法二：设置线程内的全局变量"><a href="#ThreadLocal-用法二：设置线程内的全局变量" class="headerlink" title="ThreadLocal 用法二：设置线程内的全局变量"></a>ThreadLocal 用法二：设置线程内的全局变量</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;User&gt; userContextHolder = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Interceptor</span>().checkingLogin(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkingLogin</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        userContextHolder.set(user);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Controller</span>().getList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Controller</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userContextHolder.get();</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Service</span>().getList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userContextHolder.get();</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 防止内存泄漏</span></span><br><span class="line">        userContextHolder.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name)</span> &#123; <span class="built_in">this</span>.name = name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="string">&quot;User&#123;name=&#x27;&quot;</span> + name + <span class="string">&quot;&#x27;&#125;&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以利用 ThreadLocal 在线程中传递参数，免去了到处传参的麻烦，使用的话就像上面的这段代码一样就可以了。</p><div class="note danger modern"><p><strong>存在内存泄漏的风险，使用完一定要调用 remove() 释放 user 对象。</strong></p></div><h1 id="ThreadLocal-是怎么做到线程隔离的"><a href="#ThreadLocal-是怎么做到线程隔离的" class="headerlink" title="ThreadLocal 是怎么做到线程隔离的"></a>ThreadLocal 是怎么做到线程隔离的</h1><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/ThreadLocal%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="ThreadLocal原理图"></p><ol><li>每个 Thread 都有一个唯一对应的 ThreadLocalMap<ul><li>ThreadLocalMap 以 ThreadLocal 对象为键，值是 initialValue() 或者 set() 方法中我们自己设置的</li></ul></li><li>首次调用 get() 方法时，ThreadLocal 会为当前线程初始化 ThreadLocalMap</li><li>再调用 initialValue() 方法，返回对应的我们设置的对象，以该对象为值，ThreadLocal 对象为键存储至 ThreadLocalMap</li><li>再返回该对象给线程使用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取线程自己的 ThreadLocalMap</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 ThreadLocalMap</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用重载的 initialValue() 方法获取需要设置的值</span></span><br><span class="line">    <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><div class="note info modern"><p><strong>小结：</strong></p></div><blockquote><ol><li>ThreadLocal 中的值是保存在 Thread.ThreadLocalMap 中的，这可能也是为什么叫 ThreadLocal 吧</li><li>取值的方式是懒加载的，实际上也只能懒加载。<br>我们可能会定义很多个 ThreadLocal 对象出来用，但并不是每个线程都需要用到全部的 ThreadLocal，没到要用的时候程序也无法预先判断这个线程需要用到哪些 ThreadLocal。</li></ol></blockquote><h1 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h1><blockquote><p>ThreadLocalMap 是 ThreadLocal 的一个静态内部类，没有实现 Map 接口，底层由 Entry 数组实现。</p></blockquote><ul><li>ThreadLocalMap 键：ThreadLocal 对象</li><li>ThreadLocalMap 值：通过 initialValue() 或 set() 方法传入的对象</li></ul><div class="note info modern no-icon flat"><p><strong>Entry 类：</strong></p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThrealLocalMap 键值对实现的具体对象，需要注意的是 <code>k</code> 是一个弱引用。</p><blockquote><p><strong>Java 中的四种引用类型：</strong></p><ul><li><strong>强引用：</strong>我们常常 new 出来的对象就是强引用类型，只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足的时候</li><li><strong>软引用：</strong>使用 SoftReference 修饰的对象被称为软引用，软引用指向的对象在内存要溢出的时候被回收</li><li><strong>弱引用：</strong>使用 WeakReference 修饰的对象被称为弱引用，只要发生垃圾回收，若这个对象只被弱引用指向，那么就会被回收</li><li><strong>虚引用：</strong>虚引用是最弱的引用，在 Java 中使用 PhantomReference 进行定义。虚引用中唯一的作用就是用队列接收对象即将死亡的通知</li></ul></blockquote><p>往 ThreadLocalMap 中添加元素：set() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 hash 找到 key 在 Entry[] 的第一个下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决 hash 冲突</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i]; e != <span class="literal">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get(); <span class="comment">// get() 方法由 WeakReference 继承自 Reference 而来</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前 ThreadLocal 已经存在，则覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果找到的 e 不为空，但是 k 为空，则证明该 k 被 gc 回收</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到可插入位置，新建元素</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">    <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ThreadLocalMap 的冲突处理：往后继续找到合适的位置插入，而不是在该位置拉一个链表或者红黑树。</p></blockquote><p>从 ThreadLocalMap 中取出元素：getEntry() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到第一个 key 比较与传入的 key 是否相等，相等直接返回，不相等由哈希冲突策略继续往下找</span></span><br><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先找到ThreadLocal的索引位置, 如果索引位置处的entry不为空并且键与threadLocal是同一个对象, 则直接返回; 否则去后面的索引位置继续查找。</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>ThreadLocal 是 ThreadPool 的好朋友，借助 ThreadLocal 可以实现多线程环境下的线程安全，或者为单独的线程设置全局变量</li><li>ThreadLocal 是一个将线程不安全对象变成线程安全的工具，具体将被包装的对象为每个线程都做一份拷贝，大家各自用各自的变量，不争不抢，线程就安全了</li><li>Thread 会维护自己的 ThreadLocalMap，以 ThreadLocal 为键，set() 或 initialValue() 中的返回对象为值</li><li>ThreadLocalMap 是 ThreadLocal 的静态内部类，不实现 Map 接口</li><li>ThreadLocalMap 处理哈希冲突的策略是：向后移位，直到找到合适位置为止</li></ol><hr><blockquote><p><strong>巨人的肩膀：</strong><br><a href="https://pdai.tech/md/java/thread/java-thread-x-threadlocal.html">Java 并发 - ThreadLocal详解</a><br><a href="https://javaguide.cn/java/concurrent/threadlocal.html">万字解析 ThreadLocal 关键字</a></p></blockquote>]]></content>
    
    
    <summary type="html">ThreadLocal 是线程池的好朋友，它可以让每个线程都拥有自己的对象，而不是去跟别的线程共享同一个对象，以此达到线程安全。</summary>
    
    
    
    <category term="线程" scheme="https://www.wrp.cool/categories/%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.wrp.cool/tags/Java/"/>
    
    <category term="线程" scheme="https://www.wrp.cool/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java并发：线程池</title>
    <link href="https://www.wrp.cool/posts/19352/"/>
    <id>https://www.wrp.cool/posts/19352/</id>
    <published>2022-07-13T18:52:07.000Z</published>
    <updated>2022-08-29T11:12:42.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h1><div class="note info no-icon flat"><p><strong>多线程使用会出现的两个问题：</strong></p></div><ol><li>多个线程会占用过多内存</li><li>反复创建线程开销过大</li></ol><div class="note info no-icon flat"><p><strong>解决这两个问题的方法：</strong></p></div><ol><li>使用尽量少线程，不让太多线程占用内存。</li><li>让这部分线程都保持工作，可以反复执行任务。避免线程生命周期的损耗。</li></ol><hr><p>线程池最核心的部分：<strong>让线程可以反复执行任务</strong>。</p><blockquote><p>一段伪代码大概演示线程池最重要的线程复用的方式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> Queue.pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (task != <span class="literal">null</span>) &#123;</span><br><span class="line">    task.run();</span><br><span class="line">    task = Queue.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h1><h2 id="手动创建"><a href="#手动创建" class="headerlink" title="手动创建"></a>手动创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CORE_POOL_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_POOL_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空闲线程存活时间、单位。非核心线程空闲时间超过此参数将会被回收</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">KEEP_ALIVE_TIME</span> <span class="operator">=</span> <span class="number">60</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">TimeUnit</span> <span class="variable">UNIT</span> <span class="operator">=</span> TimeUnit.SECONDS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池所使用的缓冲队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; WORK_QUEUE = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池创建线程使用的工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadFactory</span> <span class="variable">THREAD_FACTORY</span> <span class="operator">=</span> Thread::<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池拒绝处理任务时的拒绝策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">RejectedExecutionHandler</span> <span class="variable">HANDLER</span> <span class="operator">=</span> (Runnable r, ThreadPoolExecutor e) -&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(<span class="string">&quot;Task &quot;</span> + r.toString() +</span><br><span class="line">            <span class="string">&quot; rejected from &quot;</span> +</span><br><span class="line">            e.toString());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ThreadPoolExecutor</span> <span class="variable">executorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            CORE_POOL_SIZE,</span><br><span class="line">            MAXIMUM_POOL_SIZE,</span><br><span class="line">            KEEP_ALIVE_TIME,</span><br><span class="line">            UNIT,</span><br><span class="line">            WORK_QUEUE,</span><br><span class="line">            THREAD_FACTORY,</span><br><span class="line">            HANDLER</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里也感叹一下线程池的封装，将所有的操作参数全部暴露出来给到调用者去设置，最大程度的将线程池的内部逻辑与用户操作部分解耦。真是好设计啊，值得学习。<br>能考虑的这么全面，要是我来设计的话估计就只能是暴露个 <code>CORE_POOL_SIZE</code>出来就差不多了。</p></blockquote><div class="note primary modern"><p><strong>线程池添加线程规则：</strong></p></div><ol><li>如果线程数小于 <code>CORE_POOL_SIZE</code>，即使其他工作线程处于空闲状态，也会创建一个新的线程来运行新任务。</li><li>如果线程数等于（或大于）<code>CORE_POOL_SIZE</code> 但少于 <code>MAXIMUM_POOL_SIZE</code>，则将任务放入队列。</li><li>如果队列已满，并且线程数小于 <code>MAXIMUM_POOL_SIZE</code>，则创建一个新线程来运行任务。</li><li>如果队列已满，并且线程数大于或等于 <code>MAXIMUM_POOL_SIZE</code>，则拒绝该任务。</li></ol><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%B7%BB%E5%8A%A0%E7%BA%BF%E7%A8%8B%E8%A7%84%E5%88%99.png" alt="线程池添加线程规则"></p><h2 id="自动创建"><a href="#自动创建" class="headerlink" title="自动创建"></a>自动创建</h2><blockquote><p>线程池的自动创建是利用 <code>Executors</code> 工具类中的静态方法来创建线程池对象。<code>Executors</code> 为我们定义了一些比较有特性的线程池。如下是四个常用的线程池：</p></blockquote><hr><div class="note primary modern no-icon flat"><p><strong>FixedThreadPool</strong>：定长线程池<br>可控制线程最大并发数，超出的线程会在队列中等待。</p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><div class="note primary modern no-icon flat"><p><strong>CachedThreadPool</strong>：可缓存线程池<br>如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><div class="note primary modern no-icon flat"><p><strong>SingleThreaded</strong>：单线程的线程池<br>只会用唯一的工作线程来执行任务。</p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><div class="note primary modern no-icon flat"><p><strong>ScheduledThreadPool</strong>：支持定时及周期性任务执行<br>可以当做定时任务使用。</p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建</span></span><br><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">scheduledExecutorService</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, TimeUnit.NANOSECONDS, <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延迟 5s 执行</span></span><br><span class="line">scheduledExecutorService.schedule(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// run 方法</span></span><br><span class="line">&#125;, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延迟 1s 执行，之后每隔 3s 执行一次</span></span><br><span class="line">scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// run 方法</span></span><br><span class="line">&#125;, <span class="number">1</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><hr><p><strong>以上四种线程构造函数参数对比：</strong></p><table><thead><tr><th align="left">Paramter</th><th align="left">FixedThreadPool</th><th align="left">CachedThreadPool</th><th align="left">SingleThreaded</th><th align="left">ScheduledThreadPool</th></tr></thead><tbody><tr><td align="left">corePoolSize</td><td align="left">constructor-arg</td><td align="left">0</td><td align="left">1</td><td align="left">constructor-arg</td></tr><tr><td align="left">maxPoolSize</td><td align="left">same as corePoolSize</td><td align="left">Integer.MAX_VALUE</td><td align="left">1</td><td align="left">Integer.MAX_VALUE</td></tr><tr><td align="left">keepAliveTime</td><td align="left">0 seconds</td><td align="left">60 seconds</td><td align="left">0 seconds</td><td align="left">0 seconds</td></tr></tbody></table><h1 id="如何停止线程池"><a href="#如何停止线程池" class="headerlink" title="如何停止线程池"></a>如何停止线程池</h1><div class="note primary simple no-icon flat"><p><strong>停止线程相关的 5 个方法：</strong></p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isShutdown</span><span class="params">()</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isTerminated</span><span class="params">()</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">awaitTerminated</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h2 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown();"></a>shutdown();</h2><blockquote><p>调用 shutdown 方法之后，线程池并不是立刻就被关闭。事实上这个方法仅仅是初始化整个关闭过程，因为这个时候线程池中可能还有很多任务正在被执行，或者是任务队列中有大量正在等待被执行的任务，所以不是调用 shutdown 方法就立即关闭。在执行这个方法之后，线程池就接收到关闭信息，所以这个时候线程池为了优雅起见，会把正在执行的任务以及队列中等待的任务都执行完毕之后再关闭。</p></blockquote><h2 id="isShutdown"><a href="#isShutdown" class="headerlink" title="isShutdown();"></a>isShutdown();</h2><blockquote><p>isShutdown() 方法可以返回一个布尔值，true 或者 false 来判断线程池是不是已经开始关闭工作，也就是是否执行了 shutdown() 或者 shutdownNow() 方法。这个停止不是说完全停止，因为完全停止指的是所有的任务都执行完毕。</p></blockquote><h2 id="isTerminated"><a href="#isTerminated" class="headerlink" title="isTerminated();"></a>isTerminated();</h2><blockquote><p>返回整个线程池是不是已经完全终止了，这不仅仅线程池已经关闭，同时代表线程池中的所有任务都执行完毕了，就是线程池里面的线程包括正在执行的任务以及队列里面的任务都执行完了。</p></blockquote><h2 id="awaitTerminated-long-timeout-TimeUnit-unit"><a href="#awaitTerminated-long-timeout-TimeUnit-unit" class="headerlink" title="awaitTerminated(long timeout, TimeUnit unit);"></a>awaitTerminated(long timeout, TimeUnit unit);</h2><blockquote><p>这个方法作用相对比较弱，它不是用来停止线程池的，而是用来判断线程池的状态的。比如我们给 awaitTermination() 方法传入的参数是 10 秒，那么它就会等待 10 秒钟。</p><p>调用 awaitTermination() 方法之后，当前线程会等待一段时间，如果在等待的这段时间内，线程池已经关闭并且内部任务都执行完毕了，这个方法会返回true，否则超时会返回 false。、</p><p>所以这个方法只是一个用来测试在一段时间内这个线程是不是完全停止的。它起到的主要作用是检测，而不是关闭。</p></blockquote><h2 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow();"></a>shutdownNow();</h2><blockquote><p>这个方法比较暴力，它与前面我们介绍的方法都不一样，这个方法后面带了一个 Now，也就表示立刻关闭的意思。如果要想立刻关闭掉，我们作为线程池的设计者，我们想一下应该怎么办才比较优雅。在执行 shutdownNow() 方法之后，首先会给所有线程池中的线程发送 interrupt 中断信号，尝试中断这些任务的执行，然后会将任务队列中正在等待的所有任务转移到一个 List 中并返回，我们可以根据返回的任务List来进行一些补救的操作，例如记录在案并在后期重试。</p></blockquote><h1 id="线程池的钩子函数"><a href="#线程池的钩子函数" class="headerlink" title="线程池的钩子函数"></a>线程池的钩子函数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadPool</span> <span class="keyword">extends</span> <span class="title class_">ThreadPoolExecutor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处省略构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在每个线程执行之前调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.beforeExecute(t, r);</span><br><span class="line">        System.out.println(t.getName() + <span class="string">&quot;开始执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在每个线程执行之后调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.afterExecute(r, t);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在执行 shutdown 方法之后，并且线程池中所有线程执行结束时调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">terminated</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;所有线程执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处省略创建 threadPool 对象代码</span></span><br><span class="line"></span><br><span class="line">        threadPool.execute(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我被执行了。。。&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;为什么要使用线程池&quot;&gt;&lt;a href=&quot;#为什么要使用线程池&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用线程池&quot;&gt;&lt;/a&gt;为什么要使用线程池&lt;/h1&gt;&lt;div class=&quot;note info no-icon flat&quot;&gt;&lt;p&gt;&lt;stron</summary>
      
    
    
    
    <category term="线程" scheme="https://www.wrp.cool/categories/%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="https://www.wrp.cool/tags/Java/"/>
    
    <category term="线程池" scheme="https://www.wrp.cool/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>【MySQL实战】普通索引和唯一索引，应该怎么选择？</title>
    <link href="https://www.wrp.cool/posts/24920/"/>
    <id>https://www.wrp.cool/posts/24920/</id>
    <published>2022-06-15T09:21:22.000Z</published>
    <updated>2022-07-13T18:57:18.747Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查询操作下两个索引的不同"><a href="#查询操作下两个索引的不同" class="headerlink" title="查询操作下两个索引的不同"></a>查询操作下两个索引的不同</h1><p><strong>普通索引的查询过程：</strong></p><blockquote><p>对于普通索引的查询而言，查询到满足条件的第一条记录之后，还需要接着往下找，直到出现第一个不满足的记录。</p></blockquote><p><strong>唯一索引的查询过程：</strong></p><blockquote><p>对于唯一索引的查询而言，查询到满足条件的第一条记录之后，直接返回，不会再继续向下查找。</p></blockquote><p>对于查询操作来说，普通索引和唯一索引的差别就是在命中第一条记录之后有没有一个往下继续比较的动作而已。显然，一个比较的动作对于性能的影响是微乎其微，可以忽略不计的，因此本文的重点也并不在此。</p><h1 id="change-buffer"><a href="#change-buffer" class="headerlink" title="change buffer"></a>change buffer</h1><p>在 <a href="https://www.wrp.cool/posts/42257/">【MySQL实战】深入浅出索引</a> 这篇文章中有提到过 MySQL 中的 <code>页</code> 的概念，页（Page）是 InnoDB 中管理数据的最小单元。</p><p>一个 <code>页</code> 中会存放很多条记录，不管是更新还是查找数据，都是要将 <code>页</code> 先读到内存当中的，然后在内存中更新数据，完了再把更新完的 <code>页</code> 写回磁盘。</p><p>可以看到在这个过程之中，存在着性能浪费。更新数据并不一定会更新到整个 <code>页</code> 中的数据，但是读数据到内存中却是将整个 <code>页</code> 的数据全部读取出来的，写回磁盘的过程也是将整个 <code>页</code> 的数据全部写回磁盘的。而读写磁盘都是非常昂贵的 IO 操作。于是在更新中肯定会有一些操作来避免或者是尽量的减少这样的 IO 浪费。</p><p>change buffer 就是这样的一种技术。</p><p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。</p><p>将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 merge。除了访问这个数据页会触发 merge 外，系统有后台线程会定期 merge。在数据库正常关闭（shutdown）的过程中，也会执行 merge 操作。</p><p>也就是说要尽量在 merge 的过程要刷越多的数据到磁盘上越好，在一个页上一次性刷的数据越多，反过来刷的次数就会越少，性能就会越高。</p><p>值得注意的是，change buffer 实际上它是可以持久化的数据。也就是说，change buffer 在内存中有拷贝，也会被写入到磁盘上。</p><div class="note info flat"><p><strong>change buffer 的使用：</strong></p></div><p>change buffer 用的是 buffer pool 里的内存，因此不能无限增大。change buffer 的大小，可以通过参数 innodb_change_buffer_max_size 来动态设置。这个参数设置为 50 的时候，表示 change buffer 的大小最多只能占用 buffer pool 的 50%。</p><h1 id="更新操作下两个索引的不同"><a href="#更新操作下两个索引的不同" class="headerlink" title="更新操作下两个索引的不同"></a>更新操作下两个索引的不同</h1><p>第一种情况是，<strong>这个记录要更新的目标页在内存中。</strong>这时，InnoDB 的处理流程如下：</p><ul><li>对于唯一索引来说，找到待更新的位置，判断到没有冲突，插入这个值，语句执行结束；</li><li>对于普通索引来说，找到待更新的位置，插入这个值，语句执行结束。<br>这样看来，普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的 CPU 时间。但，这不是我们关注的重点。</li></ul><p>第二种情况是，<strong>这个记录要更新的目标页不在内存中。</strong>这时，InnoDB 的处理流程如下：</p><ul><li>对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；</li><li>对于普通索引来说，则是将更新记录在 change buffer，语句执行就结束了。</li></ul><p>将数据从磁盘读入内存涉及随机 IO 的访问，是数据库里面成本最高的操作之一。change buffer 因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。</p><blockquote><p>对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 change buffer 了。因此，唯一索引的更新就不能使用 change buffer，<strong>实际上也只有普通索引可以使用</strong>。</p></blockquote><h1 id="比较-change-buffer-和-redo-log-的差别"><a href="#比较-change-buffer-和-redo-log-的差别" class="headerlink" title="比较 change buffer 和 redo log 的差别"></a>比较 change buffer 和 redo log 的差别</h1><div class="note info flat"><p><strong>以写为例，change buffer 的工作流程：</strong></p></div><ol><li>待更新数据页在内存中，直接更新内存中的数据页。记录 redo log。</li><li>待更新数据页不在内存中，在内存的 change buffer 区域记录下“我要在数据页X中更新一条数据”。记录 redo log。</li></ol><p>这样的操作执行成本其实很低，不论数据页是否在内存中，都是写一次内存，然后再写一次磁盘（顺序写）。比起直接去磁盘更新对应数据性能要好一些。</p><div class="note info flat"><p><strong>以读为例，change buffer 的工作流程：</strong></p></div><ol><li>要读取的数据页在内存中，直接返回对应结果。</li><li>要读取的数据页不在内存中，将对应的数据页读取到内存中，再应用 change buffer 里面的操作日志，生成对应的结果返回。</li></ol><blockquote><p>值得注意的是：更新操作写完 redo log 之后，如果此时需要马上读取这部分数据，并不需要立即更新 redo log 中的数据到数据页中，可以读取对应数据页之后应用 change buffer 日志返回正确结果。</p></blockquote><hr><p>OK，最后回到本文主题：<strong>普通索引和唯一索引，应该怎么选择？</strong></p><p>如果在业务上可以接受，首先建议选择普通索引，因为可以应用 change buffer 的优化。</p>]]></content>
    
    
    <summary type="html">《极客时间-MySQL实战45讲》笔记整理。</summary>
    
    
    
    <category term="数据库" scheme="https://www.wrp.cool/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="笔记" scheme="https://www.wrp.cool/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【MySQL实战】深入浅出索引</title>
    <link href="https://www.wrp.cool/posts/42257/"/>
    <id>https://www.wrp.cool/posts/42257/</id>
    <published>2022-06-08T03:13:18.000Z</published>
    <updated>2022-06-15T09:29:08.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li><a href="https://time.geekbang.org/column/article/69236">《极客时间-MySQL实战45讲》04 | 深入浅出索引（上）</a></li><li><a href="https://time.geekbang.org/column/article/69636">《极客时间-MySQL实战45讲》05 | 深入浅出索引（下）</a></li><li>笔记整理</li></ul></blockquote><hr><p>首先还是要先了解 <strong>页（Page）</strong> 这个概念，才能更好的理解 InnoDB 中的索引。</p><div class="note success flat"><p><strong>页是什么？</strong></p></div><ul><li><p>页（Page）是 InnoDB 中管理数据的最小单元。</p></li><li><p>聚簇索引中的叶子结点就是一个个的页。</p><blockquote><p><em>插句题外话：</em><br><em>之前初学 MySQL 的时候，由于 DML 操作的都是一行行的数据，所以那时候总是以为 MySQL 中的最小数据单位就是 row。UPDATE 的时候就去磁盘中拿到对应的数据出来，然后 UPDATE 之后再放回去。但现在看来显然不是，MySQL 是先把该行数据所在的页先加载到内存中修改完了再延迟刷回磁盘的。</em></p></blockquote></li></ul><div class="note success flat"><p><strong>页的概览</strong></p></div><p>MySQL 中的数据最终都是存在聚簇索引树的叶子结点中的，也就是页之间其实是双向链表的这么一种数据结构，并且页与页之间也是有序的。在叶子结点中存储用户数据的部分是一种单向链表的结构。</p><p>当我们在查找数据的时候，为了快速判断要查找的数据是否在当前页之中。在页中还会记录页本页用户数据中的最大值和最小值。</p><p>如果所需要的数据就在当前页中，为了避免整个页去查找，MySQL 又在页中加入了另一个区域 Page Directory 目录，里面有很多个槽位（Slots），每一个槽位都指向了一条 User Records 中的记录。每隔几条数据，就会创建一个槽位。在一个完整的页中，每隔6条数据就会有一个 Slot。有了 Page Directory 之后，页内的用户数据就不需要去维护有序性了，直接插入在链表尾部即可。</p><p>Slot 会在新增数据的时候创建和维护，之后就可以对一张页的数据进行<strong>粗略</strong>的二分查找。因为二分查找出来的结果只能是个大概的位置，找到了这个大概的位置之后，还需要回到 User Records 中继续的进行挨个遍历匹配。</p><blockquote><p>粗略画了下页的概览图，如下：</p></blockquote><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/1654781897359.png" alt="1654781897359"></p><blockquote><p><strong>小结：</strong></p><p>MySQL 查找数据的方式，首先是通过索引将数据所在的页先加载到内存中去，之后在内存中尽量的缩小所在数据的范围，再去遍历数据找到最终所需要的数据。</p></blockquote><hr><h1 id="索引的常见模型"><a href="#索引的常见模型" class="headerlink" title="索引的常见模型"></a>索引的常见模型</h1><p>三种常见、也比较简单的数据结构，它们分别是<code>哈希表</code>、<code>有序数组</code>和<code>N叉树</code></p><blockquote><p>你心里要有个概念，数据库底层存储的核心就是基于这些数据模型的。每碰到一个新数据库，我们需要先关注它的数据模型，这样才能从理论上分析出这个数据库的适用场景。</p></blockquote><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希表是一种以键 - 值（key-value）存储数据的结构，我们只要输入待查找的键即 key，就可以找到其对应的值即 Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。如果多个 key 值经过哈希函数的换算，出现了同一个值。这种情况称为哈希冲突，一般可以往后拉出来一个链表解决。</p><ul><li><strong>优点：</strong><ul><li>新增数据快，可以直接查询到要添加的位置，直接添加或者添加为链表的尾结点。</li><li>等值查询速度快。</li></ul></li><li><strong>缺点：</strong><ul><li>由于无序，所以哈希索引做区间查询的速度是很慢的。</li></ul></li><li><strong>适用场景：</strong><ul><li>只有等值查询的场景。</li></ul></li></ul><h2 id="有序数组"><a href="#有序数组" class="headerlink" title="有序数组"></a>有序数组</h2><p>是一种数组按照下标升序或者降序存储数据的结构。</p><ul><li><strong>优点：</strong><ul><li>使用二分法做查询速度很快，时间复杂度是 O(log(N))</li><li>支持区间查询，先用二分法查询到区间最左的元素，再向右遍历直至最又的元素。</li></ul></li><li><strong>缺点：</strong><ul><li>往中间添加一个数据需要往后挪动所有的数据，这个过程很慢，时间复杂度是 O(log(N))</li></ul></li><li><strong>适用场景：</strong><ul><li>有序数组只适用于读多写少的情况。</li></ul></li></ul><h2 id="N叉树"><a href="#N叉树" class="headerlink" title="N叉树"></a>N叉树</h2><p>为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的大小。</p><p>以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。</p><p><strong>InnoDB 引擎中使用的是 B+树 这种N叉树的数据结构作为索引模型。</strong></p><h1 id="InnoDB-的索引模型"><a href="#InnoDB-的索引模型" class="headerlink" title="InnoDB 的索引模型"></a>InnoDB 的索引模型</h1><p>在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。准确的说应该是存在 B+ 树中的叶子节点中的。每个叶子节点就是开头说的<strong>页（Page）</strong>。</p><p>每一个索引在 InnoDB 里面都对应了一棵 B+ 树。根据叶子节点的内容，索引类型分为主键索引和非主键索引。主键索引的叶子节点存的是整行数据。</p><ul><li>在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。</li><li>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。</li></ul><div class="note primary flat"><p><strong>基于主键索引和普通索引的查询有什么区别？</strong></p></div><ul><li>如果语句是 select * from T where ID&#x3D;1，即主键查询方式，则只需要搜索 ID 这棵 B+ 树</li><li>如果语句是 select * from T where k&#x3D;5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为<strong>回表</strong>。</li></ul><p>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。</p><div class="note primary flat"><p>为什么普通索引的叶子节点上要存放的是 ID，为什么不直接存对应行数据的地址呢？</p></div><ul><li><strong>优点：</strong><br>  减少了页分裂或者页合并时候二级索引的维护工作。</li><li><strong>缺点：</strong><ol><li>二级索引体积可能会变大，因为其中存储了主键信息。</li><li>二级索引的访问需要两次查找，要多一次回表的操作。</li></ol></li></ul><div class="note primary flat"><p>一个老生常谈的话题了，为啥不用 select *，而要把查询的字段全部写出来呢？</p></div><p>select * 是肯定要回表的，会导致索引覆盖用不了。</p><h1 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h1><p>前文说过 InnoDB 页之间是有序的，为了维护这个有序性，在插入新值和删除旧值的时候就需要做一些必要的维护。</p><blockquote><p>有个概念可能会混淆，得先说清楚，索引是肯定有序的，这里的有序无序指的是插入的顺序。</p></blockquote><p>如果都是有序插入的话，每次都直接在页内插入一条新的数据或者申请一个新的页再插入数据即可，这样子可以保证除了最后一页所有页都是满的，空间利用率最高。有序插入的方案是最优的，自增主键就是一种 InnoDB 提供的有序插入的方案。</p><div class="note primary flat"><p><strong>页分类与页合并</strong></p></div><ul><li><p><strong>页分裂：</strong></p><blockquote><p>如果无序插入到一个页内空间已经满了的话，就需要再开新的一页来存储这个数据。根据 B+ 树的算法，会挪动部分数据过去新的页，这个过程称为<strong>页分裂</strong>。在这种情况下，性能自然会受影响。除了性能外，页分裂操作还影响数据页的利用率。因为新开的数据页不一定会被填满。</p></blockquote></li><li><p><strong>页合并：</strong></p><blockquote><p>当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</p></blockquote></li></ul><div class="note info flat"><p><strong>两个建议：</strong></p></div><ol><li>使用自增主键。这样可以保证每次插入都是有序插入的，可以防止页分裂。</li><li>删除先做逻辑上的删除，不要做物理删除，这样可以防止页合并。等到有时间了再去真正的删除。</li></ol><p>新增或者删除的时候多了分裂或者合并的操作，性能自然会受到影响。除了考虑性能外，从存储空间的角度来看，也应该用自增主键，因为普通索引的叶子节点上存储的是主键，显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</p><h1 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h1><p>由于二级索引并没有存放真实的数据，所以需要到主键索引上进行一次回表的操作，这自然会影响性能。</p><p>那如果我只要查 ID 呢？二级索引的叶子节点上就是记录了 ID，那么自然不需要回表，自然提高了性能。于是很自然的一个想法就出现了，那就是把一些经常会查询到的字段一起记录在二级索引上，这就是<strong>覆盖索引</strong>。</p><p>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</p><blockquote><p>比如有这样的一个需求：<strong>根据身份证号码查询姓名</strong></p></blockquote><p>身份证号码作为每个人的唯一标识，肯定会有很多根据身份证号码查询身份信息的请求，应该要在身份证号码这个字段上建一个索引。但查询姓名这个需求是一个很高频的需求，这个时候就可以把身份证号码跟姓名一起建立一个联合索引。这样它可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。</p><p>当然，索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。</p><h1 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h1><p>假设现在有一个（姓名，年龄）的联合索引：</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95.jpg" alt="最左前缀索引"></p><p>可以看到，索引项是按照索引定义里面出现的字段顺序排序的。</p><p>当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到 ID4，然后向后遍历得到所有需要的结果。</p><p>如果你要查的是所有名字第一个字是“张”的人，你的 SQL 语句的条件是”where name like ‘张 %’”。这时，你也能够用上这个索引，查找到第一个符合条件的记录是 ID3，然后向后遍历，直到不满足条件为止。</p><p>可以看到，不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个<strong>最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符</strong>。</p><p>很显然，这里的（姓名，年龄）索引中的（年龄）是可以复用的，于是此处相当于拥有了两个索引，分别是：（姓名，年龄）、（姓名）</p><p>那么，<strong>在建立联合索引的时候，如何安排索引内的字段顺序呢？</strong></p><ol><li>如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。<ul><li>比如上面（姓名，年龄）的例子，通过建立（姓名，年龄），相当于拥有了（姓名，年龄）和（姓名）两个索引，不需要为（姓名）单独再创建一个索引。</li></ul></li><li>考虑字段大小，将字段大一点的排到前面去。<ul><li>比如上面（姓名，年龄）的例子，如果还需要姓名跟年龄都建立索引，那么就应该建立（姓名，年龄）这样的联合索引，然后再建立一个（年龄）的索引。因为单独的（年龄）索引占用的空间比起单独的（姓名）的空间要来的小。</li></ul></li></ol><h1 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h1><blockquote><p>在 MySQL5.6 以后引入了索引下推优化（index condition pushdown)。</p></blockquote><p>还是拿上面（姓名，年龄）索引的例子，需求是这样的：检索出表中“名字第一个字是张，而且年龄是 10 岁的所有男孩”。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">SQL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tuser <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;张%&#x27;</span> <span class="keyword">and</span> age<span class="operator">=</span><span class="number">10</span> <span class="keyword">and</span> is_male<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段值。</p><p>， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p><blockquote><p><strong>无索引下推优化：</strong></p><p>查找到第一个符合 <code>name like &#39;张%&#39;</code> 的记录，也就是 ID3 的张六，之后开始一个个回表对比其他字段值，<strong>共需回表4次</strong>。</p></blockquote><blockquote><p><strong>有索引下推优化：</strong></p><p>查找到第一个符合 <code>name like &#39;张%&#39;</code> 的记录，也就是 ID3 的张六，之后在（姓名，年龄）这科索引树下直接判断是否符合 <code>age=10</code> 的条件，如果符合，则回表对比其他字段值；如果不符合，直接放弃回表，减少回表次数，<strong>共需回表2次</strong>。</p></blockquote><hr><blockquote><p>网友热心总结的一些问题，复习的时候可以试着回答一下。</p></blockquote><ol><li>select * from T where k betwee 3 and 5 这条语句的执行流程是什么样的?</li><li>回表的概念是什么?</li><li>索引覆盖的概念是什么, 索引覆盖的优点是什么?</li><li>最左前缀原则的概念是什么? 说明最左前缀原则的执行过程.</li><li>索引下推的概念是什么? MySQL 5.6 的下推优化是怎么做的?</li></ol><blockquote><p><strong>参考文章：</strong><a href="https://zhuanlan.zhihu.com/p/382375842">MySQL 页完全指南——浅入深出页的原理</a></p></blockquote><p>大家加油：）</p>]]></content>
    
    
    <summary type="html">《极客时间-MySQL实战45讲》笔记整理。</summary>
    
    
    
    <category term="数据库" scheme="https://www.wrp.cool/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="笔记" scheme="https://www.wrp.cool/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【MySQL实战】全局锁、表锁、行锁</title>
    <link href="https://www.wrp.cool/posts/27299/"/>
    <id>https://www.wrp.cool/posts/27299/</id>
    <published>2022-06-05T07:32:24.000Z</published>
    <updated>2022-06-13T12:12:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li><a href="https://time.geekbang.org/column/article/69862">《极客时间-MySQL实战45讲》06 | 全局锁和表锁 ：给表加个字段怎么有这么多阻碍？</a></li><li><a href="https://time.geekbang.org/column/article/70215">《极客时间-MySQL实战45讲》07 | 行锁功过：怎么减少行锁对性能的影响？</a></li><li>笔记整理</li></ul></blockquote><span id="more"></span><p>根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类。</p><p>在正式开篇之前还是得先搞清楚两个概念：共享锁和排他锁</p><ul><li><strong>共享锁：</strong>所有线程都可以拥有共享锁，故名为共享。一般是读锁。</li><li><strong>排他锁：</strong>仅一个线程可以拥有锁，其他线程必须等待该线程释放锁后才可以拿到锁，故名为排他。一般是写锁。</li></ul><hr><h1 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h1><blockquote><p>顾名思义，全局锁的锁定对象是整个数据库实例。</p></blockquote><ul><li><strong>加锁语法：</strong><code>flush tables with read lock; (FTWRL)</code></li><li><strong>释放锁语法：</strong><code>unlock tables;</code></li></ul><p>这是一把读锁，使用之后所有的线程只能读取数据而不能修改数据，方式是阻塞其他线程的以下一些语句：</p><ul><li>数据更新语句（数据的增删改）</li><li>数据定义语句（包括建表、修改表结构等）</li><li>更新类事务的提交语句。</li></ul><p>比较多的使用场景是全局逻辑备份，<strong>用于保证备份时的数据一致性</strong>。其底层支持是 <a href="https://www.wrp.cool/posts/574/">MVCC 多版本并发控制</a></p><blockquote><p>在备份的场景里，FTWRL 相较于 <code>set global read_only=true;</code> 的优势：</p></blockquote><ol><li>readonly 的值可能会被用来做其他逻辑，比如用来判断一个库是主库还是备库。影响面比较大，不建议使用。</li><li>异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。</li></ol><blockquote><p><strong>MySQL 全局备份方式：</strong><br>官方自带的逻辑备份工具是 mysqldump。当 mysqldump 使用参数 <code>–single-transaction</code> 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。</p><p><strong>注意：</strong><br>MySQL 并非所有的引擎都支持 <code>–single-transaction</code> 参数，底层需要 MVCC 的支持，而目前仅 InnoDB 提供了 MVCC 支持。如果有的表使用了不支持事务的引擎，那么备份就只能通过 FTWRL 方法。这往往是 DBA 要求业务开发人员使用 InnoDB 替代 MyISAM 的原因之一。</p></blockquote><h1 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h1><p>MySQL5.5 开始引入了元数据锁，自此MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。</p><h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><blockquote><p>用于锁定整个表对象，分为读锁和写锁。</p></blockquote><p>读锁（ <code>lock tables … read</code>）：该锁是一种<strong>共享锁</strong>，MySQL 中的表一旦被加上了读锁，其他线程的修改语句就会被阻塞。所有线程均仅可读。<br>写锁（ <code>lock tables … write</code>）：该锁是一种<strong>排他锁</strong>，MySQL 中的表一旦被加上了写锁，除了拥有锁的线程之外，其他的线程对该表的读写操作都会被阻塞。</p><div class="note danger flat"><p>对于 InnoDB 这种支持行锁的引擎，一般不使用 lock tables 命令来控制并发，毕竟锁住整个表的影响面太大了。</p></div><h2 id="元数据锁（meta-data-lock，MDL）"><a href="#元数据锁（meta-data-lock，MDL）" class="headerlink" title="元数据锁（meta data lock，MDL）"></a>元数据锁（meta data lock，MDL）</h2><blockquote><p>这是一种列锁，锁住的是表的表结构。也就是说上锁期间会对 DDL 的操作做限制。同样分为了 MDL 读锁和 MDL 写锁。</p></blockquote><p>MDL 是 server 层的锁，表级锁，主要用于隔离 DML 和 DDL 操作之间的干扰。每执行一条 DML、DDL 语句时都会申请 MDL锁，DML 操作需要 MDL 读锁（共享），DDL 操作需要 MDL 写锁（排他）。MDL 加锁过程是系统自动控制，无法直接干预。</p><div class="note danger flat"><p>MDL 可能导致线程爆满，打爆数据库系统。</p></div><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/MDL%E9%98%BB%E5%A1%9E%E8%BF%87%E7%A8%8B%E6%BC%94%E7%A4%BA%E5%9B%BE.jpg" alt="MDL阻塞过程演示图"></p><p>在上面的这个图中，sessionA 正常启动，正常获取 MDL 读锁，之后 sessionB 启动，也获取到 MDL 读锁。</p><p>之后 sessionC 启动需要获取 MDL 写锁，此时由于 MDL 读锁还没释放，于是 sessionC 进入阻塞状态等待获取 MDL 写锁。</p><p>但是如果碰巧 sessionA 或者 sessionB 中有一个是长事务，那么 sessionC 被阻塞的时间就会久一些，sessionC 之后的所有线程都拿不到 MDL 锁，MDL 读写锁都拿不到。</p><p>如果此时恰巧有很多的请求进来，全部都被阻塞在一起，很快就会导致线程爆满，数据库被打爆。</p><h1 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h1><blockquote><p>顾名思义，行锁就是针对数据表中行记录的锁。这很好理解，比如事务 A 更新了一行，而这时候事务 B 也要更新同一行，则必须等事务 A 的操作完成后才能进行更新。</p></blockquote><h2 id="行锁的两阶段协议"><a href="#行锁的两阶段协议" class="headerlink" title="行锁的两阶段协议"></a>行锁的两阶段协议</h2><div class="note default flat"><p>举例说明：</p></div><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E8%A1%8C%E9%94%81-%E4%B8%A4%E9%98%B6%E6%AE%B5%E5%8D%8F%E8%AE%AE.jpg" alt="行锁-两阶段协议"></p><p>在这个例子中，事务B会被事务A阻塞，直到事务A commit 才会执行事务B。显然事务A持有 id&#x3D;1、id&#x3D;2 这两行的锁。</p><blockquote><p>可以得出：</p><p>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。<br><strong>这个就是两阶段锁协议。</strong></p></blockquote><p>由两阶段协议可得：</p><div class="note warning flat"><p><strong>如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</strong></p></div><blockquote><p><strong>像这样：</strong></p><p>假设你负责实现一个电影票在线交易业务，顾客 A 要在影院 B 购买电影票。我们简化一点，这个业务需要涉及到以下操作：</p><ol><li>从顾客 A 账户余额中扣除电影票价；</li><li>给影院 B 的账户余额增加这张电影票价；</li><li>记录一条交易日志。</li></ol><p>由于两阶段协议，所以应该尽量把最可能造成锁冲突、影响并发度的锁往后放。<br>所以以上三条语句在编码时的执行顺序应该是：<code>1 3 2</code> 或者是 <code>3 1 2</code></p></blockquote><h2 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h2><blockquote><p><strong>什么是死锁：</strong></p><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。</p></blockquote><div class="note default flat"><p><strong>举例：</strong></p></div><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E6%8B%BF%E8%A1%8C%E9%94%81%E4%B8%BE%E4%B8%AA%E6%AD%BB%E9%94%81%E4%BE%8B%E5%AD%90.jpg" alt="拿行锁举个死锁例子"></p><p>此时，事务A在等待事务B中 id&#x3D;2 的行锁，事务B又在等待事务A id&#x3D;1 的锁，陷入了一种事务A等事务B，事务B等事务A的状态，这就是死锁现象。</p><div class="note primary flat"><p><strong>死锁的应对策略：</strong></p></div><ol><li><p>直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。<br> 在 InnoDB 中，innodb_lock_wait_timeout 的默认值是 50s，对于在线服务来说，这个等待时间往往是无法接受的。但是如果把这个超时时间设置的很短呢？那又可能误伤到很多只是锁等待的线程，这也不好。所以这个方案需要把握好一个比较精准的度。</p></li><li><p>发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。</p></li></ol><blockquote><p>正常情况下我们还是要采用第二种策略，即：<strong>主动死锁检测</strong>，而且 innodb_deadlock_detect 的默认值本身就是 on。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。</p><p>你可以想象一下这个过程：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。</p><p>但是如果很大量的请求都要同时更新同一行的数据呢？</p><p>每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 O(n) 的操作。假设有 1000 个并发线程要同时更新同一行，那么死锁检测操作就是 100 万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的 CPU 资源。因此，你就会看到 CPU 利用率很高，但是每秒却执行不了几个事务。</p></blockquote><div class="note primary flat"><p><strong>怎么解决由这种热点性更新导致的性能问题呢？</strong></p></div><ol><li>在业务上保证不出现死锁的情况，将死锁检测关掉。<ul><li><strong>缺点：</strong>业务上的实现很困难</li></ul></li><li>控制并发度。<ul><li><strong>怎么做？</strong>借助中间件，或者是直接修改 MySQL 源码。</li></ul></li><li>从数据库设计上优化。<ul><li><strong>怎么做？</strong>将一条数据扩展成多条数据，每次随机选择其中一条记录来做修改，人为的将并发度降低。</li></ul></li></ol><hr><blockquote><p>网友热心总结的一些问题，复习的时候可以试着回答一下。</p></blockquote><ol><li>MySQL从加锁范围上分为哪三类?</li><li>全局锁加锁方法的执行命令是什么?主要的应用场景是什么?</li><li>做整库备份时为什么要加全局锁?</li><li>MySQL的自带备份工具, 使用什么参数可以确保一致性视图, 在什么场景下不适用?</li><li>不建议使用set global readonly &#x3D; true的方法加全局锁有哪两点原因?</li><li>表级锁有哪两种类型?  各自的使用场景是什么?</li><li>MDL中读写锁之间的互斥关系怎样的?</li><li>如何安全的给小表增加字段?</li><li>两阶段锁的概念是什么? 对事务使用有什么帮助?</li><li>死锁的概念是什么? 举例说明出现死锁的情况.</li><li>死锁的处理策略有哪两种? </li><li>等待超时处理死锁的机制什么?有什么局限?</li><li>死锁检测处理死锁的机制是什么? 有什么局限?</li><li>有哪些思路可以解决热点更新导致的并发问题?</li></ol>]]></content>
    
    
    <summary type="html">《极客时间-MySQL实战45讲》笔记整理。</summary>
    
    
    
    <category term="数据库" scheme="https://www.wrp.cool/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="锁" scheme="https://www.wrp.cool/tags/%E9%94%81/"/>
    
    <category term="笔记" scheme="https://www.wrp.cool/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【MySQL实战】事务隔离</title>
    <link href="https://www.wrp.cool/posts/574/"/>
    <id>https://www.wrp.cool/posts/574/</id>
    <published>2022-06-03T06:27:10.000Z</published>
    <updated>2022-06-14T08:47:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li><a href="https://time.geekbang.org/column/article/68963">《极客时间-MySQL实战45讲》03 | 事务隔离：为什么你改了我还看不见？</a></li><li><a href="https://time.geekbang.org/column/article/70562">《极客时间-MySQL实战45讲》08 | 事务到底是隔离还是不隔离的？</a></li><li>笔记整理</li></ul></blockquote><span id="more"></span><h1 id="事务的基本特性（ACID）"><a href="#事务的基本特性（ACID）" class="headerlink" title="事务的基本特性（ACID）"></a>事务的基本特性（ACID）</h1><ul><li><strong>原子性（Atomicity）：</strong>事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。</li><li><strong>一致性（Consistency）：</strong>事务开始前和结束后，数据库的完整性约束没有被破坏。</li><li><strong>隔离性（Isolation）：</strong>同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。</li><li><strong>持久性（Durability）：</strong>事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。</li></ul><h1 id="不考虑隔离性可能产生的问题"><a href="#不考虑隔离性可能产生的问题" class="headerlink" title="不考虑隔离性可能产生的问题"></a>不考虑隔离性可能产生的问题</h1><ul><li><strong>脏读：</strong>指在一个事务处理过程中读取了另一个未提交的事务中的数据。<ul><li>比如事务A将 x 的值从0修改为1，但未回滚或提交，此时事务B读取了 x 的值为1，随后事务A回滚，将 x 的值重新设置为0。那么事务B读取的 x 的值为1的哪个过程就称为脏读。</li></ul></li><li><strong>不可重复读：</strong>一个事务内多次查询<strong>同一个数据</strong>却返回了不同的数据值。<ul><li>比如事务A查询 x 值为0，此时事务B将 x 的值修改为0并提交，事务A再次查询 x 的值为1。事务A并未对 x 的值做操作，但是两次查询 x 的值发生了变化，这个现象就被称为不可重复读。</li></ul></li><li><strong>幻读：</strong>一个事务内多次查询<strong>同一批数据</strong>却返回了不同批的数据。<ul><li>比如事务A查询用户表有100个用户，此时事务B新增或者删除了一些用户，之后事务A再次查询用户表返回的不是100个用户。这个现象就被称为幻读。</li></ul></li></ul><blockquote><p>幻读和不可重复读看起来好像很相似，都是读取了另外一个事务所提交的修改，但区别是<strong>不可重复读针对的是数据项，而幻读针对的是数据量</strong>。</p></blockquote><h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><ul><li><strong>读未提交（READ UNCOMMITTED）：</strong>一个事务还没提交时，它做的变更就能被别的事务看到。</li><li><strong>读已提交（READ COMMITTED）：</strong>一个事务提交之后，它做的变更才会被其他事务看到。</li><li><strong>可重复读（REPEATABLE READ）：</strong>一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。</li><li><strong>串行化（SERIALIZABLE ）：</strong>顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li></ul><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%BE%E4%BE%8B.jpg" alt="事务隔离级别举例"></p><ul><li><strong>读未提交：</strong> V1 的值是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2。</li><li><strong>读已提交：</strong> V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以，V3 的值也是 2。</li><li><strong>可重复读：</strong> V1、V2 是 1，V3 是 2。之所以 V2 还是 1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。</li><li><strong>串行化：</strong>在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2。</li></ul><h1 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h1><p>事务隔离级别中的 READ UNCOMMITIED 总是读取最新的数据行，而不是符合当前事务版本的数据行。而 SERIALIZABLE 则会对所有读取的行都加锁。这两种隔离级别都能够独立实现，而 READ COMMITTED 和 REPEATABLE READ 这两种隔离级别则需要依赖于 MVVC 多版本并发控制来实现。</p><div class="note primary flat"><p><strong>MVCC 多版本并发控制</strong></p></div><p><strong>什么是 MVCC？</strong></p><blockquote><p>MVCC，全称 Multi-Version Concurrency Control，即多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。</p></blockquote><p><strong>MVCC 能做什么？</strong></p><blockquote><p>借助 MVCC 实现了 READ COMMITTED，REPEATABLE READ 等隔离级别。</p></blockquote><h1 id="InnoDB-中的-MVCC"><a href="#InnoDB-中的-MVCC" class="headerlink" title="InnoDB 中的 MVCC"></a>InnoDB 中的 MVCC</h1><p>InnDB 中每个事务都有一个唯一的事务 ID，记为 transaction_id。它在事务开始时向 InnDB 申请，按照时间先后严格递增。</p><p>而每行数据其实都有多个版本，这就依赖 undo log 来实现了。每次事务更新数据就会生成一个新的数据版本，并把  transaction_id 记为 row trx_id。同时旧的数据版本会保留在 undo log 中，而且新的版本会记录旧版本的回滚指针，通过它直接拿到上一个版本。</p><p>为了保证每个事务中拿到的数据都是不被其他事务污染的，InnoDB 还需要一个 read-view（一致性读视图） 来保存每次事务查询的时候不被污染的那一份数据。</p><p>所以，InnDB 中的 MVCC 其实是通过在每行记录后面保存两个隐藏的列来实现的。一列是事务 ID：<code>trx_id</code>；另一列是回滚指针：<code>roll_pt</code>。</p><h2 id="undo-log（回滚日志）"><a href="#undo-log（回滚日志）" class="headerlink" title="undo log（回滚日志）"></a>undo log（回滚日志）</h2><p>回滚日志保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。</p><p>根据操作和删除日志时机的不同，undo log 分为两种： insert undo log 和 update undo log。</p><h3 id="insert-undo-log"><a href="#insert-undo-log" class="headerlink" title="insert undo log"></a>insert undo log</h3><p>由于 INSERT 操作记录没有历史版本只对当前事务本身可见，对于其他事务此记录不可见，所以 insert undo log 可以在事务提交后直接删除而不需要进行 purge 操作。</p><blockquote><p>purge（清除）：的主要任务是将数据库中已经 mark del 的数据删除，另外也会批量回收 undo pages</p></blockquote><p>在事务提交时，这个事务所做的 INSERT 的操作所记录的 undo log 的日志会被直接删除。</p><h3 id="update-undo-log"><a href="#update-undo-log" class="headerlink" title="update undo log"></a>update undo log</h3><p>由于 UPDATE 操作的历史版本可能其他的事务需要用到，所以 UPDATE 操作的 undo log 保存的时间会长一些，只有在系统中没有比这个回滚日志更早的版本时，purge 线程将进行最后的删除操作。</p><p>假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="回滚日志流程图"></p><p>如果发生了回滚，4就会变成3再变成2再变成1，一步一步的恢复到初始状态。</p><blockquote><p>当不需要这些回滚日志的时候，这些日志就会被删除。<br>什么时候不需要这些回滚日志呢？<strong>当系统里没有比这个回滚日志更早的 read-view 的时候。</strong></p></blockquote><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/1654328337012.png" alt="1654328337012"></p><h2 id="read-view（一致性读视图）"><a href="#read-view（一致性读视图）" class="headerlink" title="read-view（一致性读视图）"></a>read-view（一致性读视图）</h2><p>read view 是 InnDB 在实现 MVCC 时用到的一致性读视图，用于支持 RC（读提交）以及 RR（可重复读）隔离级别的实现。</p><p>read view 不是真实存在的，只是一个概念，undo log 才是它的实现，<strong>主要是通过版本和 undolog 计算出来的</strong>，作用是决定事务能看到哪些数据。</p><p>每个事务或者语句有自己的一致性视图。普通查询语句是一致性读，一致性读会根据 row trx_id 和一致性视图确定数据版本的可见性。</p><div class="note warning flat"><p><strong>可见性规则</strong></p></div><blockquote><p>一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本”。</p></blockquote><p>在实现上， InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交。</p><p>数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。（注意：低水位是数组内最小值，高水位是系统内最大的事务ID再加1，高水位不在数组内）</p><p>这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。而数据版本的可见性规则，就是基于数据的 row trx_id 和这个一致性视图的对比结果得到的。</p><div class="note primary flat"><p><strong>这个视图数组把所有的 row trx_id 分成了几种不同的情况，如下：</strong></p></div><ol><li><strong>小于低水位：</strong>表示这个版本是已提交的事务，这个数据是可见的；</li><li><strong>大于等于高水位：</strong>表示这个版本是由将来启动的事务生成的，是肯定不可见的；</li><li><strong>大于等于低水位 &amp;&amp; 小于高水位：</strong><ul><li><strong>就是当前事务：</strong>可见；</li><li><strong>row trx_id 在数组中：</strong>表示这个版本是由还没提交的事务生成的，不可见；</li><li><strong>row trx_id 不在数组中：</strong>表示这个版本是已经提交了的事务生成的，可见。</li></ul></li></ol><blockquote><p>关于第三点的 row trx_id 在不在数组中，不是很好理解，专门画了个图：</p></blockquote><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/MVCC%E6%B0%B4%E4%BD%8D%E5%9B%BE.png" alt="MVCC水位图"></p><div class="note info flat"><p><strong>一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：</strong></p></div><ol><li>版本未提交，不可见；</li><li>版本已提交，但是是在视图创建后提交的，不可见；</li><li>版本已提交，而且是在视图创建前提交的，可见。</li></ol><h1 id="更新不用-read-view"><a href="#更新不用-read-view" class="headerlink" title="更新不用 read-view"></a>更新不用 read-view</h1><div class="note danger flat"><p><strong>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）</strong></p></div><blockquote><p><strong>为什么 UPDATE 操作必须使用当前读？</strong></p><p>当 <code>x=1</code> 事务A 执行：<code>set x = x + 1</code>；事务B 也执行：<code>set x = x + 1</code>。<br><strong>一致性读：</strong></p><ul><li>事务A 与 事务B 拿到 x 的初始数据都是 x&#x3D;1，执行完毕后 x&#x3D;2，<strong>丢失其中一次更新</strong></li></ul><p><strong>当前读：</strong></p><ul><li>事务A 开始执行。事务B 等待 事务A 执行完毕</li><li>事务A 执行完毕，x&#x3D;2。事务B 开始执行，x&#x3D;3</li></ul><p><strong>可见当前读未丢失更新</strong></p></blockquote><div class="note success flat"><p><strong>这也是行锁的两阶段协议存在的原因，防止更新丢失。</strong></p></div><div class="note primary flat"><p><strong>除了 update 语句外，select 语句如果加锁，也是当前读。</strong></p></div><h1 id="一个例子结束本文"><a href="#一个例子结束本文" class="headerlink" title="一个例子结束本文"></a>一个例子结束本文</h1><p>假设现在有一个表 t，初始化语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `k` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(id, k) <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>此时，分别有事务A、事务B、事务C，执行流程如下：</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E4%BA%8B%E5%8A%A1%E4%B8%BE%E4%BE%8B.jpg" alt="事务举例"></p><p><strong>注意：</strong>begin&#x2F;start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动。如果你想要马上启动一个事务，可以使用 start transaction with consistent snapshot 这个命令。</p><ul><li>第一种启动方式，一致性视图是在执行第一个快照读语句时创建的；</li><li>第二种启动方式，一致性视图是在执行 start transaction with consistent snapshot 时创建的。</li></ul><p><strong>但是：</strong>在读提交的隔离级别下，“start transaction with consistent snapshot; ”这个用法就没意义了，等效于普通的 start transaction。</p><p><strong>因为：</strong>在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。</p><blockquote><p>本例中，事务A、事务B、事务C分别的查询结果：</p><ul><li><strong>事务A</strong>读取的 k &#x3D; 1：事务A 的一致性视图开启时 k &#x3D; 1。</li><li><strong>事务B</strong>读取的 k &#x3D; 3：事务B 的更新采用当前读，当前 k 值已经被事务C修改成2。</li><li><strong>事务C</strong>读取的 k &#x3D; 1：事务C 最初始拿到的 k 值就是1。</li></ul></blockquote><hr><p>大家加油：）</p>]]></content>
    
    
    <summary type="html">《极客时间-MySQL实战45讲》笔记整理。</summary>
    
    
    
    <category term="数据库" scheme="https://www.wrp.cool/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="笔记" scheme="https://www.wrp.cool/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【MySQL实战】日志系统：一条SQL更新语句是如何执行的？</title>
    <link href="https://www.wrp.cool/posts/39005/"/>
    <id>https://www.wrp.cool/posts/39005/</id>
    <published>2022-06-02T07:00:35.000Z</published>
    <updated>2022-06-13T07:18:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li><a href="https://time.geekbang.org/column/article/68633">《极客时间-MySQL实战45讲》02 | 日志系统：一条SQL更新语句是如何执行的？</a></li><li>笔记整理</li></ul></blockquote><span id="more"></span><p>与上一篇笔记中的查询流程相同，一条更新语句也是要经过连接器、分析器、优化器、执行器等功能模块，最后到达存储引擎。</p><p>例如这样的一个表，然后有这样的一条更新的语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> T(ID <span class="type">int</span> <span class="keyword">primary</span> key, c <span class="type">int</span>);</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> T <span class="keyword">set</span> c<span class="operator">=</span>c<span class="operator">+</span><span class="number">1</span> <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>在上一篇笔记中说过在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表 T 上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因。</p><p>但与查询流程所不相同的是，更新流程涉及到两个重要的日志模块：redo log（重做日志）和binlog（归档日志）。</p><h1 id="重要日志模块：redo-log"><a href="#重要日志模块：redo-log" class="headerlink" title="重要日志模块：redo log"></a>重要日志模块：redo log</h1><p>其实就是 MySQL 里经常说到的 WAL 技术，WAL 的全称是 Write-Ahead Logging（预写日志记录），它的关键点就是先写日志，再写磁盘。</p><blockquote><p>需要注意的是：redo log 也是在磁盘里的，并不是保存在内存里。</p></blockquote><p><strong>redo log工作流程：</strong></p><ol><li>当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log 里面。</li><li>更新内存，将这条记录的最新值放到内存里。</li><li>之后 InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。</li></ol><p><strong>干嘛要搞的这么复杂，直接写磁盘不好吗？</strong></p><ul><li><strong>直接写磁盘？？</strong>那不是每次都要去找要写在哪里，数据那么多，等找出来不是人都麻了。</li><li><strong>那redo log不也是写磁盘？？</strong>redo log是在磁盘中单独开辟出来的一块空间写滴，每次要写就在后面追加写上去就完了，不用每次都去找要写在哪里，等有空了再去找写在哪里然后写进去，省去了一个寻址的操作。<strong>顺序写可比随机写快的多的多</strong></li></ul><p><strong>还有个事儿，redo log的大小是固定的哇！！！</strong></p><blockquote><p>换句话说就是长江后浪推前浪，前浪被拍死在沙滩上哇！！前浪都被后浪卷死了哇！！！</p></blockquote><p>看图吧您！！</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/redo_log%E5%BE%AA%E7%8E%AF%E5%86%99%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="redo_log循环写示意图"></p><p>write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。就像是循环数组一样。</p><p><strong>讲这么多，redo log干嘛的哇？？</strong>用来搞哪个crash-safe的哇！！</p><blockquote><p>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe。</p><p>redo log是将未提交的数据写入磁盘，不是写入内存，因此如果数据库异常重启了，那么InnoDB也可以通过读取redo log来重新恢复那些未提交的事务。这样的能力称之为crash-safe</p></blockquote><h1 id="重要的日志模块：binlog"><a href="#重要的日志模块：binlog" class="headerlink" title="重要的日志模块：binlog"></a>重要的日志模块：binlog</h1><blockquote><p><strong>为什么有了redo log还需要binlog？</strong></p><p>上一篇笔记中说过 MySQL 整体来看，其实就有两块：一块是 Server 层，负责 MySQL 功能层面的事情，另外一块是引擎层，负责存储相关的具体事宜。redo log 只是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）。</p><p>因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力。</p></blockquote><h2 id="两种日志的不同点："><a href="#两种日志的不同点：" class="headerlink" title="两种日志的不同点："></a>两种日志的不同点：</h2><ol><li><p>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</p></li><li><p>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID&#x3D;2 这一行的 c 字段加 1 ”。</p></li><li><p>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</p></li></ol><p><strong>binlog的工作流程：</strong></p><ol><li><p>执行器先找引擎取 ID&#x3D;2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID&#x3D;2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</p></li><li><p>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</p></li><li><p>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，<strong>此时 redo log 处于 prepare 状态。</strong></p></li><li><p>然后告知执行器执行完成了，随时可以提交事务。执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</p></li><li><p>执行器调用引擎的提交事务接口，<strong>引擎把刚刚写入的 redo log 改成提交（commit）状态</strong>，更新完成。</p></li></ol><p>整个执行流程示意图（图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。）<br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/binlog%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="binlog执行流程示意图"></p><p>最后的三步将redo log的写入分成了两个部分，prepare和commit 这就是“两阶段提交”</p><h2 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h2><p>两阶段提交是为了保证两个日志的一致性设计的。</p><p><strong>假设没有两阶段提交，会怎样？</strong></p><ul><li><p><strong>先提交redo log：</strong>（提交完MySQL挂掉）</p><ul><li>重启恢复：redo log 比 binlog 多出一条数据，<ul><li>如果后续拿 binlog 做备份恢复，则丢失该条数据</li><li>如果此时拿 binlog 做一个从库复制，则从库比主库少了该条数据</li></ul></li></ul></li><li><p><strong>先提交binlog：</strong>（提交完MySQL挂掉）</p><ul><li>重启恢复：使用redo log恢复，此时 binlog 比库中多了一条数据记录<ul><li>如果后续拿 binlog 做备份恢复，会莫名多出来一条数据（该记录未曾提交）</li><li>如果此时拿 binlog 做一个从库复制，则从库比主库多了该条数据</li></ul></li></ul></li></ul><p><strong>有了两阶段提交之后呢？</strong></p><p>两阶段提交流程：1. prepare 阶段、2.写 binlog、3. commit<br>    - 在2之前崩溃：发现没有 commit 且两份日志不统一，自动回滚。两份日志一致<br>    - 在3之前崩溃：虽然没有 commit 但是两份日志统一，自动提交。两份日志一致<br>    - 备份：全靠 binlog</p><hr><blockquote><p>网友热心总结的一些问题，复习的时候可以试着回答一下。</p></blockquote><ol><li>redo log的概念是什么? 为什么会存在.</li><li>什么是WAL(write-ahead log)机制, 好处是什么.</li><li>redo log 为什么可以保证crash safe机制.</li><li>binlog的概念是什么, 起到什么作用, 可以做crash safe吗? </li><li>binlog和redolog的不同点有哪些? </li><li>物理一致性和逻辑一直性各应该怎么理解? </li><li>执行器和innoDB在执行update语句时候的流程是什么样的?</li><li>如果数据库误操作, 如何执行数据恢复?</li><li>什么是两阶段提交, 为什么需要两阶段提交, 两阶段提交怎么保证数据库中两份日志间的逻辑一致性(什么叫逻辑一致性)?</li><li>如果不是两阶段提交, 先写redo log和先写bin log两种情况各会遇到什么问题?</li></ol><p>大家加油：）</p>]]></content>
    
    
    <summary type="html">《极客时间-MySQL实战45讲》笔记整理。</summary>
    
    
    
    <category term="数据库" scheme="https://www.wrp.cool/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="笔记" scheme="https://www.wrp.cool/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【MySQL实战】基础架构：一条SQL查询语句是如何执行的？</title>
    <link href="https://www.wrp.cool/posts/7327/"/>
    <id>https://www.wrp.cool/posts/7327/</id>
    <published>2022-06-01T03:06:13.000Z</published>
    <updated>2022-06-13T07:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://time.geekbang.org/column/intro/100020801">《极客时间-MySQL实战45讲》01 | 基础架构：一条SQL查询语句是如何执行的？</a></p><ul><li>笔记整理</li></ul></blockquote><span id="more"></span><h1 id="MySQL-架构示意图"><a href="#MySQL-架构示意图" class="headerlink" title="MySQL 架构示意图"></a>MySQL 架构示意图</h1><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/MySQL%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" alt="MySQL逻辑架构图"></p><p>MySQL架构上从大体来说可以分为Server层和存储引擎层两个部分。</p><p><strong>Server层：</strong>包括连接器、查询缓存、分析器、优化器、执行器等，其中涵盖了MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有的跨存储引擎的功能也都在这一层实现，比如存储过程、触发器、视图等。</p><p><strong>存储引擎层：</strong>负责数据的存储和读取。其架构模式是插件式的，支持InnoDB、MyISAM、Menory等多个存储引擎。现在最常用的存储引擎是InnoDB，InnoDB从MySQL 5.5.5版本开始成为默认存储引擎。</p><h1 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h1><blockquote><p>连接器负责跟客户端建立连接、获取权限、维持和管理连接。</p></blockquote><p>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。<strong>之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</strong>但是这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。<u>修改完成后，只有再新建的连接才会使用新的权限设置。</u></p><p>由于 <u>MySQL 在执行过程中临时使用的内存是管理在连接对象里面的</u>。所以一旦一个连接使用时间过长，执行的操作越多，其所占用的内存也越大，而这些内存资源只有在连接被断开的时候才会被释放。一旦内存占用过大，就有可能会被系统强行杀掉，从现象上来看就是MySQL的异常重启。解决这个问题的方法一般有以下两种：</p><ol><li><strong>定期断开长连接。</strong>使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</li><li>如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，<strong>通过执行mysql_reset_connection来重新初始化连接资源。</strong>这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li></ol><h1 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h1><p>执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。</p><p>大多数情况下建议不要使用查询缓存，为什么呢？因为<strong>查询缓存往往弊大于利！</strong></p><p>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。这对于经常更新的表来说，查询缓存的命中率会非常低。除非是一些静态表，例如系统配置表之类的。</p><p>MySQL 也提供了显示指定是否使用缓存的方式：将参数 query_cache_type 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。而对于确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定，像下面这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> SQL_CACHE <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">10</span>；</span><br></pre></td></tr></table></figure><h1 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h1><p>对于SQL语句做词法分析、语法分析。</p><ul><li><strong>词法分析：</strong>分析SQL语句中的每个单词代表什么意思</li><li><strong>语法分析：</strong>分析SQL语句是否满足MySQL的语法要求</li></ul><h1 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h1><ul><li>决定使用索引的方式</li><li>如果是多表连接查询还需要决定表连接的先后顺序</li></ul><h1 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h1><p><strong>执行流程（没索引）：</strong></p><ol><li>调用 InnoDB 引擎接口取这个满足条件的第一行。</li><li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li><li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li></ol><p>在数据库的慢查询日志中有一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p><p>但是在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined 并不是完全相同的。</p><hr><p>实际上在连接器、分析器、执行器阶段都是会做权限的校验的，因此把权限校验的这一块内容放在最后一起说明：</p><p><strong>连接器的权限校验：</strong>应该是库的校验，因为连接是可以指定连接到哪个库中去的，不指定库的话连接成功之后也是要返回可以操作的库给用户的。</p><p><strong>分析器的权限校验：</strong>在分析器应该是做的表权限验证，因为分析器已经分析出要执行的SQL了需要调用那一张表了，在此处进行表的权限验证就是最合适的。</p><p><strong>执行器的权限校验：</strong>在执行器这一块我认为是做的一个存储过程、触发器、函数之类的验证，因为在这些模块中是可能会调用到其他的表的，而在分析器的时候并不知道这些模块都调用到什么表，因此MySQL需要判断当前用户是否有对这些模块所调用到的表的权限。</p><hr><blockquote><p>网友热心总结的一些问题，复习的时候可以试着回答一下。</p></blockquote><ol><li>Server 有多少组件，各自都是什么作用？</li><li>Server 层和存储引擎层各是什么作用？</li><li><code>you have an error in your SQL syntax</code> 这个错误是在词法分析还是语法分析的报错？</li><li>对于表的操作权限验证在哪里进行？</li><li>执行器执行查询语句的流程是怎么样的？</li></ol><p>大家加油：）</p>]]></content>
    
    
    <summary type="html">《极客时间-MySQL实战45讲》笔记整理。</summary>
    
    
    
    <category term="数据库" scheme="https://www.wrp.cool/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="笔记" scheme="https://www.wrp.cool/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
