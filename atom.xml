<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>知更</title>
  
  <subtitle>知道要更新，知道要进步</subtitle>
  <link href="https://www.wrp.cool/atom.xml" rel="self"/>
  
  <link href="https://www.wrp.cool/"/>
  <updated>2022-11-30T14:37:49.799Z</updated>
  <id>https://www.wrp.cool/</id>
  
  <author>
    <name>码小瑞</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IoC和Spring IoC</title>
    <link href="https://www.wrp.cool/posts/40742/"/>
    <id>https://www.wrp.cool/posts/40742/</id>
    <published>2022-11-30T10:39:50.000Z</published>
    <updated>2022-11-30T14:37:49.799Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IoC-概述"><a href="#IoC-概述" class="headerlink" title="IoC 概述"></a>IoC 概述</h1><p>控制反转 IoC（Inversion of Control)，是一种设计思想，DI（Dependency Injection）依赖注入是实现IOC的一种方法，也有人认为DI只是IOC的另一种说法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新闻类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FXNewsProvider</span> &#123; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听是否发布了新的新闻</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> IFXNewsListener newsListener;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对新闻做持久化操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> IFXNewsPersister newPersistener;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getAndPersistNews</span><span class="params">()</span> &#123;</span><br><span class="line">        String[] newsIds = newsListener.getAvailableNewsIds();</span><br><span class="line">        <span class="keyword">if</span>(ArrayUtils.isEmpty(newsIds)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(String newsId : newsIds) &#123; </span><br><span class="line">            <span class="type">FXNewsBean</span> <span class="variable">newsBean</span> <span class="operator">=</span> newsListener.getNewsByPK(newsId);</span><br><span class="line">            newPersistener.persistNews(newsBean);</span><br><span class="line">            newsListener.postProcessIfNecessary(newsId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的新闻类中需要 <code>newsListener</code> 监听新的新闻消息，<code>newPersistener</code> 对新闻做持久化操作，于是新闻类的内部需要依赖这两个对象才能完成新闻的获取和持久化操作。那么新闻类的构造器就应该是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FXNewsProvider</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.newsListener = <span class="keyword">new</span> <span class="title class_">NewsListener</span>();</span><br><span class="line">    <span class="built_in">this</span>.newPersistener = <span class="keyword">new</span> <span class="title class_">NewsPersister</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是回头看看我们是不是需要这么做呢？我们最终所要做的，其实就是直接调用 <code>persistNews()</code> 和 <code>postProcessIfNecessary()</code>，但是为了这两个方法我们需要构造整个对象出来，相当于加载了这个对象里面的全部方法和属性，但这很浪费。所以我们还能这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FXNewsProvider</span><span class="params">(NewsListener newsListener, NewsPersister newsPersister)</span> &#123; </span><br><span class="line">    <span class="built_in">this</span>.newsListener = newsListener;</span><br><span class="line">    <span class="built_in">this</span>.newPersistener = newsPersister;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让其他人去构造这两个对象，新闻类直接用就好了。所以，简单点来说，IoC的理念就是：<strong>让别人为你服务！</strong></p><p>通常情况下，被注入对象会直接依赖于被依赖对象。但是，在IoC的场景中，二者之间通过IoC Service Provider来打交道，所有的被注入对象和依赖对象现在由IoC Service Provider统一管理。</p><p>被注入对象需要什么，直接跟IOC Service Provider招呼一声，后者就会把相应的被依赖对象注入到被注入对象中，从而达到IoC Service Provider为被注入对象服务的目的。IoC Service Provider在这里就是通常的IoC突器所充当的角色。</p><p>从被注入对象的角度看，与之前直接寻求依赖对象相比，依赖对象的取得方式发生了<strong>反转</strong>，控制也从被注入对象转到了IoC Service Provider那里。</p><blockquote><p>如果要用一句话来概括 IoC 可以给我们带来什么，那么我希望是，IoC 是一种可以帮助我们解耦各业务对象间依赖关系的对象绑定方式！</p></blockquote><h2 id="IoC-Service-Provider"><a href="#IoC-Service-Provider" class="headerlink" title="IoC Service Provider"></a>IoC Service Provider</h2><p>虽然业务对象可以通过 IoC 方式声明相应的依赖（构造器、setter、属性等注入方式），但是最终仍然需要通过某种角色或者服务将这些对象绑定到一起，IoC Service Provider 就对应着 IoC 场景中的这一角色。</p><p>IoC Service Provider 的职责相对来说比较简单，主要有两个：<strong>业务对象的构建管理</strong>和<strong>业务对象间的依赖绑定</strong>。</p><p>业务对象的构建管理由容器内部自动搞定，但是业务对象间的依赖绑定关系就需要程序员来描述了。可以使用直接编码、配置文件、注解等方式描述业务对象之间的依赖绑定关系。</p><h1 id="Spring-IoC-概述"><a href="#Spring-IoC-概述" class="headerlink" title="Spring IoC 概述"></a>Spring IoC 概述</h1><p>Spring 的 IoC 容器就是一个 IoC Service Provider，但 Spring 的 IoC 容器还提供了一些额外的服务。例如：对象生命周期管理、对象作用域范围管理、AOP支持等。</p><p>Spring 提供了两种容器类型：<strong>BeanFactory</strong> 和 <strong>ApplicationContext</strong>。</p><h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><p>基础类型 IoC 容器，提供完整的 IoC 服务支持，默认采用延迟初始化策略。<strong>所以，相对来说，容器启动初期速度较快，所需要的资源有限。</strong>对于资源有限，并且功能要求不是很严格的场景，BeanFactory是比较合适的 IoC 容器选择。</p><h2 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h2><p>ApplicationContext 在 BeanFactory 的基础上构建，是相对比较高级的容器实现，除了拥有 BeanFactory 的所有支持，ApplicationContext 还提供了其他高级特性，比如事件发布、国际化信息支持等。</p><p>ApplicationContext 所管理的对象，在该类型容器启动之后，默认全部初始化并绑定完成。所以，相对于 BeanFactory 来说，ApplicationContext 要求更多系统资源，启动时间也会更长一些。在哪些系统资源充足，并且要求更多功能的场景中，ApplicationContext 类型的容器是比较合适的选择。</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/ApplicationContext%E5%92%8CBeanFactory%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="ApplicationContext和BeanFactory继承关系图"></p>]]></content>
    
    
    <summary type="html">《Spring揭秘》读书笔记</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>行为型设计模式</title>
    <link href="https://www.wrp.cool/posts/38849/"/>
    <id>https://www.wrp.cool/posts/38849/</id>
    <published>2022-11-17T05:35:23.000Z</published>
    <updated>2022-11-27T08:55:56.243Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>结构型设计模式</title>
    <link href="https://www.wrp.cool/posts/56424/"/>
    <id>https://www.wrp.cool/posts/56424/</id>
    <published>2022-11-17T05:35:08.000Z</published>
    <updated>2022-11-27T08:55:49.948Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>创建型设计模式</title>
    <link href="https://www.wrp.cool/posts/31805/"/>
    <id>https://www.wrp.cool/posts/31805/</id>
    <published>2022-11-17T05:09:37.000Z</published>
    <updated>2022-11-27T09:02:22.621Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><blockquote><p>一个对象保证在内存中只有一个实例。</p></blockquote><p><strong>单线程模式下</strong>的单例模式非常简单：</p><ol><li>设计一个全局变量保存单例对象的唯一实例</li><li>设计一个私有的构造函数保证外界无法实例化单例对象</li><li>设计一个静态方法返回这个全局变量</li></ol><p>根据这个实例化对象的实例化时机又可以分为懒汉式单例和饿汉式单例：</p><ul><li>懒汉式：在第一次获取单例对象时实例化唯一的单例对象</li><li>饿汉式：在程序启动时实例化单例对象</li></ul><p><strong>多线程模式下</strong>也是像上面的流程一样。</p><h2 id="双重检查锁-DCL"><a href="#双重检查锁-DCL" class="headerlink" title="双重检查锁 DCL"></a>双重检查锁 DCL</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleInstance</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 单例对象，volatile 禁止指令重排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">SingleInstance</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;有坏人要重复创建对象了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 静态方法返回全局变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingleInstance <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 外层if：保证性能</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// synchronized 锁住类对象，保证该虚拟机实例内同一时刻只有一个线程能执行</span></span><br><span class="line">            <span class="keyword">synchronized</span>(SingleInstance.class) &#123;</span><br><span class="line">                <span class="comment">// 内层if：保证单例对象不被重复创建</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">SingleInstance</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>顺带一提：DCL 这种方式可以保证被保护的代码在整个虚拟机实例内只执行一次。</p></blockquote><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleInstance</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">SingleInstance</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleInstance</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingleInstance <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于Java中每个类对应唯一的Class文件，所以类的静态属性实际上只会随着类的加载而加载，之后就再也不会去创建这个对象了，也就实现了单例模式。Java中类的加载肯定是只有唯一一次的，所以不管在创建这个类的时候有没有发生指令重排序，这个过程对外都是不可见的。也就解决了指令重排序的问题。</p><blockquote><p>注意：外部类加载时并不需要立即加载内部类，所以这是一种懒汉式加载单例类实例对象的方式</p></blockquote><h2 id="Enum-方式"><a href="#Enum-方式" class="headerlink" title="Enum 方式"></a>Enum 方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumSingleInstance</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    EnumSingleInstance() &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> EnumSingleInstance.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><blockquote><p>将对象的创建与使用解耦。使用的方式是引入工厂类，将目标对象的创建交给工厂类执行，需要目标对象时从工厂类获取。</p></blockquote><p>对象的创建与使用之间的解耦上面单例模式的 <code>getInstance()</code> 方法就是一个例子。</p><h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;一个对象保证在内存中只有一个实例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;单线</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>AOP和Spring AOP</title>
    <link href="https://www.wrp.cool/posts/9732/"/>
    <id>https://www.wrp.cool/posts/9732/</id>
    <published>2022-11-16T15:33:41.000Z</published>
    <updated>2022-12-03T14:13:19.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>AOP 是一种理念，要实现这种理念通常需要一种现实的方式。与 OOP 需要相应的语言支持一样，AOP 也需要某种语言以帮助实现相应的概念实体，这些实现 AOP 的语言被统称为 AOL，即 Aspect-Oriented Language。</p><p>AOL 可以与系统实现语言相同，比如，如果系统实现语言为 Java，那么，相应的 AOL 也可以为 Java。但 AOL 并非一定要与系统实现语言相同，它也可以是其他语言，比如 AspectJ 是扩展自 Java 的一种 AOL，显然与 Java 的系统实现语言（C++）属于不同的两种语言。</p><p>Java 平台上的 AOP 实现机制：动态代理、动态字节码增强、Java代码生成、自定义类加载器、AOL 扩展（AspectJ）。</p><h2 id="AOP-的概念实体"><a href="#AOP-的概念实体" class="headerlink" title="AOP 的概念实体"></a>AOP 的概念实体</h2><h3 id="Joinpoint"><a href="#Joinpoint" class="headerlink" title="Joinpoint"></a>Joinpoint</h3><p>在系统运行之前，AOP 的功能模块都需要织入到 OOP 的功能模块中。所以，要进行这种织入过程我们需要知道在系统的哪些执行点上进行织入操作，这些将要在其之上进行织入操作的系统执行点就称之为Joinpoint。</p><p><strong>常见的 Joinpoint 类型：</strong></p><ul><li>方法调用（method call）：方法被调用时所处的程序执行点</li><li>方法执行（method execution）：方法内部执行开始时点</li></ul><p>方法调用是在调用对象上的执行点，而方法执行则是在被调用到的方法逻辑执行的时点。对于同一对象，方法调用要先于方法执行。</p><ul><li>构造方法调用：程序执行过程中某个对象调用其构造方法进行初始化的时点</li><li>构造方法执行：某个对象构造方法内部执行的开始时点</li><li>字段设置：对象的某个属性通过 setter 方法被设置 <strong>或者</strong> 直接被设置的时点</li><li>字段获取：某个对象相应属性被访问的时点，可以是 getter 方法访问 <strong>或者</strong> 是直接访问</li><li>异常处理执行：在某些异常类型抛出后，对应的异常处理逻辑执行的时点</li><li>类初始化：类中某些静态类型或者静态块的初始化时点</li></ul><h3 id="Pointcut"><a href="#Pointcut" class="headerlink" title="Pointcut"></a>Pointcut</h3><p>Pointcut 概念代表的是 Joinpoint 的表述方式。将横切逻辑织入当前系统的过程中，需要参照 Pointcut 规定的 Joinpoint 信息，才可以知道应该往系统的哪些 Joinpoint 上织入横切逻辑。</p><blockquote><p>我理解的 Pointcut 概念就是一组 Joinpoint 的集合。</p></blockquote><p><strong>Pointcut 的表述方式：</strong></p><p>Pointcut 可以直接指定 Joinpoint 所在方法名称，也可以使用正则表达式，或者特定的 Pointcut 表述语言。</p><p>通常，Pointcut 与 Pointcut 之间还可以进行逻辑运算（&amp;&amp; ||）。这样，我们就可以从简单 Pointcut 开始，然后通过逻辑运算，得到最终需要的可能较为复杂的 Pointcut。</p><h3 id="Advice"><a href="#Advice" class="headerlink" title="Advice"></a>Advice</h3><p>Advice 是单一横切关注点逻辑的载体，它代表将会植入到 Joinpoint 的横切逻辑。如果将 Aspect 比作 OOP 中的 Class，那么 Advice 就相当于 Class 中的 Method。</p><p>按照 Advice 在 Joinpoint 位置执行实际的差异或者完成功能的不同，Advice 可以分成多种具体形式，如下：</p><ol><li><strong>Before Advice：</strong>在 Joinpoint 指定位置之前执行的 Advice 类型。</li><li><strong>After Advice：</strong>在相应连接点之后执行的 Advice 类型，但该类型的 Advice 还可以细分为以下三种：<ol><li>After returning Advice：当前 Joinpoint 处执行流程正常完成后执行；</li><li>After throwing Advice：在当前 Joinpoint 执行过程中抛出异常的情况下才执行；</li><li>After Advice：不管 Joinpoint 处执行流程正常结束还是抛出异常都会执行，类似 finally 块。</li></ol></li><li><strong>Around Advice：</strong>对附加其上的 Joinpoint 进行 “包裹” 可以在 Joinpoint 之前和之后都指定相应的逻辑，甚至于中断或者忽略 Joinpoint 处原来程序流程的执行，比如 Servlet 的 Filter 功能就是一种 Around Advice 的体现。</li><li><strong>Introduction：</strong>Introduction 可以为原有的对象添加新的特性或者行为，这就好像你是一个普通公民，但让你穿军装、戴军帽，添加了军人类型的 Introduction 之后，你就拥有军人的特性或者行为。</li></ol><h3 id="Aspect"><a href="#Aspect" class="headerlink" title="Aspect"></a>Aspect</h3><p>Aspect 是对系统中的横切逻辑关注点逻辑进行模块化封装的 AOP 概念实体。通常情况下，Aspect 可以包含多个 Pointcut 以及相关 Advice 定义。</p><blockquote><p>就是对 Pointcut 和 Advice 进行统一的封装和处理。</p></blockquote><h3 id="织入和织入器"><a href="#织入和织入器" class="headerlink" title="织入和织入器"></a>织入和织入器</h3><p>织入（Weaving）的过程就是连接 AOP 和 OOP 的桥梁，只有经过织入过程之后，以 Aspect 模块化的横切关注点才会集成到 OOP 的现存系统中。而完成织入这个动作的实体就是织入器。</p><h3 id="目标对象"><a href="#目标对象" class="headerlink" title="目标对象"></a>目标对象</h3><p>符合 Pointcut 所指定的条件，将织入过程中被织入横切逻辑的对象，称为目标对象（Target Object）。</p><h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><p>Spring AOP 属于第二代 AOP，采用动态代理机制和字节码生成技术实现。动态代理机制和字节码生成都是在运行期间为目标对象生成一个代理对象，而将横切逻辑织入到这个代理对象中，系统最终使用的是织入了横切逻辑的代理对象，而不是真正的目标对象。</p><h2 id="动态代理机制"><a href="#动态代理机制" class="headerlink" title="动态代理机制"></a>动态代理机制</h2><p>动态代理机制的实现主要由一个类和一个接口组成，即 <code>java.lang.reflect.Proxy</code> 类和 <code>java.lang.reflect.InvocationHandler</code> 接口。使用起来像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理类与被代理类共同接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ISubject</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被代理类实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubjectImpl</span> <span class="keyword">implements</span> <span class="title class_">ISubject</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SubjectImpl::request()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态代理具体实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestCtrlInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">RequestCtrlInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.target = target;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 横切逻辑的载体，相当于 Advice</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;RequestCtrlInvocationHandler::invoke() begin&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;RequestCtrlInvocationHandler::invoke() end&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   <span class="type">ISubject</span> <span class="variable">subject</span> <span class="operator">=</span> (ISubject) Proxy.newProxyInstance(</span><br><span class="line">            SubjectImpl.class.getClassLoader(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;ISubject.class&#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RequestCtrlInvocationHandler</span>(<span class="keyword">new</span> <span class="title class_">SubjectImpl</span>()));</span><br><span class="line">   subject.request();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// RequestCtrlInvocationHandler::invoke() begin</span></span><br><span class="line"><span class="comment">// SubjectImpl::request()</span></span><br><span class="line"><span class="comment">// RequestCtrlInvocationHandler::invoke() end</span></span><br></pre></td></tr></table></figure><p>即使还有更多的目标对象类型，只要它们织入的横切逻辑相同，用 RequestCtrlInvocationHandler 一个类并通过 Proxy 为它们生成相应的动态代理实例就可以满足要求。当 Proxy 动态生成的代理对象上相应的接口方法被调用时，对应的 InvocationHandler 就会拦截相应的方法调用，并进行相应处理。</p><p>动态代理机制只能对实现了相应 Interface 的类使用，如果某个类没有实现任何的 Interface，就无法使用动态代理机制为其生成相应的动态代理对象。</p><p><strong>为什么动态代理必须实现接口？</strong></p><ol><li>代理模式要求代理类和被代理类需要实现相同的接口；</li><li>动态代理生成的代理类会自动继承自 <code>java.lang.reflect.Proxy</code>，无法再继承被代理类；</li><li><code>Proxy::newProxyInstance</code> 方法返回 Object 对象，需要有一个接口可以强制类型转换，才能调用代理方法。</li></ol><h2 id="字节码生成"><a href="#字节码生成" class="headerlink" title="字节码生成"></a>字节码生成</h2><p>使用动态字节码生成技术需要借助 CGLIB 这样的动态字节码生成库，其扩展对象行为的原理是，我们可以对目标对象进行继承扩展，为其生成相应的子类，而子类可以通过重写来扩展父类的行为，只要将横切逻辑的实现放到子类中，然后让系统使用扩展后的目标对象的子类，就可以达到与代理模式相同的结果了。<code>SubClass instanceof SuperClass == true</code>。</p><p>要使用 CGLIB 进行扩展，首先需要实现一个 <code>org.springframework.cglib.proxy.Callback</code>。不过更多的时候，我们会直接使用 <code>org.springframework.cglib.proxy.MethodInterceptor</code> 接口（MethodInterceptor 扩展了 Callback 接口）</p><p>使用 CGLIB 扩展 SubjectImpl 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubjectCallback</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SubjectCallback::intercept() begin&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> methodProxy.invokeSuper(obj, objects);</span><br><span class="line">        System.out.println(<span class="string">&quot;SubjectCallback::intercept() end&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setSuperclass(SubjectImpl.class);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">SubjectCallback</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">SubjectImpl</span> <span class="variable">subject</span> <span class="operator">=</span> (SubjectImpl) enhancer.create();</span><br><span class="line">        subject.request();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// SubjectCallback::intercept() begin</span></span><br><span class="line"><span class="comment">// SubjectImpl::request()</span></span><br><span class="line"><span class="comment">// SubjectCallback::intercept() end</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过为 enhancer 指定需要生成的子类对应的父类，以及 Callback 实现，enhancer 最终为我们生成了需要的代理对象实例。</p><p>使用 CGLIB 也有一个缺点，就是<strong>无法对 final 方法进行重写。</strong></p>]]></content>
    
    
    <summary type="html">《Spring揭秘》读书笔记</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Spring的IoC容器之 ApplicationContext</title>
    <link href="https://www.wrp.cool/posts/11908/"/>
    <id>https://www.wrp.cool/posts/11908/</id>
    <published>2022-11-16T15:15:56.000Z</published>
    <updated>2022-12-03T03:44:56.665Z</updated>
    
    <content type="html"><![CDATA[<p><strong>常用实现：</strong></p><ul><li><code>org.springframework.context.support.FileSystemXmlApplicationContext</code> 在默情况下，从文件系统加载 Bean 定义以及相关资源的 ApplicationContext 实现。</li><li><code>org.springframework.context.support.classPathXmlApplicationContext</code> 在默认情况下，从 Classpath 加载bean定义以及相关资源的 ApplicationContext 实现。</li><li><code>org.springframework.web.context.support.XmlWebApplicationContext</code> Spring 提供的用于 Web 应用程序的 ApplicationContext 实现。</li></ul><p>作为 Spring 提供的较之 BeanFactory 更为先进的 IoC 容器实现，ApplicationContext 除了拥有 BeanFactory 支持的所有功能之外，还有一些特有的特性，即统一资源加载策略、国际化信息支持、容器内事件发布、多配置模块加载简化等。</p><h1 id="统一资源加载策略"><a href="#统一资源加载策略" class="headerlink" title="统一资源加载策略"></a>统一资源加载策略</h1><p>Spring 框架内部使用 <code>org.springframework.core.io.Resource</code> 接口作为所有资源的抽象和访问接口，就是说它用来<strong>描述资源</strong>，在构造 BeanFactory 的时候已经接触过了，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanFactory</span>(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;...&quot;</span>));</span><br></pre></td></tr></table></figure><p>其中 ClassPathResource 就是 Resource 的一个特定类型的实现，代表的是位于 Classpath 中的资源。Resource 接口还有一些其他实现类：</p><ul><li><code>ByteArrayResource</code> 将字节数组提供的数据作为一种资源进行封装，如果通过 InputStream 形式访问该类型的资源，该实现会根据字节数组的数据，构造相应的 ByteArrayInputstream 并返回。</li><li><code>ClassPathResource</code> 该实现从Java应用程序的 ClassPath 中加载具体资源并进行封装，可以使用指定的类加载器或者给定的类进行资源加载。</li><li><code>FileSystemResource</code> 对java.io.File类型的封装，所以，我们可以以文件或者URL的形式对该类型资源进行访问，只要能跟File打的交道，基本上跟FileSystemResource也可以。</li><li><code>UrlResource</code> 通过 java.net.URL 进行的具体资源查找定位的实现类，内部委派 URL 进行具体的资源操作。</li></ul><h2 id="ResourceLoader"><a href="#ResourceLoader" class="headerlink" title="ResourceLoader"></a>ResourceLoader</h2><p>ResourceLoader 职责：查找和定位资源。<code>org.springframework.core.io.ResourceLoader</code> 接口是资源查找定位策略的统一抽象，具体的资源查找定位策略则由相应的 ResourceLoader 实现类给出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ResourceLoader</span> &#123; </span><br><span class="line">    <span class="type">String</span> <span class="variable">CLASSPATH_URL_PREFIX</span> <span class="operator">=</span> ResourceUtils.CLASSPATH_URL_PREFIX;</span><br><span class="line">    Resource <span class="title function_">getResource</span><span class="params">(String location)</span>;</span><br><span class="line">    ClassLoader <span class="title function_">getClassLoader</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>DefaultResourceLoader(class implements ResourceLoader)</strong></p><p>ResourceLoader 有一个默认的实现类，即 <code>org.springframework.core.io.DefaultResourceLoader</code>，该类默认的资源查找处理逻辑如下：</p><ol><li>首先，检查资源路径是否以 <code>classpath:</code> 前缀打头，是的话构造 ClassPathResource 类型资源并返回；</li><li>否则，通过 URL，根据资源路径来定位资源，如果没抛出 <code>MalformedURLException</code> 则构造 UrlResource 类型资源并返回；</li><li>否则，委派给 <code>getResourceByPath(String)</code> 方法，该方法的默认实现是，构造 ClassPathResource 类型的资源并返回；</li><li>最终，如果还没找到，<code>getResourceByPath(String)</code> 方法会构造一个不存在的资源并返回。</li></ol><p><strong>FileSystemResourceLoader(class extends DefaultResourceLoader)</strong></p><p>继承自 DefaultResourceLoader，并重写了 <code>getResourceByPath(String)</code> 方法。使之从文件系统加载资源并以 FileSystemResource 类型返回。</p><p><strong>ResourcePatternResolver(interface extends ResourceLoader)</strong></p><p>是 ResourceLoader 的扩展，可以根据指定的资源路径匹配模式每次返回多个 Resource 实例。而 ResourceLoader 每次只能返回单一实例。接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ResourcePatternResolver</span> <span class="keyword">extends</span> <span class="title class_">ResourceLoader</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">CLASSPATH_ALL_URL_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;classpath*:&quot;</span>;</span><br><span class="line">    Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PathMatchingResourcePatternResolver(class implements ResourcePatternResolver)</strong></p><p>构造该实例时，可以指定一个 ResourceLoader，默认是 DefaultResourceLoader。如果不指定任何 ResourceLoader 的话，<code>PathMatchingResourcePatternResolver</code> 在加载资源的行为上会与 DefaultResourceLoader 基本相同，只存在返回的 Resource 数量上的差异。</p><p>以上 ResourceLoader 之间的继承关系：</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/ResourceLoader%E9%97%B4%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt="ResourceLoader间继承关系"></p><h2 id="ApplicationContext与ResourceLoader"><a href="#ApplicationContext与ResourceLoader" class="headerlink" title="ApplicationContext与ResourceLoader"></a>ApplicationContext与ResourceLoader</h2><p>ApplicationContext 继承了 ResourcePatternResolver，当然就间接实现了 ResourceLoader 接口，所以，任何的 ApplicationContext 实现都可以看作是一个 ResourceLoader 甚至是 ResourcePatternResolver。而这就是 ApplicationContext 支持 Spring 内统一资源加载策略的真相。</p><p>通常，所有的 ApplicationContext 实现类会直接或者间接地继承 <code>org.springframework.context.support.AbstractApplicationContext</code>，从这个类上，我们就可以看到 ApplicationContext 与 ResourceLoader 之间的所有关系。</p><p>AbstractApplicationContext 继承了 DefaultResourceLoader，那么，它的 getResource(String) 当然就直接用 DefaultResourceLoader 的了。剩下还需要它做的就是 ResourcePatternResolver 的 <code>Resource[] getResources(String)</code> 了。</p><p>AbstractApplicationContext 类的内部声明有一个 resourcePatternResolver 属性，对应的实例类型为 PathMatchingResourcePatternResolver。PathMatchingResourcePatternResolver 在构造时会接收一个 ResourceLoader，而 AbstractApplicationContext 又继承自 DefaultResourceLoader，当然直接把自身注入进 PathMatchingResourcePatternResolver 了，而不是重新构造 DefaultResourceLoader。</p><blockquote><p><strong>所以：</strong><code>AbstractApplicationContext</code> 即可作为 <code>ResourceLoader</code> 又可以作为 <code>ResourcePatternResolver</code></p></blockquote><p>如果某个类需要依赖到 ResourceLoader 来查找定位资源，当然就可以直接把 ApplicationContext 容器实例注入到该类中。Spring 为这提供了 ResourceLoaderAware 和 ApplicationContextAware 接口。在 Bean 的生命周期中会可以为对象实例注入 ApplicationContext。</p><p>当然要求业务对象要实现 Spring 的接口就过于依赖 Spring 框架了，但我觉得这没什么不好的。</p><h1 id="容器内事件发布"><a href="#容器内事件发布" class="headerlink" title="容器内事件发布"></a>容器内事件发布</h1><p>Java SE 提供了实现自定义事件发布功能的基础类，即 <code>java.util.EventObject</code> 类和 <code>java.util.EventListener</code> 接口。所有的自定义事件类型可以通过扩展 EventObject 来实现，而事件监听器则可以实现 EventListener 接口。使用起来可以像这样：</p><h2 id="ApplicationContext-事件发布"><a href="#ApplicationContext-事件发布" class="headerlink" title="ApplicationContext 事件发布"></a>ApplicationContext 事件发布</h2><p>Spring 的 ApplicationContext 容器内部允许以 <code>org.springframework.context.ApplicationEvent</code> 的形式发布事件，容器内注册的 <code>org.springframework.context.ApplicationListener</code> 类型的 Bean 定义会被 ApplicationContext 容器自动识别，它们负责监听容器内发布的所有 ApplicationEvent 类型的事件。也就是说，一旦容器内发布 ApplicationEvent 及其子类型的事件，注册到容器的 ApplicationListener 就会对这些事件进行处理。</p><p><strong>ApplicationEvent(abstract class)</strong></p><p>继承自 <code>java.util.EventObject</code> 是一个抽象类，需要根据情况提供相应子类以区分不同情况。Spring 提供了三个实现：</p><ol><li>ContextClosedEvent：ApplicationContext 容器在即将关闭的时候发布的事件类型。</li><li>ContextRefreshedEvent：ApplicationContext 容器在初始化或者刷新的时候发布的事件类型。</li><li>RequestHandlerEvent：Web 请求处理后发布的事件，其有一子类 ServletRequestHandlerEvent 提供特定于 Java EE 的 Servlet 相关事件。</li></ol><p><strong>ApplicationListener(interface)</strong></p><p>ApplicationContext 容器内使用的自定义事件监听器接口定义，继承自 <code>java.util.EventListener</code>。ApplicationContext 容器在启动时，会自动识别并加载 EventListener 类型 Bean定义，一旦容器内有事件发布，将通知这些注册到容器的 EventListener。</p><p><strong>ApplicationContext</strong></p><p>ApplicationContext 继承了 ApplicationEventPublisher 接口，该接口提供了 <code>void publishEvent(Object event)</code> 方法定义，自然也能充当事件发布者的角色。</p><p>ApplicationContext 容器把事件的发布和事件监听器的注册这些事情给转包给 <code>org.springframework.context.event.ApplicationEventMulticaster</code> 接口来实现，该接口定义了具体事件监听器的注册管理以及事件发布的方法，它有一个抽象实现类 <code>org.springframework.context.event.AbstractApplicationEventMulticaster</code>，这个抽象类实现了事件监听器的管理功能，出于灵活性和扩展性考虑，事件的发布功能则委托给了其子类。Spring 为这个抽象类提供了一个子类实现 <code>org.springframework.context.event.SimpleApplicationEventMulticaster</code>，添加了事件发布功能。不过，其默认使用了 SyncTaskExecutor 进行事件的发布，这可能存在一些性能问题，可以为其提供其他类型的 TaskExecutor 实现类。</p><p>因为 ApplicationContext 容器的事件发布功能全部委托给了 ApplicationEventMulticaster，所以在容器启动的时候就会检查容器内是否存在名称为 applicationEventMulticaster 的 ApplicationEventMulticaster 对象实例。有的话就使用提供的实现，没有则默认初始化一个 SimpleApplicationEventMulticaster 作为默认实现。</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/ApplicationContext%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B8%83%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="ApplicationContext事件发布关系图"></p><p>如果在业务对象中需要使用到事件发布，可以实现 <code>ApplicationEventPublisherAware</code> 接口或者是实现 <code>ApplicationContextAware</code> 接口。</p><hr><blockquote><p>ApplicationContext 还有国际化信息支持、多配置模块加载简化等其他功能，但是平时用的比较少，这里也就不多说了。实际上本文提到的统一资源加载策略、容器内事件发布等功能在平时用的也不多，但是这一块内容 Spring 在接口、类的继承和实现关系上处理的比较复杂，值得学习与研究。</p></blockquote>]]></content>
    
    
    <summary type="html">《Spring揭秘》读书笔记</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Spring的IoC容器之 BeanFactory</title>
    <link href="https://www.wrp.cool/posts/55764/"/>
    <id>https://www.wrp.cool/posts/55764/</id>
    <published>2022-11-16T15:15:39.000Z</published>
    <updated>2022-12-01T10:39:22.175Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h1><p>BeanFactory，顾名思义，就是生产 Bean 的工厂。作为 Spring 提供的基本的 IoC 容器，BeanFactory 可以完成作为 IoC Service Provider 的所有职责，包括业务对象的注册和对象间依赖关系的绑定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanFactory</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">FACTORY_BEAN_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line">    Object <span class="title function_">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">    Object <span class="title function_">getBean</span><span class="params">(String name, Class requiredType)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">    Object <span class="title function_">getBean</span><span class="params">(String name, Object[] args)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">containsBean</span><span class="params">(String name)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isTypeMatch</span><span class="params">(String name, Class targetType)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">    Class <span class="title function_">getType</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">    <span class="comment">// 获取别名</span></span><br><span class="line">    String[] getAliases(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前我们的系统业务对象需要自己去“拉”（PULL）所依赖的业务对象，有了 BeanFactory 之类的 IoC 容器之后，需要依赖什么让 BeanFactory 为我们“推”（PUSH）过来就行了。</p><ul><li>自己去“拉”就相当于是自己创建所依赖的对象。</li><li>让 BeanFactory 为我们“推”过来就必须把依赖对象和被依赖对象都交给 BeanFactory 去管理。</li></ul><p>像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BeanFactory</span> <span class="variable">container</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanFactory</span>(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;配置文件路径&quot;</span>));</span><br><span class="line"><span class="type">FXNewsProvider</span> <span class="variable">newsProvider</span> <span class="operator">=</span> (FXNewsProvider) container.getBean(<span class="string">&quot;BeanName&quot;</span>);</span><br><span class="line">newsProvider.getAndPersistNews();</span><br></pre></td></tr></table></figure><p>虽然把对象直接交给 BeanFactory 管理，但是对象之间的依赖绑定还是需要程序员自己描述清楚才可以。可以直接编码来描述对象之间的依赖关系，也可以使用配置文件来描述比如 .xml 文件，或者是注解比如 <code>@Autowired</code> 和 <code>@Component</code> ，但不管是什么方式，最终都会转换成代码的方式运行。</p><p>像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanRegistry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line">    <span class="type">BeanFactory</span> <span class="variable">container</span> <span class="operator">=</span> (BeanFactory) bindViaCode(beanRegistry);</span><br><span class="line">    <span class="type">FXNewsProvider</span> <span class="variable">newsProvider</span> <span class="operator">=</span> (FXNewsProvider) container.getBean(<span class="string">&quot;newsProvider&quot;</span>);</span><br><span class="line">    newsProvider.getAndPersistNews();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BeanFactory <span class="title function_">bindViaCode</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    <span class="type">AbstractBeanDefinition</span> <span class="variable">newsProvider</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(FXNewsProvider.class, <span class="literal">true</span>);</span><br><span class="line">    <span class="type">AbstractBeanDefinition</span> <span class="variable">newsListener</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(NewsListener.class, <span class="literal">true</span>);</span><br><span class="line">    <span class="type">AbstractBeanDefinition</span> <span class="variable">newsPersister</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(NewsPersister.class,<span class="literal">true</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 将 Bean 定义注册到容器中</span></span><br><span class="line">    registry.registerBeanDefinition(<span class="string">&quot;newsProvider&quot;</span>, newsProvider);</span><br><span class="line">    registry.registerBeanDefinition(<span class="string">&quot;listener&quot;</span>, newsListener);</span><br><span class="line">    registry.registerBeanDefinition(<span class="string">&quot;persister&quot;</span>, newsPersister);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定依赖关系</span></span><br><span class="line">    <span class="comment">// 1. 可以通过构造方法注入方式</span></span><br><span class="line">    <span class="type">ConstructorArgumentValues</span> <span class="variable">argValues</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConstructorArgumentValues</span>();</span><br><span class="line">    argValues.addIndexedArgumentValue(<span class="number">0</span>, newsListener);</span><br><span class="line">    argValues.addIndexedArgumentValue(<span class="number">1</span>, newsPersister);</span><br><span class="line">    newsProvider.setConstructorArgumentValues(argValues);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 或者通过 setter 方法注入方式</span></span><br><span class="line">    <span class="type">MutablePropertyValues</span> <span class="variable">propertyValues</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MutablePropertyValues</span>();</span><br><span class="line">    propertyValues.addPropertyValue(<span class="keyword">new</span> <span class="title class_">PropertyValue</span>(<span class="string">&quot;newsListener&quot;</span>,newsListener));</span><br><span class="line">    propertyValues.addPropertyValue(<span class="keyword">new</span> <span class="title class_">PropertyValue</span>(<span class="string">&quot;newPersistener&quot;</span>,newsPersister));</span><br><span class="line">    newsProvider.setPropertyValues(propertyValues);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定完成</span></span><br><span class="line">    <span class="keyword">return</span> (BeanFactory) registry;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>BeanFactory 只是一个接口，我们最终需要一个该接口的实现来进行实际的 Bean 的管理，<code>DefaultListableBeanFactory</code> 就是这么一个比较通用的 BeanFactory 实现类。</p><p><code>DefaultListableBeanFactory</code> 除了间接实现了 BeanFactory 接口，还实现了 <code>BeanDefinitionRegistry</code> 接口，该接口才是 BeanFactory 的实现中担当 Bean 注册管理的角色。BeanFactory 接口只定义如何访问容器内管理 Bean 的方法，各个 BeanFactory 的具体实现类负责具体 Bean 的注册以及管理工作。</p><p><code>BeanDefinitionRegistry</code> 接口定义抽象了 Bean 的注册逻辑。通常情况下，具体的 BeanFactory 实现类会实现这个接口来管理 Bean 的注册。它们之间的关系像这样：</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/BeanDefinitionRegistry%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg" alt="BeanDefinitionRegistry关系图"></p><p>每一个受管的对象，在容器中都会有一个 BeanDefinition 的实例与之相对应，该 BeanDefinition 的实例负责保存对象的所有必要信息，包括其对应的对象的class类型、是否是抽象类、构造方法参数以及其他属性等。当客户端向 BeanFactory 请求相应对象的时候，BeanFactory 会通过这些信息为客户端返回一个完备可用的对象实例。</p><h1 id="Bean-的-scope"><a href="#Bean-的-scope" class="headerlink" title="Bean 的 scope"></a>Bean 的 scope</h1><p>Spring 容器最初提供了两种 Bean 的 scope 类型：singleton（默认） 和 prototype，但发布 2.0 之后，又引入了另外三种类型，即 request、session 和 global session 类型。不过这三种类型有所限制，只能在 Web 应用中使用。也就是说，只有在支持 Web 应用的 ApplicationContext 中使用这三个 scope 才是合理的。</p><h2 id="singleton"><a href="#singleton" class="headerlink" title="singleton"></a>singleton</h2><p>标记为拥有 singleton scope 的对象定义，在 Spring 的 IoC 容器中只存在一个实例，所有对该对象的引用将共享这个实例。该实例从容器启动，并因为第一次被请求而初始化之后，将一直存活到容器退出，也就是说，它与 IoC 容器“几乎”拥有相同的“寿命”。</p><p>注意：标记为 singleton 的 bean 是由容器来保证这种类型的 bean 在同一个容器中只存在一个共享实例。如果你要手动创建它那容器也管不着是吧，应该要与单例模式区分开来，单例模式是保证在同一个 ClassLoader 中只存在一个这种类型的实例。</p><h2 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h2><p>针对声明为拥有 prototype scope 的 Bean 定义，容器在接到该类型对象的请求的时候，会每次都重新生成一个新的对象实例给请求方。虽然这种类型的对象的实例化以及属性设置等工作都是由容器负责的，但是只要准备完毕，并且对象实例返回给请求方之后，容器就不再拥有当前返回对象的引用，请求方需要自己负责当前返回对象的后继生命周期的管理工作，包括该对象的销毁。也就是说，容器每次返回给请求方一个新的对象实例之后，就任由这个对象实例“自生自灭”了。</p><h2 id="自定义-scope"><a href="#自定义-scope" class="headerlink" title="自定义 scope"></a>自定义 scope</h2><p><code>org.springframework.beans.factory.config.Scope</code> 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Scope</span> &#123; </span><br><span class="line">    Object <span class="title function_">get</span><span class="params">(String name, ObjectFactory objectFactory)</span>;</span><br><span class="line">    Object <span class="title function_">remove</span><span class="params">(String name)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">registerDestructionCallback</span><span class="params">(String name, Runnable callback)</span>;</span><br><span class="line">    String <span class="title function_">getConversationId</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要实现自己的 scope 类型，首先需要给出一个 Scope 接口的实现类，接口定义中的4个方法并非都是必须的，但 <code>get()</code> 和 <code>remove()</code> 方法必须实现。一个基于线程的 ThreadScope 的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadScope</span> <span class="keyword">implements</span> <span class="title class_">Scope</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;String, Object&gt;&gt; threadScope = ThreadLocal.withInitial(HashMap::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 容器每次获取对象会来调用这个方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String name, ObjectFactory&lt;?&gt; objectFactory)</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; scope = threadScope.get();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> scope.get(name);</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">            obj = objectFactory.getObject();</span><br><span class="line">            scope.put(name, obj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">remove</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; scope = threadScope.get();</span><br><span class="line">        <span class="keyword">return</span> scope.remove(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了 Scope 的实现类之后，我们需要把这个 Scope 注册到容器中，才能提供相应的 Bean 定义使用。通常情况下，我们可以使用 <code>ConfigurableBeanFactory</code> 的 <code>void registerScope(String scopeName, Scope scope);</code> 方法注册自定义 Scope。</p><p><code>ConfigurableBeanFactory</code> 接口间接继承了 BeanFactory 接口。</p><p>Spring 还提供了一个 <code>BeanFactoryPostProcessor</code> 用于注册自定义 Scope，即 <code>org.springframework.beans.factory.config.CustomScopeConfigurer</code>。</p><p>对于 ApplicationContext 来说，它可以自动识别并加载 <code>BeanFactoryPostProcessor</code>，所以可以直接配置 <code>CustomScopeConfigurer</code>。像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">CustomScopeConfigurer <span class="title function_">csc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">CustomScopeConfigurer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomScopeConfigurer</span>();</span><br><span class="line">    c.addScope(<span class="string">&quot;thread&quot;</span>, <span class="keyword">new</span> <span class="title class_">ThreadScope</span>());</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="BeanFactory-运行阶段"><a href="#BeanFactory-运行阶段" class="headerlink" title="BeanFactory 运行阶段"></a>BeanFactory 运行阶段</h1><p>Spring 的 IoC 容器实现以上功能的过程，基本上可以按照类似的流程划分为两个阶段，即<strong>容器启动阶段</strong>和<strong>Bean实例化阶段</strong></p><h2 id="容器启动阶段"><a href="#容器启动阶段" class="headerlink" title="容器启动阶段"></a>容器启动阶段</h2><blockquote><p>.xml, @Component –&gt; BeanDefinition</p></blockquote><p>容器启动伊始，首先会通过某种途径加载 Configuration MetaData。除去代码方式比较直接，在大部分情况下，容器需要依赖某些工具类（BeanDefinitionReader）对加载的 Configuration MetaData 进行解析和分析，并将分析后的信息编组为相应的 BeanDefinition，最后把这些保存了 Bean 定义必要信息的 BeanDefinition，注册到相应的 BeanDefinitionRegistry，这样容器的启动工作就完成了。</p><p>Spring 提供了一种叫做 BeanFactoryPostProcessor 的容器扩展机制。该机制允许我们在容器实例化相应对象之前，对注入到容器的 BeanDefinition 所保存的信息做相应的修改。这可以让我们对最终的 BeanDefinition 做一些额外的操作，比如修改其中 Bean 定义的某些属性，为 Bean 定义增加其他信息等。</p><p>如果要自定义实现 BeanFactoryPostProcessor，需要实现 <code>org.springframework. beans.factory.config.BeanFactoryPostProcessor</code> 接口。又因为一个容器可能拥有多个 BeanFactoryPostProcessor，可能还需要实现 <code>org.springframework.core.Ordered</code> 接口来保证各个 BeanFactoryPostProcessor 可以按照顺序执行。</p><p><strong>常见的 BeanFactoryPostProcessor ：</strong></p><ul><li><code>org.springframework.beans.factory.config.PropertyPlaceholderConfigurer</code> 处理配置文件中的占位符</li><li><code>org.springframework.beans.factory.config.PropertyOverrideConfigurer</code> 替换 Bean 定义的属性信息</li><li><code>org.springframework.beans.factory.config.CustomEditorConfigurer</code> 用于注册一些自定义的字符串转换，例如：<code>StringArrayPropertyEditor</code> 将以逗号分隔的字符串转换成字符数组。如果需要自定义字符串到Java类型的转换，则需要实现 <code>PropertyEditor</code> 接口，再通过<code>CustomEditorConfigurer</code> 注册自定义的 <code>PropertyEditor</code>。但通常可以直接继承 <code>java.beans.PropertyEditorSupport</code> 再重写相关方法，会更方便一些。</li></ul><h2 id="Bean实例化阶段"><a href="#Bean实例化阶段" class="headerlink" title="Bean实例化阶段"></a>Bean实例化阶段</h2><p>当某个请求方通过容器的 getBean 方法明确地请求某个对象，或者因依赖关系容器需要隐式地调用 getBean 方法时，就会触发第二阶段的活动。</p><p>该阶段，容器会首先检查所请求的对象之前是否已经初始化。如果没有，则会根据注册的 BeanDefinition 所提供的信息实例化被请求对象，并为其注入依赖。如果该对象实现了某些回调按口，也会根据回调接口的要求来装配它。当该对象装配完毕之后，容器会立即将其返回请求方使用。</p><p>Bean 的实例化过程像这样：</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/Bean%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B.jpg" alt="Bean实例化过程"></p><p>Spring 容器将对其所管理的对象全部给予统一的生命周期管理，这些被管理的对象完全摆脱了原来那种 “new 完后被使用，脱离作用于后即被回收” 的命运。</p><h3 id="Bean的实例化与BeanWrapper"><a href="#Bean的实例化与BeanWrapper" class="headerlink" title="Bean的实例化与BeanWrapper"></a>Bean的实例化与BeanWrapper</h3><p>容器在内部实现的时候，采用策略模式来决定采用何种方式初始化 bean 实例。通常，可以通过反射或者 CGLIB 动态字节码生成来初始化相应的 bean 实例或者动态生成其子类。</p><ul><li>反射：<code>SimpleInstantiationStrategy</code></li><li>CGLIB：<code>CglibSubclassingInstantiationStrategy</code>，容器默认的初始化方式。</li></ul><p>容器只要根据相应 Bean 定义的 BeanDefinition 取得实例化信息，结合 CglibSubclassingInstantiationStrategy 以及不同的 Bean 定义类型，就可以返回实例化完成的对象实例。但不是直接返回构造完成的对象实例，而是以 BeanWrapper 对构造完成的对象实例进行包裹，返回相应的 BeanWrapper 实例。</p><p><strong>至此，第一步结束。</strong></p><p>BeanWrapper 的作用是对某个 Bean 进行“包裹”，然后对这个“包裹”的 Bean 进行操作，比如设置或者获取 Bean 的属性值。第二步的设置属性值，就在这里完成。</p><p>前文提到的 <code>CustomEditorConfigurer</code>，当把各种各样的 <code>PropertyEditor</code> 注入到容器中后，后面就是由 BeanWrapper 来使用这些 <code>PropertyEditor</code>。</p><p>使用 BeanWrapper 设置属性的方式，免去了反射设置属性的繁琐：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里除了使用反射也可以使用 CGLIB</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">provider</span>  <span class="operator">=</span> Class.forName(<span class="string">&quot;package.name.FXNewsProvider&quot;</span>).newInstance();</span><br><span class="line"><span class="type">Object</span> <span class="variable">listener</span>  <span class="operator">=</span> Class.forName(<span class="string">&quot;package.name.NewsListener&quot;</span>).newInstance();</span><br><span class="line"><span class="type">Object</span> <span class="variable">persister</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;package.name.NewsPersister&quot;</span>).newInstance();</span><br><span class="line"></span><br><span class="line"><span class="type">BeanWrapper</span> <span class="variable">newsProvider</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanWrapperImpl</span>(provider);</span><br><span class="line">newsProvider.setPropertyValue(<span class="string">&quot;newsListener&quot;</span>, listener);</span><br><span class="line">newsProvider.setPropertyValue(<span class="string">&quot;newPersistener&quot;</span>, persister);</span><br><span class="line"></span><br><span class="line">assertTrue(newsProvider.getWrappedInstance() <span class="keyword">instanceof</span> FXNewsProvider); </span><br><span class="line">assertSame(provider, newsProvider.getWrappedInstance()); </span><br><span class="line">assertSame(listener, newsProvider.getPropertyValue(<span class="string">&quot;newsListener&quot;</span>)); </span><br><span class="line">assertSame(persister, newsProvider.getPropertyValue(<span class="string">&quot;newPersistener&quot;</span>));</span><br></pre></td></tr></table></figure><h3 id="各色的-Aware-接口"><a href="#各色的-Aware-接口" class="headerlink" title="各色的 Aware 接口"></a>各色的 Aware 接口</h3><p>当对象实例化完成并且相关属性以及依赖设置完成之后，Spring 容器会检查当前对象实例是否实现了一系列的以 Aware 命名结尾的接口定义。如果是，则将这些 Aware 接口定义中规定的依赖注入给当前对象实例。有这些 Aware 接口：</p><ul><li><code>org.springframework.beans.factory.BeanNameAware</code> 将该对象实例的 Bean 定义对应的 BeanName 设置到当前对象实例。</li><li><code>org.springframework.beans.factory.BeanClassLoaderAware</code> 将对应加载当前 Bean 的 ClassLoader 注入当前对象实例。</li><li><code>org.springframework.beans.factory.BeanFactoryAware</code> 将 BeanFactory 容器自身设置到当前对象实例。</li></ul><h3 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h3><blockquote><p>BeanPostProcessor 是容器提供的对象实例化阶段的强有力的扩展点。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置处理要执行的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">default</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置处理要执行的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">default</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较常见的 BeanPostProcessor 的场景：</p><ul><li>为当前对象提供代理</li><li>处理标记接口实现类：ApplicationContext 对应的哪些 Aware 接口实际上就是通过 BeanPostProcessor 的方式进行处理的。</li></ul><h3 id="InitializingBean和-PostConstruct"><a href="#InitializingBean和-PostConstruct" class="headerlink" title="InitializingBean和@PostConstruct"></a>InitializingBean和@PostConstruct</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该接口的作用在于，在对象实例化过程调用过 “BeanPostProcessor 的前置处理” 之后，会接着检测当前对象是否实现了 InitializingBean 接口，如果是，则会调用其 afterPropertiesSet() 方法进一步调整对象实例的状态。比如，在有些情况下，某个业务对象实例化后，还不能处于可以使用状态。这个时候就可以让该业务对象实现该接口，并在方法 afterPropertiesSet() 中完成对该业务对象的后续处理。</p><p>如果让业务对象实现这个接口，则显得 Spring 容器比较具有侵入性。所以，Spring 还提供了另一种方式来指定自定义的对象初始化操作，<code>@PostConstruct</code> 注解。通过 <code>@PostConstruct</code> 注解，业务对象的自定义初始化操作可以以任何方式命名，而不再受制于 afterPropertiesSet()。</p><h3 id="DisposableBean与-PreDestroy"><a href="#DisposableBean与-PreDestroy" class="headerlink" title="DisposableBean与@PreDestroy"></a>DisposableBean与@PreDestroy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DisposableBean</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 InitializingBean 和 @PostConstruct 相对应，DisposableBean 与 @PreDestroy 为对象提供了执行自定义销毁逻辑的机会。</p><p>最常见到该功能的使用场景就是在 Spring 容器中注册数据库连接池，在系统推出后，连接池应该关闭，以释放相应资源。</p>]]></content>
    
    
    <summary type="html">《Spring揭秘》读书笔记</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>synchronized 用的这么多，不得优化优化？</title>
    <link href="https://www.wrp.cool/posts/34939/"/>
    <id>https://www.wrp.cool/posts/34939/</id>
    <published>2022-11-16T15:03:43.000Z</published>
    <updated>2022-11-17T05:09:07.072Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>类加载机制</title>
    <link href="https://www.wrp.cool/posts/15474/"/>
    <id>https://www.wrp.cool/posts/15474/</id>
    <published>2022-11-16T14:49:12.000Z</published>
    <updated>2022-11-16T14:49:28.157Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>JVM 垃圾回收</title>
    <link href="https://www.wrp.cool/posts/23073/"/>
    <id>https://www.wrp.cool/posts/23073/</id>
    <published>2022-11-04T17:11:10.000Z</published>
    <updated>2022-11-17T13:27:54.212Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对象已死？"><a href="#对象已死？" class="headerlink" title="对象已死？"></a>对象已死？</h1><p>在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”（“死去”即不可能再被任何途径使用的对象）了。</p><h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><p>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</p><p><strong>优点：</strong>原理简单，判断效率高。<br><strong>缺点：</strong>无法解决循环引用问题。</p><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E5%88%A9%E7%94%A8%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E5%9B%9E%E6%94%B6.png" alt="利用可达性分析算法判断对象是否可回收"></p><h3 id="GC-Roots-对象"><a href="#GC-Roots-对象" class="headerlink" title="GC Roots 对象"></a>GC Roots 对象</h3><p><strong>固定对象：</strong></p><ul><li>栈帧中的本地变量表中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</li><li>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。</li><li>在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。</li><li>在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</li><li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</li><li>所有被同步锁（synchronized关键字）持有的对象。</li><li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li></ul><p><strong>临时性对象：</strong></p><p>如果只针对 Java 堆中的某一块区域发起垃圾回收，必须考虑到内存区域并不是封闭独立的所以某个区域里的对象完全有可能被位于堆中其他区域的对象所引用，这时候就需要将这些关联区域的对象也一并加入GC Roots集合中去，才能保证可达性分析的正确性。</p><h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h3><p>可以用来做外部资源回收的工作，但是 try-finally 可以做的更好，并且 finalize() 方法执行效率低、执行成本高、不确定性大，所以一般不推荐使用，仅作了解。</p><p>真正宣告一个对象死亡，要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记。随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。</p><p>这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。这样做的原因是，如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。</p><p>如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 此代码演示了两点：</span></span><br><span class="line"><span class="comment">* 1.对象可以在被GC时自我拯救。</span></span><br><span class="line"><span class="comment">* 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalizeEscapeGC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">FinalizeEscapeGC</span> <span class="variable">SAVE_HOOK</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">isAlive</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;yes, I am still alive :)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;finalize method executed!&quot;</span>);</span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> <span class="title class_">FinalizeEscapeGC</span>();</span><br><span class="line">        <span class="comment">//对象第一次成功拯救自己</span></span><br><span class="line">        SAVE_HOOK = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="literal">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;no, I am dead :(&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下面这段代码与上面的完全相同，但是这次自救却失败了</span></span><br><span class="line">        SAVE_HOOK = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="literal">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;no, I am dead :(&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四大引用类型"><a href="#四大引用类型" class="headerlink" title="四大引用类型"></a>四大引用类型</h2><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似 <code>Object obj=new Object()</code> 这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></table></figure><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">// 使对象只被弱引用关联</span></span><br></pre></td></tr></table></figure><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">// 使对象只被虚引用关联</span></span><br></pre></td></tr></table></figure><h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。</p><p><strong>缺点：</strong></p><ol><li>效率不稳定，效率随着需要被回收的对象的增多而降低。</li><li>内存空间碎片化，会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li></ol><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E2%80%9C%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E2%80%9D%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="“标记-清除”算法示意图"></p><h2 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h2><p>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p><p><strong>优点：</strong>对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。</p><p><strong>缺点：</strong>将可用内存缩小为了原来的一半。</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="标记-复制算法示意图"></p><p>现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。</p><p>HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。</p><h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>标记过程与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E2%80%9C%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E2%80%9D%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="“标记-整理”算法示意图"></p><p><code>标记-清除</code>算法与<code>标记-整理</code>算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策：</p><ul><li><strong>移动：</strong>移动操作必须全程暂停用户应用程序才能进行</li><li><strong>不移动：</strong>存活对象所导致的内存碎片化问题</li></ul><p>是否移动对象都存在弊端，移动则内存回收时会更复杂，不移动则内存分配时会更复杂</p><blockquote><p>有一种“和稀泥式”解决方案可以不在内存分配和访问上增加太大额外负担，做法是让虚拟机平时多数时间都采用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经大到影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间。</p></blockquote><h1 id="经典垃圾收集器"><a href="#经典垃圾收集器" class="headerlink" title="经典垃圾收集器"></a>经典垃圾收集器</h1><h2 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h2><p>“分代收集”（Generational Collection）的理论建立在两个分代假说之上：</p><ul><li>弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。</li><li>强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。</li></ul><p><em>分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则。</em></p><p>这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：<strong>收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。</strong></p><blockquote><p>显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间；如果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。</p></blockquote><p>设计者一般至少会把Java堆划分为新生代（Young Generation）和老年代（Old Generation）两个区域。顾名思义，在新生代中，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。</p><p>但是分代收集并非只是简单划分一下内存区域那么容易，它至少存在一个明显的困难：<strong>对象不是孤立的，对象之间会存在跨代引用。</strong>为了解决这个问题，就需要对分代收集理论添加第三条经验法则：</p><ul><li>跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。</li></ul><p>依据这条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构（该结构被称为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GCRoots进行扫描。虽然这种方法需要在对象改变引用关系（如将自己或者某个属性赋值）时维护记录数据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。</p><h2 id="垃圾收集器图示"><a href="#垃圾收集器图示" class="headerlink" title="垃圾收集器图示"></a>垃圾收集器图示</h2><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="HotSpot虚拟机的垃圾收集器"></p><p>图展示了七种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用，图中收集器所处的区域，则表示它是属于新生代收集器抑或是老年代收集器。</p><h2 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h2><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/SerialSerialOld%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="SerialSerial Old收集器运行示意图"></p><p>这个收集器是一个单线程工作的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。</p><p><strong>优点：</strong>简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。<br><strong>缺点：</strong>在进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。</p><p><strong>适用场景：</strong>对于内存资源受限的环境，它是所有收集器里额外内存消耗（Memory Footprint）最小的；对于单核处理器或处理器核心数较少的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p><h2 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h2><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/ParNewSerialOld%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="ParNewSerial Old收集器运行示意图"></p><p>它是 Serial 收集器的多线程版本。</p><p>是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。</p><p>默认开启的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。</p><h2 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h2><p>Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）</p><p>Parallel Scavenge收集器ᨀ供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX：MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX：GCTimeRatio参数。</p><p><strong>-XX：MaxGCPauseMillis：</strong>参数允许的值是一个大于0的毫秒数，收集器将尽力保证内存回收花费的时间不超过用户设定值。但垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的。</p><p><strong>-XX：GCTimeRatio：</strong>参数的值则应当是一个大于0小于100的整数，也就是垃圾收集时间占总时间的比率，相当于吞吐量的倒数。譬如把此参数设置为19，那允许的最大垃圾收集时间就占总时间的5%（即1&#x2F;(1+19)），默认值为99，即允许最大1%（即1&#x2F;(1+99)）的垃圾收集时间。</p><h2 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h2><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/SerialSerialOld%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="SerialSerial Old收集器运行示意图"></p><p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。在服务端模式下有两大用途：</p><ol><li>在 JDK 1.5 以及之前版本(Parallel Old 诞生以前)中与 Parallel Scavenge 收集器搭配使用。</li><li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li></ol><h2 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h2><p>Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/ParallelScavengeParallelOld%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Parallel ScavengeParallel Old收集器运行示意图"></p><h2 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h2><blockquote><p>CMS（Concurrent Mark Sweep）收集器是一种基于<strong>标记-清除</strong>算法实现的，以获取<strong>最短回收停顿时间</strong>为目标的收集器。<strong>优点：</strong>并发收集、低停顿。</p></blockquote><p><strong>整个运作过程分为四步：</strong></p><ol><li><strong>初始标记：</strong>仅仅只是标记一下GC Roots能直接关联到的对象，速度很快</li><li><strong>并发标记：</strong>从GC Roots的直接关联对象开始遍历整个对象图，耗时较长但是不需要停顿用户线程</li><li><strong>重新标记：</strong>修正在并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</li><li><strong>并发清除：</strong>使用标记-清除算法清理删除掉标记阶段判断的已经死亡的对象，不需要移动存活对象</li></ol><p>由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一起工作，所以从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/ConcurrentMarkSweep%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="ConcurrentMarkSweep收集器运行示意图"></p><p><strong>四个缺点：</strong></p><ol><li>与用户线程并发执行期间，会占用一部分线程而导致应用程序变慢而降低总吞吐量</li><li>款基于“标记-清除”算法实现，收集结束时可能会有大量空间碎片产生</li><li>无法清理浮动垃圾：在CMS的并发标记和并发清理阶段，用户线程是还在继续运行，会有新的垃圾对象产生。这部分垃圾就称为“浮动垃圾”，只能等下一次垃圾清楚再回收</li><li>需要预留空间：由于在垃圾收集阶段用户线程还需要持续运行，那就还需要预留足够内存空间提供给用户线程使用，因此CMS收集器必须预留一部分空间供并发收集时的程序运作使用</li></ol><h2 id="Garbage-First-收集器"><a href="#Garbage-First-收集器" class="headerlink" title="Garbage First 收集器"></a>Garbage First 收集器</h2><p>Garbage First（简称G1）收集器主要面向服务端应用，目标是建立一个可预测的时间停顿模型，就是可以由用户来指定每次回收停顿多长时间。但指定的时间如果很短，那每次也只能回收少量垃圾，并且还会增加回收次数，甚至由于每次只回收少量垃圾，可能会引发 Full GC 反而降低性能。通常把期望停顿时间设置为一两百毫秒或者两三百毫秒会是比较合理的。</p><p>基于这个目标，G1 追求的是满足应用内存的分配需求，而不追求一次性回收所有的内存垃圾。于是传统的内存布局模型就不太适合 G1 了，因为每次新生代或者老年代回收的区域都比较固定，也就没办法预测每次内存回收所耗费的时间。所以 G1 开创了收集器面向局部收集的设计思路和基于 Region 的内存布局形式。</p><h3 id="Region-内存布局"><a href="#Region-内存布局" class="headerlink" title="Region 内存布局"></a>Region 内存布局</h3><p>G1不以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。</p><p>虽然G1仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，它们都是一系列区域（不需要连续）的动态集合。G1收集器之所以能建立可预测的停顿时间模型，是因为它将Region作为单次回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1 还会为每个 Region 维护一个回收成本，之后在每次回收计算出由哪些 Region 组成回收集可以在不超过期望停顿时间的约束下获得最高的收益。</p><p>Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。</p><p><strong>G1收集器Region分区示意图：</strong></p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/G1%E6%94%B6%E9%9B%86%E5%99%A8Region%E5%88%86%E5%8C%BA%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="G1收集器Region分区示意图"></p><h3 id="Region-里面的跨代引用问题"><a href="#Region-里面的跨代引用问题" class="headerlink" title="Region 里面的跨代引用问题"></a>Region 里面的跨代引用问题</h3><h3 id="G1收集器的运作过程"><a href="#G1收集器的运作过程" class="headerlink" title="G1收集器的运作过程"></a>G1收集器的运作过程</h3><h2 id="ZGC-收集器"><a href="#ZGC-收集器" class="headerlink" title="ZGC 收集器"></a>ZGC 收集器</h2><h1 id="JVM-内存分配与回收策略"><a href="#JVM-内存分配与回收策略" class="headerlink" title="JVM 内存分配与回收策略"></a>JVM 内存分配与回收策略</h1><hr><blockquote><p><strong>巨人的肩膀：</strong></p><ul><li>《深入理解Java虚拟机》</li></ul></blockquote>]]></content>
    
    
    <summary type="html">在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Java对象内存结构</title>
    <link href="https://www.wrp.cool/posts/4996/"/>
    <id>https://www.wrp.cool/posts/4996/</id>
    <published>2022-11-03T10:17:11.000Z</published>
    <updated>2022-11-03T11:43:44.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h1><p>当 new 一个新的对象时，首先检查这个对象所属的类是否已经被加载、解析和初始化。如果没有那必须先执行类加载过程。接下来虚拟机将为新生对象分配内存，为对象分配空间的任务实际上便等同于把一块确定大小的内存块（类加载完毕后对象大小也被确定）从 Java 堆中划分出来。</p><h2 id="对象内存空间分配"><a href="#对象内存空间分配" class="headerlink" title="对象内存空间分配"></a>对象内存空间分配</h2><p>分配空间有两种方式：指针碰撞和空闲列表。</p><p><strong>指针碰撞：</strong>假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”（Bump The Pointer）。</p><p><strong>空闲列表：</strong>但如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”（Free List）。</p><blockquote><p>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理（Compact）的能力决定。因此，当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用CMS这种基于清（Sweep）算法的收集器时，“理论上”就只能采用较为复杂的空闲列表来分配内存。<em>（CMS的实现里面，为了能在多数情况下分配得更快，设计了一个叫作Linear Allocation Buffer的分配缓冲区，通过空闲列表拿到一大块分配缓冲区之后，在它里面仍然可以使用指针碰撞方式来分配。）</em></p></blockquote><h2 id="指向新对象"><a href="#指向新对象" class="headerlink" title="指向新对象"></a>指向新对象</h2><p>对象创建在虚拟机中是非常频繁的行为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题关键是为对象内存分配这个动作提供原子性保证，有两种可选方案：CAS和线程隔离。</p><p><strong>CAS：</strong>对分配内存空间的动作进行同步处理，CAS配上失败重试的方式保证更新操作的原子性</p><p><strong>线程隔离：</strong>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。是否使用TLAB，可以通过-XX：+&#x2F;-UseTLAB参数来设定。</p><h2 id="初始化新对象"><a href="#初始化新对象" class="headerlink" title="初始化新对象"></a>初始化新对象</h2><p><strong>内存空间初始化：</strong>内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值，如果使用了TLAB的话，这一项工作也可以ᨀ前至TLAB分配时顺便进行。这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。</p><p><strong>对象头初始化：</strong>接下来，Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（懒加载）、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><h1 id="堆内存中的对象"><a href="#堆内存中的对象" class="headerlink" title="堆内存中的对象"></a>堆内存中的对象</h1><p>对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p><h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>HotSpot虚拟机对象的对象头部分包括两类信息：一类是用于存储对象自身的运行时数据，另一类是类型指针。</p><p><strong>对象自身的运行时数据：</strong>哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。</p><p><strong>类型指针：</strong>即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。</p><p>此外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据。</p><h2 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h2><p>实例数据部分是对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。</p><p>HotSpot虚拟机默认的分配顺序为longs&#x2F;doubles、ints、shorts&#x2F;chars、bytes&#x2F;booleans、oops（Ordinary Object Pointers，oops）</p><h2 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h2><p>对象的第三部分是对齐填充，这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是任何对象的大小都必须是8字节的整数倍。对象头部分已经被精心设计成正好是8字节的倍数（1倍或者2倍），因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p><h1 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h1><p>Java程序会通过栈上的reference数据来操作堆上的具体对象，主流的访问方式有两种：句柄、直接指针。</p><p><strong>句柄：</strong>使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。</p><p>使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E9%80%9A%E8%BF%87%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png" alt="通过句柄访问对象"></p><p><strong>直接指针：</strong>使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。</p><p>使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本。</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E9%80%9A%E8%BF%87%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png" alt="通过直接指针访问对象"></p><hr><blockquote><p><strong>巨人的肩膀：</strong></p><ul><li>《深入理解Java虚拟机》</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;对象的创建&quot;&gt;&lt;a href=&quot;#对象的创建&quot; class=&quot;headerlink&quot; title=&quot;对象的创建&quot;&gt;&lt;/a&gt;对象的创建&lt;/h1&gt;&lt;p&gt;当 new 一个新的对象时，首先检查这个对象所属的类是否已经被加载、解析和初始化。如果没有那必须先执行类加载过程。接</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>线程基础（下）</title>
    <link href="https://www.wrp.cool/posts/32328/"/>
    <id>https://www.wrp.cool/posts/32328/</id>
    <published>2022-11-01T13:42:40.000Z</published>
    <updated>2022-11-01T16:24:59.060Z</updated>
    
    <content type="html"><![CDATA[<p>承接上文，本文将介绍：线程的生命周期、如何捕获线程异常、以及可以让并行变串行的join()方法</p><h1 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h1><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4800715d63964fe28eaaebac61c364c4~tplv-k3u1fbpfcp-watermark.image" alt="线程的6个状态.png"></p><blockquote><p>在这张图片中，包含了线程的所有状态以及每种状态之间的互相转换过程。其中箭头的指向是固定的，单箭头的指向则表明了两个线程的状态是不可逆的，一旦从一端到另一端之后就无法再回去原来的状态。</p></blockquote><h2 id="NEW、RUNNABLE、TERMINATED"><a href="#NEW、RUNNABLE、TERMINATED" class="headerlink" title="NEW、RUNNABLE、TERMINATED"></a>NEW、RUNNABLE、TERMINATED</h2><ol><li><p><em>新创建（NEW）</em><br>线程一经创建，也就是去 new 了一个 Thread 类之后，未调用 start 方法之前，这时的线程就是「新创建」的状态</p></li><li><p><em>可运行（RUNNABLE）</em><br>有些地方可能将「可运行」状态称之为「就绪」状态，这两者其实都是「RUNNABLE」状态</p><p> 调用 start 方法开始，直到 run 方法中的代码执行完毕之前，如果没有其他的操作使得线程状态跑到上图右边的三种状态中去的话，线程将会一直处于「可运行」状态。</p><p> 注意：线程并没有一个「运行」的状态，就算是正在执行 run() 方法的线程状态也是「可运行」状态。</p></li><li><p><em>已终止（TERMINATED）</em><br>当 run 方法的代码执行完毕或者是抛出未处理的异常的时，线程就会处于「已终止」状态中。这个状态也是线程的最终状态，线程一旦进入了这个状态将无法再回到其他的状态中。</p><p> NEW、RUNNABLE、TERMINATED 这三种状态都是单向的，是无法返回的。NEW –&gt; RUNNABLE –&gt; TERMINATED</p></li><li><p><em>代码演示</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">500</span>)</span><br><span class="line">                <span class="comment">// run() 方法执行中</span></span><br><span class="line">                System.out.println(<span class="string">&quot;thread.state = &quot;</span> + Thread.currentThread().getState());  <span class="comment">// RUNNABLE</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;thread.state = &quot;</span> + thread.getState());  <span class="comment">// NEW</span></span><br><span class="line"></span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(<span class="string">&quot;thread.state = &quot;</span> + thread.getState());  <span class="comment">// RUNNABLE</span></span><br><span class="line"></span><br><span class="line">    thread.join();</span><br><span class="line">    System.out.println(<span class="string">&quot;thread.state = &quot;</span> + thread.getState());  <span class="comment">// TERMINATED</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="BLOCKED、WAITING、TIMED-WAITING"><a href="#BLOCKED、WAITING、TIMED-WAITING" class="headerlink" title="BLOCKED、WAITING、TIMED_WAITING"></a>BLOCKED、WAITING、TIMED_WAITING</h2><ol><li><p><em>被阻塞（BLOCKED）</em><br>如果线程执行了一个被 synchronize 关键字修饰的代码块，并且这个代码块还处于其他线程的执行之中，这时调用的线程就会处于阻塞的状态，等待其他线程执行完毕后再执行。<br>等待的这个线程在等待的时间内就是处于 <em>BLOCKED</em> 状态。</p><blockquote><p>习惯上来说 BLOCKED、WAITING、TIMED_WAITING 都称之为阻塞状态，而不仅仅是 BLOCKED。</p></blockquote></li><li><p><em>等待(WAITING)</em> 和 <em>计时等待(TIMED_WAITING)</em><br>当线程阻塞时就会进入等待的状态。其中等待和计时等待非常好理解，有带 time 参数的等待就是计时等待，反之则是等待。</p></li><li><p><em>代码演示</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">5</span>); <span class="comment">// 让 t1 和 t2 先跑一会</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;t1 sleep(50) t1.state = &quot;</span>+t1.getState()); <span class="comment">// TIMED_WAITING</span></span><br><span class="line">        System.out.println(<span class="string">&quot;t1 get LOCK，t2 be BLOCKED t2.state = &quot;</span> + t2.getState()); <span class="comment">// BLOCKED</span></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>); <span class="comment">// 进入 wait() 中</span></span><br><span class="line">        System.out.println(<span class="string">&quot;t1 wait(), t1.state = &quot;</span> + t1.getState()); <span class="comment">// WAITING</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="捕获线程异常"><a href="#捕获线程异常" class="headerlink" title="捕获线程异常"></a>捕获线程异常</h1><p>由于 Runnable 和 Thread 之间的解耦设计，导致 Thread 在运行 Runnable 时其实是无法感知到 Runnable 内部的运行逻辑的，Thread 无法知道这个线程执行完了是否需要处理返回值，是否会抛出什么异常等等</p><p>例如线程池，线程池中的 Thread 根本不知道会传进来一个什么样的 Runnable，对于 Thread 而言，只关注执行上的逻辑，而不关注 Runnable 内部的逻辑。</p><p>毫无疑问这样的设计是优秀的，但如果线程在执行的过程当中发生了异常，那处理起来就不是很方便了。针对这种情况可以利用 Thread.UncaughtExceptionHandler 捕获异常。</p><p>如果主线程抛出一个异常，可以直接使用 <code>try-catch</code> 捕获处理这个异常。如果异常是子线程中抛出的，那么主线程对这个异常并不敏感，无法直接捕获处理这个异常。虽然在控制台能看到异常信息，但是这个异常信息是子线程输出的，主线程并无法感知到这个异常，之所以能在控制台看到异常信息，是因为主线程与子线程共用了同一个控制台。</p><p>如果还不是很理解上面这段话，你可以跑一下这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;我是子线程抛出来的异常&quot;</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">5000</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;我是主线程抛出来的异常&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                System.out.println(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于主线程的异常，可以直接使用 <code>try-catch</code> 来捕获处理。对于子线程的异常，每次抛出异常的时机都不相同，主线程无法知道什么时候子线程会抛出异常，更无法捕获处理子线程中的异常。</p><p>其实这个例子也很形象的向我们展示了线程的工作过程：每个线程在执行期间是互不打扰的，自己干自己的事情。每个线程在领取到自己的任务（run方法）之后，等待被分配资源开始执行（start方法）之后便是一直闷头干下去，直到把工作做完（run方法执行完毕）</p><p>这样就要求子线程必须能够自行处理异常，也就是在子线程内部使用 <code>try-catch</code> 来处理异常。但子线程不一定能够处理自己的异常，有些异常需要向外通知父线程，让父线程去执行对应的处理逻辑。</p><p>这样看来，子线程更像是父线程的一个方法，异常可以在方法中使用 <code>try-catch</code> 自行处理，也可以标记在方法签名上向外抛出。</p><p>针对需要通知父线程处理的异常，可以使用 <em>Thread.UncaughtExceptionHandler</em> 这个接口来接收并处理异常。</p><p>这个接口的使用方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义的线程异常处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MyUncaughtExceptionHandler</span> <span class="keyword">implements</span> <span class="title class_">Thread</span>.UncaughtExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyUncaughtExceptionHandler</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;：成功捕获了异常。抛出异常的线程是：&quot;</span> + t.getName() + <span class="string">&quot;。抛出的异常是：&quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 方式一：设置为默认异常处理器</span></span><br><span class="line">    <span class="comment">// MyUncaughtExceptionHandler --&gt; Thread.defaultUncaughtExceptionHandler</span></span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> <span class="title class_">MyUncaughtExceptionHandler</span>(<span class="string">&quot;默认的线程异常处理器&quot;</span>));</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>()).start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式二：设置为线程专用的异常处理器</span></span><br><span class="line">    <span class="comment">// MyUncaughtExceptionHandler --&gt; t.uncaughtExceptionHandler</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>(), <span class="string">&quot;Thread-0&quot;</span>);</span><br><span class="line">    t.setUncaughtExceptionHandler(<span class="keyword">new</span> <span class="title class_">MyUncaughtExceptionHandler</span>(<span class="string">&quot;为 Thread-0 专门设置的异常处理器&quot;</span>));</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Task 抛出的异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先创建一个类实现 <code>Thread.UncaughtExceptionHandler</code> 作为自定义的线程异常处理器，再根据需要设置为默认的异常处理器，或者是为每个线程单独设置的异常处理器。</p><p>如果没有单独设置异常处理器也没有设置默认的异常处理器，那么调用 <code>ThreadGroup</code> 类对异常做处理，该类实现了 <code>Thread.UncaughtExceptionHandler</code> 接口，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 首先检查是否存在父线程组，如果存在则调用父线程组的异常处理器进行处理，这里是一个递归的操作</span></span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">        parent.uncaughtException(t, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取全局异常处理器</span></span><br><span class="line">        Thread.<span class="type">UncaughtExceptionHandler</span> <span class="variable">ueh</span> <span class="operator">=</span> Thread.getDefaultUncaughtExceptionHandler();</span><br><span class="line">        <span class="comment">// 尝试使用全局异常处理器处理</span></span><br><span class="line">        <span class="keyword">if</span> (ueh != <span class="literal">null</span>) &#123;</span><br><span class="line">            ueh.uncaughtException(t, e);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(e <span class="keyword">instanceof</span> ThreadDeath)) &#123;</span><br><span class="line">            <span class="comment">// 不存在全局异常处理器，直接将异常的堆栈信息打印出来</span></span><br><span class="line">            System.err.print(<span class="string">&quot;Exception in thread \&quot;&quot;</span> + t.getName() + <span class="string">&quot;\&quot; &quot;</span>);</span><br><span class="line">            e.printStackTrace(System.err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="并行变串行，join"><a href="#并行变串行，join" class="headerlink" title="并行变串行，join()"></a>并行变串行，join()</h1><blockquote><p>join方法的作用是同步。在主线程中去创建并启动一个线程，再调用这个线程的join方法之后，会使得两个线程原本是并行关系变成串行关系，也就是主线程将会等待子线程执行完毕之后再继续执行。</p></blockquote><p>注意：join方法可以传入一个long类型的参数，表示过了多少毫秒之后两个线程将由串行关系再次转变成并行关系。但如果传入的参数是0的话，表示的是永久等待，也就是主线程将会等待直到子线程执行完毕之后再次执行，相当于不传参数的join方法。</p><p><strong>代码演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;开始执行&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Test</span>());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Test</span>());</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;所有子线程执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main方法执行结果</span></span><br><span class="line"><span class="comment">// 子线程Thread-0开始执行</span></span><br><span class="line"><span class="comment">// 子线程Thread-1开始执行</span></span><br><span class="line"><span class="comment">// 子线程Thread-0执行完毕</span></span><br><span class="line"><span class="comment">// 子线程Thread-1执行完毕</span></span><br><span class="line"><span class="comment">// 所有子线程执行完毕</span></span><br></pre></td></tr></table></figure><p>上面的代码如果将两个线程执行join方法的那行代码注释掉，则执行结果为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">所有子线程执行完毕</span><br><span class="line">子线程Thread-<span class="number">0</span>开始执行</span><br><span class="line">子线程Thread-<span class="number">1</span>开始执行</span><br><span class="line">子线程Thread-<span class="number">1</span>执行完毕</span><br><span class="line">子线程Thread-<span class="number">0</span>执行完毕</span><br></pre></td></tr></table></figure><p>很明显，join方法的调用会使得主线程去等待子线程执行完毕之后再重新执行代码。</p><h2 id="join期间被中断"><a href="#join期间被中断" class="headerlink" title="join期间被中断"></a>join期间被中断</h2><blockquote><p>如果主线程调用子线程的 join() 方法后，在子线程执行的期间，有 interrupt 通知进入了，怎么办？</p></blockquote><p>针对上面的问题，我再重申一下关于 join() 方法作用的介绍。<strong>主线程将会等待调用了join方法的子线程执行完毕后再继续执行</strong></p><p>实际上，是主线程在等待子线程执行完毕，也就是说陷入阻塞状态的是主线程而不是子线程。所以关于上面的问题如果有 interrupt 通知进入了主线程将会抛出一个 InterruptedException 来响应这个 interrupt 通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">mainThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        mainThread.interrupt();</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        thread.join();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程被中断了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main方法执行结果</span></span><br><span class="line">main线程被中断了</span><br></pre></td></tr></table></figure><p>启动一个子线程并调用join方法，这时主线程就在等待子线程的执行完毕，然后子线程去中断了主线程。也就是中断了一个正在<strong>因join方法陷入阻塞</strong>的线程，那么此时我们中断的是这个陷入阻塞的线程，而不是正在执行的子线程。</p><h2 id="join期间的线程状态"><a href="#join期间的线程状态" class="headerlink" title="join期间的线程状态"></a>join期间的线程状态</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">mainThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(mainThread.getState());</span><br><span class="line">        System.out.println(Thread.currentThread().getState());</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">    thread.join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main方法执行结果</span></span><br><span class="line"><span class="comment">// WAITING</span></span><br><span class="line"><span class="comment">// RUNNABLE</span></span><br></pre></td></tr></table></figure><p>在子线程中去打印主线程和子线程各自的状态，明显调用了join方法的主线程被阻塞了是WAITING状态，而正在运行的子线程则是RUNNABLE状态。</p><h2 id="join-方法分析"><a href="#join-方法分析" class="headerlink" title="join() 方法分析"></a>join() 方法分析</h2><p><strong>join() 方法源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    join(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可知，join() 方法实际上还是调用了 wait() 方法的。如果没有传入时间参数，则是调用了 wait(0) 这个方法，代表永久等待，直到被唤醒。<br>有意思的是这其中并没有看到 notify() 或者是 notifyAll() 方法，也就是并没有线程去唤醒这个等待子线程执行完毕的主线程，但是当子线程执行完毕之后，这确确实实被唤醒了。</p><p>我们知道，主线程被唤醒的条件是子线程执行完毕，又知道线程执行完毕只有两种情况，一是 run() 方法运行结束，二是抛出了运行时异常。至此，答案水落石出，当线程执行完毕时，将会去执行 notifyAll() 方法唤醒其他的线程。</p><blockquote><p>注意：我们并不提倡使用 Thread 类的实例作为 synchronized 的锁对象原因也是在此，因为这可能会破坏原有的 wait-notify 结构。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;承接上文，本文将介绍：线程的生命周期、如何捕获线程异常、以及可以让并行变串行的join()方法&lt;/p&gt;
&lt;h1 id=&quot;线程生命周期&quot;&gt;&lt;a href=&quot;#线程生命周期&quot; class=&quot;headerlink&quot; title=&quot;线程生命周期&quot;&gt;&lt;/a&gt;线程生命周期&lt;/h1&gt;&lt;p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>synchronized 是怎样保证线程安全的</title>
    <link href="https://www.wrp.cool/posts/11150/"/>
    <id>https://www.wrp.cool/posts/11150/</id>
    <published>2022-11-01T13:00:34.000Z</published>
    <updated>2022-11-16T13:25:48.060Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一句话说明 synchronized 关键字的作用：</strong></p><blockquote><p>保证在 <strong>「同一时刻」</strong> 最多只有 <strong>「一个」</strong> 线程执行该段代码，以达到保证 <strong>「并发安全」</strong> 的效果</p></blockquote><p>上一篇文章讲述的线程不安全的例子，现在就给出解决办法：synchronized。</p><h1 id="synchronized-关键字的使用方式"><a href="#synchronized-关键字的使用方式" class="headerlink" title="synchronized 关键字的使用方式"></a>synchronized 关键字的使用方式</h1><p>为了阅读方便，把前一篇文章中的示例代码再放到这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共享变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 对共享变量的修改</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100_000</span>; i++) &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123; &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;num = &quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以理解为是一个锁的作用，用来保护需要同步执行的代码，只有拿到锁的线程才能执行被保护的代码。如果使用 synchronized 来保护 <code>num++</code> 这行代码 ，那就可以保证 num 变量的线程安全。因为这样同一个时刻就只有一个线程能执行 <code>num++</code> 了。被保护代码也称为临界区代码。</p><p>synchronized 既然是一把锁，那肯定就需要一个对象来充当这个锁对象，这个对象可以是类对象或者是实例对象。由此就有了两个锁的概念：类锁、对象锁。</p><p>再根据使用方式的不同，类锁可以分为：</p><ul><li>静态方法加锁</li><li>代码块直接指定类锁</li></ul><p>对象锁可以分为：</p><ul><li>普通方法加锁</li><li>代码块直接指定对象锁</li></ul><p>由于 Java 中的类是全局唯一的对象，而对象则可以存在多个。于是，类锁是全局唯一的，被类锁保护的代码在同一时刻肯定只有唯一一个线程能执行该代码；对象锁在全局可以同时存在多个，被对象锁保护的代码在同一时刻可能会被多个线程同时执行，但这些线程肯定持有不同的对象锁。</p><h2 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a>类锁</h2><p>由于类锁在全局的唯一性，所以使用类锁保护的代码可以保证在整个 JVM 实例中同一时刻只有一个线程能执行该方法。</p><h3 id="静态方法加锁"><a href="#静态方法加锁" class="headerlink" title="静态方法加锁"></a>静态方法加锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 synchronized 关键字添加在静态方法签名上，以 Task.class 类对象为锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码块指定类锁"><a href="#代码块指定类锁" class="headerlink" title="代码块指定类锁"></a>代码块指定类锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Task.class) &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h2><p>被 new 出来或者反射加载的对象，在内存中可以存在多份。所以被对象锁保护的代码同一时刻可能会被多个线程执行，但是这些线程持有的实例对象肯定不同。</p><h3 id="普通方法加锁"><a href="#普通方法加锁" class="headerlink" title="普通方法加锁"></a>普通方法加锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 synchronized 关键字添加在方法签名上，以 this 对象为锁</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码块指定对象锁"><a href="#代码块指定对象锁" class="headerlink" title="代码块指定对象锁"></a>代码块指定对象锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类锁和对象锁的使用场景"><a href="#类锁和对象锁的使用场景" class="headerlink" title="类锁和对象锁的使用场景"></a>类锁和对象锁的使用场景</h2><p>类锁的经典使用场景有单例模式的双重检查锁（DCL）实现，由于类锁限制的范围太广泛了，在整个 JVM 实例同一时刻只有一个线程能执行被保护代码，也就是完全放弃了并行带来的性能提升，在使用类锁的时候这一点是需要认真考量的。DCL 的外层判断也是为了降低锁的粒度，基于性能的考量而加的。</p><p>对象锁的使用场景就比较多了，早期的并发容器当中使用的都是对象锁来保护并发安全，例如 Vector 和 Hashtable。早期并发容器中对象锁的使用也可以做为一个参考，一个对象内部的资源需要被保护时，可以以这个对象为锁来使用 synchronized 关键字。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;一句话说明 synchronized 关键字的作用：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;保证在 &lt;strong&gt;「同一时刻」&lt;/strong&gt; 最多只有 &lt;strong&gt;「一个」&lt;/strong&gt; 线程执行该段代码，以达到保证 &lt;st</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>synchronized 锁的方法，不急就再等等</title>
    <link href="https://www.wrp.cool/posts/11151/"/>
    <id>https://www.wrp.cool/posts/11151/</id>
    <published>2022-11-01T13:00:34.000Z</published>
    <updated>2022-11-16T13:08:46.293Z</updated>
    
    <content type="html"><![CDATA[<p>在 synchronized 的使用中，如果继续往下执行代码的条件不被满足的话可以先释放当前持有的锁对象再等等，等到执行条件被满足后再接着往下执行。</p><blockquote><p>就像平时去医院排队看病一样，轮到我们了在医生问诊的过程中，可能会先让你先去做某一项检查，等检查完拿到检查结果之后再重新排队等待医生叫号。<br>排队看病的例子中，当我们在被医生问诊的时候，我们就独占了医生这把锁；需要做某一项检查的时候就是往下继续问诊的流程继续不了了；拿到检查结果后我们也要重新排队等待医生继续问诊。</p></blockquote><p>在程序的世界里，我们使用 synchronized 锁来保护医生对象，一个医生同一时刻只能给一个病人问诊；调用 wait() 方法先去做检查；当问诊结束了调用 notify() 方法去通知下一位病人问诊。</p><h1 id="wait-方法介绍"><a href="#wait-方法介绍" class="headerlink" title="wait() 方法介绍"></a>wait() 方法介绍</h1><p><strong>wait() 方法的使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">    object.wait();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (Object.class) &#123;</span><br><span class="line">    Object.class.wait();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="built_in">this</span>.wait();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Object.class.wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>wait() 方法的重载：</strong></p><ul><li>wait(long timeout)：在 timeout 毫秒内如果没有被 notify 唤醒则自行唤醒。</li><li>wait(long timeout, int nanos)：在 1,000,000*timeout+nanos 纳米内如果没有被 notify 唤醒则自行唤醒。</li></ul><h1 id="notify-方法介绍"><a href="#notify-方法介绍" class="headerlink" title="notify() 方法介绍"></a>notify() 方法介绍</h1><p>调用 wait() 方法当前线程会放弃 synchronized 锁，相对应的调用 notify() 方法之后原来放弃 synchronized 锁的线程就会重新去竞争 synchronized 锁，竞争到锁的线程可以继续执行。</p><p>notify() 方法还有一个兄弟方法叫做 notifyAll()，notify() 方法只会唤醒被 wait() 阻塞的线程之一；而 notifyAll() 会唤醒全部被 wait() 阻塞的线程。</p><p>被 wait() 方法阻塞的线程想要被唤醒必须是另外的一个线程去调用了 notiify() 并且轮到本线程被唤醒，或者是直接调用 notifyAll()。</p><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Demo</span><span class="params">(<span class="type">int</span> num)</span> &#123; <span class="built_in">this</span>.num = num; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Integer&gt; waitList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">50</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Integer&gt; notifyList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                waitList.add(num);</span><br><span class="line">                LOCK.wait();</span><br><span class="line">                notifyList.add(num);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Demo</span>(i)).start();</span><br><span class="line">            Thread.sleep(<span class="number">10</span>); <span class="comment">// 一个个去睡觉</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// notifyDemo();</span></span><br><span class="line">        <span class="comment">// notifyAllDemo();</span></span><br><span class="line">        System.out.println(waitList);</span><br><span class="line">        System.out.println(notifyList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">notifyDemo</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                LOCK.notify();</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>); <span class="comment">// 一个个来唤醒</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">notifyAllDemo</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">            LOCK.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">50</span>); <span class="comment">// 等待全部唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 main() 方法中调用 notify() 方法的执行结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure><p>在 main() 方法中调用 notifyAll() 方法的执行结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span><br></pre></td></tr></table></figure><p>很明显，notify() 是顺序唤醒线程的，而 notifyAll() 是倒序唤醒线程的。如果想要深究这部分原因，进入到 Object 类中看到 wait()、notify()、notifyAll() 这三个方法都是被 native 修饰的方法。再深入就是 jvm 的 C++ 实现了，包括还得看 synchronized 的实现等等。这部分内容暂时道行还不够，就先不做介绍了，暂时就先记住这么个现象吧。</p><p>如果业务上需要对线程的唤醒顺序有要求的话，可以分用多个锁来指定唤醒对应线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                LOCK.wait();</span><br><span class="line">                System.out.println(<span class="string">&quot;被唤醒。&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">            LOCK.notify();</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            str.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                str.append(i + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">9</span>)</span><br><span class="line">                    str.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            str.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看上面这段代码，输出结果是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line">被唤醒。</span><br></pre></td></tr></table></figure><p>显然对于 notify() 和 wait() 之间的执行顺序，调用 notify() 或者 notifyAll() 之后并不会马上释放本线程的 monitor 锁，而是等待被线程执行完毕之后再释放 monitor 锁给被 wait() 阻塞的线程去竞争。</p><h1 id="问诊案例"><a href="#问诊案例" class="headerlink" title="问诊案例"></a>问诊案例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeeDoctor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Doctor</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Doctor</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(LOCK) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello doctor.&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (needDoCheck()) &#123;</span><br><span class="line">                LOCK.notifyAll();</span><br><span class="line">                LOCK.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;You&#x27;re healthy&quot;</span>);</span><br><span class="line">            LOCK.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">needDoCheck</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (checkIsDone()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isChecking()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;is checking...&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;wait a minute&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是问诊案例的大概流程，有三个地方需要注意：</p><ol><li><p>判断是否需要等待应该使用 while 循环判断，因为很可能被唤醒的线程检查结果还没出来，还是需要继续等待。</p></li><li><p>尽量使用 notifyAll() 方法唤醒，因为不能确定被唤醒线程能否往下继续执行。如果被唤醒线程因条件不满足继续等待，那还有其他线程可以继续抢锁，而 notify() 在这种情况下会导致所有线程都陷入等待无法唤醒。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 synchronized 的使用中，如果继续往下执行代码的条件不被满足的话可以先释放当前持有的锁对象再等等，等到执行条件被满足后再接着往下执行。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;就像平时去医院排队看病一样，轮到我们了在医生问诊的过程中，可能会先让你先去做某一项检</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java运行时数据区域</title>
    <link href="https://www.wrp.cool/posts/26815/"/>
    <id>https://www.wrp.cool/posts/26815/</id>
    <published>2022-11-01T10:51:45.000Z</published>
    <updated>2022-11-05T14:36:25.189Z</updated>
    
    <content type="html"><![CDATA[<p>Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。分别有：</p><ul><li><strong>程序计数器</strong>（Program Counter Register）</li><li><strong>虚拟机栈</strong>（VM Stack）</li><li><strong>本地方法栈</strong>（Native Method Stack）</li><li><strong>方法区</strong>（Method Area）</li><li><strong>堆</strong>（Heap）</li></ul><p>其中，程序计数器、虚拟机栈、本地方法栈这三个区域是线程隔离的区域，每个线程都有自己的程序计数器、虚拟机栈、本地方法栈，所以这三个区域内的变量是线程安全的。我们称这类内存区域为“线程私有”的内存，他们的生命周期与线程相同。</p><p>方法区和堆则是所有线程共享的区域，存放在这里面的数据需要注意线程安全问题。</p><h1 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h1><p>程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的<br>字节码的行号指示器。它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。</p><p>此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何 OutOfMemoryError 情况的区域。</p><h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1><p>虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><p><strong>局部变量表：</strong>局部变量表（Local Variables Table）是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。如果执行的是实例方法（没有被static修饰的方法），那局部变量表中第0位索引的变量槽默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问到这个隐含的参数</p><p><strong>操作数栈：</strong>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和读取内容，也就是出栈和入栈操作。譬如在做算术运算的时候是通过将运算涉及的操作数栈压入栈顶后调用运算指令来进行的，又譬如在调用其他方法的时候是通过操作数栈来进行方法参数的传递。举个例子，例如整数加法的字节码指令iadd，这条指令在运行的时候要求操作数栈中最接近栈顶的两个元素已经存入了两个int型的数值，当执行这个指令时，会把这两个int值出栈并相加，然后将相加的结果重新入栈。</p><p><strong>动态连接：</strong>Java 多态的基石，在运行时动态指定调用方法。</p><p><strong>方法出口：</strong>当一个方法开始执行后，只有两种方式退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者；第二种退出方式是在方法执行的过程中遇到了异常，并且这个异常没有在方法体内得到妥善处理，一个方法使用异常完成出口的方式退出，是不会给它的上层调用者提供任何返回值的。</p><blockquote><p>注：《Java虚拟机规范》明确允许Java虚拟机实现自行选择是否支持栈的动态扩展，而HotSpot虚拟机的选择是不支持扩展，所以除非在创建线程申请内存时就因无法获得足够内存而出现OutOfMemoryError异常，否则在线程运行时是不会因为扩展而导致内存溢出的，只会因为栈容量无法容纳新的栈帧而导致StackOverflowError异常。</p></blockquote><h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</p><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>此内存区域的唯一目的就是存放对象实例，Java世界里“几乎”所有的对象实例都在这里分配内存。</p><p>根据《Java虚拟机规范》的规定，Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。但对于大对象（典型的如数组对象），多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的内存空间。</p><p>Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。</p><h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。</p><p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p><h2 id="String-字符串常量池"><a href="#String-字符串常量池" class="headerlink" title="String 字符串常量池"></a>String 字符串常量池</h2><p>JDK7 以前 String 字符串常量池是存放在永久代空间中的，自 JDK7 移除永久代之后将 String 字符串常量池移动至堆内存。所以关于 String::intern() 方法在 JDK7 之后会有些不一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;计算机&quot;</span>).append(<span class="string">&quot;软件&quot;</span>).toString();</span><br><span class="line">    System.out.println(str1.intern() == str1);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;ja&quot;</span>).append(<span class="string">&quot;va&quot;</span>).toString();</span><br><span class="line">    System.out.println(str2.intern() == str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码在 JDK6 中运行，会得到两个false。原因是：在JDK 6中，intern()方法会把<strong>首次遇到</strong>的字符串实例复制到永久代的字符串常量池中存储，返回的也是永久代里面这个字符串实例的引用，而由StringBuilder创建的字符串对象实例在Java堆上，所以必然不可能是同一个引用，结果将返回false。</p><p>在 JDK7 中运行，会得到一个 true 一个 false，原因是：JDK7 的intern()方法实现不需要再拷贝字符串的实例到永久代了，<strong>因为字符串常量池已经移到Java堆中，那只需要在常量池里记录一下首次出现的实例引用即可</strong>，因此intern()返回的引用和由StringBuilder创建的那个字符串实例就是同一个。而对str2比较返回false，这是因为“java”这个字符串在执行String-Builder.toString()之前就已经出现过了，字符串常量池中已经有它的引用，<strong>不符合intern()方法要求“首次遇到”的原则</strong>，“计算机软件”这个字符串则是首次出现的，因此结果返回true。</p><h1 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h1><p>在JDK 1.4中新加入了NIO（New Input&#x2F;Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I&#x2F;O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著ᨀ高性能，因为避免了在Java堆和Native堆中来回复制数据。</p><p>显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。</p><hr><blockquote><p><strong>巨人的肩膀：</strong></p><ul><li>《深入理解Java虚拟机》</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。分别有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;程序计数器&lt;/strong&gt;（Program Counter Register）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;虚拟机栈&lt;/s</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis 对象结构和数据类型</title>
    <link href="https://www.wrp.cool/posts/35006/"/>
    <id>https://www.wrp.cool/posts/35006/</id>
    <published>2022-09-14T08:41:33.000Z</published>
    <updated>2022-10-17T12:01:18.869Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://xiaolincoding.com/redis/data_struct/command.html">小林Coding-Redis 常见数据类型和应用场景</a></p></blockquote><p>Redis 是一个键值对数据库，它的键值对中的 key 就是字符串对象，value 可以是字符串对象也可以是其他的集合数据类型对象，比如：List、Hash、Set、Zset 等。</p><p>Redis 中常见的数据类型有五种：String（字符串）、Hash（哈希）、List（列表）、Set（集合）、Zset（有序集合）。</p><p>随着 Redis 版本更新，后面又支持了四种：BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）。</p><h1 id="Redis-对象结构"><a href="#Redis-对象结构" class="headerlink" title="Redis 对象结构"></a>Redis 对象结构</h1><p>Redis 是使用了一个<strong>哈希表</strong>保存所有键值对，哈希表的最大好处就是让我们可以用 O(1) 的时间复杂度来快速查找到键值对。哈希表其实就是一个数组，数组中的元素叫做哈希桶。</p><p>哈希桶存放的是指向键值对数据的指针，这样通过指针就能找到键值对数据。因为键值对的 value 可以是字符串对象或者集合对象，所以键值对中并不直接保存值本身，而是保存了 <code>void * key</code> 和 <code>void * value</code> 指针，分别指向了实际的键对象和值对象，这样一来，即使值是集合数据，也可以通过 value 指针找到。</p><p><strong>Redis对象结构示意图：</strong></p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/Redis%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="Redis对象结构示意图"></p><p>以上三个属性是 Redis 对象中重要的三个属性，Redis 对象还有其他的一些属性，这里就先不展开。</p><ul><li><strong>type</strong>：标识该对象是什么类型的对象（String、List、Hash、Set、Zset）</li><li><strong>encoding</strong>：标识该对象使用了哪种底层的数据结构</li><li><strong>ptr</strong>：指向底层数据结构的指针</li></ul><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>String 是最基本的 key-value 结构，key 是唯一标识，value 是具体的值，value其实不仅是字符串， 也可以是数字（整数或浮点数），value 最多可以容纳的数据长度是 <strong>512M</strong>。底层数据结构是 int 和 SDS（简单动态字符串）。</p><p>SDS 是 Redis 内部实现的字符串对象，并没有采用 C语言 的字符串表示。由 Redis 内部实现的 SDS 优势如下：</p><ol><li>SDS 可以保存二进制数据，因为 SDS 采用 len 属性的值来表示字符串是否结束。</li><li>SDS 获取字符串长度的时间复杂度是 O(1)，因为 SDS 采用 len 属性记录字符串长度</li><li>SDS 拼接字符串不会造成缓冲区溢出，是安全的，因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，空间不够会自动扩容，所以不会导致缓冲区溢出的问题。</li></ol><p>字符串对象的内部编码（encoding）有 3 种 ：<strong>int、embstr 和 raw</strong>。</p><ul><li><p><strong>int</strong>：如果保存的是可以用 long 类型表示的整数值，那么直接将值保存在 ptr 属性里面即可，编码设置为 int。</p></li><li><p><strong>embstr 和 raw</strong>：保存的是字符串，底层的数据结构都是 SDS，如果是较短的字符串那么将编码设置为 embstr，如果是较长的字符串那么将编码设置为 raw。</p></li></ul><p>embstr 和 raw 的边界在不同的 Redis 版本中是不相同的。embstr 会通过一次内存分配函数来分配一块连续的内存空间来保存 redisObject 和 SDS，而 raw 编码会通过调用两次内存分配函数来分别分配两块空间来保存redisObject 和 SDS。Redis 这样做会有很多好处：</p><ul><li>embstr 编码在创建和释放对象时只需要调用一次内存函数。</li><li>embstr 所有的数据都保存在一块连续的内存，可以更好的利用 CPU 缓存提高性能。</li></ul><p>但 embstr 也是有缺点的，如果需要重新分配字符串内存时，整个 redisObject 和 SDS 都需要重新分配空间，<strong>所以 embstr 编码的字符串对象是只读的</strong>，我们对 embstr 编码的字符串对象执行的任何修改，程序都会先将对象的编码从 embstr 转换成 raw，然后再执行修改。</p><p><strong>String 类型的使用场景：</strong>缓存对象、常规计数、分布式锁、分布式服务之间共享 Session 信息</p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>List 列表是简单的字符串列表，按照插入顺序排序，可以从头部或尾部向 List 列表添加元素。列表的最大长度为 <code>2^32 - 1</code>，也即每个列表支持超过 40 亿个元素。在 Redis 3.2 版本之后，List 数据类型底层数据结构只由 quicklist 实现，替代了双向链表和压缩列表。</p><p><strong>List 类型的使用场景：</strong>消息队列</p><p>消息队列在存取消息时，必须要满足三个需求，分别是：<strong>消息保序、处理重复的消息和保证消息可靠性</strong>。</p><div class="note default flat"><p><strong>如何满足消息保序需求？</strong></p></div><p>List 本身就是按先进先出的顺序对数据进行存取的，所以，如果使用 List 作为消息队列保存消息的话，就已经能满足消息保序的需求了。</p><p>List 可以使用 LPUSH + RPOP （或者反过来，RPUSH + LPOP）命令实现消息队列。不过这种方式在消费者读取数据时，有一个潜在的性能风险点：</p><p>生产者往 List 中写入消息时并不会通知消费者去消费消息，消费者只能不断的尝试从 List 中去取消息，这会导致消费者的 CPU 一直消耗在 RPOP 命令上，带来不必要的性能损失。</p><p>为了解决这个问题，Redis提供了 BRPOP 命令。<strong>BRPOP命令也称为阻塞式读取</strong>，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据。和消费者程序自己不停地调用RPOP命令相比，这种方式能节省CPU开销。</p><div class="note default flat"><p><strong>如何处理重复的消息？</strong></p></div><p>需要为每一条消息生成一个 ID 号，消费者记录自己消费过的 ID，取出消息时先判断自己是否消费过此消息，如果消费过则不再处理。</p><div class="note default flat"><p><strong>如何保证消息可靠性？</strong></p></div><p>当消费者程序从 List 中读取一条消息后，List 就不会再留存这条消息了。所以，如果消费者程序在处理消息的过程出现了故障或宕机，就会导致消息没有处理完成，那么，消费者程序再次启动后，就没法再次从 List 中读取消息了。</p><p>为了留存消息，List 类型提供了 <code>BRPOPLPUSH</code> 命令，BRPOPLPUSH 命令从列表中取出最后一个元素，并插入到另外一个列表的头部；如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</p><blockquote><p>BRPOPLPUSH 命令：<code>BRPOPLPUSH L1 L2 10</code>，从 L1 取出一条消息返回并存入 L2 中，阻塞时间为 10s。</p></blockquote><p>使用 BRPOPLPUSH 命令后，如果消费者程序读了消息但没能正常处理，等它重启后，就可以从备份 List 中重新读取消息并进行处理了。</p><h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><p>Hash 是一个键值对（key - value）集合，特别适合用于存储对象。其中 value 的形式如：<code>value=[&#123;field1, value1&#125;,...&#123;fieldN, valueN&#125;]</code>。在 Redis7.0 以后底层的数据结构改为 listpack，不再使用压缩列表或哈希表。</p><p><strong>应用场景：</strong>缓存对象、购物车（以 用户ID 为 key，商品ID 为 field，商品数量为 value）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 缓存 UID:1 对象</span></span><br><span class="line">&gt; HSET UID:1 name admin age 18</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 UID:1 对象的姓名、年龄等属性值</span></span><br><span class="line">&gt; HGET UID:1 name</span><br><span class="line"><span class="string">&quot;admin&quot;</span></span><br><span class="line">&gt; HGET UID:1 age</span><br><span class="line"><span class="string">&quot;18&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建购物车</span></span><br><span class="line">&gt; HSET SHOPPINGCART:UID:01 1001 1 1002 2 1003 10</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取购物车信息</span></span><br><span class="line">&gt; HGETALL SHOPPINGCART:UID:01</span><br><span class="line">1) <span class="string">&quot;1001&quot;</span></span><br><span class="line">2) <span class="string">&quot;1&quot;</span></span><br><span class="line">3) <span class="string">&quot;1002&quot;</span></span><br><span class="line">4) <span class="string">&quot;2&quot;</span></span><br><span class="line">5) <span class="string">&quot;1003&quot;</span></span><br><span class="line">6) <span class="string">&quot;10&quot;</span></span><br></pre></td></tr></table></figure><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>Set 类型是一个无序并唯一的集合，它的存储顺序不会按照插入的先后顺序进行存储。</p><p>一个集合最多可以存储 <code>2^32-1</code> 个元素。概念和数学中个的集合基本类似，可以交集，并集，差集等等，所以 Set 类型除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集。</p><p>但是 Set 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，可能会导致 Redis 实例阻塞。</p><p>在主从集群中，为了避免主库因为 Set 做聚合计算（交集、差集、并集）时导致主库被阻塞，我们可以选择一个从库完成聚合统计，或者把数据返回给客户端，由客户端来完成聚合统计。</p><div class="note primary flat"><p><strong>Set 集合运算操作</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 交集运算</span></span><br><span class="line">SINTER key [key ...]</span><br><span class="line"><span class="comment"># 将交集结果存入新集合destination中</span></span><br><span class="line">SINTERSTORE destination key [key ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 并集运算</span></span><br><span class="line">SUNION key [key ...]</span><br><span class="line"><span class="comment"># 将并集结果存入新集合destination中</span></span><br><span class="line">SUNIONSTORE destination key [key ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 差集运算</span></span><br><span class="line">SDIFF key [key ...]</span><br><span class="line"><span class="comment"># 将差集结果存入新集合destination中</span></span><br><span class="line">SDIFFSTORE destination key [key ...]</span><br></pre></td></tr></table></figure><p><strong>应用场景：</strong>点赞、共同关注、抽奖活动。</p><div class="note default flat"><p><strong>点赞</strong></p></div><p>Set 集合可以保证一个用户只能点一个赞，这里举例子一个场景，key 是文章ID，value 是用户ID。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># uid:1 用户对文章 article:1 点赞</span></span><br><span class="line">&gt; SADD article:1 uid:1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># uid:2 用户对文章 article:1 点赞</span></span><br><span class="line">&gt; SADD article:1 uid:2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># uid:3 用户对文章 article:1 点赞</span></span><br><span class="line">&gt; SADD article:1 uid:3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># uid:1 取消了对 article:1 文章点赞</span></span><br><span class="line">&gt; SREM article:1 uid:1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 article:1 文章所有点赞用户</span></span><br><span class="line">&gt; SMEMBERS article:1</span><br><span class="line">1) <span class="string">&quot;uid:3&quot;</span></span><br><span class="line">2) <span class="string">&quot;uid:2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 article:1 文章的点赞用户数量</span></span><br><span class="line">&gt; SCARD article:1</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断用户 uid:1 是否对文章 article:1 点赞了</span></span><br><span class="line">&gt; SISMEMBER article:1 uid:1</span><br><span class="line">(<span class="built_in">integer</span>) 0  <span class="comment"># 返回0说明没点赞，返回1则说明点赞了</span></span><br></pre></td></tr></table></figure><div class="note default flat"><p><strong>共同关注</strong></p></div><p>Set 类型支持交集运算，所以可以用来计算共同关注的好友、公众号等。key 可以是用户id，value 则是已关注的公众号的id。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># uid:1 用户关注公众号 id 为 5、6、7、8、9</span></span><br><span class="line">&gt; SADD uid:1 5 6 7 8 9</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"><span class="comment"># uid:2  用户关注公众号 id 为 7、8、9、10、11</span></span><br><span class="line">&gt; SADD uid:2 7 8 9 10 11</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># uid:1 和 uid:2 共同关注的公众号</span></span><br><span class="line">&gt; SINTER uid:1 uid:2</span><br><span class="line">1) <span class="string">&quot;7&quot;</span></span><br><span class="line">2) <span class="string">&quot;8&quot;</span></span><br><span class="line">3) <span class="string">&quot;9&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给 uid:2 推荐 uid:1 关注的公众号</span></span><br><span class="line">&gt; SDIFF uid:1 uid:2</span><br><span class="line">1) <span class="string">&quot;5&quot;</span></span><br><span class="line">2) <span class="string">&quot;6&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给 uid:1 推荐 uid:2 关注的公众号</span></span><br><span class="line">&gt; SDIFF uid:2 uid:1</span><br><span class="line">1) <span class="string">&quot;10&quot;</span></span><br><span class="line">2) <span class="string">&quot;11&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证某个公众号是否被 uid:1 或 uid:2 关注</span></span><br><span class="line">&gt; SISMEMBER uid:1 5</span><br><span class="line">(<span class="built_in">integer</span>) 1 <span class="comment"># 返回1，说明关注了</span></span><br><span class="line">&gt; SISMEMBER uid:2 5</span><br><span class="line">(<span class="built_in">integer</span>) 0 <span class="comment"># 返回0，说明没关注</span></span><br></pre></td></tr></table></figure><div class="note default flat"><p><strong>抽奖活动</strong></p></div><p>存储某活动中中奖的用户名 ，Set 类型因为有去重功能，可以保证同一个用户不会中奖两次。</p><p>如果允许重复中奖，使用 SRANDMEMBER 命令。如果不允许重复中奖，使用 SPOP 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从集合key中随机选出count个元素，元素不从key中删除</span></span><br><span class="line">SRANDMEMBER key [count]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从集合key中随机选出count个元素，元素从key中删除</span></span><br><span class="line">SPOP key [count]</span><br></pre></td></tr></table></figure><h1 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h1><p>Zset 有序集合相比于 Set 集合多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序集合的元素值，一个是元素排序值。</p><p>有序集合保留了集合不能有重复成员的特性（分值可以重复），但不同的是，有序集合中的元素可以排序。</p><p>在 Redis 7.0 中，Zset 有序集合的底层数据结构就交由 listpack 数据结构来实现了，压缩列表数据结构就被废弃了。</p><div class="note primary flat"><p><strong>常用命令</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 往有序集合key中加入带分值元素</span></span><br><span class="line">ZADD key score member [[score member]...]   </span><br><span class="line"><span class="comment"># 往有序集合key中删除元素</span></span><br><span class="line">ZREM key member [member...]                 </span><br><span class="line"><span class="comment"># 返回有序集合key中元素member的分值</span></span><br><span class="line">ZSCORE key member</span><br><span class="line"><span class="comment"># 返回有序集合key中元素个数</span></span><br><span class="line">ZCARD key </span><br><span class="line"></span><br><span class="line"><span class="comment"># 为有序集合key中元素member的分值加上increment</span></span><br><span class="line">ZINCRBY key increment member</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正序获取有序集合key从start下标到stop下标的元素</span></span><br><span class="line">ZRANGE key start stop [WITHSCORES]</span><br><span class="line"><span class="comment"># 倒序获取有序集合key从start下标到stop下标的元素</span></span><br><span class="line">ZREVRANGE key start stop [WITHSCORES]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回有序集合中指定分数区间内的成员，分数由低到高排序。</span></span><br><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回指定成员区间内的成员，按字典正序排列, 分数必须相同。</span></span><br><span class="line">ZRANGEBYLEX key min max [LIMIT offset count]</span><br><span class="line"><span class="comment"># 返回指定成员区间内的成员，按字典倒序排列, 分数必须相同</span></span><br><span class="line">ZREVRANGEBYLEX key max min [LIMIT offset count]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 并集计算(相同元素分值相加)，numberkeys一共多少个key，结果保存至destkey集合</span></span><br><span class="line">ZUNIONSTORE destkey numberkeys key [key...] </span><br><span class="line"><span class="comment"># 交集计算(相同元素分值相加)，numberkeys一共多少个key，结果保存至destkey集合</span></span><br><span class="line">ZINTERSTORE destkey numberkeys key [key...]</span><br></pre></td></tr></table></figure><p><strong>应用场景：</strong>排行榜、电话或者姓名等排序</p><div class="note default flat"><p><strong>排行榜</strong></p></div><p>以文章点赞数排行榜为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># arcticle:1 文章获得了200个赞</span></span><br><span class="line">&gt; ZADD user:1:ranking 200 arcticle:1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># arcticle:2 文章获得了40个赞</span></span><br><span class="line">&gt; ZADD user:1:ranking 40 arcticle:2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># arcticle:3 文章获得了100个赞</span></span><br><span class="line">&gt; ZADD user:1:ranking 100 arcticle:3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># arcticle:4 文章获得了50个赞</span></span><br><span class="line">&gt; ZADD user:1:ranking 50 arcticle:4</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># arcticle:5 文章获得了150个赞</span></span><br><span class="line">&gt; ZADD user:1:ranking 150 arcticle:5</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><div class="note default flat"><p><strong>电话排序</strong></p></div><p>使用有序集合的 ZRANGEBYLEX 或 ZREVRANGEBYLEX 可以帮助我们实现电话号码或姓名的排序，我们以 ZRANGEBYLEX （返回指定成员区间内的成员，按 key 正序排列，分数必须相同）为例。</p><p>注意：不要在分数不一致的 SortSet 集合中去使用 ZRANGEBYLEX和 ZREVRANGEBYLEX 指令，因为获取的结果会不准确。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt; ZADD phone 0 13100111100 0 13110114300 0 13132110901 </span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">&gt; ZADD phone 0 13200111100 0 13210414300 0 13252110901 </span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">&gt; ZADD phone 0 13300111100 0 13310414300 0 13352110901 </span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有电话号码</span></span><br><span class="line">&gt; ZRANGEBYLEX phone - +</span><br><span class="line">1) <span class="string">&quot;13100111100&quot;</span></span><br><span class="line">2) <span class="string">&quot;13110114300&quot;</span></span><br><span class="line">3) <span class="string">&quot;13132110901&quot;</span></span><br><span class="line">4) <span class="string">&quot;13200111100&quot;</span></span><br><span class="line">5) <span class="string">&quot;13210414300&quot;</span></span><br><span class="line">6) <span class="string">&quot;13252110901&quot;</span></span><br><span class="line">7) <span class="string">&quot;13300111100&quot;</span></span><br><span class="line">8) <span class="string">&quot;13310414300&quot;</span></span><br><span class="line">9) <span class="string">&quot;13352110901&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 132 号段的号码</span></span><br><span class="line">&gt; ZRANGEBYLEX phone [132 (133</span><br><span class="line">1) <span class="string">&quot;13200111100&quot;</span></span><br><span class="line">2) <span class="string">&quot;13210414300&quot;</span></span><br><span class="line">3) <span class="string">&quot;13252110901&quot;</span></span><br></pre></td></tr></table></figure><h1 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h1><p>Bitmap，即位图，是一串连续的二进制数组（0和1），可以通过偏移量（offset）定位元素。BitMap 通过最小的单位bit来进行 <code>0|1</code> 的设置，表示某个元素的值或者状态，时间复杂度为 O(1)。使用它进行储存将非常节省空间，特别适合一些数据量大且使用二值统计的场景。</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/BitMap%E5%AD%98%E5%82%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="BitMap存储示意图"></p><p>Bitmap 本身是用 String 类型作为底层数据结构实现的一种统计二值状态的数据类型。</p><p>String 类型是会保存为二进制的字节数组，所以，Redis 就把字节数组的每个 bit 位利用起来，用来表示一个元素的二值状态，你可以把 Bitmap 看作是一个 bit 数组。</p><div class="note primary flat"><p><strong>常用命令</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置值，其中value只能是 0 和 1</span></span><br><span class="line">SETBIT key offset value</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取值</span></span><br><span class="line">GETBIT key offset</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取指定范围内值为 1 的个数</span></span><br><span class="line"><span class="comment"># start 和 end 以字节为单位</span></span><br><span class="line">BITCOUNT key start end</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># BitMap间的运算</span><br><span class="line"># operations 位移操作符，枚举值</span><br><span class="line">#   AND 与运算 &amp;</span><br><span class="line">#   OR 或运算 |</span><br><span class="line">#   XOR 异或 ^</span><br><span class="line">#   NOT 取反 ~</span><br><span class="line"># result 计算的结果，会存储在该key中</span><br><span class="line"># key1 … keyn 参与运算的key，可以有多个，空格分割，NOT 运算只能一个key</span><br><span class="line"># 当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 <span class="number">0</span>。</span><br><span class="line"># 返回值是保存到 destkey 的字符串的长度（以字节<span class="type">byte</span>为单位），和输入 key 中最长的字符串长度相等。</span><br><span class="line">BITOP [operations] [result] [key1] [keyn…]</span><br><span class="line"></span><br><span class="line"># 返回指定key中第一次出现指定value(<span class="number">0</span>/<span class="number">1</span>)的位置</span><br><span class="line">BITPOS [key] [value]</span><br></pre></td></tr></table></figure><p><strong>应用场景：</strong>签到统计、判断用户登录状态、连续签到用户统计</p><div class="note default flat"><p><strong>连续签到用户统计</strong></p></div><p>以统计七天连续签到打卡的用户为例：</p><p>把每天的日期作为 Bitmap 的 key，userId 作为 offset，若是打卡则将 offset 位置的 bit 设置成 1。key 对应的集合的每个 bit 位的数据则是一个用户在该日期的打卡记录。</p><p>一共有 7 个这样的 Bitmap，如果我们能对这 7 个 Bitmap 的对应的 bit 位做 『与』运算。同样的 UserID offset 都是一样的，当一个 userID 在 7 个 Bitmap 对应对应的 offset 位置的 bit &#x3D; 1 就说明该用户 7 天连续打卡。</p><p>结果保存到一个新 Bitmap 中，我们再通过 BITCOUNT 统计 bit &#x3D; 1 的个数便得到了连续打卡 7 天的用户总数了。</p><h1 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h1><p>HyperLogLog 是一个用来做基数估计的数据类型，什么是基数估计呢？</p><p>比如现有数据集：{1, 3, 5, 7, 5, 7, 8}，其中构成这个集合的基本元素是：{1, 3, 5, 7, 8}，总共有 5 个，那么基数就是 5。基数估计就是在可接受的误差范围内，快速计算基数。</p><p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 <code>2^64</code> 个不同元素的基数，和元素越多就越耗费内存的 Set 和 Hash 类型相比，HyperLogLog 就非常节省空间。</p><p>不过，有一点需要你注意一下，HyperLogLog 的统计规则是基于概率完成的，所以它给出的统计结果是有一定误差的，标准误算率是 0.81%。</p><div class="note primary flat"><p><strong>HyperLogLog 使用命令：</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加指定元素到 HyperLogLog 中</span></span><br><span class="line">PFADD key element [element ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回给定 HyperLogLog 的基数估算值。</span></span><br><span class="line">PFCOUNT key [key ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将多个 HyperLogLog 合并为一个 HyperLogLog</span></span><br><span class="line">PFMERGE destkey sourcekey [sourcekey ...]</span><br></pre></td></tr></table></figure><p><strong>应用场景：</strong>百万级网页 UV 计数</p><p>在统计 UV 时，你可以用 PFADD 命令（用于向 HyperLogLog 中添加新元素）把访问页面的每个用户都添加到 HyperLogLog 中。</p><p>接下来，就可以用 PFCOUNT 命令直接获得 page1 的 UV 值了，这个命令的作用就是返回 HyperLogLog 的统计结果。</p><h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><p>Stream 是 Redis 5.0 版本新增加的数据类型，是 Redis 专门为消息队列设计的数据类型。在 Redis 5.0 Stream 没出来之前，消息队列的实现方式都有着各自的缺陷，例如：</p><ul><li>发布订阅模式，不能持久化也就无法可靠的保存消息，并且对于离线重连的客户端不能读取历史消息的缺陷；</li><li>List 实现消息队列的方式不能重复消费，一个消息消费完就会被删除，而且生产者需要自行实现全局唯一 ID。</li></ul><p>基于以上问题，Redis 5.0 便推出了 Stream 用于完美地实现消息队列，它支持消息的持久化、支持自动生成全局唯一 ID、支持 ack 确认消息的模式、支持消费组模式等，让消息队列更加的稳定和可靠。</p><div class="note default flat"><p><strong>基本操作：生产和消费</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># * 表示让 Redis 为插入的数据自动生成一个全局唯一的 ID</span></span><br><span class="line"><span class="comment"># 往名称为 mymq 的消息队列中插入一条消息，消息的键是 name，值是 zhangsan</span></span><br><span class="line">&gt; XADD mymq * name zhangsan</span><br><span class="line"><span class="string">&quot;1663241868161-0&quot;</span></span><br></pre></td></tr></table></figure><p>插入成功后会返回全局唯一的 ID：”1663241868161-0”。消息的全局唯一 ID 由两部分组成：</p><ul><li>第一部分“1663241868161”是数据插入时，以毫秒为单位计算的当前服务器时间；</li><li>第二部分表示插入消息在当前毫秒内的消息序号，这是从 0 开始编号的。例如，“1663241868161-0”就表示在“1663241868161”毫秒内的第 1 条消息。</li></ul><p>消费者通过 XREAD 命令从消息队列中读取消息时，可以指定一个消息 ID，并从这个消息 ID 的下一条消息开始进行读取（注意是输入消息 ID 的下一条信息开始读取，不读取输入ID的消息）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里输入的毫秒时间戳是刚才生成的ID的前一毫秒</span></span><br><span class="line">&gt; XREAD STREAMS mymq 1663241868160-0</span><br><span class="line">1) 1) <span class="string">&quot;mymq&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1663241868161-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;zhangsan&quot;</span></span><br></pre></td></tr></table></figure><p>如果想要实现阻塞读（当没有数据时，阻塞住），可以调用 XRAED 时设定 BLOCK 配置项，实现类似于 BRPOP 的阻塞读取操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 10000 = 10s，命令最后的“$”符号表示读取最新的消息</span></span><br><span class="line">&gt; XREAD BLOCK 10000 STREAMS mymq $</span><br><span class="line">(nil)</span><br><span class="line">(10.00s)</span><br></pre></td></tr></table></figure><div class="note default flat"><p><strong>消费组</strong></p></div><p>Stream 可以以使用 XGROUP 创建消费组，创建消费组之后，Stream 可以使用 XREADGROUP 命令让消费组内的消费者读取消息。</p><p>创建两个消费组，这两个消费组消费的消息队列是 mymq，都指定从第一条消息开始读取：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个名为 group1 的消费组，0-0 表示从第一条消息开始读取。</span></span><br><span class="line">&gt; XGROUP CREATE mymq group1 0-0</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 创建一个名为 group2 的消费组，0-0 表示从第一条消息开始读取。</span></span><br><span class="line">&gt; XGROUP CREATE mymq group2 0-0</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>消费组 group1 内的消费者 consumer1 从 mymq 消息队列中读取所有消息的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令最后的参数“&gt;”，表示从第一条尚未被消费的消息开始读取。</span></span><br><span class="line">&gt; XREADGROUP GROUP group1 consumer1 STREAMS mymq &gt;</span><br><span class="line">1) 1) <span class="string">&quot;mymq&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1654254953808-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;xiaolin&quot;</span></span><br></pre></td></tr></table></figure><p>消息队列中的消息一旦被消费组里的一个消费者读取了，就不能再被该消费组内的其他消费者读取了，即同一个消费组里的消费者不能消费同一条消息。</p><p>不同消费组的消费者可以消费同一条消息（但是有前提条件，创建消息组的时候，不同消费组指定了相同位置开始读取消息）</p><p>使用消费组的目的是让组内的多个消费者共同分担读取消息，所以，我们通常会让每个消费者读取部分消息，从而实现消息读取负载在多个消费者间是均衡分布的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 让 group2 中的 consumer1 从 mymq 消息队列中消费一条消息</span></span><br><span class="line">&gt; XREADGROUP GROUP group2 consumer1 COUNT 1 STREAMS mymq &gt;</span><br><span class="line">1) 1) <span class="string">&quot;mymq&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1663243059501-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="comment"># 让 group2 中的 consumer2 从 mymq 消息队列中消费一条消息</span></span><br><span class="line">&gt; XREADGROUP GROUP group2 consumer2 COUNT 1 STREAMS mymq &gt;</span><br><span class="line">1) 1) <span class="string">&quot;mymq&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1663243061599-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="comment"># 让 group2 中的 consumer3 从 mymq 消息队列中消费一条消息</span></span><br><span class="line">&gt; XREADGROUP GROUP group2 consumer3 COUNT 1 STREAMS mymq &gt;</span><br><span class="line">1) 1) <span class="string">&quot;mymq&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1663243062597-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;3&quot;</span></span><br></pre></td></tr></table></figure><div class="note default flat"><p><strong>消息确认</strong></p></div><p>Streams 会自动使用内部队列（也称为 PENDING List）留存消费组里每个消费者读取的消息，直到消费者使用 XACK 命令通知 Streams “消息已经处理完成”。</p><p>消费确认增加了消息的可靠性，一般在业务处理完成之后，需要执行 XACK 命令确认消息已经被消费完成，整个流程的执行如下图所示：</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/Stream%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="Stream消息确认流程图"></p><p>如果消费者没有成功处理消息，它就不会给 Streams 发送 XACK 命令，消息仍然会留存。此时，消费者可以在重启后，用 XPENDING 命令查看已读取、但尚未确认处理完成的消息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; XPENDING mymq group1</span><br><span class="line">1) (<span class="built_in">integer</span>) 3</span><br><span class="line">2) <span class="string">&quot;1663245004996-0&quot;</span> <span class="comment"># 表示 group1 中所有消费者读取的消息最小 ID</span></span><br><span class="line">3) <span class="string">&quot;1663245010578-0&quot;</span> <span class="comment"># 表示 group1 中所有消费者读取的消息最大 ID</span></span><br><span class="line">4) 1) 1) <span class="string">&quot;consumer1&quot;</span></span><br><span class="line">      2) <span class="string">&quot;1&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;consumer2&quot;</span></span><br><span class="line">      2) <span class="string">&quot;1&quot;</span></span><br><span class="line">   3) 1) <span class="string">&quot;consumer3&quot;</span></span><br><span class="line">      2) <span class="string">&quot;1&quot;</span></span><br></pre></td></tr></table></figure><p>如果想查看某个消费者具体读取了哪些数据，可以执行下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 group1 里 consumer2 从 mymq 消息队列中读取未确认哪些消息</span></span><br><span class="line">&gt; XPENDING mymq group1 - + 10 consumer2</span><br><span class="line">1) 1) <span class="string">&quot;1663245009507-0&quot;</span></span><br><span class="line">   2) <span class="string">&quot;consumer2&quot;</span></span><br><span class="line">   3) (<span class="built_in">integer</span>) 276418</span><br><span class="line">   4) (<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><p>group1 里 consumer2 应答 1663245009507-0：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 应答</span></span><br><span class="line">&gt; XACK mymq GROUP1 1663245009507-0</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应答成功后没有未确认消息了</span></span><br><span class="line">&gt; XPENDING mymq GROUP1 - + 10 consumer2</span><br><span class="line">(empty array)</span><br></pre></td></tr></table></figure><div class="note default flat"><p><strong>对于 MQ 来说，为什么 Redis 显得不专业？</strong></p></div><ol><li><p>Redis 在以下 2 个场景下，可能会导致数据丢失：</p><ul><li>AOF 持久化配置为每秒写盘，但这个写盘过程是异步的，Redis 宕机时会存在数据丢失的可能</li><li>主从复制也是异步的，主从切换时，也存在丢失数据的可能 (opens new window)。</li></ul></li><li><p>Redis Stream 消息不可堆积</p><ul><li>Redis 的数据都存储在内存中，这就意味着一旦发生消息积压，则会导致 Redis 的内存持续增长，如果超过机器内存上限，就会面临被 OOM 的风险。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://xiaolincoding.com/redis/data_struct/command.html&quot;&gt;小林Coding-Redis 常见数据类型和应用场景&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p</summary>
      
    
    
    
    <category term="Redis" scheme="https://www.wrp.cool/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker 基础概念和基本用法</title>
    <link href="https://www.wrp.cool/posts/24100/"/>
    <id>https://www.wrp.cool/posts/24100/</id>
    <published>2022-09-13T08:15:21.000Z</published>
    <updated>2022-10-17T14:16:10.403Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录一些 Docker 中的基本概念，以及一些常用命令，主要是为了理清楚 <code>镜像</code>、<code>容器</code>、<code>网络</code>、<code>数据卷</code> 这几个概念、作用、操作。当然能够帮到大家就更好了。</p><h1 id="Docker-介绍"><a href="#Docker-介绍" class="headerlink" title="Docker 介绍"></a>Docker 介绍</h1><p><strong>Docker 的四大组成对象：</strong></p><ul><li>Docker 镜像：相当于软件的安装包</li><li>Docker 容器：相当于安装完正在运行的软件</li><li>Docker 网络：负责软件之间的相互通信</li><li>Docker 数据卷：将软件内外的数据相互映射，提供容器内外数据交互功能</li></ul><p>Docker 是以 服务端&#x2F;客户端 的形式对外提供服务的，服务端是 docker daemon，客户端是 docker CLI。所有的镜像模块、容器模块、网络模块、数据卷模块都是实现在 docker daemon 之中的。</p><p>docker daemon 暴露了一套 RESTFul API 接口以对外提供服务，我们可以在控制台通过编写 http 请求来控制 docker daemon，但是这样太繁琐了。所以，Docker 提供了 docker CLI 可以在控制台更方便的控制 docker daemon。</p><h1 id="搭建-Docker-运行环境"><a href="#搭建-Docker-运行环境" class="headerlink" title="搭建 Docker 运行环境"></a>搭建 Docker 运行环境</h1><p>Docker 主要是运行在 Linux 系统中的，也有提供运行在 Windows、Mac 系统上的桌面软件，运行在 Windows、Mac 系统上的 Docker 也是搭了一层 Linux 的隔离。Windows 和 Mac 操作系统的 Docker 环境下载连接如下：</p><ul><li><a href="https://docs.docker.com/desktop/install/windows-install/">Windows 安装环境下载</a></li><li><a href="https://docs.docker.com/desktop/install/mac-install/">Mac 安装环境下载</a></li></ul><p><strong>CentOS 安装如下：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"></span><br><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line">sudo yum install docker-ce</span><br><span class="line"></span><br><span class="line">sudo systemctl enable docker  # 开机自启动</span><br><span class="line">sudo systemctl start docker   # 启动 Docker 服务</span><br></pre></td></tr></table></figure><p>安装完成，启动成功之后可以运行两条命令查看 Docker 的一些基本信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker version  # Docker 版本信息（包含客户端和服务端的版本信息）</span><br><span class="line">docker info     # Docker 详细信息（包含镜像、容器状态等）</span><br></pre></td></tr></table></figure><p><strong>配置国内镜像源：</strong></p><p>修改 <code>/etc/docker/daemon.json</code> 文件（如果不存在，直接创建即可）添加以下内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;https://registry.docker-cn.com&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>修改完成，重启 Docker 以生效：<code>systemctl restart docker</code></p><p>运行 <code>docker info</code> 看看是否已经生效，大概在倒数两三行的位置可以看到 Registry Mirrors 信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Registry Mirrors:</span><br><span class="line"> https://registry.docker-cn.com/</span><br></pre></td></tr></table></figure><h1 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h1><p>在 <a href="https://hub.docker.com/">dockerhub</a> 中搜索想要下载的镜像直接下载即可，有标注 <code>DOCKER OFFICIAL IMAGE</code> 字样的镜像为官方维护的镜像。也可以在控制台查看 dockerhub 的镜像信息：<code>docker search image-name</code></p><p>下载命令：<code>docker pull image-name</code></p><p><strong>镜像命名规则：</strong> <code>username</code>&#x2F;<code>repository</code>:<code>tag</code></p><ul><li><strong>username：</strong> 上传该镜像的用户，由官方维护的镜像无此信息</li><li><strong>repository：</strong> 镜像名称，通常是软件名</li><li><strong>tag：</strong> 镜像标签，通常是版本信息，也可以是环境需求、构建方式等信息</li></ul><p>当我们在下载镜像时如果没有明确给出 <code>tag</code> 时，Docker 会默认使用 <code>latest</code> 作为 <code>tag</code>，也就是默认下载最新版本的镜像。</p><p><strong>常用命令：</strong></p><table><thead><tr><th align="left">操作</th><th align="left">命令</th></tr></thead><tbody><tr><td align="left">查看本地镜像信息</td><td align="left"><code>docker images</code></td></tr><tr><td align="left">查看本地镜像的详细信息</td><td align="left"><code>docker inspect image-name</code></td></tr><tr><td align="left">删除镜像</td><td align="left"><code>docker rmi image-name</code></td></tr></tbody></table><p><strong>创建镜像：</strong></p><p>提交容器修改保存成镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker commit -m &quot;message&quot; container-name your-image-name</span><br></pre></td></tr></table></figure><p>创建镜像之后可以使用 <code>docker images</code> 命令查看镜像信息。创建时如果忘了指定镜像名称可以通过 <code>docker tag</code> 重新命名镜像。</p><p><strong>镜像导入导出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 将镜像保存导出</span><br><span class="line">docker save -o save-path/save-name1.tar your-image-name1 your-image-name2</span><br><span class="line"># 将导出的镜像导入</span><br><span class="line">docker load -i image-path/image-name.tar</span><br></pre></td></tr></table></figure><p><strong>容器导入导出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 导出容器（一次只能导出一个）</span><br><span class="line">docker export -o save-name.tar your-container-name</span><br><span class="line"># 导入容器（导入之后是镜像）</span><br><span class="line">docker import save-name.tar your-image-name</span><br></pre></td></tr></table></figure><h1 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h1><p>Docker 镜像运行起来就是 Docker 容器了，也就是一个个运行起来的软件。</p><p><strong>Docker 容器的生命周期：</strong></p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/docker%E5%AE%B9%E5%99%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="docker容器生命周期"></p><p>Docker 容器的生命周期分为五种状态，分别为：</p><ul><li><strong>Created：</strong>容器已经被创建，容器所需的相关资源已经准备就绪，但容器中的程序还未处于运行状态。</li><li><strong>Running：</strong>容器正在运行，也就是容器中的应用正在运行。</li><li><strong>Paused：</strong>容器已暂停，表示容器中的所有程序都处于暂停 ( 不是停止 ) 状态。</li><li><strong>Stopped：</strong>容器处于停止状态，占用的资源和沙盒环境都依然存在，只是容器中的应用程序均已停止。</li><li><strong>Deleted：</strong>容器已删除，相关占用的资源及存储在 Docker 中的管理信息也都已释放和移除。</li></ul><p><strong>常用命令：</strong></p><table><thead><tr><th align="left">操作</th><th align="left">命令</th><th align="left">常用参数</th></tr></thead><tbody><tr><td align="left">创建容器</td><td align="left"><code>docker create image-name</code></td><td align="left"><code>--name</code>（指定容器名称）</td></tr><tr><td align="left">启动容器</td><td align="left"><code>docker start container-name</code></td><td align="left"></td></tr><tr><td align="left">创建并启动容器</td><td align="left"><code>docker run image-name</code></td><td align="left"><code>--name</code>、<code>-d</code>（后台运行）<br> <code>--rm</code>（停止后删除）、<code>-e</code>（设置环境）</td></tr><tr><td align="left">停止容器</td><td align="left"><code>docker stop container-name</code></td><td align="left"></td></tr><tr><td align="left">删除容器</td><td align="left"><code>docker rm container-name</code></td><td align="left"><code>-v</code>（删除相关联的数据卷）</td></tr><tr><td align="left">查看容器状态</td><td align="left"><code>docker ps</code></td><td align="left"><code>-a</code>（查看全部容器）</td></tr><tr><td align="left">进入容器</td><td align="left"><code>docker exec container-name</code></td><td align="left"><code>-it</code>（当前控制台输入输出）<br> <code>bash</code>&#x2F;<code>sh</code>（以哪种方式启动）</td></tr></tbody></table><p><strong>写时复制：</strong></p><p>在通过镜像运行容器时，并不是马上就把镜像里的所有内容拷贝到容器所运行的沙盒文件系统中，而是利用 UnionFS 将镜像以只读的方式挂载到沙盒文件系统中。只有在容器中发生对文件的修改时，修改才会体现到沙盒环境上。</p><p>容器是基于镜像启动的，在启动容器的时候并不是直接创建一个容器，而是利用镜像直接启动，当发生修改时再利用写时复制机制去修改。这样可以大幅提高容器启动速度，做到秒启动。</p><h1 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h1><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/docker%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.png" alt="docker容器网络模型"></p><p>在 Docker 网络中，有三个比较核心的概念，也就是：<code>沙盒（Sandbox）</code>、<code>网络（Network）</code>、<code>端点（Endpoint）</code>。这三者形成了 Docker 网络的核心模型，也就是容器网络模型 ( Container Network Model )。</p><ul><li><strong>沙盒：</strong>每个容器完全独立的网络环境，隔离了容器网络与宿主机网络。</li><li><strong>网络：</strong>Docker 内部的虚拟子网，网络内的参与者相互可见并能够进行通讯。</li><li><strong>端点：</strong>可控封闭网络环境的出入口，当端口相互配对后，就能进行数据传输了。</li></ul><p>目前 Docker 官方为我们提供了五种 Docker 网络驱动，分别是：<strong>Bridge Driver（默认，网桥模式）</strong>、Host Driver、Overlay Driver、MacLan Driver、None Driver。docker daemon 中默认维护了一个 bridge 的网络，所有的容器默认都是加入到此网络中。</p><h2 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h2><p>要让一个容器连接到另外一个容器，可以在容器通过 <code>docker create</code> 或 <code>docker run</code> 创建时通过 <code>--link</code> 选项进行配置，同时也可以为连接指定一个别名，这样在代码中可以直接使用别名进行连接。如下就是创建 mysql 容器和 webapp 容器，让 webapp 容器连接至 mysql 容器中，并且在 webapp 容器中为 mysql 容器取别名为 database。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name mysql -e MYSQL_ROOT_PASSWORD=root mysql</span><br><span class="line">docker run -d --name webapp --link mysql:database webapp</span><br></pre></td></tr></table></figure><p>这样在 webapp 中如果需要连接 mysql 可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://database:3306/database-name&quot;</span>;</span><br></pre></td></tr></table></figure><p>如果不是连接默认端口，那么需要在启动时通过 <code>--expose</code> 参数告诉容器暴露对应端口，使用如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name mysql --expose=3307 -e MYSQL_ROOT_PASSWORD=root mysql</span><br></pre></td></tr></table></figure><p>可通过 <code>docker ps</code> 命令查看容器对外暴露了哪些端口。</p><h2 id="创建网络"><a href="#创建网络" class="headerlink" title="创建网络"></a>创建网络</h2><p>我们也可以自定义网络，形成虚拟子网的目的，<strong>只有在同一网络之中的容器才可以互联</strong>。</p><ul><li>创建网络：<code>docker network create -d bridge network-name</code>，<code>-d</code> 指定网络类型</li><li>查看网络：<code>docker network ls</code></li><li>删除网络：<code>docker network rm network-name</code></li></ul><p>创建容器时指定网络：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name your-container-name --network=network-name container-name</span><br></pre></td></tr></table></figure><h2 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h2><p>将容器中的端口映射至宿主机的端口。如下：</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/docker%E7%BD%91%E7%BB%9C%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E6%A8%A1%E5%9E%8B.png" alt="docker网络端口映射模型"></p><p>要映射端口，我们可以在创建容器时使用 <code>-p</code> 或者是 <code>--publish</code> 参数。</p><p>使用方式：<code>-p &lt;host-port&gt;:&lt;container-port&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nginx -p 80:80 nginx</span><br></pre></td></tr></table></figure><p>可通过 <code>docker ps</code> 查看端口映射情况</p><h1 id="Docker-数据卷"><a href="#Docker-数据卷" class="headerlink" title="Docker 数据卷"></a>Docker 数据卷</h1><p>数据管理使用挂载的方式，通过数据卷可以方便管理挂载的目录</p><h2 id="容器数据管理"><a href="#容器数据管理" class="headerlink" title="容器数据管理"></a>容器数据管理</h2><p>容器内的文件系统是随着容器的生命周期而创建和移除的，容器内部的数据无法被持久化存储。由于容器隔离，操作容器内部文件也变得很麻烦。Docker 解决这一问题的方式是文件挂载，将宿主操作系统中的文件挂载到容器内部，便可以让容器内外都共享这个文件。通过这种方式可以互通容器内外的文件，那么文件数据持久化以及操作容器内部文件的问题也就得到了解决。</p><p>Docker 提供了三种文件挂载的方式：Bind Mount、Volume 和 Tmpfs Mount。</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/docker%E6%96%87%E4%BB%B6%E6%8C%82%E8%BD%BD.png" alt="docker文件挂载"></p><ul><li><p><strong>Bind Mount：</strong> 直接将宿主操作系统中的目录和文件挂载到容器内的文件系统中，形成挂载映射关系，在容器内外对文件的读写都相互可见。</p><blockquote><p>使用 <code>-v</code> 参数设置，示例：<code>-v &lt;host-path&gt;:&lt;container-path&gt;:ro</code>，ro（可选）表示容器内只读。为避免混淆，此处强制使用绝对路径。</p></blockquote></li><li><p><strong>Volume（数据卷）：</strong> 仅指定容器内的目录，宿主操作系统挂载的目录由 Docker 进行管理，不需要关心具体挂载到了宿主操作系统中的哪里。</p><blockquote><p>Bind Mount 模式为指定 <code>&lt;host-path&gt;</code> 则为 Volume。此种方式生成的数据在路径上会有 Docker 生成的 ID，所以能够自己命名：<code>-v name:&lt;container-path&gt;</code></p></blockquote></li><li><p><strong>Tmpfs Mount：</strong> 挂载系统内存中的一部分到容器的文件系统里，不过由于内存和容器的特征，它的存储并不是持久的，其中的内容会随着容器的停止而消失。</p><blockquote><p>使用 <code>--tmpfs</code> 参数挂载，<code>--tmpfs &lt;host-path&gt;</code></p></blockquote></li></ul><p>以上创建出来的数据挂载信息，或者是数据卷信息可以通过 <code>docker inspect</code> 命令查看。</p><h2 id="数据卷管理"><a href="#数据卷管理" class="headerlink" title="数据卷管理"></a>数据卷管理</h2><p>上面对数据卷的操作都是基于容器的，多少有点不方便，Docker 提供了独立操作数据卷的方式。</p><p><strong>数据卷使用命令：</strong></p><table><thead><tr><th align="left">操作</th><th align="left">命令</th></tr></thead><tbody><tr><td align="left">创建数据卷</td><td align="left"><code>docker volume create volume-name</code></td></tr><tr><td align="left">查看数据卷</td><td align="left"><code>docker volume ls</code></td></tr><tr><td align="left">删除数据卷</td><td align="left"><code>docker volume rm volume-name</code></td></tr><tr><td align="left">删除没有被引用且未命名的数据卷</td><td align="left"><code>docker volume prune -f</code></td></tr></tbody></table><p><strong>数据卷容器：</strong></p><p>创建数据卷容器的方式很简单，由于不需要容器本身运行，因而我们找个简单的系统镜像都可以完成创建。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker create --name appdata -v /webapp/storage ubuntu</span><br></pre></td></tr></table></figure><p>在使用数据卷容器时，我们不建议再定义数据卷的名称，因为我们可以通过对数据卷容器的引用来完成数据卷的引用。之前我们提到，Docker 的 Network 是容器间的网络桥梁，如果做类比，数据卷容器就可以算是容器间的文件系统桥梁。我们可以像加入网络一样引用数据卷容器，只需要在创建新容器时使用专门的 <code>--volumes-from</code> 选项即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nginx --volumes-from appdata nginx</span><br></pre></td></tr></table></figure><p>引用数据卷容器时，不需要再定义数据卷挂载到容器中的位置，Docker 会以数据卷容器中的挂载定义将数据卷挂载到引用的容器中。</p><p>使用数据卷容器看起来与使用原始数据卷的方式差不多，但是数据卷容器主要是在迁移数据卷时提供方便。如果迁移数据卷至其他目录，不用修改引用容器中的数据卷，数据卷容器相当于对数据卷的路径做了一层包装或者是取了个别名的意思。</p><hr><blockquote><p><strong>巨人的肩膀：</strong></p><ul><li>掘金小册-开发者必备的 Docker 实践指南</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文主要记录一些 Docker 中的基本概念，以及一些常用命令，主要是为了理清楚 &lt;code&gt;镜像&lt;/code&gt;、&lt;code&gt;容器&lt;/code&gt;、&lt;code&gt;网络&lt;/code&gt;、&lt;code&gt;数据卷&lt;/code&gt; 这几个概念、作用、操作。当然能够帮到大家就更好了。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="分布式" scheme="https://www.wrp.cool/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring Security</title>
    <link href="https://www.wrp.cool/posts/28582/"/>
    <id>https://www.wrp.cool/posts/28582/</id>
    <published>2022-09-06T03:38:08.000Z</published>
    <updated>2022-10-11T06:00:41.678Z</updated>
    
    <content type="html"><![CDATA[<p>关于 Spring Security 的文章网上有很多，B站也有很多教程，我都看过一些，但感觉对这部分的知识还不是很牢固。网上的大部分文章主要都是从后端的用户认证开始讲起的，一上来就是这些比较偏向实用部分的内容我觉得不是很好理解，还有很多巨长的类名方法名等等，这并不是在说网上的这些文章写的不好，毕竟本文也是一篇前人栽树，后人乘凉的文章。但是写这篇文章的初衷是想要从一个简单的小例子入手，解释清楚那些巨长的类名方法名都是干嘛的，应该怎么使用。</p><p>Spring Security 的一些介绍就不多说了，直接一个小 demo 走起，这个 demo 力争简洁，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入账号：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入密码：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> sc.next();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 开始认证    </span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">AuthenticationManager</span> <span class="variable">am</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SampleAuthenticationManager</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1、封装一个 UsernamePasswordAuthenticationToken 对象</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Authentication</span> <span class="variable">unAuth</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(username, password);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、经过 AuthenticationManager 的认证，如果认证失败会抛出一个 AuthenticationException 错误</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Authentication</span> <span class="variable">auth</span> <span class="operator">=</span> am.authenticate(unAuth);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、将这个认证过的 Authentication 填入 SecurityContext 里面</span></span><br><span class="line">            SecurityContextHolder.getContext().setAuthentication(auth);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;认证失败：&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 SecurityContext 中取出 Authentication</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Authentication</span> <span class="variable">auth</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        System.out.println(<span class="string">&quot;认证成功！&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;输入的账号：&quot;</span> + auth.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;输入的密码：&quot;</span> + auth.getCredentials());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现一个简单 AuthenticationManager 用于认证</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SampleAuthenticationManager</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键认证部分</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Authentication <span class="title function_">authenticate</span><span class="params">(Authentication auth)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> auth.getName();</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> (String) auth.getCredentials(); <span class="comment">// getCredentials 返回的是密码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (username == <span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(username))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadCredentialsException</span>(<span class="string">&quot;账号不能为空&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (password == <span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(password))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadCredentialsException</span>(<span class="string">&quot;密码不能为空&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 认证成功，创建认证成功对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(auth.getName(), auth.getCredentials());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring Security 主要的两个功能是认证和鉴权。这两个功能组合起来就能完成用户登录的需求，也就是一个系统中最基础最重要的模块。根据不同系统的需求，用户认证的工作可能会很繁琐。具体的认证步骤由程序员自行编写，Spring Security 的策略是把每个认证步骤串联起来成为一整个认证流程。上面的这个 demo 仅仅是一个简单的账号密码判空操作而已。主要是说明了怎么编写认证步骤。</p><h1 id="重要组件"><a href="#重要组件" class="headerlink" title="重要组件"></a>重要组件</h1><ul><li>Authentication：认证对象接口，定义了认证对象的数据形式。</li><li>AuthenticationManager：认证工作的上层接口，用于校验 <code>Authentication</code>，返回一个认证完成后的 <code>Authentication</code> 对象。</li><li>SecurityContext：上下文对象，<code>Authentication</code> 对象会放在里面。</li><li>SecurityContextHolder：用于拿到上下文对象的静态工具类。</li></ul><h2 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h2><p>Authentication 只是定义了一种在 Spring Security 进行认证过的数据的数据形式应该是怎么样的，要有权限，要有密码，要有身份信息，要有额外信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Authentication</span> <span class="keyword">extends</span> <span class="title class_">Principal</span>, Serializable &#123;</span><br><span class="line">    <span class="comment">// 获取用户权限列表</span></span><br><span class="line">    Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities();</span><br><span class="line">    <span class="comment">// 获取证明用户认证的信息，通常情况下获取到的是密码等信息。</span></span><br><span class="line">    Object <span class="title function_">getCredentials</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 获取用户的额外信息，（这部分信息可以是我们的用户表中的信息）。</span></span><br><span class="line">    Object <span class="title function_">getDetails</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 获取用户身份信息，在未认证的情况下获取到的是用户名，在已认证的情况下获取到的是 UserDetails。</span></span><br><span class="line">    Object <span class="title function_">getPrincipal</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 获取当前 Authentication 是否已认证。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAuthenticated</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 设置当前 Authentication 是否已认证（true or false）。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setAuthenticated</span><span class="params">(<span class="type">boolean</span> var1)</span> <span class="keyword">throws</span> IllegalArgumentException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AuthenticationManager"><a href="#AuthenticationManager" class="headerlink" title="AuthenticationManager"></a>AuthenticationManager</h2><p><code>AuthenticationManager</code> 定义了一个认证方法，它将一个未认证的 <code>Authentication</code> 传入，返回一个已认证的 <code>Authentication</code>，默认使用的实现类为：<code>ProviderManager</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AuthenticationManager</span> &#123;</span><br><span class="line">    <span class="comment">// 认证方法</span></span><br><span class="line">    Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span> </span><br><span class="line">        <span class="keyword">throws</span> AuthenticationException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SecurityContext"><a href="#SecurityContext" class="headerlink" title="SecurityContext"></a>SecurityContext</h2><p>上下文对象，认证后的数据就放在这里面，这个接口里面只有两个方法，其主要作用就是 get or set <code>Authentication</code>。接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SecurityContext</span> <span class="keyword">extends</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    Authentication <span class="title function_">getAuthentication</span><span class="params">()</span>; <span class="comment">// 获取Authentication对象</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setAuthentication</span><span class="params">(Authentication authentication)</span>; <span class="comment">// 放入Authentication对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SecurityContextHolder"><a href="#SecurityContextHolder" class="headerlink" title="SecurityContextHolder"></a>SecurityContextHolder</h2><p>可以说是 <code>SecurityContext</code> 的工具类，用于 get or set or clear <code>SecurityContext</code>，默认会把数据都存储到当前线程中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityContextHolder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clearContext</span><span class="params">()</span> &#123;</span><br><span class="line">        strategy.clearContext(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SecurityContext <span class="title function_">getContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> strategy.getContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setContext</span><span class="params">(SecurityContext context)</span> &#123;</span><br><span class="line">        strategy.setContext(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>由这四个组件组成的认证流程就是：</p><ol><li>将登录请求的身份信息封装成未认证的 <code>Authentication</code></li><li>将未认证的 <code>Authentication</code> 交由 <code>AuthenticationManager</code> 实行认证</li><li><code>AuthenticationManager</code> 认证完成返回认证后的 <code>Authentication</code></li><li>将认证过的 <code>Authentication</code> 放入 <code>SecurityContext</code></li></ol><p>上面的这四个组件就是 Spring Security 当中最重要的几个组件，Spring Security 其他的内容也是围绕这几个组件展开的。</p><h1 id="ProviderManager"><a href="#ProviderManager" class="headerlink" title="ProviderManager"></a>ProviderManager</h1><p>ProviderManager 是 AuthenticationManager 的默认实现类，由它衍生出来了 AuthenticationProvider 接口。</p><p>原来的一个 AuthenticationManager 只做一次认证工作，但是 ProviderManager 把多个认证工作放在一个集合中，遍历取出每个认证对象一次次做认证工作，只要有一次通过了，就认为这次认证是成功的。在 ProviderManager 中把认证工作封装成了 AuthenticationProvider。</p><div class="note default flat"><p><strong>AuthenticationProvider：</strong></p></div><p>认证提供者，服务于 ProviderManager 类，由实现了这个接口的对象组成一个集合，在 ProviderManager 中遍历取出认证 Authentication。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AuthenticationProvider</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 认证</span></span><br><span class="line">    Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span></span><br><span class="line">            <span class="keyword">throws</span> AuthenticationException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否支持当前的 Authentication 对象</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class&lt;?&gt; authentication)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProviderManager 这个类的代码比较复杂，摘一些跟它认证流程有关的代码出来看看，以下代码在源码的基础上有做改动，主要是为了方便看一些</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 构造方法之一，传入一个个的 AuthenticationProvider 对象</span></span><br><span class="line"><span class="comment"> * 待会就拿这些对象来认证。</span></span><br><span class="line"><span class="comment"> * parent 对象传入 null，parent 相当于是一个兜底的 AuthenticationManager，</span></span><br><span class="line"><span class="comment"> * 如果所有的 AuthenticationProvider 认证都没通过，则使用 parent 做一次认证。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ProviderManager</span><span class="params">(AuthenticationProvider... providers)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(Arrays.asList(providers), (AuthenticationManager)<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Authentication</span>&gt; toTest = authentication.getClass();</span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">parentResult</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次取出 provider 认证 authentication</span></span><br><span class="line">    <span class="keyword">for</span>(AuthenticationProvider provider : <span class="built_in">this</span>.getProviders()) &#123;</span><br><span class="line">        <span class="comment">// provider 不能支持 authentication，直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> (!provider.supports(toTest))  <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用 provider 进行认证</span></span><br><span class="line">            result = provider.authenticate(authentication);</span><br><span class="line">            <span class="comment">// 认证通过</span></span><br><span class="line">            <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.copyDetails(authentication, result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InternalAuthenticationServiceException | AccountStatusException | AuthenticationException e) &#123;</span><br><span class="line">            <span class="comment">// 某次异常处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// providers 认证失败，尝试使用 parent 认证</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.parent != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = parentResult = <span class="built_in">this</span>.parent.authenticate(authentication);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ProviderNotFoundException | AuthenticationException e) &#123;</span><br><span class="line">            <span class="comment">// 异常处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 认证成功，擦除密码信息</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.eraseCredentialsAfterAuthentication &amp;&amp; result <span class="keyword">instanceof</span> CredentialsContainer) &#123;</span><br><span class="line">            ((CredentialsContainer)result).eraseCredentials();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发布认证成功事件</span></span><br><span class="line">        <span class="keyword">if</span> (parentResult == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.eventPublisher.publishAuthenticationSuccess(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// 执行至此，说明 providers 和 parent 都没认证成功，包装异常信息抛出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码如果觉得比较复杂也可以不看，只需知道 ProviderManager 类的认证流程即可。</p><h1 id="DaoAuthenticationProvider"><a href="#DaoAuthenticationProvider" class="headerlink" title="DaoAuthenticationProvider"></a>DaoAuthenticationProvider</h1><p>DaoAuthenticationProvider 就是 AuthenticationProvider 的最常实现类，顾名思义，Dao 正是数据访问层的缩写，也暗示了这个身份认证器的实现思路。</p><p>按照我们最直观的思路，怎么去认证一个用户呢？</p><p>用户前台提交了用户名和密码，而数据库中保存了用户名和密码，认证便是负责比对同一个用户名，提交的密码和保存的密码是否相同便是了。</p><p>在 Spring Security 中。提交的用户名和密码，被封装成了 UsernamePasswordAuthenticationToken，而根据用户名加载用户的任务则是交给了 UserDetailsService。</p><h2 id="UserDetailsService"><a href="#UserDetailsService" class="headerlink" title="UserDetailsService"></a>UserDetailsService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line">    <span class="comment">// 查询用户，去哪里查询自己实现，一般是数据库。</span></span><br><span class="line">    UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要我们自己编写一个类实现 UserDetailsService 接口，在数据库中查询出登录的用户，将其包装成 UserDetails 对象返回。</p><p>这个接口的实现类写完需要在 Spring Security 配置中注册我们自己写的实现类，否则 Spring Security 是不知道你实现了这个接口的。</p><h2 id="UserDetails"><a href="#UserDetails" class="headerlink" title="UserDetails"></a>UserDetails</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDetails</span> <span class="keyword">extends</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// 当前认证用户的权限列表</span></span><br><span class="line">    Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities();</span><br><span class="line">    <span class="comment">// 当前认证用户密码</span></span><br><span class="line">    String <span class="title function_">getPassword</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 当前认证用户用户名</span></span><br><span class="line">    String <span class="title function_">getUsername</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 账户是否没过期</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 账户是否没被锁定（可以用来做黑名单）</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 账户凭据是否没过期</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 账户是否启用</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是一个接口，用来包装对应的数据库查出来的我们自己的 User 对象，包装完之后交给 Spring Security 去判断当前认证的用户账号情况。</p><h2 id="DaoAuthenticationProvider-比对密码"><a href="#DaoAuthenticationProvider-比对密码" class="headerlink" title="DaoAuthenticationProvider 比对密码"></a>DaoAuthenticationProvider 比对密码</h2><p>以下代码从源码中来，又跟源码不大一样，为了好看一些，有做删减。</p><p><strong>先从数据库加载用户：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> UserDetails <span class="title function_">retrieveUser</span><span class="params">(String username, UsernamePasswordAuthenticationToken authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">loadedUser</span> <span class="operator">=</span> <span class="built_in">this</span>.getUserDetailsService().loadUserByUsername(username);</span><br><span class="line">        <span class="keyword">if</span> (loadedUser == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 找不到直接报错，</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> loadedUser;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UsernameNotFoundException | InternalAuthenticationServiceException | Exception e) &#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>比对密码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">additionalAuthenticationChecks</span><span class="params">(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    <span class="keyword">if</span> (authentication.getCredentials() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 前台没传密码，直接报错</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">presentedPassword</span> <span class="operator">=</span> authentication.getCredentials().toString();</span><br><span class="line">        <span class="comment">// 比对密码，passwordEncoder 是需要注册的密码器。</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.passwordEncoder.matches(presentedPassword, userDetails.getPassword())) &#123;</span><br><span class="line">            <span class="comment">// 密码不匹配，直接报错</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PasswordEncoder：</strong>是一个接口，用来定义一些密码器的，Spring Security 提供了多种不同的密码策略，需要选择一种密码策略，在配置文件中注册。通常使用 BCryptPasswordEncoder。</p><div class="note default flat"><p><strong>小结：</strong></p></div><ol><li>顶层接口，一切的开始：AuthenticationManager，用于管理认证的每一个环节。</li><li>Authentication：认证对象，所有的一切都是为它服务的，放在 SecurityContext 中传来传去的。每一个认证环节的开始和结束都是它。</li><li>ProviderManager：AuthenticationManager 最重要的实现类，那也就是最重要的一个认证环节。</li><li>ProviderManager 把自己的认证工作委托给了多个 AuthenticationProvider，只要有一个认证成功了就认为是成功的。</li><li>AuthenticationManager 和 ProviderManager 的职责是不同的，主要就是它们的认证策略不同。</li><li>具体的登录密码比对工作交给了 DaoAuthenticationProvider，这也是 ProviderManager 最重要的一个 AuthenticationProvider。</li><li>通常需要实现 UserDetailsService 和 UserDetails，DaoAuthenticationProvider 根据这两个对象来校验密码。</li></ol><p>写这篇文章的目的主要是学习 Spring Security 的过程中有很多的不理解的地方，很多类名都特别长，长的又差不多，感觉很难理解。所以想要写一篇文章来帮助自己巩固这部分的知识，这篇文章的一些内容也是在网上其他文章中出现过的。</p><p>推荐一个 GitHub 上的一个 Spring Security 的仓库，写的真的不错：<a href="https://github.com/rookie-ricardo/spring-boot-learning-demo">向大佬学习</a></p><hr><p>本来鉴权部分应该是要单独的写一篇文章来总结的，但是看了看 Spring Security 的动态鉴权，看是看的明白个大概，就是道行太浅还用不上这么高级的东西。这里就先简单的介绍一下简单的鉴权方案吧。</p><p>有需要动态鉴权的同学也可以先看看这两篇文章，顺带一提，大佬写的文章真的不错。</p><ul><li><a href="https://zhuanlan.zhihu.com/p/365515214">Spring Security 鉴权流程</a></li><li><a href="https://juejin.cn/post/6847902222668431368">SpringSecurity动态鉴权流程解析</a></li></ul><p><strong>鉴权策略：</strong></p><ol><li>在 SecurityConfig 配置文件中手动开启 <code>@EnableGlobalMethodSecurity(prePostEnabled = true)</code></li><li>在 UserDetailService.loadUserByUsername 方法中查询出用户所具有的全部权限</li><li>将权限封装在 UserDetail.getAuthorities() 方法中供 Spring Security 获取</li><li>在每个需要授权的 API 上加上 <code>@PreAuthorize(&quot;hasAuthority(&#39;权限值&#39;)&quot;)</code> 注解</li><li>如果用户权限列表有该接口对应权限值就能访问对应接口</li></ol><hr><blockquote><p><strong>前人栽树：</strong></p><ul><li><a href="https://zhuanlan.zhihu.com/p/365513384">Spring Security 认证流程</a></li><li><a href="https://juejin.cn/post/6846687598442708999">SpringSecurity+JWT认证流程解析</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于 Spring Security 的文章网上有很多，B站也有很多教程，我都看过一些，但感觉对这部分的知识还不是很牢固。网上的大部分文章主要都是从后端的用户认证开始讲起的，一上来就是这些比较偏向实用部分的内容我觉得不是很好理解，还有很多巨长的类名方法名等等，这并不是在说网</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JWT 工具类封装</title>
    <link href="https://www.wrp.cool/posts/64951/"/>
    <id>https://www.wrp.cool/posts/64951/</id>
    <published>2022-09-05T11:04:10.000Z</published>
    <updated>2022-10-17T12:03:00.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1><p>JWT（Json Web Token）是一种用于用户认证的技术，前端携带 JWT 访问后端服务器，后端服务器可以解析 JWT 判断是否由本服务器签发，以及解析出一些简单的数据后可以拿到本次请求的用户。引入 JWT 主要为了解决传统 session 验证的弊端，session 认证的弊端：</p><ol><li>Session 保存在服务器中，用户数增加对服务器开销造成一定压力。</li><li>Session 保存在服务器物理内存中，对分布式不友好。</li><li>依赖 Cookie，对于非浏览器的客户端、手机移动端等不适用。</li><li>客户端 Cookie 泄漏会导致服务器不安全。</li><li>由于依赖 Cookie，所以无法跨域。</li></ol><p>JWT 的优势：</p><ol><li>简洁、数据量小、传输速度快</li><li>存储在客户端，原则上是跨语言的，支持任何 web 形式。</li><li>不依赖 Cookie 和 Session，对分布式友好。</li><li>容易跨域，对单点登录友好。</li><li>对手机移动端适用。</li></ol><p>JWT 认证流程图：</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/JWT%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B.png" alt="JWT认证流程"></p><h2 id="JWT-结构"><a href="#JWT-结构" class="headerlink" title="JWT 结构"></a>JWT 结构</h2><p>JWT 分成三个部分，每个部分都是一个字符串，中间由 <code>.</code> 隔开。</p><ul><li>Header：头部，标记加密的算法</li><li>Payload：负载，存放具体数据</li><li>Signature：签名，由 “Header + Payload + 服务器本地密钥” 经 MD5 加密后的值。</li></ul><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>Header 是一个描述 JWT 元数据的 JSON 对象，alg 属性表示签名使用的算法，默认为 HMAC SHA256（写为HS256）；typ 属性表示令牌的类型，JWT 令牌统一写为 JWT。最后，使用 Base64 URL 算法将上述 JSON 对象转换为字符串保存。一般是下面这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h3><p>有效载荷部分，是 JWT 的主体内容部分，也是一个 JSON 对象，包含需要传递的数据，可以存放自定义数据。JWT 指定七个默认字段供选择</p><ol><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ol><p>注意：此部分内容未加密，不能存放敏感信息。</p><h3 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h3><p>signature 是签证信息，该签证信息是通过 <code>header</code> 和 <code>payload</code>，加上 <code>secret</code>，通过算法加密生成。</p><h1 id="JWTUtil"><a href="#JWTUtil" class="headerlink" title="JWTUtil"></a>JWTUtil</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入 JWT 依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.auth0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>java-jwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.auth0.jwt.JWT;</span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.JWTCreator;</span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.algorithms.Algorithm;</span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.exceptions.JWTDecodeException;</span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.interfaces.DecodedJWT;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JWTUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可从 application.yml 中获取</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">SECRET</span> <span class="operator">=</span> <span class="string">&quot;maxiaorui&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成用户 Token</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map     存放在 token 的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expires 过期时间（单位：秒）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generateUserToken</span><span class="params">(Map&lt;String, String&gt; map, Integer expires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> JWTCreator.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> JWT.create();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// payload</span></span><br><span class="line">        map.forEach(builder::withClaim);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定过期时间</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">expiresAt</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        expiresAt.add(Calendar.SECOND, expires);</span><br><span class="line">        builder.withExpiresAt(expiresAt.getTime());</span><br><span class="line"></span><br><span class="line"><span class="comment">//        builder.withIssuer(&quot;issuer&quot;);                       // 签发人</span></span><br><span class="line"><span class="comment">//        builder.withSubject(&quot;subject&quot;);                     // 主题</span></span><br><span class="line"><span class="comment">//        builder.withAudience(&quot;audience1&quot;, &quot;audience2&quot;);     // 受众</span></span><br><span class="line"><span class="comment">//        builder.withNotBefore(new Date());                  // 生效时间</span></span><br><span class="line"><span class="comment">//        builder.withIssuedAt(new Date());                   // 签发时间</span></span><br><span class="line"><span class="comment">//        builder.withJWTId(&quot;jti&quot;);                           // 编号</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成原始 Token，此处可对 payload 数据做混淆</span></span><br><span class="line">        <span class="keyword">return</span> builder.sign(Algorithm.HMAC256(SECRET));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验用户 Token</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token 用户 Token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> DecodedJWT</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DecodedJWT <span class="title function_">verify</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(token))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JWTDecodeException</span>(<span class="string">&quot;Token 无效&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果在生成 Token 的时候做了混淆此处应该解析混淆</span></span><br><span class="line">        <span class="keyword">return</span> JWT.require(Algorithm.HMAC256(SECRET)).build().verify(token);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 DecodedJWT 中解析 payload：<code>DecodedJWT.getClaims();</code></p><p>解析可能出现的异常：</p><ul><li>JWTDecodeException：header、payload 被修改会出现的异常</li><li>SignatureVerificationException：签名不匹配异常</li><li>TokenExpiredException：令牌过期异常</li><li>AlgorithmMismatchException：算法不匹配异常</li></ul><hr><p>说句题外话，有没有发现 JWT 的前面总是会加 <code>Bearer</code> 这个单词？？？</p><p>那么加了能干嘛呢，不加行不行呢？？</p><p>别问，问就是规范，至于什么规范？<a href="https://www.google.com/">谷歌</a>、<a href="https://www.bing.com/">必应</a>、<a href="https://www.baidu.com/">百度</a></p><blockquote><p><strong>前人栽树：</strong></p><ul><li><a href="https://cnodejs.org/topic/5b0c4a7b8a4f51e140d942fc">一篇文章告诉你JWT的实现原理</a></li><li><a href="https://www.cnblogs.com/johnvwan/p/15557287.html">JWT分布式场景应用解析 </a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">关于 JWT 的介绍包括简介、原理、使用场景等网上有很多文章写的都非常好，本文不会过多赘述，主要记录 JWT 工具类的封装。</summary>
    
    
    
    <category term="代码段记录" scheme="https://www.wrp.cool/categories/%E4%BB%A3%E7%A0%81%E6%AE%B5%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发：volatile</title>
    <link href="https://www.wrp.cool/posts/63338/"/>
    <id>https://www.wrp.cool/posts/63338/</id>
    <published>2022-08-25T07:26:42.000Z</published>
    <updated>2022-10-17T11:18:36.227Z</updated>
    
    <content type="html"><![CDATA[<h1 id="volatile-的特性"><a href="#volatile-的特性" class="headerlink" title="volatile 的特性"></a>volatile 的特性</h1><p>当我们声明共享变量为 volatile 后，对这个变量的读&#x2F;写将会很特别。理解 volatile特性的一个好方法是把对 volatile 变量的单个读&#x2F;写，看成是使用同一个锁对这些单个读&#x2F;写操作做了同步。下面我们通过具体的示例来说明，请看下面的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileFeaturesExample</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">vl</span> <span class="operator">=</span> <span class="number">0L</span>; <span class="comment">//使用 volatile 声明 64 位的 long 型变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">long</span> l)</span> &#123;</span><br><span class="line">        vl = l; <span class="comment">//单个 volatile 变量的写</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getAndIncrement</span> <span class="params">()</span> &#123;</span><br><span class="line">        vl++; <span class="comment">//复合（多个）volatile 变量的读/写</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vl; <span class="comment">//单个 volatile 变量的读</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设有多个线程分别调用上面程序的三个方法，这个程序在语义上和下面程序等价：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileFeaturesExample</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">vl</span> <span class="operator">=</span> <span class="number">0L</span>; <span class="comment">// 64 位的 long 型普通变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">long</span> l)</span> &#123; <span class="comment">//对单个的普通变量的写用同一个锁同步</span></span><br><span class="line">        vl = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getAndIncrement</span> <span class="params">()</span> &#123; <span class="comment">//普通方法调用</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> get(); <span class="comment">//调用已同步的读方法</span></span><br><span class="line">        temp += <span class="number">1L</span>; <span class="comment">//普通写操作</span></span><br><span class="line">        set(temp); <span class="comment">//调用已同步的写方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">get</span><span class="params">()</span> &#123; <span class="comment">//对单个的普通变量的读用同一个锁同步</span></span><br><span class="line">        <span class="keyword">return</span> vl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面示例程序所示，对一个 volatile 变量的单个读&#x2F;写操作，与对一个普通变量的读&#x2F;写操作使用同一个锁来同步，它们之间的执行效果相同。</p><p>锁的 happens-before 规则保证释放锁和获取锁的两个线程之间的内存可见性，这意味着对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入。</p><p>锁的语义决定了临界区代码的执行具有原子性。这意味着即使是 64 位的 long 型和 double 型变量，只要它是 volatile 变量，对该变量的读写就将具有原子性。如果是多个 volatile 操作或类似于 volatile++ 这种复合操作，这些操作整体上不具有原子性。</p><p>简而言之，volatile 变量自身具有下列特性：</p><ul><li>可见性。对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入。</li><li>原子性：对任意单个 volatile 变量的读&#x2F;写具有原子性，但类似于 volatile++ 这种复合操作不具有原子性。</li></ul><h1 id="volatile-写-读建立的-happens-before-关系"><a href="#volatile-写-读建立的-happens-before-关系" class="headerlink" title="volatile 写-读建立的 happens before 关系"></a>volatile 写-读建立的 happens before 关系</h1><p>上面讲的是 volatile 变量自身的特性，对程序员来说，volatile 对线程的内存可见性的影响比 volatile 自身的特性更为重要，也更需要我们去关注。</p><p>从内存语义的角度来说，volatile 的写-读与锁的释放-获取有相同的内存效果：volatile 写和锁的释放有相同的内存语义；volatile 读与锁的获取有相同的内存语义。</p><p>请看下面使用 volatile 变量的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileExample</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">        a = <span class="number">1</span>;          <span class="comment">//1</span></span><br><span class="line">        flag = <span class="literal">true</span>;    <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;     <span class="comment">//3</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a;  <span class="comment">//4</span></span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设线程 A 执行 writer()方法之后，线程 B 执行 reader()方法。根据 happens before 规则，这个过程建立的 happens before 关系可以分为两类：</p><ol><li>根据程序次序规则，1 happens before 2; 3 happens before 4。</li><li>根据 volatile 规则，2 happens before 3。</li><li>根据 happens before 的传递性规则，1 happens before 4。</li></ol><p>上述 happens before 关系的图形化表现形式如下：</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/volatile-1.png" alt="volatile-1"></p><p>在上图中，每一个箭头链接的两个节点，代表了一个 happens before 关系。黑色箭头表示程序顺序规则；橙色箭头表示 volatile 规则；蓝色箭头表示组合这些规则后提供的 happens before 保证。</p><p>这里 A 线程写一个 volatile 变量后，B 线程读同一个 volatile 变量。A 线程在写volatile 变量之前所有可见的共享变量，在 B 线程读同一个 volatile 变量后，将立即变得对 B 线程可见。</p><h1 id="volatile-写的内存语义"><a href="#volatile-写的内存语义" class="headerlink" title="volatile 写的内存语义"></a>volatile 写的内存语义</h1><blockquote><p>当写一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量值刷新到主内存。</p></blockquote><p>以上面示例程序 VolatileExample 为例，假设线程 A 首先执行 writer()方法，随后线程 B 执行 reader()方法，初始时两个线程的本地内存中的 flag 和 a 都是初始状态。下图是线程 A 执行 volatile 写后，共享变量的状态示意图：</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/volatile-2.png" alt="volatile-2"></p><p>如上图所示，线程 A 在写 flag 变量后，本地内存 A 中被线程 A 更新过的两个共享变量的值被刷新到主内存中。此时，本地内存 A 和主内存中的共享变量的值是一致的。</p><h1 id="volatile-读的内存语义"><a href="#volatile-读的内存语义" class="headerlink" title="volatile 读的内存语义"></a>volatile 读的内存语义</h1><blockquote><p>当读一个 volatile 变量时，JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</p></blockquote><p>当读一个 volatile 变量时，JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</p><p>下面是线程 B 读同一个 volatile 变量后，共享变量的状态示意图：</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/volatile-3.png" alt="volatile-3"></p><p>如上图所示，在读 flag 变量后，本地内存 B 包含的值已经被置为无效。此时，线程 B 必须从主内存中读取共享变量。线程 B 的读取操作将导致本地内存 B 与主内存中的共享变量的值也变成一致的了。</p><p>如果我们把 volatile 写和 volatile 读这两个步骤综合起来看的话，在读线程 B 读一个 volatile 变量后，写线程 A 在写这个 volatile 变量之前所有可见的共享变量的值都将立即变得对读线程 B 可见。</p><div class="note default flat"><p><strong>volatile 读写内存语义总结：</strong></p></div><ul><li>线程 A 写一个 volatile 变量，实质上是线程 A 向接下来将要读这个 volatile 变量的某个线程发出了（其对共享变量所在修改的）消息。</li><li>线程 B 读一个 volatile 变量，实质上是线程 B 接收了之前某个线程发出的（在写这个 volatile 变量之前对共享变量所做修改的）消息。</li><li>线程 A 写一个 volatile 变量，随后线程 B 读这个 volatile 变量，这个过程实质上是线程 A 通过主内存向线程 B 发送消息。</li></ul><hr><blockquote><p><strong>巨人的肩膀：</strong></p><ul><li><a href="https://www.infoq.cn/minibook/java_memory_model">深入理解Java内存模型</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">volatile 读：直接从主内存读；volatile 写：立即刷新到主内存。</summary>
    
    
    
    <category term="Java" scheme="https://www.wrp.cool/categories/Java/"/>
    
    <category term="并发" scheme="https://www.wrp.cool/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
  </entry>
  
</feed>
