<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>知更</title>
  
  <subtitle>“知道要更新，知道要进步”</subtitle>
  <link href="https://www.wrp.cool/atom.xml" rel="self"/>
  
  <link href="https://www.wrp.cool/"/>
  <updated>2021-09-28T06:12:37.476Z</updated>
  <id>https://www.wrp.cool/</id>
  
  <author>
    <name>王瑞鹏</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RabbitMQ 远征篇</title>
    <link href="https://www.wrp.cool/posts/28560/"/>
    <id>https://www.wrp.cool/posts/28560/</id>
    <published>2021-09-28T05:29:17.000Z</published>
    <updated>2021-09-28T06:12:37.476Z</updated>
    
    <content type="html"><![CDATA[<p><font size=5><strong>初始 RabbitMQ</strong></font></p><p>RabbitMQ 是一个开源的消息代理和队列服务器，用来通过普通协议在完全不同的应用之间共享数据，RabbitMQ 是使用 Erlang 语言来编写的，并且 RabbitMQ 是基于 AMQP 协议的。</p><a id="more"></a><p><font size=5><strong>Q&amp;A Time</strong></font></p><p>RabbitMQ 高性能的原因？</p><ol><li>Erlang语言最初在于交换机领域的架构模式，这样使得 RabbitMQ 在 Broker 之间进行数据交互的性能是非常优秀的</li><li>Erlang语言的优点：有着和原生 Socket 一样的延迟</li></ol><p>什么是 AMQP？<br>AMQP全称：Advanced Messgae Queuing Protocol（高级消息队列协议）<br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20210928135718.png" alt="20210928135718"></p><p>AMQP 核心概念：</p><ol><li><strong>Server：</strong>又称 Broker，接受客户端的连接，实现 AMQP 实体服务</li><li><strong>Connection：</strong>连接，应用程序与 Broker 的网络连接</li><li><strong>Channel：</strong>网络信道，几乎所有的操作都在 Channel 中进行，Channel 是进行消息读写的通道。客户端可建立多个 Channel，每个 Channel 代表一个会话任务。</li><li><strong>Message：</strong>消息，服务器和应用程序之间传送的数据，由 Properties 和 Body 组成。Properties 可以对消息进行修饰，比如消息的优先级、延迟等高级特性；Body 则就是消息体内容。</li><li><strong>Virtual Host：</strong>虚拟地址，用于进行逻辑隔离，最上层的消息路由。一个 Virtual Host里面可以有若干个 Exchange 和 Queue，同一个 Virtual Host 里面不能用相同名称的 Exchange 或 Queue。</li><li><strong>Exchange：</strong>交换机，接收消息，根据路由键转发消息到绑定的队列。</li><li><strong>Binding：</strong>Exchange 和 Queue 之间的虚拟连接，binding 中可以包含 Routing Key。</li><li><strong>Routing Key：</strong>一个路由规则，虚拟机可用它来确定如何路由一个特定消息。</li><li><strong>Queue：</strong>也成为 Message Queue，消息队列，保存消息并将他们转发给消费者。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;font size=5&gt;&lt;strong&gt;初始 RabbitMQ&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;RabbitMQ 是一个开源的消息代理和队列服务器，用来通过普通协议在完全不同的应用之间共享数据，RabbitMQ 是使用 Erlang 语言来编写的，并且 RabbitMQ 是基于 AMQP 协议的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="中间件" scheme="https://www.wrp.cool/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="RabbitMQ" scheme="https://www.wrp.cool/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 启航篇</title>
    <link href="https://www.wrp.cool/posts/38923/"/>
    <id>https://www.wrp.cool/posts/38923/</id>
    <published>2021-09-20T05:41:52.000Z</published>
    <updated>2021-09-28T05:49:20.703Z</updated>
    
    <content type="html"><![CDATA[<p>RabbitMQ 启航篇，本文将记录一下 RabbitMQ 在 CentOS 7 中安装的详细过程，以及简单的使用。以本文正式开始 RabbitMQ 的学习。</p><a id="more"></a><blockquote><p>RabbitMQ 的运行是基于 Erlang 的。所以在安装 RabbitMQ 之前需要先安装好 Erlang 的环境。RabbitMQ 对于运行环境 Erlang 也是有要求的，在安装 Erlang 之前应该先确定好要安装的 RabbitMQ 版本和 Erlang 版本是否兼容。</p><p>在 RabbitMQ 官网中可以查看各个版本的 RabbitMQ 对于 Erlang 环境的版本要求。<a href="https://www.rabbitmq.com/which-erlang.html" target="_blank" rel="noopener">RabbitMQ 安装对应 Erlang 版本查询</a></p></blockquote><h1 id="Erlang-环境安装"><a href="#Erlang-环境安装" class="headerlink" title="Erlang 环境安装"></a>Erlang 环境安装</h1><p>在正式安装开始之前需要先安装好 Erlang 所需要的一些依赖，这里通过 yum 源进行安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install unixODBC unixODBC-devel wxBase wxGTK SDL wxGTK-gl epel-release</span><br></pre></td></tr></table></figure><ol><li><p><strong>下载：</strong><a href="https://www.erlang-solutions.com/downloads/" target="_blank" rel="noopener">https://www.erlang-solutions.com/downloads/</a><br> 根据需要的版本以及操作系统选择对应的版本下载即可。在这里下载的是23.2版本的Erlang</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;packages.erlang-solutions.com&#x2F;erlang&#x2F;rpm&#x2F;centos&#x2F;7&#x2F;x86_64&#x2F;esl-erlang_23.2-1~centos~7_amd64.rpm</span><br></pre></td></tr></table></figure></li><li><p><strong>按照官网的要求先添加一个密钥</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm --import https:&#x2F;&#x2F;packages.erlang-solutions.com&#x2F;rpm&#x2F;erlang_solutions.asc</span><br></pre></td></tr></table></figure></li><li><p><strong>解压刚下载好的安装包</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -Uvh esl-erlang_23.2-1~centos~7_amd64.rpm</span><br></pre></td></tr></table></figure></li><li><p><strong>通过 yum 源安装 Erlang</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install erlang</span><br></pre></td></tr></table></figure></li><li><p><strong>验证安装是否成功</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">erl -version</span><br></pre></td></tr></table></figure><p> 如果可以看到 Erlang 的版本信息则说明安装成功。</p></li></ol><h1 id="RabbitMQ-安装"><a href="#RabbitMQ-安装" class="headerlink" title="RabbitMQ 安装"></a>RabbitMQ 安装</h1><p>前文 RabbitMQ 所需要的环境 Erlang 已经安装成功，现在可以安装 RabbitMQ 了。</p><ol><li><p><strong>下载：</strong><a href="https://www.rabbitmq.com/download.html" target="_blank" rel="noopener">https://www.rabbitmq.com/download.html</a> ，打开下载页面找到以下部分，根据系统选择下载即可。<br> 需要选择版本去 GitHub 中寻找合适的版本。<br> <img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20210920144340.png" alt="20210920144340"></p></li><li><p><strong>解压下载的安装包</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -Uvh rabbitmq-server-3.9.5-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure></li></ol><p>至此，RabbitMQ 就安装成功了，运行 <code>systemctl start rabbitmq-server</code> 即可启动 RabbitMQ。</p><hr><p><font size=5><strong>常用命令</strong></font></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加用户</span></span><br><span class="line">rabbitmqctl add_user 用户 密码</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置用户角色（根绝角色分配权限）</span></span><br><span class="line">rabbitmqctl set_user_tags 用户 角色</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改用户密码</span></span><br><span class="line">rabbitmqctl change_password 用户 新密码</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除用户</span></span><br><span class="line">rabbitmqctl delete_user 用户</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为用户设置权限</span></span><br><span class="line">rabbitmqctl set_permissions -p / 用户 ".*" ".*" ".*"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 打开 RabbitMQ WEB 界面管理，访问地址：http://虚拟机IP:15672，需要创建一个用户进行访问</span></span><br><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure><blockquote><p>参考文章：<br><a href="https://juejin.cn/post/6844903926408413197#heading-0" target="_blank" rel="noopener">RabbitMQ的六种工作模式</a><br><a href="https://segmentfault.com/a/1190000023107822" target="_blank" rel="noopener">连RabbitMQ的5种核心消息模式都不懂，也敢说自己会用消息队列！</a></p></blockquote><hr><p><strong>一个代码仓库介绍一下 RabbitMQ 中五种常用模式，也在此正式启航 RabbitMQ</strong></p><ul><li><a href="https://github.com/wangruipeng-wrp/rabbitmq" target="_blank" rel="noopener">GitHub</a></li><li><a href="https://gitee.com/wangruipeng-wrp/rabbtmq" target="_blank" rel="noopener">Gitee</a></li></ul><p>大家加油：）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;RabbitMQ 启航篇，本文将记录一下 RabbitMQ 在 CentOS 7 中安装的详细过程，以及简单的使用。以本文正式开始 RabbitMQ 的学习。&lt;/p&gt;</summary>
    
    
    
    
    <category term="中间件" scheme="https://www.wrp.cool/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="RabbitMQ" scheme="https://www.wrp.cool/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Redis 高可用集群搭建</title>
    <link href="https://www.wrp.cool/posts/61883/"/>
    <id>https://www.wrp.cool/posts/61883/</id>
    <published>2021-09-12T16:22:34.000Z</published>
    <updated>2021-09-19T03:08:19.055Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>先占个坑，回头来把这篇博客补全。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;先占个坑，回头来把这篇博客补全。&lt;/p&gt;
&lt;/blockquote&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis 持久化机制（RDB 和 AOF）</title>
    <link href="https://www.wrp.cool/posts/59553/"/>
    <id>https://www.wrp.cool/posts/59553/</id>
    <published>2021-09-12T16:21:49.000Z</published>
    <updated>2021-09-19T03:08:15.591Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>先占个坑，回头来把这篇博客补全。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;先占个坑，回头来把这篇博客补全。&lt;/p&gt;
&lt;/blockquote&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Spring Boot 集成 Redis</title>
    <link href="https://www.wrp.cool/posts/44305/"/>
    <id>https://www.wrp.cool/posts/44305/</id>
    <published>2021-09-12T16:21:09.000Z</published>
    <updated>2021-09-16T02:54:22.481Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>使用 Spring Boot 操作 Redis 其实非常简单，本文主要记录一下整合的步骤，方便后续查看。</p></blockquote><a id="more"></a><ol><li><p>添加 Redis 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在 yml 文件中配置 Redis 服务器信息</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">database:</span> <span class="string">"指定所使用的是 Redis 中的哪个数据库"</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">"Redis 服务器 IP 地址"</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">"Redis 端口号"</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">"指定登录客户端的密码，如果没有可以不指定"</span></span><br></pre></td></tr></table></figure></li><li><p>在 Spring Boot 中使用 StringRedisTemplate 操作 Redis 缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Redis 工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span>(onConstructor = @__(<span class="meta">@Autowired</span>))</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisOperator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以 key 为键获取 Redis 中的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置 Redis 键值对</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        set(key, value, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置 Redid 键值对</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 过期时间，单位：秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String key, String value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForValue().set(key, value, time);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除 Redis 中的键值对</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(String... keys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String key : keys)</span><br><span class="line">            redisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>以上是我在日常开发中真实使用到的一些对 Redis 的操作，在此封装成一个简单的工具类，以后随着使用的越多会封装更多简便的方法。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;使用 Spring Boot 操作 Redis 其实非常简单，本文主要记录一下整合的步骤，方便后续查看。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Spring Boot" scheme="https://www.wrp.cool/categories/Spring-Boot/"/>
    
    
    <category term="Spring Boot" scheme="https://www.wrp.cool/tags/Spring-Boot/"/>
    
    <category term="Redis" scheme="https://www.wrp.cool/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Keepalived 实现 Nginx 的主备和互备</title>
    <link href="https://www.wrp.cool/posts/42807/"/>
    <id>https://www.wrp.cool/posts/42807/</id>
    <published>2021-08-22T07:05:46.000Z</published>
    <updated>2021-09-01T15:58:24.277Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文侧重点是讲解 Keepalived 的原理以及使用方式。</p></blockquote><p><strong>简单讲解一下 Keepalived 的工作原理：</strong></p><ol><li>通过 VRRP 协议将虚拟IP绑定至本机的一张网卡上</li><li>将 Nginx 服务器的IP隐藏起来不对用户暴露，用户直接访问虚拟IP</li><li>通过虚拟IP对同一个集群内的不同节点网卡的绑定来实现控制用户访问不同的节点</li></ol><a id="more"></a><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ol><li>CentOS 7 虚拟机1，IP地址：<code>192.168.160.136</code>，为了方便区分取主机名为 <code>keep_136</code></li><li>CentOS 7 虚拟机2，IP地址：<code>192.168.160.137</code>，为了方便区分取主机名为 <code>keep_137</code></li><li>分别安装：<code>nginx-1.20.1</code>、<code>keepalived-2.2.4</code></li><li>绑定虚拟IP为 <code>192.168.160.161</code></li></ol><h3 id="实验准备工作"><a href="#实验准备工作" class="headerlink" title="实验准备工作"></a>实验准备工作</h3><ol><li><strong>安装 Nginx</strong><ul><li>详细步骤记录于：<a href="https://www.wrp.cool/posts/62048/">Nginx 安装</a></li></ul></li></ol><ol start="2"><li><strong>安装 Keepalived</strong><ul><li><strong>下载：</strong><a href="https://www.keepalived.org/download.html" target="_blank" rel="noopener">https://www.keepalived.org/download.html</a></li><li><strong>依赖：</strong><code>yum -y install libnl libnl-level</code></li><li><strong>配置：</strong><code>./configure --prefix=/usr/local/keepalived --sysconf=/etc</code></li><li><strong>安装：</strong><code>make &amp;&amp; make install</code></li><li><strong>配置文件：</strong><code>/etc/keepalived/keelalived.conf</code></li></ul></li></ol><ol start="3"><li><strong>注册 Keepalived 为系统服务</strong><ul><li>进入 Keepalived 的安装目录下的<code>/keepalived/etc/</code>，以本实验为例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~&#x2F;software&#x2F;keepalived-2.2.4&#x2F;keepalived&#x2F;etc</span><br></pre></td></tr></table></figure></li><li>复制安装目录下的<code>init.d</code>目录下的<code>keepalived</code>文件拷贝到<code>/etc/init.d</code>目录中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -a init.d&#x2F;keepalived &#x2F;etc&#x2F;init.d&#x2F;</span><br></pre></td></tr></table></figure></li><li>复制<code>sysconfig</code>目录中的<code>keepalive</code>文件至<code>/etc/sysconfig</code>目录中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -a sysconfig&#x2F;keepalived &#x2F;etc&#x2F;sysconfig&#x2F;</span><br></pre></td></tr></table></figure></li><li>重新加载<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure></li><li>启动、关闭、重启<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start keepalived</span><br><span class="line">systemctl stop keepalived</span><br><span class="line">systemctl restart keepalived</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="主备实验步骤"><a href="#主备实验步骤" class="headerlink" title="主备实验步骤"></a>主备实验步骤</h3><ol><li><p>配置 Keepalived 主机（keep_136）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line"># 全局配置</span><br><span class="line">global_defs &#123;</span><br><span class="line">    router_id keep_136          # 路由ID：当前安装 keepalived 节点主机的标识符，全局唯一</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 计算机节点</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER                # 标识当前节点为主节点或者是备节点。MASTER&#x2F;BACKUP</span><br><span class="line">    interface ens33             # 指定虚拟IP所绑定的本机网卡</span><br><span class="line">    virtual_router_id 51        # 虚拟路由ID，保持主备节点一致即可</span><br><span class="line">    priority 100                # 标识计算节点权重，当主节点宕机后权重高的节点优先成为主节点</span><br><span class="line">    advert_int 1                # 心跳检测间隔时间，单位：秒</span><br><span class="line"></span><br><span class="line">    # 认证授权的密码，防止非法节点接入</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 虚拟IP</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.160.161</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置 Keepalived 备用机（keep_137）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">    router_id keep_137</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 80</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.160.161</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="互备实验步骤"><a href="#互备实验步骤" class="headerlink" title="互备实验步骤"></a>互备实验步骤</h3><blockquote><p>做完了主备之后，互备其实很简单，就是在备用机中添加一份主机的配置，在主机中添加一份备用机的配置。</p></blockquote><ol><li><p>配置 Keepalived 主机（keep_136）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 添加一个备用机节点的配置</span><br><span class="line">vrrp_instance VI_2 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 52</span><br><span class="line">    priority 80</span><br><span class="line">    advert_int 1</span><br><span class="line"></span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.160.162</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置 Keepalived 备用机（keep_137）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 添加一个主机节点的配置</span><br><span class="line">vrrp_instance VI_2 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 52</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line"></span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.160.162</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="验证配置"><a href="#验证配置" class="headerlink" title="验证配置"></a>验证配置</h3><ol><li>分别启动两台虚拟机中的 Keepalived 服务</li><li>观察此时的虚拟IP绑定在哪台虚拟机中，可使用 <code>ip addr</code> 命令查看</li><li>打开浏览器访问虚拟IP，此时由主机提供服务</li><li>停止提供服务的 Keepalived</li><li>浏览器中再次访问该虚拟IP，此时可见由备用机开始提供服务</li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文侧重点是讲解 Keepalived 的原理以及使用方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;简单讲解一下 Keepalived 的工作原理：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过 VRRP 协议将虚拟IP绑定至本机的一张网卡上&lt;/li&gt;
&lt;li&gt;将 Nginx 服务器的IP隐藏起来不对用户暴露，用户直接访问虚拟IP&lt;/li&gt;
&lt;li&gt;通过虚拟IP对同一个集群内的不同节点网卡的绑定来实现控制用户访问不同的节点&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="负载均衡" scheme="https://www.wrp.cool/categories/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
    
    <category term="Keepalived" scheme="https://www.wrp.cool/tags/Keepalived/"/>
    
    <category term="主备" scheme="https://www.wrp.cool/tags/%E4%B8%BB%E5%A4%87/"/>
    
    <category term="互备" scheme="https://www.wrp.cool/tags/%E4%BA%92%E5%A4%87/"/>
    
  </entry>
  
  <entry>
    <title>Git 钩子自动化部署 Spring Boot 项目</title>
    <link href="https://www.wrp.cool/posts/19410/"/>
    <id>https://www.wrp.cool/posts/19410/</id>
    <published>2021-08-17T09:20:20.000Z</published>
    <updated>2021-09-05T07:37:46.614Z</updated>
    
    <content type="html"><![CDATA[<p>开发过程中，接口开发完毕给测试人员做测试的时候会很经常的需要将一些测试提交的修改更新到测试服务器上去，但是如果每次提交都手动的去测试服务器打包代码，重启服务的话，那太麻烦了。</p><p>之前在 Linux 服务器上部署这个博客的时候有了解到 git 里面有一个钩子的东西可以做这种自动化的部署，于是最近研究了一下针对上面的问题可以使用 git 的钩子来做一个项目的自动部署，这样就不用每次都去手动的部署了，要更新的时候只需要把代码提交到 git 上就可以完成自动化部署。</p><p>接下来详细说一下部署的过程，也算是做一个记录，方便以后查看。</p><a id="more"></a><hr><p><font size=4><strong>在测试环境上搭建git仓库</strong></font></p><ol><li><p><strong>安装git</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install git</span><br></pre></td></tr></table></figure></li><li><p><strong>创建一个 git 用户并且设置密码</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd git</span><br><span class="line">passwd git</span><br></pre></td></tr></table></figure></li><li><p><strong>选定一个目录作为git仓库，并初始化这个git仓库</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一个 project.git 的目录，并初始化为 git 仓库</span></span><br><span class="line">git init --bare projuce.git</span><br></pre></td></tr></table></figure></li><li><p><strong>将本地的 ssh 公钥部署到服务器上</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1) 创建 ssh 公钥</span></span><br><span class="line">ssh-keygen -t rsa -C "你的邮箱"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2) 创建 authorized_keys 文件</span></span><br><span class="line">touch /home/git/.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3) 将本地创建的公钥复制到 authorized_keys 中，一行一个</span></span><br></pre></td></tr></table></figure></li><li><p><strong>本地项目添加测试服务器的 git 远程仓库地址</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@'测试服务器IP':'仓库路径'</span><br></pre></td></tr></table></figure><p>接下来就是在本地正常的提交代码到测试服务器的 git 仓库了，就像是平时开发一样提交即可。</p></li></ol><hr><p><font size=4><strong>将代码部署到测试服务器</strong></font></p><ol><li><p><strong>检出代码</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --work-tree='要发布的目录' --git-dir='远程仓库地址' checkout -f</span><br></pre></td></tr></table></figure></li><li><p><strong>打包</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn package</span><br></pre></td></tr></table></figure></li><li><p><strong>启动</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar xxx.jar</span><br></pre></td></tr></table></figure></li></ol><p><font size=4><strong>自动化部署到测试服务器</strong></font></p><p>自动化部署的流程跟以上是一样的，只是利用了 git 的钩子来自动的执行一个部署的脚本，以此免去了人工手动部署的工作。</p><ol><li><p><strong>在测试服务器上的 git 远程仓库中有一个 <code>hooks</code> 文件夹，在这个文件夹中创建 <code>post-receive</code> 文件</strong></p><blockquote><p>这个文件就是钩子，当我们的代码提交到这个远程仓库中就会触发这个文件的执行，于是我们就可以把代码部署的脚本写在这个文件中，利用这个来实现自动部署。</p></blockquote></li><li><p><strong>赋予 <code>post-receive</code> 可执行权限</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x post-receive</span><br></pre></td></tr></table></figure></li><li><p><strong>自动部署代码脚本</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">echo "删除项目目录"</span><br><span class="line">rm -rf "项目目录"</span><br><span class="line"></span><br><span class="line">echo "创建项目目录"</span><br><span class="line">mkdir "项目目录"</span><br><span class="line"></span><br><span class="line">echo "拉取代码"</span><br><span class="line">git --work-tree='项目根目录' --git-dir='远程仓库地址' checkout -f</span><br><span class="line"></span><br><span class="line">echo "进入项目根目录"</span><br><span class="line">cd ~/foodie-prod/foodie/</span><br><span class="line"></span><br><span class="line">echo "maven 打包"</span><br><span class="line">/usr/local/apache-maven-3.8.1/bin/mvn package # 此处 maven 打包需要使用全路径</span><br><span class="line"></span><br><span class="line">echo "停止正在运行的 Spring Boot"</span><br><span class="line">appid=`ps -ef |grep java|grep foodie|awk '&#123;print $2&#125;'`</span><br><span class="line">kill $appid</span><br><span class="line"></span><br><span class="line">echo "进入 jar 包所在路径"</span><br><span class="line">cd "jar 包所在路径"</span><br><span class="line"></span><br><span class="line">echo "后台启动 Spring Boot"</span><br><span class="line">nohup java -jar -Dspring.profiles.active="配置文件" foodie-api-0.0.1-SNAPSHOT.jar &gt; ~/temp.log 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line">echo "休眠 10s 等待 Spring Boot 启动"</span><br><span class="line">sleep 10</span><br><span class="line"></span><br><span class="line">echo "自动化发布脚本执行结束！"</span><br></pre></td></tr></table></figure><blockquote><p>注意：<br>以上脚本在编写时应该对每一步都进行校验以保证最终成功运行。<br>钩子的运行日志可以提交代码时查看。</p></blockquote></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;开发过程中，接口开发完毕给测试人员做测试的时候会很经常的需要将一些测试提交的修改更新到测试服务器上去，但是如果每次提交都手动的去测试服务器打包代码，重启服务的话，那太麻烦了。&lt;/p&gt;
&lt;p&gt;之前在 Linux 服务器上部署这个博客的时候有了解到 git 里面有一个钩子的东西可以做这种自动化的部署，于是最近研究了一下针对上面的问题可以使用 git 的钩子来做一个项目的自动部署，这样就不用每次都去手动的部署了，要更新的时候只需要把代码提交到 git 上就可以完成自动化部署。&lt;/p&gt;
&lt;p&gt;接下来详细说一下部署的过程，也算是做一个记录，方便以后查看。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="https://www.wrp.cool/categories/Spring/"/>
    
    <category term="Spring Boot" scheme="https://www.wrp.cool/categories/Spring/Spring-Boot/"/>
    
    
    <category term="git" scheme="https://www.wrp.cool/tags/git/"/>
    
    <category term="Spring Boot" scheme="https://www.wrp.cool/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 安装</title>
    <link href="https://www.wrp.cool/posts/7587/"/>
    <id>https://www.wrp.cool/posts/7587/</id>
    <published>2021-08-17T09:19:35.000Z</published>
    <updated>2021-09-05T07:04:15.883Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下 Linux 中安装 MySQL 的步骤。</p><a id="more"></a><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>MySQL 下载地址：<a href="https://www.mysql.com/downloads/" target="_blank" rel="noopener">https://www.mysql.com/downloads/</a></p><ol><li><p><strong>进入下载地址点击这个链接</strong><br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20210818114657.png" alt="20210818114657"></p></li><li><p><strong>选择 MySQL Yum Repository</strong><br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20210818115056.png" alt="20210818115056"></p></li><li><p><strong>进入这个页面之后选择合适的的版本点击 <code>Download</code></strong><br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20210818120024.png" alt="20210818120024"></p></li><li><p><strong>右键这个链接选择“复制链接地址”到 Linux 系统中使用 <code>wget</code> 下载即可</strong><br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20210818120520.png" alt="20210818120520"></p></li></ol><hr><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ol><li><p><strong>检查是否安装了 MySQL 或者 Mariadb，如果安装了需要先卸载</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 检查是否安装了 MySQL</span></span><br><span class="line">rpm -qa |grep mysql</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 卸载 MySQL</span></span><br><span class="line">rpm -e --nodeps "上面查询出来的全部内容"</span><br></pre></td></tr></table></figure></li><li><p><strong>开始安装</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将下载的 MySQL 文件加载进本地 yum 源中</span></span><br><span class="line">yum -y localinstall mysql80-community-release-el7-3.noarch.rpm</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过 yum 源进行安装</span></span><br><span class="line">yum -y install mysql-community-server</span><br></pre></td></tr></table></figure></li><li><p><strong>启动 MySQL</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动</span></span><br><span class="line">service mysqld start</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 MySQL 服务是否启动成功</span></span><br><span class="line">ps -ef |grep mysql</span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h4><ol><li><p><strong>查询 MySQL 临时密码</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep 'temporary password' /var/log/mysqld.log</span><br></pre></td></tr></table></figure></li><li><p><strong>登录 MySQL</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p'临时密码'</span><br></pre></td></tr></table></figure></li><li><p><strong>修改 root 用户密码</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 调整密码复杂度和长度</span></span><br><span class="line">set global validate_password.policy=0;</span><br><span class="line">set global validate_password.length=4;</span><br><span class="line"></span><br><span class="line">ALTER USER 'root'@'localhost' IDENTIFIED BY "新密码";</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一下 Linux 中安装 MySQL 的步骤。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://www.wrp.cool/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Linux" scheme="https://www.wrp.cool/tags/Linux/"/>
    
    <category term="MySQL" scheme="https://www.wrp.cool/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 配置</title>
    <link href="https://www.wrp.cool/posts/48812/"/>
    <id>https://www.wrp.cool/posts/48812/</id>
    <published>2021-08-17T09:19:13.000Z</published>
    <updated>2021-08-28T13:12:23.207Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文记录一些 nginx 中的配置，以便后续查看。</p></blockquote><a id="more"></a><p>Nginx 的配置文件都放在 conf 目录下，其中最重要的就是 <code>nginx.conf</code> 配置文件，本文也主要记录该配置文件中的配置</p><p>为了使配置文件能够更方便管理，把一些站点配置写到外面来，不要直接写入 <code>nginx.conf</code> 文件</p><p>在 conf 文件夹下创建一个 hosts 文件夹，之后将每个虚拟主机的配置都以 <code>域名.conf</code> 的命名格式保存在 hosts 文件夹中</p><p>之后在 nginx.conf 文件的 http 的大括号内引入自己写的配置文件 <code>include hosts/*.conf;</code></p><h4 id="运行配置"><a href="#运行配置" class="headerlink" title="运行配置"></a>运行配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 指定运行 worker 进程的用户</span></span><br><span class="line">user root;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> worker 进程的数量</span></span><br><span class="line">worker_processes  3;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志文件输出配置 可根据日志级别输出到不同的日志文件中</span></span><br><span class="line"><span class="meta">#</span><span class="bash">error_log  logs/error.log;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定 pid</span></span><br><span class="line"><span class="meta">#</span><span class="bash">pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 工作模式</span></span><br><span class="line">events &#123;</span><br><span class="line">    # 默认使用 epoll，采用异步非阻塞的处理方式</span><br><span class="line">    use epoll;</span><br><span class="line">    # 每个 worker 进程的客户端最大连接数</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="传输配置"><a href="#传输配置" class="headerlink" title="传输配置"></a>传输配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    # 导入请求类型</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    # 日志格式，main 为格式的名称，可以通过 main 来指定输出此日志格式。</span><br><span class="line">    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span><br><span class="line">                        '$status $body_bytes_sent "$http_referer" '</span><br><span class="line">                        '"$http_user_agent" "$http_x_forwarded_for"';</span><br><span class="line"></span><br><span class="line">    # 定义日志输出格式</span><br><span class="line">    access_log  logs/access.log  main;</span><br><span class="line"></span><br><span class="line">    # sendfile 高效传输文件，开启可提升传输性能，开启后才可以使用 tcp_nopush，当数据累积到一定大小后才发送，提高了效率</span><br><span class="line">    sendfile        on;</span><br><span class="line">    tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    # 设置客户端与服务端请求的超时时间，保证客户端多次请求的时候不会重复建立新的连接，节约资源资源损耗</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    # 启用 gzip 压缩，静态资源文件压缩后传输会更快一些</span><br><span class="line">    gzip  on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>日志格式：</strong></p><table><thead><tr><th>名称</th><th>解释</th></tr></thead><tbody><tr><td>$remote_addr</td><td>客户端IP</td></tr><tr><td>$remote_user</td><td>远程客户端用户名，一般为：’-‘</td></tr><tr><td>$time_local</td><td>时间和时区</td></tr><tr><td>$request</td><td>请求的 url 和 method</td></tr><tr><td>$status</td><td>响应状态码</td></tr><tr><td>$body_bytes_send</td><td>响应客户端内容字节数</td></tr><tr><td>$http_referer</td><td>记录用户从哪个链接跳转过来的</td></tr><tr><td>$http_user_agent</td><td>用户所使用的代理，一般情况下为浏览器</td></tr><tr><td>$http_x_forwarded_for</td><td>通过代理服务器来记录客户端的IP</td></tr></tbody></table><h4 id="虚拟主机配置"><a href="#虚拟主机配置" class="headerlink" title="虚拟主机配置"></a>虚拟主机配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">    # 虚拟主机配置块</span><br><span class="line">    server &#123;</span><br><span class="line">        listen      80;         # 监听端口</span><br><span class="line">        server_name localhost;  # 请求域名</span><br><span class="line"></span><br><span class="line">        # 设置请求头，一般用于解决跨域问题</span><br><span class="line">        add_header 'Access-Control_Allow_Origin' *;             # 允许跨域请求的域</span><br><span class="line">        add_header 'Access-Control_Allow_Credentials' 'true';   # 允许带上 cookie 请求</span><br><span class="line">        add_header 'Access-Control_Allow_Methods' *;            # 允许请求的方法（GET/POST/PUT/DELETE）</span><br><span class="line">        add_header 'Access-Control_Allow_Headers' *;            # 允许请求的 header</span><br><span class="line"></span><br><span class="line">        # 对源站点进行验证（防盗链）</span><br><span class="line">        valid_referers *.wrp.cool;</span><br><span class="line">        if ($valid_referers) &#123;</span><br><span class="line">            return 403;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # 请求路由映射，匹配拦截</span><br><span class="line">        location / &#123;</span><br><span class="line">            root        html;           # 网站根路径（配置负载均衡之后不需要配置根路径）</span><br><span class="line">            index       index.html;     # 默认首页</span><br><span class="line">            expires     10s;            # 设置缓存</span><br><span class="line">            # alias 可以为请求路径配置一个别名</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # ssl 证书配置</span><br><span class="line">        ssl on                              # 开启ssl</span><br><span class="line">        ssl_certificate "ssl证书路径";       # 配置 ssl 证书</span><br><span class="line">        ssl_certificate_key "ssl证书路径";   # 配置 ssl 证书密钥</span><br><span class="line">        ssl_session_cache shared:SSL:10m;   # ssl 会话 cache</span><br><span class="line">        ssl_session_timeout 10m;            # ssl 会话超时时间</span><br><span class="line">        # 配置加密套件</span><br><span class="line">        ssl_protocols TLSv1.1 TLSv1.2;</span><br><span class="line">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>location 的匹配规则：</strong></p><ul><li><code>空格</code>：普通匹配</li><li><code>=</code>：精确匹配</li><li><code>~*</code>：匹配正则表达式，不区分大小写</li><li><code>~</code>：匹配正则表达式，区分大小写</li><li><code>^~</code>：以某个字符路径开头</li></ul><p><strong>expires 指令</strong></p><ul><li><code>expires 10s</code>：10s之后过期</li><li><code>expires @22h30m</code>：22h30m这个时间点之后过期</li><li><code>expires -1h</code>：一个小时之前就过期了</li><li><code>expires epoch</code>：关闭缓存</li><li><code>expires off</code>：使用浏览器默认缓存</li></ul><h4 id="负载均衡配置"><a href="#负载均衡配置" class="headerlink" title="负载均衡配置"></a>负载均衡配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">    # 负载均衡配置快</span><br><span class="line">    upstream load_balance &#123;</span><br><span class="line">        </span><br><span class="line">        # 使用 ip hash 作为负载均衡算法，使用 ip hash 算法之后不能把服务器直接移除，只能标记为 down</span><br><span class="line">        ip_hash;</span><br><span class="line"></span><br><span class="line">        # 使用 url hash 作为负载均衡算法</span><br><span class="line">        hash $request_uri;</span><br><span class="line"></span><br><span class="line">        # 使用 least_conn 作为负载均衡算法，哪台服务器连接数少就去请求哪台服务器</span><br><span class="line">        least_conn;</span><br><span class="line"></span><br><span class="line">        # 配置上游服务器</span><br><span class="line">        server localhost:81;</span><br><span class="line">        server localhost:82;</span><br><span class="line">        server localhost:83;</span><br><span class="line"></span><br><span class="line">        # 常链接数量，用于提高网络吞吐量，相当于连接池</span><br><span class="line">        keepalive   32;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 将一些负载均衡节点中的静态资源文件缓存在nginx服务器当中</span><br><span class="line">    # prody_cache_path 指令设置缓存保存的目录</span><br><span class="line">    # keys_zone 指令设置共享缓存空间的名称和索引信息大小</span><br><span class="line">    # max_size 指令指定缓存大小</span><br><span class="line">    # inactive 指令指定超过这个时间则清理此缓存</span><br><span class="line">    # use_temp_path 指令指定临时目录，使用后会影响 nginx 性能</span><br><span class="line">    proxy_cache_path /usr/local/cache keys_zone=mycache:5m max_size=1g inactive=1h use_temp_path=off;</span><br><span class="line"></span><br><span class="line">    # 虚拟主机配置块</span><br><span class="line">    server &#123;</span><br><span class="line">        listen      80;         # 监听端口</span><br><span class="line">        server_name localhost;  # 请求域名</span><br><span class="line"></span><br><span class="line">        # 开启并且使用缓存</span><br><span class="line">        proxy_cache mycache;</span><br><span class="line"></span><br><span class="line">        # 指定命中缓存返回码</span><br><span class="line">        proxy_cache_valid 200 304 8h;</span><br><span class="line"></span><br><span class="line">        # 请求路由映射，匹配拦截</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://load_balance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>upstream 模块参数：</strong></p><ul><li><p><code>weight</code>：配置每台服务器的权重</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 负载均衡配置快</span></span><br><span class="line">upstream load_balance &#123;</span><br><span class="line">    server localhost:81 weight=1;</span><br><span class="line">    server localhost:82 weight=2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>max_conns</code>：配置服务器最大链接数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 负载均衡配置快</span></span><br><span class="line">upstream load_balance &#123;</span><br><span class="line">    server localhost:81 max_conns=200;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>注意：</strong>在多 <code>worker</code> 线程的环境下，可能会超过指定的最大连接数。</p></li><li><p><code>slow_start</code>：设置服务器权重从零开始至设置值的时间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 负载均衡配置快</span></span><br><span class="line">upstream load_balance &#123;</span><br><span class="line">    server localhost:81 slow_start=60s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>注意：</strong><br>  ① 该参数不能在 <code>hash</code> 和 <code>random load balancing</code> 中使用。<br>  ② 如果在 <code>upstream</code> 中只有一台 server，则该参数无效。<br>  ③ 该参数为商业版 nginx 才有的，使用需要付费。 </p></li><li><p><code>down</code>：标识该服务器已经宕机。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 负载均衡配置快</span></span><br><span class="line">upstream load_balance &#123;</span><br><span class="line">    server localhost:81 down;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>backup</code>：标识该服务器为备用机。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 负载均衡配置快</span></span><br><span class="line">upstream load_balance &#123;</span><br><span class="line">    server localhost:81 backup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>注意：</strong>当所有服务器都无法访问才会访问备用机。</p></li><li><p><code>max_fails</code>：最大失败次数，超过这个次数时，默认该服务器已经宕机。与<code>fail_timeout</code>搭配使用。</p></li><li><p><code>fail_timeout</code>：当超过最大失败次数时，经过多少时间去重新访问这台服务器，默认值为10s。与<code>max_fails</code>搭配使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 负载均衡配置快</span></span><br><span class="line">upstream load_balance &#123;</span><br><span class="line">    server localhost:81 max_fails=50 file_timeout=10s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文记录一些 nginx 中的配置，以便后续查看。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Nginx" scheme="https://www.wrp.cool/categories/Nginx/"/>
    
    
    <category term="Linux" scheme="https://www.wrp.cool/tags/Linux/"/>
    
    <category term="Nginx" scheme="https://www.wrp.cool/tags/Nginx/"/>
    
    <category term="配置" scheme="https://www.wrp.cool/tags/%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>【Spring Boot】全局异常处理器</title>
    <link href="https://www.wrp.cool/posts/19537/"/>
    <id>https://www.wrp.cool/posts/19537/</id>
    <published>2021-08-11T08:13:13.000Z</published>
    <updated>2021-08-17T09:35:03.549Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下最近在开发中遇到的一个问题有以及一个不错的解决方案。</p><p>通常情况下一个请求从前端发起到后端的 Controller 接收这个请求，再去调用对应的 Service 方法去处理对应的逻辑，再由 Controller 将处理的结果封装成一个 JSON 对象返回给前端。这是我们的一个正常的请求处理的过程，但是这其中也有一些例外的地方，如果在 Service 处理的时候出现了一些业务上的逻辑问题流程已经无法再继续往下面去走了，这个时候需要在 Service 直接返回到前端需要怎么做？</p><a id="more"></a><p>其实可以通过约定不同的返回值给到 Controller 去判断需要怎么处理再怎么返回给前端。但是这样会带来两个问题：</p><ol><li>一旦项目中的返回类型多了起来就会造成 Controller 层代码的冗余。</li><li>Service 一旦返回事务就会提交，这样子就没办法灵活的来控制我们的事务了。当然这也可以通过 Service 层代码编写的逻辑来解决，但这么处理就不是那么的优雅了。</li></ol><p>一个优雅的处理方式应该是定义好一个业务异常类 BizException，这个类需要继承 RuntimeException 类，一旦在 Service 中需要返回的时候就抛出 BizException 异常，这样事务就可以回滚，然后再由 Spring Boot 的全局异常处理器来捕获这个异常直接将我们自定义的异常信息返回给前端。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义业务异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BizException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处的异常信息仅仅为了演示而定义的只有一个 errMsg 字段</span></span><br><span class="line">    <span class="comment">// 实际使用中可以根据需要将这个异常信息定义的丰富一些，比如使用一个 Enum 来维护这些异常信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String errMsg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BizException</span><span class="params">(String errMsg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.errMsg = errMsg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局异常处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ApiResponse 类为接口全局响应类</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(BizException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ApiResponse</span>&lt;<span class="title">String</span>&gt; <span class="title">businessExceptionHandler</span>(<span class="title">BizException</span> <span class="title">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ApiResponse.fail(e.getErrMsg());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一下最近在开发中遇到的一个问题有以及一个不错的解决方案。&lt;/p&gt;
&lt;p&gt;通常情况下一个请求从前端发起到后端的 Controller 接收这个请求，再去调用对应的 Service 方法去处理对应的逻辑，再由 Controller 将处理的结果封装成一个 JSON 对象返回给前端。这是我们的一个正常的请求处理的过程，但是这其中也有一些例外的地方，如果在 Service 处理的时候出现了一些业务上的逻辑问题流程已经无法再继续往下面去走了，这个时候需要在 Service 直接返回到前端需要怎么做？&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="https://www.wrp.cool/categories/Spring/"/>
    
    <category term="Spring Boot" scheme="https://www.wrp.cool/categories/Spring/Spring-Boot/"/>
    
    
    <category term="Spring Boot" scheme="https://www.wrp.cool/tags/Spring-Boot/"/>
    
    <category term="Spring" scheme="https://www.wrp.cool/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>通过2-3树来理解红黑树</title>
    <link href="https://www.wrp.cool/posts/18972/"/>
    <id>https://www.wrp.cool/posts/18972/</id>
    <published>2021-07-18T06:15:42.000Z</published>
    <updated>2021-08-04T12:42:02.929Z</updated>
    
    <content type="html"><![CDATA[<p>好了，终于来到了这块最难啃的骨头了——<strong>红黑树</strong>。</p><p>首先，当然是直接摆出红黑树大名鼎鼎的五条基本性质了</p><ol><li><font color=blue>节点是红色或者黑色。</font></li><li><font color=blue>根节点是黑色。</font></li><li><font color=blue>所有叶子节点都是黑色。（叶子节点是空节点）</font></li><li><font color=blue>不存在能够和两条红链接相连的节点。（每个红色的节点的两个子节点都是黑色）</font></li><li><font color=blue>从任意一个节点到叶子节点，经过的黑色节点数量是一样的。（黑平衡）</font></li></ol><p>只要满足以上五个性质的二叉搜索树就可以称之为红黑树。</p><a id="more"></a><blockquote><p>温馨提示：本文比较长，开始之前还请你耐下心来，一步一步仔细看完，我相信这篇文章会带给你一些收获。继续加油！：）</p></blockquote><p>红黑树其实也是一种二叉搜索树，只不过这是一种性能更好的二叉搜索树。二叉搜索树的结构决定了增删改查这些操作对于二叉搜索树而言都是对数级别的时间复杂度，所以这是一种高效的数据结构，但它有一个致命的缺陷，就是有序插入元素的情况下，它会严重的向一边倾斜退化成一个链表，也就是所谓的失衡。所以，我们希望我们的二叉搜索树在任何情况下都能保持左图的样子，或者说是尽量保持成左图的样子，而永远不要退化成右图的样子。于是我们为二叉搜索树加入了平衡机制，其中红黑树就是这么一种机制。<strong>对于二叉搜索树的有序性而言，红黑树在这基础上又添加了平衡性。</strong>以上红黑树的五条基本性质就是维持平衡的手段。</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20210720231008.png" alt="20210720231008"></p><p>像左图这样的树我们称之为平衡的，而红黑树仅仅只是维持平衡的手段而已，<font color=blue>红黑树在本质上依然是一棵二叉搜索树。</font></p><p>像红黑树这样的数据结构，肯定也不是一朝一夕能够发明出来的，而是有一个演化的过程，从二叉搜索树到红黑树之间就有一个不可缺少的过渡——<strong>2-3查找树</strong>。</p><h1 id="2-3查找树"><a href="#2-3查找树" class="headerlink" title="2-3查找树"></a>2-3查找树</h1><br><p><strong>定义：</strong></p><ul><li>一棵2-3查找树要么是一棵空树，要么由<code>2-节点</code>和<code>3-节点</code>组成。</li><li><code>2-节点</code>：含有一个节点本身的值和两条链接，左连接指向的2-3树值都小于该节点，右链接指向的2-3树值都大于该节点。</li><li><code>3-节点</code>：含有两个节点本身的值和三条链接，左连接指向的2-3树值都小于该节点，中链接指向的2-3树值都位于节点的两个值之间，右链接指向的2-3树值都大于该节点。</li></ul><p><strong>注意：</strong></p><ul><li>2-3查找树是一种完美平衡的树结构，也就是说一棵2-3树中的任意节点的左子树、中子树、右子树高度相等。</li></ul><p><strong>由完美平衡可知：</strong></p><ul><li><code>2-节点</code>要么没有两条链接都指向空，要么两条链接都不为空。</li><li><code>3-节点</code>要么没有三条链接都指向空，要么三条链接都不为空。</li></ul><p><strong>如图：</strong><br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/album_temp_1627184547.PNG" alt="album_temp_1627184547"></p><blockquote><p><strong>接下来将分析2-3树中的各种插入情况</strong></p></blockquote><h2 id="向2-节点添加元素"><a href="#向2-节点添加元素" class="headerlink" title="向2-节点添加元素"></a>向2-节点添加元素</h2><p>首先，需要在2-3树中搜索到一个可以添加节点的位置，如果搜索结束于一个<code>2-节点</code>，那么很好办，只需要将这个<code>2-节点</code>替换成一个<code>3-节点</code>。像这样：<br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/IMG_0045.PNG" alt="IMG_0045"></p><hr><p>其实向一个<code>2-节点</code>插入元素是非常简单的，只需要将一<code>2-节点</code>变换成一个<code>3-节点</code>即可。但是这很简单的一步却是保持2-3树完美平衡<strong>最关键的一步</strong>。</p><p>试想一个问题：一棵完美的平衡二叉树，也就是满二叉树，它的节点个数是奇数还是偶数？答案非常简单，是奇数，根节点的左子树和右子树的节点数是相同的，于是整棵树的节点数就是<code>2 * 左子树的节点数 + 1</code>。采用递归的思想，整棵树无论对于哪个节点求节点个数得出的答案都是奇数。</p><p>于是，如果一棵二叉树的节点个数是偶数，那么这棵二叉树绝对不是完美平衡，想要得到一棵完美平衡的二叉树必备的一个条件就是树的节点个数为奇数。实际上一棵完美平衡的二叉树的节点数是等于<code>2 ^ h - 1</code>的。（其中h为树的高度，根节点的高度为1）</p><p>一棵二叉树在生成的过程当中，依次将元素插入其中，这不可能保证整棵树的节点个数在任何情况下都是奇数。事实上，在节点只能存放一个元素的情况下，不可能实现完美平衡的树结构。2-3树中的<code>3-节点</code>正是为了解决这一情况而存在的。</p><p>正常情况下，向二叉树中的一个左右子树都为空的节点插入元素无论插入在左子树还是右子树中肯定会造成这个节点的不完美平衡，但是现在引入了<code>3-节点</code>这样的一个过渡的节点，说白了，这其实是在暂存一下这种不平衡的情况，一旦在这个<code>3-节点</code>中再次插入一个元素之后立马会分裂成为一棵左右子树都不为空的二叉树。</p><h2 id="向3-节点添加元素"><a href="#向3-节点添加元素" class="headerlink" title="向3-节点添加元素"></a>向3-节点添加元素</h2><p>单纯的向一棵仅有一个三节点的2-3树添加元素是比较简单的，这里简单讲一下思路即可。</p><ol><li>将新节点插入<code>3-节点</code>中，组成一个临时的<code>4-节点</code>。此时这个<code>4-节点</code>中包含三个值和四条链接。</li><li>将这个<code>4-节点</code>的三个值都抽取出来成为三个<code>2-节点</code>，中值抽取出来的<code>2-节点</code>作为根，根的左链接指向三个节点中的最小者，右链接指向三个节点中的最大者。</li></ol><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/album_temp_1627305570.PNG" alt="album_temp_1627305570"></p><blockquote><p>也许有些同学也注意到了，这一步操作使得树的高度增加了，在将<code>4-节点</code>分裂为三个<code>2-节点</code>的过程当中，树高由1变成了2。这也是2-3树的生长方式，当根节点已经是一个<code>3-节点</code>的时候插入一个新的节点，此时根节点分裂为三个<code>2-节点</code>，树高度加1。与普通的二叉查找树不同的是2-3树的生长方向是由下至上生长的，而二叉查找树的生长方向是由上至下生长的。</p></blockquote><h3 id="向一个父节点为2-节点的3-节点添加元素"><a href="#向一个父节点为2-节点的3-节点添加元素" class="headerlink" title="向一个父节点为2-节点的3-节点添加元素"></a>向一个父节点为2-节点的3-节点添加元素</h3><ol><li>插入到<code>3-节点</code>中，组成一个临时的<code>4-节点</code>。</li><li>将<code>4-节点</code>的中值所抽取出来的根节点插入至父节点，使父节点从原来的<code>2-节点</code>变成<code>3-节点</code><br> 此处插入过程与“向<code>2-节点</code>添加元素”相同。</li><li>将<code>4-节点</code>分裂出来的两个<code>2-节点</code>移动至父节点中，成为<code>3-节点</code>的两个子树。</li></ol><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/album_temp_1627307311.PNG" alt="album_temp_1627307311"></p><h3 id="向一个父节点为3-节点的3-节点添加元素"><a href="#向一个父节点为3-节点的3-节点添加元素" class="headerlink" title="向一个父节点为3-节点的3-节点添加元素"></a>向一个父节点为3-节点的3-节点添加元素</h3><ol><li>插入到<code>3-节点</code>中，组成一个临时的<code>4-节点</code>。</li><li>将<code>4-节点</code>的中值抽取出来的根节点插入至父节点，使父节点从原来的<code>3-节点</code>变成一个临时的<code>4-节点</code>。</li><li>将<code>4-节点</code>分裂出来的两个<code>2-节点</code>移动至父节点也就是新的临时的<code>4-节点</code>中，成为新的临时<code>4-节点</code>的两个子树。</li><li>将新的临时的<code>4-节点</code>分裂出来的根继续往上插入<br> 此处插入的过程与“向一个父节点为<code>2-节点</code>的<code>3-节点</code>添加元素”相同。</li></ol><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/album_temp_1627307543.PNG" alt="album_temp_1627307543"></p><h3 id="向“从插入节点出发直到根节点全部都是3-节点”的节点添加元素"><a href="#向“从插入节点出发直到根节点全部都是3-节点”的节点添加元素" class="headerlink" title="向“从插入节点出发直到根节点全部都是3-节点”的节点添加元素"></a>向“从插入节点出发直到根节点全部都是3-节点”的节点添加元素</h3><ol><li>一直按照“向一个父节点为<code>3-节点</code>的<code>3-节点</code>添加元素”的方式插入元素，那么直到最后根节点也会变成一个临时的<code>4-节点</code>。</li><li>将根节点转换成的临时<code>4-节点</code>分裂开来，按照“向<code>3-节点</code>添加元素”的方式，中值成为整颗2-3树新的根，此时树高加一。</li></ol><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/album_temp_1627310222.PNG" alt="album_temp_1627310222"></p><hr><p><strong>以上就是2-3树中插入元素的全部情况，做个小结：</strong></p><ol><li>向<code>2-节点</code>插入元素：直接插入至<code>2-节点中</code>生成一个三节点。</li><li>向<code>3-节点</code>插入元素：<ol><li>父节点为<code>2-节点</code>：组成临时<code>4-节点</code>，分裂后的根插入父节点组成<code>3-节点</code>。</li><li>父节点为<code>3-节点</code>：组成临时<code>4-节点</code>，分裂后的根插入父节点，再次组成临时<code>4-节点</code>。<br> 不断重复此过程，直到找到一个<code>2-节点</code>为止。如果直到根节点还找不到，则将根节点分裂成三个<code>2-节点</code>，此时树高加一。</li></ol></li></ol><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>其实我更愿意这么来理解红黑树：<font color=blue>使用二叉树来表现2-3树</font>。换句话说，其实2-3树和红黑树是等价的。</p><blockquote><p>其实一般的红黑树是等价于2-3-4树的，也就是我们前面说的2-3树中再加了一个<code>4-节点</code>。但是本文讲述的红黑树是左倾红黑树，具体的左倾红黑树与一般红黑树的区别，在这就留个坑吧。在这里只需要记住一点：<strong>左倾红黑树中红链接全部都是左连接</strong>。</p></blockquote><p>一棵2-3树中的<code>2-节点</code>跟二叉查找树中的节点是完全相同的，也就是说普通的节点就可以表示2-3树中的<code>2-节点</code>。于是我们只要能够使用二叉树的形式来表现一个<code>3-节点</code>我们就可以成功的将一棵2-3树转化成为红黑树。</p><p>将<code>3-节点</code>中的两个值分别当作是两个<code>2-节点</code>分裂开，中间使用一条连接将这两个<code>2-节点</code>相连接起来，表示了这两个<code>2-节点</code>代表了一个<code>3-节点</code>。这样的链接被称为红链接。</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/album_temp_1627903082.PNG" alt="album_temp_1627903082"></p><p>为了方便表示红链接我们注意到每个红色链接都会指向唯一的一个节点，所以我们将节点标记为红色来表示指向此节点的链接是红链接，相反的没有被红链接指向的节点全部就被标记为黑色。</p><p>本文一开始就提出的红黑树的五条基本性质中的第1点、第2点、第3点也就是这么来的，性质4和性质5稍微有一些抽象：</p><ol><li><font color=blue>节点是红色或者黑色</font>：每个节点都会被标记为红色或者黑色。</li><li><font color=blue>根节点是黑色</font>：二叉树中没有链接指向根节点，所以根节点被标记为黑色。</li><li><font color=blue>所有叶子节点都是黑色</font>：叶子节点都是空节点，没有被红链接所指向，所以标记为黑色。</li><li><font color=blue>不存在能够和两条红链接相连的节点</font>：如果将红黑树中由红链接相连的节点合并起来，得到的就是一棵2-3树。相反，如果将一棵2-3树中的<code>3-节点</code>画作由红色左连接相连的两个<code>2-节点</code>，那么肯定不会存在能够和两条红链接相连的节点。</li><li><font color=blue>从任意一个节点到叶子节点，经过的黑色节点数量是一样的。</font>：如果将红链接画平，那么第5点将很容易理解。</li></ol><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/album_temp_1627905396.PNG" alt="album_temp_1627905396"></p><blockquote><p>上图中粗链接表示为红链接</p></blockquote><h2 id="着色和旋转"><a href="#着色和旋转" class="headerlink" title="着色和旋转"></a>着色和旋转</h2><p>保持红黑树五大性质的两大法宝就是着色和旋转，其中旋转又分为左旋转和右旋转。</p><h3 id="着色"><a href="#着色" class="headerlink" title="着色"></a>着色</h3><p>着色操作比较简单，只需要改变对节点颜色的标记即可。</p><h3 id="左旋转和右旋转"><a href="#左旋转和右旋转" class="headerlink" title="左旋转和右旋转"></a>左旋转和右旋转</h3><p>下图中粗链接表示为红链接<br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20210803095327.png" alt="20210803095327"></p><p>具体的旋转过程在<a href="https://www.wrp.cool/posts/54793/">AVL 树</a>这篇文章中已经有具体的说明。这里不再过多的赘述。</p><blockquote><p>需要注意的是：旋转过后应该保持根节点颜色相同，以及这里的旋转过程是在插入节点时调用的，在2-3树中插入操作总是和树中的节点相互融合的，所以要将旋转后的节点标记为红色。</p></blockquote><!-- TODO 聊清楚左右旋转的着色原理 --><hr><p>在正式开始插入操作之前，有一点需要先注意：新插入的节点默认是红色的节点，因为在插入的时候除非是插入在根节点的位置之外，所有的插入首先都是与原有的节点做融合操作，而融合进其他节点的节点在红黑树中被标记为红色。</p><h2 id="向红黑树中的“2-节点”插入元素"><a href="#向红黑树中的“2-节点”插入元素" class="headerlink" title="向红黑树中的“2-节点”插入元素"></a>向红黑树中的“2-节点”插入元素</h2><p>向一个<code>2-节点</code>中插入元素之后，会与原来的<code>2-节点</code>一起形成一个<code>3-节点</code>。这就引申出了两种情况：</p><ol><li>插入节点小于<code>2-节点</code>，插入在<code>2-节点</code>的左边，成为<code>2-节点</code>的左孩子。<br> 符合左倾红黑树的定义，即红链接在左边，此时无需修改。</li><li>插入节点大于<code>2-节点</code>，插入在<code>2-节点</code>的右边，成为<code>2-节点</code>的右孩子。<br> 不符合左倾红黑树的定义，即红链接在右边，此时需要对被插入节点做一次左旋转的操作，以将右红链接纠正为左红链接。</li></ol><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/album_temp_1628078520.PNG" alt="album_temp_1628078520"></p><h2 id="向红黑树中的“3-节点”插入元素"><a href="#向红黑树中的“3-节点”插入元素" class="headerlink" title="向红黑树中的“3-节点”插入元素"></a>向红黑树中的“3-节点”插入元素</h2><p>向一个<code>3-节点</code>中插入元素之后，与原来的<code>3-节点</code>之间会产生三种情况：</p><ol><li>插入的元素小于<code>3-节点</code>的两个元素。</li><li>插入的元素位于<code>3-节点</code>的两个元素之间。</li><li>插入的元素大于<code>3-节点</code>的两个元素。</li></ol><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/album_temp_1628079653.PNG" alt="album_temp_1628079653"></p><blockquote><p>注意：以上的三种情况中最后的一个步骤都是需要将根节点也就是b节点转换成黑色的，这样才能保持红黑树的第五条性质，黑平衡。</p></blockquote><h2 id="插入代码实现"><a href="#插入代码实现" class="headerlink" title="插入代码实现"></a>插入代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RBTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> e;</span><br><span class="line">        Node left, right;</span><br><span class="line">        <span class="keyword">boolean</span> color;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.e = e;</span><br><span class="line">            <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.color = RED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 左旋转</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">leftRotate</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 暂存</span></span><br><span class="line">        Node x = node.right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 旋转</span></span><br><span class="line">        node.right = x.left;</span><br><span class="line">        x.left = node;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 着色</span></span><br><span class="line">        x.color = node.color;</span><br><span class="line">        node.color = RED;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 右旋转</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">rightRotate</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 暂存</span></span><br><span class="line">        Node x = node.left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 旋转</span></span><br><span class="line">        node.left = x.right;</span><br><span class="line">        x.right = node;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 着色</span></span><br><span class="line">        x.color = node.color;</span><br><span class="line">        node.color = RED;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node == <span class="keyword">null</span> ? BLACK : node.color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flipColors</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        node.color = RED;</span><br><span class="line">        node.left.color = BLACK;</span><br><span class="line">        node.right.color = BLACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">        add(root, e);</span><br><span class="line">        root.color = BLACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.e &gt; e) &#123;</span><br><span class="line">            node.left = add(node.left, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.e &lt; e) &#123;</span><br><span class="line">            node.right = add(node.right, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isRed(node.right) &amp;&amp; !isRed(node.left))</span><br><span class="line">            node = leftRotate(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isRed(node.left) &amp;&amp; isRed(node.left.left))</span><br><span class="line">            node = rightRotate(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isRed(node.left) &amp;&amp; isRed(node.right))</span><br><span class="line">            flipColors(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本文中的参考图片出自《算法：第4版》这本书中的红黑树章节。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;好了，终于来到了这块最难啃的骨头了——&lt;strong&gt;红黑树&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;首先，当然是直接摆出红黑树大名鼎鼎的五条基本性质了&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;font color=blue&gt;节点是红色或者黑色。&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=blue&gt;根节点是黑色。&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=blue&gt;所有叶子节点都是黑色。（叶子节点是空节点）&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=blue&gt;不存在能够和两条红链接相连的节点。（每个红色的节点的两个子节点都是黑色）&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font color=blue&gt;从任意一个节点到叶子节点，经过的黑色节点数量是一样的。（黑平衡）&lt;/font&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;只要满足以上五个性质的二叉搜索树就可以称之为红黑树。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="https://www.wrp.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="平衡二叉树" scheme="https://www.wrp.cool/tags/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="2-3树" scheme="https://www.wrp.cool/tags/2-3%E6%A0%91/"/>
    
    <category term="红黑树" scheme="https://www.wrp.cool/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>AVL 树</title>
    <link href="https://www.wrp.cool/posts/54793/"/>
    <id>https://www.wrp.cool/posts/54793/</id>
    <published>2021-07-04T02:50:29.000Z</published>
    <updated>2021-07-18T06:16:53.241Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章所讲述的【<a href="https://www.wrp.cool/posts/46128/">二叉搜索树</a>】其实有一个非常严重的漏洞：如果插入的元素都是有序的怎么办？</p><blockquote><p>如果按照有序的方式或者近乎有序的方式将元素插入到二叉搜索树当中去，那么此时的二叉搜索树将退化成一个链表的数据结构。于是引入平衡这种机制来防止这种情况的发生，引入平衡的二叉树被成为平衡二叉树。</p></blockquote><p><strong>平衡：</strong><font color=blue>一棵树中对于任意节点都有左子树的高度减去右子树的高度的绝对值小于等于1，则称这棵二叉树是平衡的。</font></p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>首先还是先看看百度百科中对于AVL树的定义（<a href="https://baike.baidu.com/item/AVL%E6%A0%91" target="_blank" rel="noopener">AVL树-百度百科</a>）。</p><p><strong>AVL树的特点：</strong></p><ul><li>本身首先是一棵二叉搜索树</li><li>带有平衡性：每个节点的左右子树的高度之差的绝对值（<strong>平衡因子</strong>）最多为1。<br>也就是说，AVL树，本质上是带了平衡功能的二叉搜索树。</li></ul><p><strong>平衡因子：</strong>左子树的高度减去右子树的高度。（注意：平衡因子的值可能为负，不过这是正常的，平衡因子的正负性能够帮助我们区分二叉树是向左倾斜的还是向右倾斜的）</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><blockquote><p>本质上AVL树还是一种二叉搜索树，但是引入了“平衡因子”的概念来维护树的平衡，所以在树的节点类中要新增加一个<code>height</code>变量来维护树的高度。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节点类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> e, height;</span><br><span class="line">    <span class="keyword">public</span> Node left, right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> e, Node left, Node right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.height = <span class="number">1</span>; <span class="comment">// 新节点默认高度为 1</span></span><br><span class="line">        <span class="keyword">this</span>.e = e;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设计两个辅助函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取节点高度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> node == <span class="keyword">null</span> ? <span class="number">0</span> : node.height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取平衡因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBalanceFactor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> node == <span class="keyword">null</span> ? <span class="number">0</span> : getHeight(node.left) - getHeight(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="树的平衡与失衡"><a href="#树的平衡与失衡" class="headerlink" title="树的平衡与失衡"></a>树的平衡与失衡</h1><p>一个节点的平衡因子是有这个节点左子树的高度减去右子树的高度得到的。如果平衡因子的绝对值小于等于一，则这个节点是平衡的，反之则称之为失衡。</p><p><font color=blue>那么什么情况会导致树的失衡呢？</font><br>当左右子树的高度本来就相差1的情况下，其中较高的子树再次加1的情况下，此时就会产生失衡。</p><p><font color=blue>那么失衡总共有多少种情况呢？</font><br>四种，分别是LL型、RR型、LR型、RL型，L和R分别是Left和Right的缩写。<br>其中第一个字母代表的是较高的子树是左子树还是右子树，第二个字母代表的是新增的节点是增加在较高子树的左子树还是右子树。<br>除了这四种失衡的情况，其余的情况就都是平衡的了。</p><p>下面为这四种情况分别举个例子：<br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20210714225927.png" alt="20210714225927"></p><blockquote><p>以上的四种情况失衡的节点都是根节点。</p></blockquote><h1 id="左旋转与右旋转-平衡-LL和RR"><a href="#左旋转与右旋转-平衡-LL和RR" class="headerlink" title="左旋转与右旋转 平衡 LL和RR"></a>左旋转与右旋转 平衡 LL和RR</h1><p>左旋转与右旋转就是对不平衡节点的平衡操作，就拿上面比较简单的LL和RR的例子来演示左旋转与右旋转。</p><p><strong>具体的旋转过程用这两张图来表示：</strong><br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-AVL-3.jpg" alt="数据结构-AVL-3"><br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-AVL-2.jpg" alt="数据结构-AVL-2"></p><blockquote><p>这里的<code>D、E、F、G</code>分别是挂在在<code>A、B、C</code>节点下的二叉树，这里假设<code>D、E、F、G</code>高度相同。为了方便理解，你可以直接把<code>D、E、F、G</code>就当成是单个节点。</p></blockquote><p><font color=blue>这里最重要的一点是旋转前后整个树依然保持着二叉搜索树的性质，也就是图中的结论在旋转前和旋转后都是成立的。</font></p><p><font size=5><strong>编码实现：</strong></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 左旋转</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">leftRotate</span><span class="params">(Node a)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 暂存</span></span><br><span class="line">    Node b = a.right;</span><br><span class="line">    Node e = b.left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 旋转</span></span><br><span class="line">    b.left = a;</span><br><span class="line">    a.right = e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新Height</span></span><br><span class="line">    a.height = Math.max(getHeight(a.left), getHeight(a.right)) + <span class="number">1</span>;</span><br><span class="line">    b.height = Math.max(getHeight(b.left), getHeight(b.right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 右旋转</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">rightRotate</span><span class="params">(Node a)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 暂存</span></span><br><span class="line">    Node b = a.left;</span><br><span class="line">    Node f = b.right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 旋转</span></span><br><span class="line">    b.right = a;</span><br><span class="line">    a.left = f;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新Height</span></span><br><span class="line">    a.height = Math.max(getHeight(a.left), getHeight(a.right)) + <span class="number">1</span>;</span><br><span class="line">    b.height = Math.max(getHeight(b.left), getHeight(b.right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="左旋转与右旋转-平衡-LR和RL"><a href="#左旋转与右旋转-平衡-LR和RL" class="headerlink" title="左旋转与右旋转 平衡 LR和RL"></a>左旋转与右旋转 平衡 LR和RL</h1><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-AVL-4.jpg" alt="数据结构-AVL-4"></p><p>大概的处理过程就是这个样子，先旋转其中一个节点，将LR和RL变成LL或者是RR的形式，最后再旋转一次即可完成对LR和RL的平衡。</p><h1 id="在二叉搜索树中引入AVL"><a href="#在二叉搜索树中引入AVL" class="headerlink" title="在二叉搜索树中引入AVL"></a>在二叉搜索树中引入AVL</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 保持平衡</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">keepBalance</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 平衡维护</span></span><br><span class="line">    <span class="keyword">int</span> balance = getBalanceFactor(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LL</span></span><br><span class="line">    <span class="keyword">if</span> (balance &gt;= <span class="number">2</span> &amp;&amp; getBalanceFactor(root.left) &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> rightRotate(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RR</span></span><br><span class="line">    <span class="keyword">if</span> (balance &lt;= -<span class="number">2</span> &amp;&amp; getBalanceFactor(root.right) &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> leftRotate(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LR</span></span><br><span class="line">    <span class="keyword">if</span> (balance &gt;= <span class="number">2</span> &amp;&amp; getBalanceFactor(root.left) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        root.left = leftRotate(root.left);</span><br><span class="line">        <span class="keyword">return</span> rightRotate(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RL</span></span><br><span class="line">    <span class="keyword">if</span> (balance &lt;= -<span class="number">2</span> &amp;&amp; getBalanceFactor(root.right) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        root.right = rightRotate(root.right);</span><br><span class="line">        <span class="keyword">return</span> leftRotate(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    root = add(root, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node root, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node(e, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e &lt; root.e) root.left = add(root.left, e);</span><br><span class="line">    <span class="keyword">if</span> (e &gt; root.e) root.right = add(root.right, e);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新Height</span></span><br><span class="line">    root.height = Math.max(getHeight(root.left), getHeight(root.right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 平衡维护</span></span><br><span class="line">    <span class="keyword">return</span> keepBalance(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    delNode(root, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">delNode</span><span class="params">(Node root, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e &gt; root.e) &#123;</span><br><span class="line">        root.right = delNode(root.right, e);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e &lt; root.e) &#123;</span><br><span class="line">        root.left = delNode(root.left, e);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size --;</span><br><span class="line">    Node retNode;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span>) retNode =  root.right;</span><br><span class="line">    <span class="keyword">if</span> (root.right == <span class="keyword">null</span>) retNode = root.left;</span><br><span class="line">    retNode = delMax(root.left);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新Height</span></span><br><span class="line">    root.height = Math.max(getHeight(root.left), getHeight(root.right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 平衡维护</span></span><br><span class="line">    <span class="keyword">return</span> keepBalance(retNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一篇文章所讲述的【&lt;a href=&quot;https://www.wrp.cool/posts/46128/&quot;&gt;二叉搜索树&lt;/a&gt;】其实有一个非常严重的漏洞：如果插入的元素都是有序的怎么办？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果按照有序的方式或者近乎有序的方式将元素插入到二叉搜索树当中去，那么此时的二叉搜索树将退化成一个链表的数据结构。于是引入平衡这种机制来防止这种情况的发生，引入平衡的二叉树被成为平衡二叉树。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;平衡：&lt;/strong&gt;&lt;font color=blue&gt;一棵树中对于任意节点都有左子树的高度减去右子树的高度的绝对值小于等于1，则称这棵二叉树是平衡的。&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="https://www.wrp.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://www.wrp.cool/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="二叉树" scheme="https://www.wrp.cool/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="平衡二叉树" scheme="https://www.wrp.cool/tags/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="递归" scheme="https://www.wrp.cool/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树</title>
    <link href="https://www.wrp.cool/posts/46128/"/>
    <id>https://www.wrp.cool/posts/46128/</id>
    <published>2021-06-29T13:12:03.000Z</published>
    <updated>2021-07-05T14:55:47.530Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote><p>二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： <font color=blue>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。</font>二叉搜索树作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势；所以应用十分广泛，例如在文件系统和数据库系统一般会采用这种数据结构进行高效率的排序与检索操作。</p><p>以上资料来自：<a href="https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91" target="_blank" rel="noopener">二叉搜索树-百度百科</a></p></blockquote><a id="more"></a><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> e;</span><br><span class="line">        <span class="keyword">public</span> Node left, right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> e, Node left, Node right)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.e = e;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    add(root, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node root, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        size ++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node(e, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (e &lt; root.e) &#123;</span><br><span class="line">        root.left = add(root.left, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e &gt; root.e) &#123;</span><br><span class="line">        root.right = add(root.right, e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> find(root, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(Node root, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e &lt; root.e) </span><br><span class="line">        <span class="keyword">return</span> find(root.left, e);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e &gt; root.e)</span><br><span class="line">        <span class="keyword">return</span> find(root.right, e);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除最大元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">delMax</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        root.right = delMax(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        size --;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            root = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除任意元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> delNode(root, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">delNode</span><span class="params">(Node root, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e &gt; root.e) &#123;</span><br><span class="line">        root.right = delNode(root.right, e);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e &lt; root.e) &#123;</span><br><span class="line">        root.left = delNode(root.left, e);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size --;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line">    <span class="keyword">if</span> (root.right == <span class="keyword">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">    <span class="keyword">return</span> delMax(root.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前序遍历（递归版本）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    System.out.println(root);</span><br><span class="line">    preOrder(root.left);</span><br><span class="line">    preOrder(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前序遍历（循环版本）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用栈来模拟递归</span></span><br><span class="line">    IStack&lt;Node&gt; stack = <span class="keyword">new</span> ArrayStack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        Node node = stack.pop();</span><br><span class="line">        System.out.print(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>)</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>)</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序遍历（递归版本）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    inOrder(root.left);</span><br><span class="line">    System.out.println(root);</span><br><span class="line">    inOrder(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序遍历（循环版本）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用栈来模拟递归</span></span><br><span class="line">    IStack&lt;Node&gt; stack = <span class="keyword">new</span> ArrayStack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node node = stack.pop();</span><br><span class="line">        System.out.print(node);</span><br><span class="line"></span><br><span class="line">        root = node.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后序遍历（递归版本）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    postOrder(root.left);</span><br><span class="line">    postOrder(root.right);</span><br><span class="line">    System.out.println(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用栈来模拟递归</span></span><br><span class="line">    IStack&lt;Node&gt; stack = <span class="keyword">new</span> ArrayStack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Node prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span> &amp;&amp; root.right != prev) &#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.print(root);</span><br><span class="line">            prev = root;</span><br><span class="line">            root = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="层序遍历二叉树"><a href="#层序遍历二叉树" class="headerlink" title="层序遍历二叉树"></a>层序遍历二叉树</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    IQueue&lt;Node&gt; queue = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    queue.enque(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        Node node = queue.deque();</span><br><span class="line">        System.out.println(node);</span><br><span class="line"></span><br><span class="line">        queue.enque(node.left);</span><br><span class="line">        queue.enque(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于二叉搜索树是一种比较简单的数据结构，所以本文更多的是一些代码的记录，并不对其中的逻辑做深入的阐述。<br>如果你发现了什么错误或者是有什么疑问都欢迎在评论区指出。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： &lt;font color=blue&gt;若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。&lt;/font&gt;二叉搜索树作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势；所以应用十分广泛，例如在文件系统和数据库系统一般会采用这种数据结构进行高效率的排序与检索操作。&lt;/p&gt;
&lt;p&gt;以上资料来自：&lt;a href=&quot;https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;二叉搜索树-百度百科&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构" scheme="https://www.wrp.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://www.wrp.cool/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="二叉树" scheme="https://www.wrp.cool/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="递归" scheme="https://www.wrp.cool/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="遍历" scheme="https://www.wrp.cool/tags/%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="https://www.wrp.cool/posts/11306/"/>
    <id>https://www.wrp.cool/posts/11306/</id>
    <published>2021-06-16T14:32:13.000Z</published>
    <updated>2021-06-29T13:08:40.045Z</updated>
    
    <content type="html"><![CDATA[<p>本来像是这样的排序算法在网上搜个快速排序能找到很多的博客在详细的说明快速排序的实现、特点、性能、时间复杂度等等，但还是决定要自己写一篇博客来讲讲这个算法，实际上是想要分享一些在学习这个算法的过程中一些让我感到惊讶的地方。</p><p>也正是因为这样的一些比较独特的，比较不可思议却又是合乎情理的存在才让算法变得更神秘，更吸引人了。</p><a id="more"></a><hr><p>先简单的讲一下快速排序的核心思想：</p><blockquote><p>每次在数组中随机的找到一个元素，以这个元素为基准将整个数组分成大于基准元素的部分和小于基准元素的部分，之后再按照小于基准元素、基准元素、大于基准元素这样的顺序排好，之后再递归的对小于基准元素部分和大于基准元素部分分别进行相同的操作。有一些书中也会将这个基准元素称为标兵。</p></blockquote><p>根据这样的一个思想我们可以很快速的设计出第一版的快速排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> j = l;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[l]))</span><br><span class="line">            swap(arr, i, ++j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, l, j);</span><br><span class="line"></span><br><span class="line">    sort(arr, l, j - <span class="number">1</span>);</span><br><span class="line">    sort(arr, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处swap函数用于交换数组中两个下标处的值。</span></span><br></pre></td></tr></table></figure><p>有些书上的快速排序实现的过程可能跟上面代码并不一致，这里也想说一点关于自己的想法，对于算法的实现我们更应该关注的是这个算法的思想，以及我们所实现的算法的时间复杂度分析上，而不是去纠结具体实现的方式。</p><p>上面的代码看着好起来并不复杂，但是想要彻底的理解的话其实并不容易，关键是要能够理解<code>j</code>代表什么，也就是<code>j</code>的语义。</p><p><font color=blue>此处的<code>j</code>代表了小于标兵元素部分的最右边的元素。</font></p><blockquote><p>上面的代码对于初学者可能并不是特别友好，如果你有任何的疑问欢迎在评论区提问。</p></blockquote><hr><p><strong>有意思的地方现在开始了：</strong></p><p>如果你觉得上面的代码没问题的话，在这里强烈建议你设计一个数据规模是百万这个级别并且已经排好序的数组来跑一下上面的这个快速排序算法，你会发现这一点也不快速。</p><p>由于我们每次所选择的标兵元素都是数组中的第一个元素，所以如果是一个已经排好序的数组，这个快速排序算法会直接退化成一个<code>O(n^2)</code>级别的算法。</p><p>改进的方式是使用随机标兵，于是上面的代码迎来了第一次改进。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机标兵（针对有序数组的优化）</span></span><br><span class="line">    swap(arr, l, l + random.nextInt(r - l + <span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> j = l;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[l]))</span><br><span class="line">            swap(arr, i, ++j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, l, j);</span><br><span class="line"></span><br><span class="line">    sort(arr, l, j - <span class="number">1</span>);</span><br><span class="line">    sort(arr, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码的逻辑还是没有改变，还是选取数组中的第一个元素为标兵元素，但是在每次选取之前将数组中的第一个元素和数组中的随机任何一个元素交换一下位置，以达到随机标兵的效果。</p><hr><p>但就算是这样这个算法依旧不完美，设想一下：<strong>如果是一个所有元素都相同的数组呢？</strong><br>比如一个容量为一百万的数组里面存放的元素全部都是0。</p><p>如果是这样的情况，那么随机标兵也就没有作用了，快速排序也就再次退化成了一个<code>O(n^2)</code>级别的算法。</p><p>于是第二次改进：<strong>双路快速排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机标兵（针对完全有序数组所进行的优化）</span></span><br><span class="line">    swap(arr, l, l + random.nextInt(r - l + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = l + <span class="number">1</span>, j = r;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[i] &lt; arr[l]) i++;</span><br><span class="line">        <span class="keyword">while</span> (arr[j] &gt; arr[l]) j--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        swap(arr, i++, j--);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, l, j);</span><br><span class="line"></span><br><span class="line">    sort(arr, l, j - <span class="number">1</span>);</span><br><span class="line">    sort(arr, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>双路快速排序算法已经是一个可以满足所有场景的快速排序算法了。</p><p>但是这还不够完美，还是刚刚的例子，如果数组中全部元素都相同的话，虽然可以满足O(nlogn)这个级别的速度实现排序，但是如果全部元素都相同的话快速排序还可以做到O(n)级别的时间复杂度。</p><p>于是最终版本：<strong>三路快速排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机标兵（针对完全有序数组所进行的优化）</span></span><br><span class="line">    SortingHelper.swap(arr, l, l + random.nextInt(r - l + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lt = l, i = l + <span class="number">1</span>, gt = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; gt) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arr[i].compareTo(arr[l]) &lt; <span class="number">0</span>) </span><br><span class="line">            SortingHelper.swap(arr, ++lt, i++);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[i].compareTo(arr[l]) &gt; <span class="number">0</span>) </span><br><span class="line">            SortingHelper.swap(arr, i, --gt);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i++;</span><br><span class="line">    &#125;</span><br><span class="line">    SortingHelper.swap(arr, l, lt);</span><br><span class="line"></span><br><span class="line">    sort(arr, l, lt - <span class="number">1</span>);</span><br><span class="line">    sort(arr, gt, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本来像是这样的排序算法在网上搜个快速排序能找到很多的博客在详细的说明快速排序的实现、特点、性能、时间复杂度等等，但还是决定要自己写一篇博客来讲讲这个算法，实际上是想要分享一些在学习这个算法的过程中一些让我感到惊讶的地方。&lt;/p&gt;
&lt;p&gt;也正是因为这样的一些比较独特的，比较不可思议却又是合乎情理的存在才让算法变得更神秘，更吸引人了。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://www.wrp.cool/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序" scheme="https://www.wrp.cool/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>递归</title>
    <link href="https://www.wrp.cool/posts/38362/"/>
    <id>https://www.wrp.cool/posts/38362/</id>
    <published>2021-05-30T06:39:51.000Z</published>
    <updated>2021-07-09T12:46:50.284Z</updated>
    
    <content type="html"><![CDATA[<p>大家应该都听过这么一个故事：</p><blockquote><p>从前有座山，山上有座庙，庙里有个老和尚和一个小和尚，老和尚在给小和尚讲一个故事，故事是什么呢？故事就是：从前有座山，山上有座庙，庙里有个老和尚和一个小和尚，老和尚在给小和尚讲一个故事，故事是什么呢？故事就是：从前有座山，山上有座庙，庙里有个老和尚和一个小和尚，老和尚在给小和尚讲一个故事，故事是什么呢？故事就是：…..</p></blockquote><p>也都应该经历过这么一个场景：</p><blockquote><p>有一些理发店里面呢，会有两个镜子相对的情况，镜子A里面可以看到镜子B，镜子B里面又可以看到镜子A，镜子A跟镜子B之间互相反射的循环反反复复的无穷无尽。</p></blockquote><p>我认为这可以算是现实世界中的递归现象。当然了，现实世界中类似于这样的现象并不少见。我觉得发明了递归算法的人一定也是在这其中的某一个场景或者是某一个故事下获得的灵感。</p><p><font color=blue>毕竟，计算机科学就是一种对于现实世界的抽象。</font></p><a id="more"></a><hr><p>学习计算机的同学所接触到的第一个递归算法应该都是递归求阶乘或者是数组求和这样的算法。虽然求阶乘或者是求和这只是很简单的递归代码，但是递归算法该有的，它也一样都没有落下。其实这样的功能只需要一层简单的循环就可以搞定，递归算法在这里反而是降低了代码的可读性，并没有为我们带来实际上的好处。<br><font color=#aaa>这里并不是不鼓励同学们使用递归来编写逻辑代码，而是希望不要过度设计自己的代码，还是那句话，刚刚好的才是最美：）</font></p><p><font size=5 ><strong>递归</strong></font> <a href="https://baike.baidu.com/item/%E9%80%92%E5%BD%92" target="_blank" rel="noopener">百度百科</a></p><blockquote><p>程序调用自身的编程技巧称为递归（ recursion）。递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。<strong>一般来说，递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。</strong></p></blockquote><p>结合一下递归求阶乘的代码理解一下上面百度百科的这段话，特别是最后一句话。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归求阶乘</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个简单的递归代码，但是麻雀虽小，却也五脏俱全。在这个例子中，<strong>边界条件、递归前进段和递归返回段</strong>都是很明确的。</p><ul><li><strong>边界条件：</strong>n == 1</li><li><strong>递归前进段：</strong>每次调用 <code>factorial(n - 1)</code> 时递归算法就前进一个函数单位</li><li><strong>递归返回段：</strong>当<code>n-1</code>减到<code>n==1</code>的时候，也就是if条件成立返回1的时候，<code>factorial(n - 1)</code>开始返回，每次返回，递归就结束一次<code>factorial(n - 1)</code>函数的调用，也就是返回一个函数单位。</li></ul><blockquote><p>简单一些来理解的话：递归无非就是一个满足了<strong>直接或者是间接的调用自身、以及在某个时候会结束对自身调用</strong>这两个条件的函数，仅此而已。</p></blockquote><p> 如果要我一句话来描述递归算法的话，我会说：<font color=blue>比起循环，这是一种更能够提高代码可读性的循环。</font></p><p> 我认为递归所能完成的逻辑，换成循环来做这样的事情甚至效率上还要更高一些，因为循环并不需要额外的方法调用的成本。但是在某些复杂的场景下，使用递归会让我们的代码变得非常简洁易于理解，比如：二叉树的前、中、后序的遍历；求一个二叉树的节点个数等等。</p><p> 但是递归也有一个非常明显的缺点，那就是几乎所有的编程语言的函数调用栈都有一个明确的大小，这就导致了递归函数的调用层数不能超出这个大小，否则会产生一个栈内存的溢出，在Java中这是一个叫做<code>StackOverflowError</code>的异常。</p><hr><p><font size=5 ><strong>递归函数的宏观语义</strong></font></p><p>递归的本质实际上就是将一个问题不断的拆解成一个一个的小的问题，直到最后的一个问题小到不能再小了，这个时候我们可以很容易的解决这个问题，将这个问题的解决结果返回给上一个问题，解决掉上一个问题之后再解决上上个问题以此类推，最终解决我们的问题。<strong>拆解问题的过程也就是递归前进段，解决掉最基本问题开始返回的阶段也就是递归返回段。</strong></p><p>更多的时候我喜欢把递归函数理解成一个单元，也就是递归单元。因为递归函数调用自身后还是走一遍自身的逻辑，每次递归调用在逻辑上并没有产生任何的变化，相应的我们只是改变了每次调用的参数而已。<strong>将递归函数拆解成的一个一个的小问题的这个步骤，就体现在每次调用递归函数的参数列表都要比上一次的参数列表要更简单一点点。</strong></p><p>很多时候编写递归逻辑的时候都是因为递归调用自身的这个动作会令我们感到很迷惑，没有办法理解到这一步操作是怎么执行的。我第一次接触二叉树前序遍历的代码的时候就是倒在了这一步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树前序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prevOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    System.out.print(node);</span><br><span class="line">    prevOrder(node.left);</span><br><span class="line">    prevOrder(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我刚刚开始看这代码的时候我完全无法理解为什么上面这段代码为什么会以中、左、右的方式输出一个二叉树，甚至我完全不能够明白这段代码的逻辑。原因是我自己的思维跟着递归函数一起被递归进去了，一直试图去理解每次递归进去之后发生了什么事情，而递归函数的逻辑一直没变。就像是开头的哪个老和尚讲故事一样，我完全没办法跳出递归逻辑。</p><p><font color=blue>但是，如果能从宏观的角度来看这段代码，就舒服多了。</font></p><ul><li><strong>首先，明白我们写的递归函数是要完成一个什么样的功能。</strong></li><li><strong>然后，不要去研究递归进去的逻辑是什么样的，仅仅只看第一层逻辑。</strong></li><li>因为递归进去的逻辑跟第一层的逻辑是完全一样的。</li></ul><p>如果要把 <code>prevOrder</code> 这个递归函数所做的事情理解成一个递归单元的话，我们只需要整理出这个函数所要实现的功能就可以理解这个递归函数的逻辑。</p><p><font size=4><strong>Q&amp;A Time</strong></font></p><ul><li><strong>Q：prevOrder这个函数的功能是什么？</strong></li><li>A：按照中、左、右的顺序输出一棵二叉树。</li><li><strong>Q：第7行的逻辑是什么？</strong></li><li>A：输出当前节点。</li><li><strong>Q：第8行的逻辑是什么？</strong></li><li>A：按照中、左、右的顺序输出当前节点的左子树。</li><li><strong>Q：第9行的逻辑是什么？</strong></li><li>A：按照中、左、右的顺序输出当前节点的右子树。</li></ul><blockquote><p>看到这里如果还不能够明白这个递归逻辑的话，我建议在纸上画一棵高度为3，7个节点的满二叉树然后按照上面 Q&amp;A 再结合代码依次访问一下这棵二叉树上的各个节点，你也许能更加直观的感受什么是递归的宏观语义。</p></blockquote><p>我所理解的递归函数的宏观语义是：</font></p><ul><li><p>将一个大的问题一点一点的拆分成许多个小的问题，或者说是抽象成多个小问题，<strong>每一个问题就是一个递归单元，每一个递归单元在逻辑上都是相同的，唯一不同的只是参数列表。</strong></p></li><li><p>在这个例子中，前序遍历当前节点、前序遍历当前节点的左子树、前序遍历当前节点的右子树，这是<strong>完完全全相同的逻辑。</strong></p></li><li><p>当我们能够按照这种思维来解读递归代码的话，我们可以完全不关心递归调用里面的逻辑是怎样的，递归调用也就可以理解成为一种普通的函数调用。</p></li></ul><hr><p><font size=5 ><strong>如何编写一个递归程序？</strong></font></p><p>借助力扣第206号问题（<a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">反转链表</a>）来讲述如何梳理出递归函数的宏观语义以及怎么编写递归函数。</p><blockquote><p>给你<strong>单链表</strong>的头节点 <code>head</code> 请你反转链表，并返回反转后的链表<br><strong>示例一：</strong><br>输入：head = (1) -&gt; (2) -&gt; (3) -&gt; (4) -&gt; (5) -&gt; NULL<br>输出：head = (5) -&gt; (4) -&gt; (3) -&gt; (2) -&gt; (1) -&gt; NULL<br><strong>示例二：</strong><br>输入：head = (1) -&gt; (2) -&gt; NULL<br>输出：head = (2) -&gt; (1) -&gt; NULL<br><strong>示例三：</strong><br>输入：head = (1) -&gt; NULL<br>输出：head = (1) -&gt; NULL<br><strong>示例四：</strong><br>输入：head = NULL<br>输出：head = NULL</p></blockquote><p>如果一个问题已经明确了要使用递归来求解的话，我们第一步要做的就是找出这个拆解后最基本的那个问题，对于反转链表的这个问题来说，显而易见最基本的问题就是当链表为空或者是链表只有一个节点的情况。一个空链表反转过后还是一个空链表，一个只有一个节点的链表反转过后还是只有一个节点。找出最基本的问题只是递归函数中最基础的部分，如果连最基本的问题都找不出来的话，那么几乎可以断定这个问题无法使用递归求解。</p><p>完成了最基本的部分接下来才是一个如何编写一个递归函数的重头戏，<font color=blue>将递归函数单元化，也就是找出这个递归函数的宏观语义，清楚这个递归函数要表达什么。</font>将递归函数看作是一个单元之后其实就不需要再考虑我们要求解的这个问题具体是什么了，解决问题的重点就放在了怎么解决一个一个拆解出来的小问题了。</p><ul><li>这里我再啰嗦一下解释一下示例一这个例子：</li><li>反转前：<code>head</code> 的值为1，指向了值为2的节点，值为2的节点指向了值为3的节点…最终指向NULL</li><li>反转后：<code>head</code> 的值为5，指向了值为4的节点，值为4的节点指向了值为3的节点…最终指向NULL</li></ul><p>假如我们现在处于 <code>(3)</code> 这个节点，结合递归函数的宏观语义来看一下此时链表的状态。前面的 <code>(1)</code> 和 <code>(2)</code> 节点是没有变化的，因为我们现在处于 <code>(3)</code> 这个节点，还没有反转到 <code>(1)</code> 和 <code>(2)</code> 。<font color=blue>但是对于已经反转过的 <code>(4)</code> 和 <code>(5)</code> 来说，应该是 <code>NULL &lt;- (4) &lt;- (5)</code> 这个样子的。</font>而此时的 <code>(3)</code> 这个节点仍然是指向了 <code>(4)</code> 这个节点的。</p><p>好了，分析到此为止，答案已经是显而易见的了。当我们处于 <code>(3)</code> 这个节点的时候，我们只需要将 <code>(3)</code> 这个节点当作是已经反转完成的链表的下一个待反转节点再将 <code>(3)</code> 这个节点反转过来就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)  <span class="comment">// 最基本的问题</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode rev = reverseList(head.next);  <span class="comment">// 得到已经反转完成的链表</span></span><br><span class="line">        head.next.next = head;                  <span class="comment">// 将当前节点挂接在已经反转完成的链表的下一个节点，注意：head.next此时指向的是已经反转完成的链表的尾节点。</span></span><br><span class="line">        head.next = <span class="keyword">null</span>;                       <span class="comment">// 执行到这一步的时候，head已经挂载到反转完成链表的尾节点的位置了，但是链表尾节点必须指向null，所以令 head.next = null</span></span><br><span class="line">        <span class="keyword">return</span> rev;                             <span class="comment">// 返回已经反转完成的链表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的这段代码也就是力扣上第206号问题的答案，有兴趣的同学可以将代码复制到力扣上第206号问题的解答区中去验证结果。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;大家应该都听过这么一个故事：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从前有座山，山上有座庙，庙里有个老和尚和一个小和尚，老和尚在给小和尚讲一个故事，故事是什么呢？故事就是：从前有座山，山上有座庙，庙里有个老和尚和一个小和尚，老和尚在给小和尚讲一个故事，故事是什么呢？故事就是：从前有座山，山上有座庙，庙里有个老和尚和一个小和尚，老和尚在给小和尚讲一个故事，故事是什么呢？故事就是：…..&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也都应该经历过这么一个场景：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有一些理发店里面呢，会有两个镜子相对的情况，镜子A里面可以看到镜子B，镜子B里面又可以看到镜子A，镜子A跟镜子B之间互相反射的循环反反复复的无穷无尽。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我认为这可以算是现实世界中的递归现象。当然了，现实世界中类似于这样的现象并不少见。我觉得发明了递归算法的人一定也是在这其中的某一个场景或者是某一个故事下获得的灵感。&lt;/p&gt;
&lt;p&gt;&lt;font color=blue&gt;毕竟，计算机科学就是一种对于现实世界的抽象。&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://www.wrp.cool/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="递归" scheme="https://www.wrp.cool/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="算法" scheme="https://www.wrp.cool/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>lambda 表达式</title>
    <link href="https://www.wrp.cool/posts/47234/"/>
    <id>https://www.wrp.cool/posts/47234/</id>
    <published>2021-05-23T01:12:50.000Z</published>
    <updated>2021-09-02T02:42:57.820Z</updated>
    
    <content type="html"><![CDATA[<p>jdk1.8之后才出现了lambda表达式这个东西，这说明了lambda表达式实际上并不是编程中必须掌握的一项技能，但是既然jdk1.8之后支持了lambda表达式，那么说明lambda表达式肯定是会有其独特的用处。其实lambda表达式最重要的就是让我们写的代码更加的优雅，看起来更加的舒服。同时，使用lambda表达式也能在一定程度上少写一些代码，提高一些编程的效率。不过我还是认为lambda表达式最重要的是让代码变得更加优雅。</p><p>关于lambda表达式的一些基本的使用在网上实际上已经有了很多的博客或者教程，本文就不再赘述这些别人已经写过的东西了，主要还是想聊一下自己在学习lambda表达式过程中的一些理解。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="number">2021</span>);</span><br><span class="line">    list.add(<span class="number">0</span>);</span><br><span class="line">    list.add(<span class="number">5</span>);</span><br><span class="line">    list.add(<span class="number">23</span>);</span><br><span class="line">    list.forEach(item -&gt; System.out.print(item));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：20210523</span></span><br></pre></td></tr></table></figure><p><code>item -&gt; System.out.print(item)</code> 这就是一个最基本的lambda表达式，这实际上是一个抽象方法的实现，只不过是写成这个样子，看起来更加优雅了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">        action.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的是forEach方法的接口定义，具体的实现内容先不看，先看看forEach的参数列表中的 <code>Consumer&lt;? super T&gt; action</code> 这个东西，它叫函数式接口。</p><blockquote><p>在《Java核心技术 卷一》这本书中对函数式接口的定义是这样的：<br>对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式。<br>这种接口称为<strong>函数式接口</strong>（functional interface）</p><p>粗浅的理解可以是：一个接口中如果只定义了一个抽象方法的话，那么这个接口就是一个函数式接口。</p></blockquote><p>看看这个 Consumer 所谓的函数式接口中唯一定义的一个抽象方法长什么样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br></pre></td></tr></table></figure><p>上面说的 <code>item -&gt; System.out.print(item)</code> 这个东西是对一个抽象方法的实现，实际上就是对 <code>accept</code> 这个抽象方法的实现，我以我的理解来尝试复原这个实现，将它变成我们平时见到的普通的方法实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">    System.out.print(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么看起来一下子清晰多了，forEach方法将这个lambda表达式解析成了它所需要的参数，也就是Consumer接口的实现，之后再调用这个方法来遍历List集合。</p><p><em>当然具体的遍历方式我们也看到了，底层还是使用的forEach循环来遍历这个集合，所以在这里顺带提一下，除非遍历集合的内容只要一行代码就可以完成，像是我上面这样子，否则使用lambda表达式来遍历集合的话就不是很必要了。因为这并不会让我们的代码变得优雅或者是提高效率，反而平白的增加的后期维护的成本，得不偿失。</em></p><blockquote><p>思考一个问题：<br><font color = blue>如果有一个方法的代码刚刚好可以实现accept这个抽象接口，能不能直接把这个方法的代码作为accept的实现传递给forEach方法呢？</font></p></blockquote><p>还是上面的这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="number">2021</span>);</span><br><span class="line">    list.add(<span class="number">0</span>);</span><br><span class="line">    list.add(<span class="number">5</span>);</span><br><span class="line">    list.add(<span class="number">23</span>);</span><br><span class="line">    list.forEach(System.out::print);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：20210523</span></span><br></pre></td></tr></table></figure><p><code>System.out::print</code> 也是一种lambda表达式，在这段代码中，这两种实现方式的效果是完全一样的。</p><blockquote><p><code>::</code>表示的是方法的引用，实际上就是将<code>System.out</code>对象中的<code>print</code>方法直接作为抽象方法<code>accept</code>的实现传到forEach中去。</p></blockquote><p>结合这两个例子来看，lambda表达式中我们实际上只是传递的一个代码段，而不是接口的实现，底层的jvm会自动的根据上下文帮助我们封装成接口的实现以供方法调用，仅此而已。我认为这应该就是lambda表达式的真面目。</p><hr><p>除了传递方法的引用进去，lambda表达式还可以直接传递一个构造器。像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 声明两个函数式接口 (此处借用 java.util.function.Supplier 函数接口)*/</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Supplier1</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Supplier2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">(String str)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Main */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Main</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"执行无参构造器"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Main</span><span class="params">(String str)</span> </span>&#123; System.out.println(<span class="string">"执行有参构造器"</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Supplier1&lt;Main&gt; s1 = Main::<span class="keyword">new</span>;</span><br><span class="line">        Supplier2&lt;Main&gt; s2 = Main::<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">        s1.get();</span><br><span class="line">        s2.get(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">执行无参构造器</span></span><br><span class="line"><span class="comment">执行有参构造器</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>上面的代码就是调用了Main类中对应的构造器来构建一个Main的实例并返回，写法也非常的简单，直接双冒号调用new关键字即可。具体的调用哪一个构造器会根据上下文自动选择跟函数式接口参数对应的上的构造器。</p><p>上面的使用lambda表达式创建的Supplier1对象和Supplier2对象的方式实际上等价于下面的样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Supplier1&lt;Main&gt; s1 = <span class="keyword">new</span> Supplier1&lt;Main&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Main <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Main();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Supplier2&lt;Main&gt; s2 = <span class="keyword">new</span> Supplier2&lt;Main&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Main <span class="title">get</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Main(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>再来看看lambda表达式中this的指向问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"Test"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        r.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Runnable r = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        r.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Main main = <span class="keyword">new</span> Main();</span><br><span class="line">        main.test1();</span><br><span class="line">        main.test2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Main"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">Test</span></span><br><span class="line"><span class="comment">Main</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>先借书里的一句话来说明一下this的指向：在lambda表达式中，this的使用并没有任何特殊之处。lambda表达式的作用域嵌套在test2方法中，与出现在这个方法中的其他位置一样，lambda表达式中this的含义并没有发生变化。</p><p>对于这个实际上很好理解，<font color=blue>lambda表达式中的this出现在任何地方都跟哪个地方本来的this是一样的，并没有因为lambda而发生不同。</font>这实际上也从另外的角度说明了lambda表达式仅仅只是传递了一段代码过去，而没有做其他处理。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;jdk1.8之后才出现了lambda表达式这个东西，这说明了lambda表达式实际上并不是编程中必须掌握的一项技能，但是既然jdk1.8之后支持了lambda表达式，那么说明lambda表达式肯定是会有其独特的用处。其实lambda表达式最重要的就是让我们写的代码更加的优雅，看起来更加的舒服。同时，使用lambda表达式也能在一定程度上少写一些代码，提高一些编程的效率。不过我还是认为lambda表达式最重要的是让代码变得更加优雅。&lt;/p&gt;
&lt;p&gt;关于lambda表达式的一些基本的使用在网上实际上已经有了很多的博客或者教程，本文就不再赘述这些别人已经写过的东西了，主要还是想聊一下自己在学习lambda表达式过程中的一些理解。&lt;/p&gt;</summary>
    
    
    
    <category term="Java 基础" scheme="https://www.wrp.cool/categories/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="lambda" scheme="https://www.wrp.cool/tags/lambda/"/>
    
  </entry>
  
  <entry>
    <title>选择排序 &amp; 插入排序</title>
    <link href="https://www.wrp.cool/posts/21500/"/>
    <id>https://www.wrp.cool/posts/21500/</id>
    <published>2021-05-14T12:41:43.000Z</published>
    <updated>2021-05-23T01:14:27.052Z</updated>
    
    <content type="html"><![CDATA[<p>具体的选择排序和插入排序的代码我已经放<a href="https://github.com/wangruipeng-wrp/algorithm-and-data-structure/tree/master/src/Sort" target="_blank" rel="noopener">github</a>上了，本文不会针对具体的代码实现展开讨论。更多的是想聊一些在学习这两个算法过程中的自身一些心态的变化。</p><a id="more"></a><p>作为铺垫，还是简单讲一下插入排序和选择排序</p><blockquote><p><strong>选择排序：</strong><br>每次都找出一个最小的元素按照顺序排好</p></blockquote><blockquote><p><strong>插入排序：</strong><br>首先假装第一个元素是有序的，然后每次从无序的数组中拿出一个元素插入到有序的数组里面去</p></blockquote><p>我在学习这两个算法的时候是先学的选择排序，再学的插入排序。在还没有深入理解的情况下，<font color=Blue>我其实想当然的认为选择排序算法的性能就一定是要优于插入排序算法的。</font></p><p>我这么想的原因其实也非常简单，选择排序每次循环在做的事情仅仅只是比较两个元素的大小，直到最后找出最小的哪个元素，最后再交换两个元素就可以完成一轮排序，是通过一种比较的方式来实现排序这样的功能。</p><p>反过来看插入排序呢，在一开始需要保存待插入的元素，然后再往前一个个的比较，如果比较的元素比待插入的元素要大，那么就覆盖掉他后面的哪个元素。</p><p>这么粗浅的看，同样的乱序数组，插入排序和选择排序所使用的比较的次数在极端的情况下（也就是倒序数组的情况下）是相等的。</p><p>而选择排序呢，每次比较完成之后仅仅需要一次交换位置的操作即可完成本轮的排序，但是反观插入排序呢，每一次都需要有一个覆盖掉后面元素的动作，直到找到正确的位置插入了才可以完成本轮的排序。</p><p>这么一个想法出现在我脑海里之后，我几乎是断定的选择排序在性能上是要优于插入排序的。</p><p><font color=Blue>但是，如果现在是一个完全有序的数组来进行排序的呢，或者说是一个近乎有序的数组在排序呢？</font></p><p>这个时候选择排序还是必须每次都比较剩下的元素找到最小的哪一个，唯一的不同是交换元素位置的操作变少了。</p><p>再看看插入排序呢，每次都只需要比较一下前面的一个元素就好了，交换位置的操作同样变少了。但是有序的情况下，插入排序有着一个非常巨大的优势就是比较的操作也变的很少。</p><p><font color=red>于是，当对一个完全有序或者是近乎有序的数组排序时，插入排序的性能是要优于选择排序的。</font></p><p>上面是对于选择排序和插入排序在前几天学习的过程中自己对于两者性能之间的一些看法。</p><hr><p>实际上不仅仅是在这个例子中，在平时中我很多时候也总是会太果断的认为一个事情，直到举一个反例出来之后被啪啪打脸。</p><p>对于这样子的情况说的好听一些我认为是对于自己逻辑思维能力的一种莫名的自信，说的直白一些的话实际上是自己的一种无知造成了这样莫名的自信。</p><p>我认为这并不是一个好的习惯，今天在这里留下这样的一篇博客，作为一个见证：<br><font color=Blue>希望自己在今后能保持谦虚，保持好学，一点一点的变成一个厉害的人：）</font></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;具体的选择排序和插入排序的代码我已经放&lt;a href=&quot;https://github.com/wangruipeng-wrp/algorithm-and-data-structure/tree/master/src/Sort&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github&lt;/a&gt;上了，本文不会针对具体的代码实现展开讨论。更多的是想聊一些在学习这两个算法过程中的自身一些心态的变化。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://www.wrp.cool/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序算法" scheme="https://www.wrp.cool/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="选择排序" scheme="https://www.wrp.cool/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    
    <category term="插入排序" scheme="https://www.wrp.cool/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>原型模式</title>
    <link href="https://www.wrp.cool/posts/54363/"/>
    <id>https://www.wrp.cool/posts/54363/</id>
    <published>2021-05-02T02:06:35.000Z</published>
    <updated>2021-05-07T13:50:01.874Z</updated>
    
    <content type="html"><![CDATA[<p>原型模式简单来说就是以一个已经创建好的对象为原型，使用二进制流的方式复制这个对象。</p><a id="more"></a><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p><strong>借《设计模式之禅》这本书中一个例子来简述一下原型模式：</strong></p><p>先来想想一个业务场景，现在有一家银行想要对它的储户发送一封广告邮件，银行的储户比较多，大概几百万上千万个储户。每个储户发送一封邮件，其中邮件的内容都是一样的，不一样的是邮件的收件人邮箱，收件人称谓等一些属性不同，其他的属性都大同小异。其中将相同的部分抽取成一个邮件模板类。</p><p><strong>模板类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Template</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String subject = <span class="string">"xxx银行国庆大酬宾！！！"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String content = <span class="string">"把你的钱全部存到我们银行，我们帮你花掉它"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>邮件类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mail</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String subject;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String addresseeAddress;</span><br><span class="line">    <span class="keyword">private</span> String addresseeName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = Template.subject;</span><br><span class="line">        <span class="keyword">this</span>.content = Template.content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mail mail = <span class="keyword">new</span> Mail();</span><br><span class="line">        <span class="comment">// 发送一百万封邮件</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1_000_000</span>; i++) &#123;</span><br><span class="line">            mail.setAddresseeAddress(randomAddresseeAddress());</span><br><span class="line">            mail.setAddresseeName(randomAddresseeName());</span><br><span class="line">            sendMail(mail);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码实际上已经能够基本的实现我们想要的功能了，当然这得要有个非常非常重要的前提，那就是这个项目的甲方是一个比较将就的甲方。</p><p>看看上面的代码有什么问题，实际上没什么问题，就是慢了点，如果遇到这种百万级别千万级别的发送邮件的场景，使用单线程慢慢发的话可能得发一天甚至还不止。像这样的业务场景是必须使用多线程来发送邮件的，但是如果跟上面一样多个线程公用同一个mail对象的话那线程就不安全了。当然你可以选择创建多个mail对象来提供给每个线程，但是这真的大可不必，<strong>原型模式</strong>就是专门为了解决这样的业务场景而生的。</p><p><strong>使用原型模式来改造一下上面邮件类的代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mail</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String subject;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String addresseeAddress;</span><br><span class="line">    <span class="keyword">private</span> String addresseeName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = Template.subject;</span><br><span class="line">        <span class="keyword">this</span>.content = Template.content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对应的客户端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    Mail mail = <span class="keyword">new</span> Mail();</span><br><span class="line">    <span class="comment">// 发送一百万封邮件</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1_000_000</span>; i++) &#123;</span><br><span class="line">        Mail cloneMail = (Mail) mail.clone();</span><br><span class="line">        cloneMail.setAddresseeAddress(randomAddresseeAddress());</span><br><span class="line">        cloneMail.setAddresseeName(randomAddresseeName());</span><br><span class="line">        sendMail(mail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与原来的不同之处就是Mail类实现了覆盖了Object方法中的clone方法，客户端不再使用同一个对象发送邮件，而是通过clone方法获取一个新的对象。之所以不让客户端自己创建一个新对象是因为我们现在演示使用的Mail对象非常简单，如果是在真实的业务场景中，创建一个Mail邮件对象一定是一个相当复杂的过程，创建一个这样的对象对于计算机资源的开销也是非常大的。而现在我们需要创建的是百万甚至是千万级别的这样的对象，这对于资源的开销是相当巨大的。</p><p><strong>小结原型模式的适用场景：</strong></p><ul><li>类初始化需要消耗较多的资源，例如：计算资源、硬件资源等</li><li>创建对象的过程非常繁琐，需要准备较多的访问权限，或者是大量的数据</li><li>一个对象会提供给其他对象访问，而且各个调用者可能都会修改其中的值</li></ul><blockquote><p>在实际的项目开发中原型模式很少单独出现，一般是和工厂模式一起出现，通过原型模式创建一个对象再由工厂模式将这个对象提供给调用者。</p></blockquote><h1 id="浅克隆和深克隆"><a href="#浅克隆和深克隆" class="headerlink" title="浅克隆和深克隆"></a>浅克隆和深克隆</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prototype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; arrayList;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Prototype</span><span class="params">(ArrayList&lt;String&gt; arrayList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arrayList = arrayList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    arrayList.add(<span class="string">"A"</span>);</span><br><span class="line">    arrayList.add(<span class="string">"B"</span>);</span><br><span class="line"></span><br><span class="line">    Prototype prototypeTest = <span class="keyword">new</span> Prototype(arrayList);</span><br><span class="line">    Prototype cloneTest = (Prototype) prototypeTest.clone();</span><br><span class="line"></span><br><span class="line">    cloneTest.getArrayList().add(<span class="string">"C"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(prototypeTest.getArrayList());</span><br><span class="line">    System.out.println(cloneTest.getArrayList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行main方法后输出：</span><br><span class="line">[A, B, C]</span><br><span class="line">[A, B, C]</span><br></pre></td></tr></table></figure><p>通过上面的这个例子已经可以可以了解到clone方法仅仅只是克隆了对象的引用而已，而不是克隆了整个对象。通过clone方法得到的对象跟原来的对象中的引用数据类型都是指向同一片内存空间。</p><blockquote><p>clone方法相当于仅仅只是将这个对象栈内存中的数据复制一份存到一个新的引用类型的变量中而已。具体的栈内存和堆内存的关系在<a href="https://www.wrp.cool/posts/24923/">【JavaScript】数据类型</a>一文中有详细介绍。</p></blockquote><p>由于对克隆只是克隆了引用对象的地址而已，并没有深入去克隆这个对象中的引用，所以这种克隆方式称之为浅克隆。如果要实现对引用的克隆则需要修改clone方法，使其不仅克隆引用对象的地址，还能够克隆一个新的引用对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    Prototype prototype = (Prototype) <span class="keyword">super</span>.clone();</span><br><span class="line">    <span class="comment">// 克隆引用对象</span></span><br><span class="line">    prototype.arrayList = (ArrayList&lt;String&gt;) <span class="keyword">this</span>.arrayList.clone();</span><br><span class="line">    <span class="keyword">return</span> prototype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对每个需要深拷贝的对象再进行一次单独的克隆即可完成深克隆，此时原型对象和克隆对象之间分别享有两个不同的ArrayList对象，完成了对ArrayList对象的深克隆。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;原型模式简单来说就是以一个已经创建好的对象为原型，使用二进制流的方式复制这个对象。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://www.wrp.cool/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="创建型设计模式" scheme="https://www.wrp.cool/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="https://www.wrp.cool/posts/29125/"/>
    <id>https://www.wrp.cool/posts/29125/</id>
    <published>2021-04-23T13:51:13.000Z</published>
    <updated>2021-05-07T13:20:17.307Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>单例模式从名称上就很好理解：一个对象保证在内存中只有一个实例。<br>当然，如果是多线程的话也要保证多个线程在运行的过程当中这个实例只会被创建一次。</p><p>单例模式的实现也有两种，懒汉式和饿汉式。从名字上就很好区分，懒汉式就是延迟创建单例对象的一种方式，饿汉式就是即刻创建单例对象的方式。两种实现方式本文都说到。</p><a id="more"></a><h1 id="单线程中的单例模式"><a href="#单线程中的单例模式" class="headerlink" title="单线程中的单例模式"></a>单线程中的单例模式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazeSingleInstance</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LazeSingleInstance lazeSingleInstance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazeSingleInstance</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazeSingleInstance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazeSingleInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            lazeSingleInstance = <span class="keyword">new</span> LazeSingleInstance();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazeSingleInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单线程中的单例模式就只是这样子而已，非常简单。设计一个私有的构造函数是为了不让在外部创建这个类的实例，当然对外也需要提供一个可以获取类实例的方法，这也是单例模式中核心的方法，接下来也将围绕这个方法展开讨论。</p><p>这也是单例模式中最简单的实现，真正的难点在于多线程中如何保证多个线程运行过程中只创建一个实例。</p><h1 id="多线程中的单例模式"><a href="#多线程中的单例模式" class="headerlink" title="多线程中的单例模式"></a>多线程中的单例模式</h1><p>首先复现一个单例模式中可能出现的线程不安全问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazeSingleInstance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lazeSingleInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        lazeSingleInstance = <span class="keyword">new</span> LazeSingleInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lazeSingleInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>先介绍一下Java中new一个对象的过程都发生了什么事情：</strong><br>第一步：为这个对象分配内存。<br>第二步：初始化这个对象，也就是初始化对象里面的一些值。<br>第三步：将对象的地址赋值给创建这个对象的变量。</p></blockquote><p>在上面的这段代码当中，我们假设线程A执行到了第3行的第一步或者是第二步，而这时候刚刚好线程B执行到了第2行，由于线程A还没有为这个对象赋值，所以此时这个对象仍然是null的，那么线程B一样会执行到第三行代码。在这个过程当中，lazeSingleCase对象被创建了两次，违背了单例模式的设计原则。也就是发生了线程不安全的问题。</p><p>感兴趣的同学可以去实际的使用两个线程debug一下这段代码。<br>具体的多线程debug应该怎么操作可以参考<a href="https://blog.wrp.cool/posts/29198/" target="_blank" rel="noopener">【碎笔02】IDEA多线程调试</a>。</p><h2 id="第一次演进：使用-synchronized-关键字解决线程安全的问题。"><a href="#第一次演进：使用-synchronized-关键字解决线程安全的问题。" class="headerlink" title="第一次演进：使用 synchronized 关键字解决线程安全的问题。"></a>第一次演进：使用 synchronized 关键字解决线程安全的问题。</h2><p>具体的 synchronized 关键字的用法可以参考<a href="https://blog.wrp.cool/posts/10492/" target="_blank" rel="noopener">【Java并发】Synchronized关键字</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazeSingleInstance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lazeSingleInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        lazeSingleInstance = <span class="keyword">new</span> LazeSingleInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lazeSingleInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 getInstance() 方法上加了 synchronized 关键字之后保证了同一时间内只有一个线程能够执行方法内的代码，这样就解决了上述的线程不安全的问题。</p><p>但是 synchronized 关键字是加在 static 修饰的方法上的，这意味着锁住了这个类的class文件，这锁的范围太广了，消耗的资源太多。<br>这显然不是一个好的办法。</p><h2 id="第二次演进：将-synchronized-关键字移动至方法内部"><a href="#第二次演进：将-synchronized-关键字移动至方法内部" class="headerlink" title="第二次演进：将 synchronized 关键字移动至方法内部"></a>第二次演进：将 synchronized 关键字移动至方法内部</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazeSingleInstance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (LazeSingleInstance<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazeSingleInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            lazeSingleInstance = <span class="keyword">new</span> LazeSingleInstance();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lazeSingleInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以类锁的形式将创建单例对象的代码锁起来，这也保证了同一段时间内只有一个线程能够执行到创建对象的代码，也同样能够实现单例模式。<br>比起上面将 synchronized 直接加在方法上还得跟其他的加了 LazeSingleInstance.class 类锁的代码去竞争锁的情况在性能上已经是提升了很多了。</p><p><strong>思考一个问题：</strong><br>每个调用 getInstance() 方法的线程都得先等待拿到了锁才能够执行，懒汉式单例模式在仅仅只是在第一次调用这个对象时候才需要去创建这个对象，而现在每次都需要去判断对象是否存在，这显然是不合理的。</p><h2 id="第三次演进：双重检查锁"><a href="#第三次演进：双重检查锁" class="headerlink" title="第三次演进：双重检查锁"></a>第三次演进：双重检查锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazeSingleInstance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lazeSingleInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LazeSingleInstance<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lazeSingleInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                lazeSingleInstance = <span class="keyword">new</span> LazeSingleInstance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lazeSingleInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有兴趣的同学建议先自己分析一下上面的这段代码，这个也是一个比较取巧的一个设计了。</p><p>在外面加多一层 if 的判断，这样就不用每次调用 getInstance() 方法就得去等待 synchronized 锁了。<br>至此，双重检查锁也就设计完毕了。</p><blockquote><p><strong>介绍一个指令重排序的问题</strong><br>jvm 为了能够让 Java 的执行效率能够提高一些，在上面的 new 一个对象的过程，其中的第二步和第三步是有可能会颠倒过来的。也就是先为对象赋上地址值，再初始化这个对象。</p><p>看到这里的同学建议思考一个问题：双重检查锁中如果在创建对象的时候发生了指令重排序的问题，可能会导致什么情况。</p></blockquote><p><strong>答案揭晓：</strong><br>如果是在创建对象的时候先为对象赋上地址值，这个时候对象就已经不是 null 了，那么如果在还没有初始化的情况下，另外一个线程走到了第一个 if 的判断就会直接返回一个还没有初始化的对象。</p><h2 id="第四次演进：使用-volatile-关键字"><a href="#第四次演进：使用-volatile-关键字" class="headerlink" title="第四次演进：使用 volatile 关键字"></a>第四次演进：使用 volatile 关键字</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazeSingleInstance lazeSingleInstance;</span><br></pre></td></tr></table></figure><p>将这个单例对象使用 volatile 关键字去修饰即可解决指令重排序的问题。具体的 volatile 关键字的作用不久会聊到。<br>在这里先了解到 volatile 关键字可以限制在创建这个对象的时候禁止指令重排序即可。</p><h2 id="另外一种解决指令重排序的办法：使用静态内部类实现单例模式"><a href="#另外一种解决指令重排序的办法：使用静态内部类实现单例模式" class="headerlink" title="另外一种解决指令重排序的办法：使用静态内部类实现单例模式"></a>另外一种解决指令重排序的办法：使用静态内部类实现单例模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazeSingleInstance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazeSingleInstance</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> LazeSingleInstance lazeSingleInstance = <span class="keyword">new</span> LazeSingleInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazeSingleInstance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.lazeSingleInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其实也是另外的一种实现单例模式的方式。<br>由于Java中每个类对应唯一的Class文件，所以类的静态属性实际上只会随着类的加载而加载，之后就再也不会去创建这个对象了，也就实现了单例模式。<br>Java中类的加载肯定是只有唯一一次的，所以不管在创建这个类的时候有没有发生指令重排序，这个过程对外都是不可见的。也就解决了指令重排序的问题。</p><p>上面所说的单例模式都是懒汉式单例模式，可以看到单例对象都是在第一次调用的时候才会去创建的，是一个延迟加载的机制。<br>下面就来讲一下饿汉式单例模式。</p><h1 id="饿汉式单例模式"><a href="#饿汉式单例模式" class="headerlink" title="饿汉式单例模式"></a>饿汉式单例模式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstance</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> SingleInstance instance = <span class="keyword">new</span> SingleInstance();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleInstance</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleInstance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饿汉式单例模式实现起来也是比较简单，仅需要在类的初始化的时候直接创建单例对象即可。当然私有的构造函数和提供一个对外访问单例对象的接口还是必须要有的。</p><hr><p><strong>懒汉式和饿汉式的区别和各自的优缺点：</strong></p><ol><li>饿汉式中不存在线程安全问题，因为饿汉式随着类的加载而创建单例对象。</li><li>懒汉式相比与饿汉式更加能够把资源更好的利用起来，如果一个单例对象在一开始就创建出来但是长期不去使用的话，一直驻留在内存中肯定是要比使用到再去创建要耗费掉一些内存空间的。</li><li>当然相比之下我感觉使用静态内部类来实现的单例模式是一种比较好的方式。</li></ol><hr><h1 id="通过反射破坏单例模式"><a href="#通过反射破坏单例模式" class="headerlink" title="通过反射破坏单例模式"></a>通过反射破坏单例模式</h1><p>关于一些反射的知识在<a href="https://blog.wrp.cool/posts/25346/" target="_blank" rel="noopener">【Java基础】反射</a>这篇文章中已经说的很详细了，这方面不了解的同学可以再补补习。</p><blockquote><p>具体的反射如何破坏单例模式的代码这里不再去实现，只做一些原理讲解。不管是懒汉式单例模式还是饿汉式单例模式，都必须得要有一个私有的构造方法，这是为了防止从外部直接new出来单例对象。但这怎么说呢，防君子不防小人吧，如果是通过反射的话很容易能够创建一个新的单例对象出来。而懒汉式单例模式对于反射攻击则是完全没有办法防御的，饿汉式单例模式还能够通过在构造方法做一个判断去防止放射攻击。</p></blockquote><p><strong>演示一下饿汉式单例模式防止反射攻击：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstance</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingleInstance instance = <span class="keyword">new</span> SingleInstance();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"禁止使用反射创建对象！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleInstance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的就是饿汉式防止反射攻击的一种方式，在私有构造方法中判断一下单例对象是否为空，由于饿汉式单例模式是在类加载时直接创建的单例对象，所以一旦通过反射调用私有构造方法的话肯定会抛出异常结束程序运行。</p><p>但是没有绝对安全的系统，即使是这样，单例模式还是不够安全的。</p><h1 id="使用枚举类防止防止反射攻击"><a href="#使用枚举类防止防止反射攻击" class="headerlink" title="使用枚举类防止防止反射攻击"></a>使用枚举类防止防止反射攻击</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumSingleInstance &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    EnumSingleInstance() &#123;</span><br><span class="line">        <span class="keyword">this</span>.data = <span class="keyword">new</span> Object();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object instance = EnumSingleInstance.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是通过一个Enum类来实现的单例模式，这也是《Effective Java》这本书中推荐的实现单例的方式。这种实现单例的方式可以有效的防止反射和对象的序列化和反序列化对单例模式造成的破坏。具体的原因呢，笔者现在也还是不大明白，先在这里留个坑吧，以后再补好了。</p><p>关于单例模式其实很多学习Java的同学在刚接触Java不久，大概是在学完面向对象之后，应该都会实现一下懒汉式单例模式和饿汉式单例模式。在哪个时候来看单例模式实际上是很简单的一个设计模式，但是单例模式中关于多线程的处理，还有关于Java对象序列化与反序列化的处理，以及如何防止反射破坏单例模式。这些可就一点都不简单了，也说明了越学越深入了吧。</p><p>本来还想聊一下单例模式关于Java对象的序列化与反序列化的，但是我自己暂时也还是没学到这一部分，所以呢就也是留个坑在这里吧，等着以后学到了再来补。有兴趣的同学也可以点击文末的“欢迎打扰”一起交流学习。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;单例模式从名称上就很好理解：一个对象保证在内存中只有一个实例。&lt;br&gt;当然，如果是多线程的话也要保证多个线程在运行的过程当中这个实例只会被创建一次。&lt;/p&gt;
&lt;p&gt;单例模式的实现也有两种，懒汉式和饿汉式。从名字上就很好区分，懒汉式就是延迟创建单例对象的一种方式，饿汉式就是即刻创建单例对象的方式。两种实现方式本文都说到。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://www.wrp.cool/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="创建型设计模式" scheme="https://www.wrp.cool/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Java" scheme="https://www.wrp.cool/tags/Java/"/>
    
    <category term="设计模式" scheme="https://www.wrp.cool/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="创建型" scheme="https://www.wrp.cool/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B/"/>
    
    <category term="单例模式" scheme="https://www.wrp.cool/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="懒汉式单例模式" scheme="https://www.wrp.cool/tags/%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="饿汉式单例模式" scheme="https://www.wrp.cool/tags/%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="双重检查锁" scheme="https://www.wrp.cool/tags/%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81/"/>
    
    <category term="指令重排序" scheme="https://www.wrp.cool/tags/%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>建造者模式</title>
    <link href="https://www.wrp.cool/posts/25434/"/>
    <id>https://www.wrp.cool/posts/25434/</id>
    <published>2021-04-17T11:31:08.000Z</published>
    <updated>2021-05-07T13:17:03.713Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>首先来看一下百度百科关于建造者模式的描述。（<a href="https://baike.baidu.com/item/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/3229729?fr=aladdin" target="_blank" rel="noopener">建造者模式，百度百科</a>）</p><p><strong>实用范围：</strong><br>1、当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。<br>2、当构造过程必须允许被构造的对象有不同表示时。</p><p><strong>建造者模式中的4个角色：</strong><br>1、Builder：为创建一个产品对象的各个部件指定抽象接口。<br>2、ConcreteBuilder：实现Builder的接口以构造和装配该产品的各个部件，定义并明确它所创建的表示，并提供一个检索产品的接口。<br>3、Director：构造一个使用Builder接口的对象。<br>4、Product：表示被构造的复杂对象。ConcreteBuilder创建该产品的内部表示并定义它的装配过程，包含定义组成部件的类，包括将这些部件装配成最终产品的接口。</p><hr><blockquote><p>以上是百度百科中关于建造者模式的一些描述，下面说一些我自己的理解。</p></blockquote><a id="more"></a><p><strong>实用范围：</strong><br>1、创建对象部分的代码必须与使用到这个对象的代码解耦。<br>2、一个对象必须有多种不同的装配方式，这不仅仅是简单的参数不同。</p><p><strong>建造者模式中的4个角色：</strong><br>1、Product（产品）：要创建的对象，是一个具体的实体类。<br>2、Builder（建造者）：根据创建对象的过程实际抽象出来的接口。<br>3、ConcreteBuilder（具体建造者）：实现builder接口，实际创建对象的类。<br>4、Director（导演）：在完成上面的三个对象的工作之后交由Director类来创建对象，由此达到创建对象的过程与实际使用对象的代码解耦的目的。</p><h1 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h1><p>这里实际以创建一个手机对象为例子来用代码描述一下建造者模式</p><p><strong>手机类</strong>，对应的是Product角色：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBrand</span><span class="params">(String brand)</span> </span>&#123; <span class="keyword">this</span>.brand = brand; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNum</span><span class="params">(String num)</span> </span>&#123; <span class="keyword">this</span>.num = num; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> brand + <span class="string">"Phone&#123;name='"</span> + name + <span class="string">"', num='"</span> + num + <span class="string">"'&#125;"</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>由创建手机的过程抽象出来的抽象类</strong>，对应的是Builder角色：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">builderPhoneName</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">builderPhoneNum</span><span class="params">(String num)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Phone <span class="title">makePhone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>两个实际创建手机类的创建者</strong>，分别创建华为手机和小米手机，对应的是ConcreteBuilder角色：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HUAWEIPhoneBuilder</span> <span class="keyword">extends</span> <span class="title">PhoneBuilder</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HUAWEIPhoneBuilder</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>.phone.setBrand(<span class="string">"HUAWEI"</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">builderPhoneName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.phone.setName(name); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">builderPhoneNum</span><span class="params">(String num)</span> </span>&#123; <span class="keyword">this</span>.phone.setNum(num); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">makePhone</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.phone; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MIPhoneBuilder</span> <span class="keyword">extends</span> <span class="title">PhoneBuilder</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MIPhoneBuilder</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>.phone.setBrand(<span class="string">"MI"</span>); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">builderPhoneName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.phone.setName(name); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">builderPhoneNum</span><span class="params">(String num)</span> </span>&#123; <span class="keyword">this</span>.phone.setNum(num); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">makePhone</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.phone; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>创建手机的类</strong>，对应的是Director角色：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneDirector</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PhoneBuilder phoneBuilder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PhoneDirector</span><span class="params">(PhoneBuilder phoneBuilder)</span> </span>&#123; <span class="keyword">this</span>.phoneBuilder = phoneBuilder; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">makePhone</span><span class="params">(String name, String num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.phoneBuilder.builderPhoneName(name);</span><br><span class="line">        <span class="keyword">this</span>.phoneBuilder.builderPhoneNum(num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.phoneBuilder.makePhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>以上准备工作完成，接下来测试一下效果怎么样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PhoneDirector HUAWEIDirector = <span class="keyword">new</span> PhoneDirector(<span class="keyword">new</span> HUAWEIPhoneBuilder());</span><br><span class="line">        Phone HUAWEIPhone = HUAWEIDirector.makePhone(<span class="string">"P30"</span>, <span class="string">"135 0000 0000"</span>);</span><br><span class="line"></span><br><span class="line">        PhoneDirector MIDirector = <span class="keyword">new</span> PhoneDirector(<span class="keyword">new</span> MIPhoneBuilder());</span><br><span class="line">        Phone MIPhone = MIDirector.makePhone(<span class="string">"MI11"</span>, <span class="string">"135 1111 1111"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(HUAWEIPhone);</span><br><span class="line">        System.out.println(MIPhone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HUAWEIPhone&#123;name&#x3D;&#39;P30&#39;, num&#x3D;&#39;135 0000 0000&#39;&#125;</span><br><span class="line">MIPhone&#123;name&#x3D;&#39;MI11&#39;, num&#x3D;&#39;135 1111 1111&#39;&#125;</span><br></pre></td></tr></table></figure><p><strong>类图：</strong>（为了能够更好的看清楚这个结构，这个类图中省略了小米手机类）<br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20210418103856.png" alt="20210418103856"></p><p><strong>小结：</strong>（以下两个小点分别对应百度百科实用范围中的两个小点）</p><ol><li>测试类在使用手机对象时完全没有涉及到创建手机的过程，将创建手机过程与测试类的使用是解耦的。</li><li>如果我们需要的对象是一个其他的表示的话，比如我们需要把华为手机换成小米手机，只需要把HUAWEIPhoneBuilder换成MIPhoneBuilder即可。</li></ol><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>思考一个问题：如果实际开发中不需要将创建对象的代码与实际使用这个对象的代码分离开呢？也就是仅仅只是需要有多种不同的装配对象的方式。</p><p>还是上面的这个例子，将创建对象的逻辑与对象本身绑定在一起，仅仅只剩下一个Product角色。<br>这里假设只是需要一个华为手机。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Phone</span><span class="params">(HUAWEIPhoneBuilder huaweiPhoneBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand = huaweiPhoneBuilder.brand;</span><br><span class="line">        <span class="keyword">this</span>.name = huaweiPhoneBuilder.name;</span><br><span class="line">        <span class="keyword">this</span>.num = huaweiPhoneBuilder.num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> brand + <span class="string">"Phone&#123;name='"</span> + name + <span class="string">"', num='"</span> + num + <span class="string">"'&#125;"</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原来的 ConcreteBuilder 具体创建者角色</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HUAWEIPhoneBuilder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String brand;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> String num;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认创建的手机品牌</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HUAWEIPhoneBuilder</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>.brand = <span class="string">"HUAWEI"</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> HUAWEIPhoneBuilder <span class="title">buildName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> HUAWEIPhoneBuilder <span class="title">buildNum</span><span class="params">(String num)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.num = num;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Phone <span class="title">build</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Phone(<span class="keyword">this</span>); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone HUAWEIPhone = <span class="keyword">new</span> Phone.HUAWEIPhoneBuilder().buildName(<span class="string">"P30"</span>).buildNum(<span class="string">"135 0000 0000"</span>).build();</span><br><span class="line">        System.out.println(HUAWEIPhone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HUAWEIPhone&#123;name&#x3D;&#39;P30&#39;, num&#x3D;&#39;135 0000 0000&#39;&#125;</span><br></pre></td></tr></table></figure><p><strong>类图：</strong><br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20210418105741.png" alt="20210418105741"></p><p><strong>小结：</strong></p><ol><li>将创建对象的过程与这个对象绑定在一起，以一种链式调用的方式来解决在不同的业务场景下同一个对象的不同的装配方式。</li><li>但同时使用这个对象的代码与创建对象的代码也就耦合了。</li></ol><hr><p>上面只需创建华为手机的例子仅仅只是对于前面的一个扩展，这并不能够很好的帮助我们理解什么是对象的不同装配方式，以及如何去使用。<br>下面举一个更加形象的例子来帮助大家去理解建造者模式，比如我现在需要一个只有加法和减法的计算器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> result;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> result; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入基础操作数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Calculator</span><span class="params">(<span class="keyword">int</span> result)</span> </span>&#123; <span class="keyword">this</span>.result = result; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Calculator <span class="title">add</span><span class="params">(<span class="keyword">int</span> addNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.result += addNum;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Calculator <span class="title">sub</span><span class="params">(<span class="keyword">int</span> subNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.result -= subNum;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="keyword">new</span> Calculator(<span class="number">10</span>).add(<span class="number">10</span>).sub(<span class="number">5</span>).getResult();</span><br><span class="line">        System.out.println(<span class="string">"result："</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result：15</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;首先来看一下百度百科关于建造者模式的描述。（&lt;a href=&quot;https://baike.baidu.com/item/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/3229729?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;建造者模式，百度百科&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实用范围：&lt;/strong&gt;&lt;br&gt;1、当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。&lt;br&gt;2、当构造过程必须允许被构造的对象有不同表示时。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;建造者模式中的4个角色：&lt;/strong&gt;&lt;br&gt;1、Builder：为创建一个产品对象的各个部件指定抽象接口。&lt;br&gt;2、ConcreteBuilder：实现Builder的接口以构造和装配该产品的各个部件，定义并明确它所创建的表示，并提供一个检索产品的接口。&lt;br&gt;3、Director：构造一个使用Builder接口的对象。&lt;br&gt;4、Product：表示被构造的复杂对象。ConcreteBuilder创建该产品的内部表示并定义它的装配过程，包含定义组成部件的类，包括将这些部件装配成最终产品的接口。&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;以上是百度百科中关于建造者模式的一些描述，下面说一些我自己的理解。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://www.wrp.cool/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="创建型设计模式" scheme="https://www.wrp.cool/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Java" scheme="https://www.wrp.cool/tags/Java/"/>
    
    <category term="设计模式" scheme="https://www.wrp.cool/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="创建型" scheme="https://www.wrp.cool/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B/"/>
    
    <category term="建造者模式" scheme="https://www.wrp.cool/tags/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
