<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>知更</title>
  
  <subtitle>“知道要更新，知道要进步”</subtitle>
  <link href="https://www.wrp.cool/atom.xml" rel="self"/>
  
  <link href="https://www.wrp.cool/"/>
  <updated>2021-07-03T02:20:57.728Z</updated>
  <id>https://www.wrp.cool/</id>
  
  <author>
    <name>王瑞鹏</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二叉搜索树</title>
    <link href="https://www.wrp.cool/posts/46128/"/>
    <id>https://www.wrp.cool/posts/46128/</id>
    <published>2021-06-29T13:12:03.000Z</published>
    <updated>2021-07-03T02:20:57.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote><p>二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： <font color=blue>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。</font>二叉搜索树作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势；所以应用十分广泛，例如在文件系统和数据库系统一般会采用这种数据结构进行高效率的排序与检索操作。</p><p>以上资料来自：<a href="https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91" target="_blank" rel="noopener">二叉搜索树-百度百科</a></p></blockquote><a id="more"></a><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> e;</span><br><span class="line">        <span class="keyword">public</span> Node left, right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> e, Node left, Node right)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.e = e;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    add(root, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node root, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node(e, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        size ++;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (e &lt; root.e) &#123;</span><br><span class="line">        root.left = add(root.left, e);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e &gt; root.e) &#123;</span><br><span class="line">        root.right = add(root.right, e);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> find(root, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(Node root, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e &lt; root.e) </span><br><span class="line">        <span class="keyword">return</span> find(root.left, e);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e &gt; root.e)</span><br><span class="line">        <span class="keyword">return</span> find(root.right, e);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除最大元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">delMax</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        root.right = delMax(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        size --;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            root = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除任意元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> delNode(root, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">delNode</span><span class="params">(Node root, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == root.e) &#123;</span><br><span class="line">        root = delMax(root.left);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> delNode(e &gt; root.e ? root.right : root.left, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前序遍历（递归版本）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    System.out.println(root);</span><br><span class="line">    preOrder(root.left);</span><br><span class="line">    preOrder(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前序遍历（循环版本）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用栈来模拟递归</span></span><br><span class="line">    IStack&lt;Node&gt; stack = <span class="keyword">new</span> ArrayStack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        Node node = stack.pop();</span><br><span class="line">        System.out.print(node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>)</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>)</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序遍历（递归版本）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    inOrder(root.left);</span><br><span class="line">    System.out.println(root);</span><br><span class="line">    inOrder(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序遍历（循环版本）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用栈来模拟递归</span></span><br><span class="line">    IStack&lt;Node&gt; stack = <span class="keyword">new</span> ArrayStack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node node = stack.pop();</span><br><span class="line">        System.out.print(node);</span><br><span class="line"></span><br><span class="line">        root = node.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后序遍历（递归版本）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    postOrder(root.left);</span><br><span class="line">    postOrder(root.right);</span><br><span class="line">    System.out.println(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用栈来模拟递归</span></span><br><span class="line">    IStack&lt;Node&gt; stack = <span class="keyword">new</span> ArrayStack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Node prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span> &amp;&amp; root.right != prev) &#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.print(root);</span><br><span class="line">            prev = root;</span><br><span class="line">            root = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="层序遍历二叉树"><a href="#层序遍历二叉树" class="headerlink" title="层序遍历二叉树"></a>层序遍历二叉树</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    IQueue&lt;Node&gt; queue = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    queue.enque(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        Node node = queue.deque();</span><br><span class="line">        System.out.println(node);</span><br><span class="line"></span><br><span class="line">        queue.enque(node.left);</span><br><span class="line">        queue.enque(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上就是一些二叉树的基本实现，有错误或者疑问都欢迎在评论区指出。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： &lt;font color=blue&gt;若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。&lt;/font&gt;二叉搜索树作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势；所以应用十分广泛，例如在文件系统和数据库系统一般会采用这种数据结构进行高效率的排序与检索操作。&lt;/p&gt;
&lt;p&gt;以上资料来自：&lt;a href=&quot;https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;二叉搜索树-百度百科&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="数据结构" scheme="https://www.wrp.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://www.wrp.cool/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="二叉树" scheme="https://www.wrp.cool/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="递归" scheme="https://www.wrp.cool/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="遍历" scheme="https://www.wrp.cool/tags/%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>写在前面</title>
    <link href="https://www.wrp.cool/posts/62949/"/>
    <id>https://www.wrp.cool/posts/62949/</id>
    <published>2021-06-25T15:00:10.000Z</published>
    <updated>2021-06-27T15:31:10.558Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>你好，陌生人。<br>虽然我不认识你，但也希望你能够保持自己，请继续加油：）<br>如果你想认识我，我叫王瑞鹏。</p></blockquote><a id="more"></a><br><center><font size=5>这里的评论区就当作留言板吧~</font></center>]]></content>
    
    
    <summary type="html">&lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;你好，陌生人。&lt;br&gt;虽然我不认识你，但也希望你能够保持自己，请继续加油：）&lt;br&gt;如果你想认识我，我叫王瑞鹏。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="https://www.wrp.cool/posts/11306/"/>
    <id>https://www.wrp.cool/posts/11306/</id>
    <published>2021-06-16T14:32:13.000Z</published>
    <updated>2021-06-29T13:08:40.045Z</updated>
    
    <content type="html"><![CDATA[<p>本来像是这样的排序算法在网上搜个快速排序能找到很多的博客在详细的说明快速排序的实现、特点、性能、时间复杂度等等，但还是决定要自己写一篇博客来讲讲这个算法，实际上是想要分享一些在学习这个算法的过程中一些让我感到惊讶的地方。</p><p>也正是因为这样的一些比较独特的，比较不可思议却又是合乎情理的存在才让算法变得更神秘，更吸引人了。</p><a id="more"></a><hr><p>先简单的讲一下快速排序的核心思想：</p><blockquote><p>每次在数组中随机的找到一个元素，以这个元素为基准将整个数组分成大于基准元素的部分和小于基准元素的部分，之后再按照小于基准元素、基准元素、大于基准元素这样的顺序排好，之后再递归的对小于基准元素部分和大于基准元素部分分别进行相同的操作。有一些书中也会将这个基准元素称为标兵。</p></blockquote><p>根据这样的一个思想我们可以很快速的设计出第一版的快速排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> j = l;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[l]))</span><br><span class="line">            swap(arr, i, ++j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, l, j);</span><br><span class="line"></span><br><span class="line">    sort(arr, l, j - <span class="number">1</span>);</span><br><span class="line">    sort(arr, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处swap函数用于交换数组中两个下标处的值。</span></span><br></pre></td></tr></table></figure><p>有些书上的快速排序实现的过程可能跟上面代码并不一致，这里也想说一点关于自己的想法，对于算法的实现我们更应该关注的是这个算法的思想，以及我们所实现的算法的时间复杂度分析上，而不是去纠结具体实现的方式。</p><p>上面的代码看着好起来并不复杂，但是想要彻底的理解的话其实并不容易，关键是要能够理解<code>j</code>代表什么，也就是<code>j</code>的语义。</p><p><font color=blue>此处的<code>j</code>代表了小于标兵元素部分的最右边的元素。</font></p><blockquote><p>上面的代码对于初学者可能并不是特别友好，如果你有任何的疑问欢迎在评论区提问。</p></blockquote><hr><p><strong>有意思的地方现在开始了：</strong></p><p>如果你觉得上面的代码没问题的话，在这里强烈建议你设计一个数据规模是百万这个级别并且已经排好序的数组来跑一下上面的这个快速排序算法，你会发现这一点也不快速。</p><p>由于我们每次所选择的标兵元素都是数组中的第一个元素，所以如果是一个已经排好序的数组，这个快速排序算法会直接退化成一个<code>O(n^2)</code>级别的算法。</p><p>改进的方式是使用随机标兵，于是上面的代码迎来了第一次改进。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机标兵（针对有序数组的优化）</span></span><br><span class="line">    swap(arr, l, l + random.nextInt(r - l + <span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> j = l;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[l]))</span><br><span class="line">            swap(arr, i, ++j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, l, j);</span><br><span class="line"></span><br><span class="line">    sort(arr, l, j - <span class="number">1</span>);</span><br><span class="line">    sort(arr, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码的逻辑还是没有改变，还是选取数组中的第一个元素为标兵元素，但是在每次选取之前将数组中的第一个元素和数组中的随机任何一个元素交换一下位置，以达到随机标兵的效果。</p><hr><p>但就算是这样这个算法依旧不完美，设想一下：<strong>如果是一个所有元素都相同的数组呢？</strong><br>比如一个容量为一百万的数组里面存放的元素全部都是0。</p><p>如果是这样的情况，那么随机标兵也就没有作用了，快速排序也就再次退化成了一个<code>O(n^2)</code>级别的算法。</p><p>于是第二次改进：<strong>双路快速排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机标兵（针对完全有序数组所进行的优化）</span></span><br><span class="line">    swap(arr, l, l + random.nextInt(r - l + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = l + <span class="number">1</span>, j = r;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[i] &lt; arr[l]) i++;</span><br><span class="line">        <span class="keyword">while</span> (arr[j] &gt; arr[l]) j--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        swap(arr, i++, j--);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, l, j);</span><br><span class="line"></span><br><span class="line">    sort(arr, l, j - <span class="number">1</span>);</span><br><span class="line">    sort(arr, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>双路快速排序算法已经是一个可以满足所有场景的快速排序算法了。</p><p>但是这还不够完美，还是刚刚的例子，如果数组中全部元素都相同的话，虽然可以满足O(nlogn)这个级别的速度实现排序，但是如果全部元素都相同的话快速排序还可以做到O(n)级别的时间复杂度。</p><p>于是最终版本：<strong>三路快速排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机标兵（针对完全有序数组所进行的优化）</span></span><br><span class="line">    SortingHelper.swap(arr, l, l + random.nextInt(r - l + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lt = l, i = l + <span class="number">1</span>, gt = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; gt) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arr[i].compareTo(arr[l]) &lt; <span class="number">0</span>) </span><br><span class="line">            SortingHelper.swap(arr, ++lt, i++);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[i].compareTo(arr[l]) &gt; <span class="number">0</span>) </span><br><span class="line">            SortingHelper.swap(arr, i, --gt);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i++;</span><br><span class="line">    &#125;</span><br><span class="line">    SortingHelper.swap(arr, l, lt);</span><br><span class="line"></span><br><span class="line">    sort(arr, l, lt - <span class="number">1</span>);</span><br><span class="line">    sort(arr, gt, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本来像是这样的排序算法在网上搜个快速排序能找到很多的博客在详细的说明快速排序的实现、特点、性能、时间复杂度等等，但还是决定要自己写一篇博客来讲讲这个算法，实际上是想要分享一些在学习这个算法的过程中一些让我感到惊讶的地方。&lt;/p&gt;
&lt;p&gt;也正是因为这样的一些比较独特的，比较不可思议却又是合乎情理的存在才让算法变得更神秘，更吸引人了。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://www.wrp.cool/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序" scheme="https://www.wrp.cool/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>递归</title>
    <link href="https://www.wrp.cool/posts/38362/"/>
    <id>https://www.wrp.cool/posts/38362/</id>
    <published>2021-05-30T06:39:51.000Z</published>
    <updated>2021-06-01T14:38:49.065Z</updated>
    
    <content type="html"><![CDATA[<p>大家应该都听过这么一个故事：</p><blockquote><p>从前有座山，山上有座庙，庙里有个老和尚和一个小和尚，老和尚在给小和尚讲一个故事，故事是什么呢？故事就是：从前有座山，山上有座庙，庙里有个老和尚和一个小和尚，老和尚在给小和尚讲一个故事，故事是什么呢？故事就是：从前有座山，山上有座庙，庙里有个老和尚和一个小和尚，老和尚在给小和尚讲一个故事，故事是什么呢？故事就是：…..</p></blockquote><p>也都应该经历过这么一个场景：</p><blockquote><p>有一些理发店里面呢，会有两个镜子相对的情况，镜子A里面可以看到镜子B，镜子B里面又可以看到镜子A，镜子A跟镜子B之间互相反射的循环反反复复的无穷无尽。</p></blockquote><p>我认为这可以算是现实世界中的递归现象。当然了，现实世界中类似于这样的现象并不少见。我觉得发明了递归算法的人一定也是在这其中的某一个场景或者是某一个故事下获得的灵感。</p><p><font color=blue>毕竟，计算机科学就是一种对于现实世界的抽象。</font></p><a id="more"></a><hr><p>学习计算机的同学所接触到的第一个递归算法应该都是递归求阶乘或者是数组求和这样的算法。虽然求阶乘或者是求和这只是很简单的递归代码，但是递归算法该有的，它也一样都没有落下。其实这样的功能只需要一层简单的循环就可以搞定，递归算法在这里反而是降低了代码的可读性，并没有为我们带来实际上的好处。<br><font color=#aaa>这里并不是不鼓励同学们使用递归来编写逻辑代码，而是希望不要过度设计自己的代码，还是那句话，刚刚好的才是最美：）</font></p><p><font size=5 ><strong>递归</strong></font> <a href="https://baike.baidu.com/item/%E9%80%92%E5%BD%92" target="_blank" rel="noopener">百度百科</a></p><blockquote><p>程序调用自身的编程技巧称为递归（ recursion）。递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。<strong>一般来说，递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。</strong></p></blockquote><p>结合一下递归求阶乘的代码理解一下上面百度百科的这段话，特别是最后一句话。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归求阶乘</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个简单的递归代码，但是麻雀虽小，却也五脏俱全。在这个例子中，<strong>边界条件、递归前进段和递归返回段</strong>都是很明确的。</p><ul><li><strong>边界条件：</strong>n == 1</li><li><strong>递归前进段：</strong>每次调用 <code>factorial(n - 1)</code> 时递归算法就前进一个函数单位</li><li><strong>递归返回段：</strong>当<code>n-1</code>减到<code>n==1</code>的时候，也就是if条件成立返回1的时候，<code>factorial(n - 1)</code>开始返回，每次返回，递归就结束一次<code>factorial(n - 1)</code>函数的调用，也就是返回一个函数单位。</li></ul><blockquote><p>简单一些来理解的话：递归无非就是一个满足了<strong>直接或者是间接的调用自身、以及在某个时候会结束对自身调用</strong>这两个条件的函数，仅此而已。</p></blockquote><p> 如果要我一句话来描述递归算法的话，我会说：<font color=blue>比起循环，这是一种更能够提高代码可读性的循环。</font></p><p> 我认为递归所能完成的逻辑，换成循环来做这样的事情甚至效率上还要更高一些，因为循环并不需要额外的方法调用的成本。但是在某些复杂的场景下，使用递归会让我们的代码变得非常简洁易于理解，比如：二叉树的前、中、后序的遍历；求一个二叉树的节点个数等等。</p><p> 但是递归也有一个非常明显的缺点，那就是几乎所有的编程语言的函数调用栈都有一个明确的大小，这就导致了递归函数的调用层数不能超出这个大小，否则会产生一个栈内存的溢出，在Java中这是一个叫做<code>StackOverflowError</code>的异常。</p><hr><p><font size=5 ><strong>递归函数的宏观语义</strong></font></p><p>递归的本质实际上就是将一个问题不断的拆解成一个一个的小的问题，直到最后的一个问题小到不能再小了，这个时候我们可以很容易的解决这个问题，将这个问题的解决结果返回给上一个问题，解决掉上一个问题之后再解决上上个问题以此类推，最终解决我们的问题。<strong>拆解问题的过程也就是递归前进段，解决掉最基本问题开始返回的阶段也就是递归返回段。</strong></p><p>更多的时候我喜欢把递归函数理解成一个单元，也就是递归单元。因为递归函数调用自身后还是走一遍自身的逻辑，每次递归调用在逻辑上并没有产生任何的变化，相应的我们只是改变了每次调用的参数而已。<strong>将递归函数拆解成的一个一个的小问题的这个步骤，就体现在每次调用递归函数的参数列表都要比上一次的参数列表要更简单一点点。</strong></p><p>很多时候编写递归逻辑的时候都是因为递归调用自身的这个动作会令我们感到很迷惑，没有办法理解到这一步操作是怎么执行的。我第一次接触二叉树前序遍历的代码的时候就是倒在了这一步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树前序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prevOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    System.out.print(node);</span><br><span class="line">    prevOrder(node.left);</span><br><span class="line">    prevOrder(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我刚刚开始看这代码的时候我完全无法理解为什么上面这段代码为什么会以中、左、右的方式输出一个二叉树，甚至我完全不能够明白这段代码的逻辑。原因是我自己的思维跟着递归函数一起被递归进去了，一直试图去理解每次递归进去之后发生了什么事情，而递归函数的逻辑一直没变。就像是开头的哪个老和尚讲故事一样，我完全没办法跳出递归逻辑。</p><p><font color=blue>但是，如果能从宏观的角度来看这段代码，就舒服多了。</font></p><ul><li><strong>首先，明白我们写的递归函数是要完成一个什么样的功能。</strong></li><li><strong>然后，不要去研究递归进去的逻辑是什么样的，仅仅只看第一层逻辑。</strong></li><li>因为递归进去的逻辑跟第一层的逻辑是完全一样的。</li></ul><p>如果要把 <code>prevOrder</code> 这个递归函数所做的事情理解成一个递归单元的话，我们只需要整理出这个函数所要实现的功能就可以理解这个递归函数的逻辑。</p><p><font size=4 ><strong>Q&amp;A Time</strong></font></p><ul><li><strong>Q：prevOrder这个函数的功能是什么？</strong></li><li>A：按照中、左、右的顺序输出一棵二叉树。</li><li><strong>Q：第7行的逻辑是什么？</strong></li><li>A：输出当前节点。</li><li><strong>Q：第8行的逻辑是什么？</strong></li><li>A：按照中、左、右的顺序输出当前节点的左子树。</li><li><strong>Q：第9行的逻辑是什么？</strong></li><li>A：按照中、左、右的顺序输出当前节点的右子树。</li></ul><blockquote><p>看到这里如果还不能够明白这个递归逻辑的话，我建议在纸上画一棵高度为3，7个节点的满二叉树然后按照上面 Q&amp;A 再结合代码依次访问一下这棵二叉树上的各个节点，你也许能更加直观的感受什么是递归的宏观语义。</p></blockquote><p><font color=blue>我所理解的递归函数的宏观语义是：</font></p><ul><li><p>将一个大的问题一点一点的拆分成许多个小的问题，或者说是抽象成多个小问题，<strong>每一个问题就是一个递归单元，每一个递归单元在逻辑上都是相同的，唯一不同的只是参数列表。</strong></p></li><li><p>在这个例子中，前序遍历当前节点、前序遍历当前节点的左子树、前序遍历当前节点的右子树，这是<strong>完完全全相同的逻辑。</strong></p></li><li><p>当我们能够按照这种思维来解读递归代码的话，我们可以完全不关心递归调用里面的逻辑是怎样的，递归调用也就可以理解成为一种普通的函数调用。</p></li></ul><hr><p><font size=5 ><strong>如何编写一个递归程序？</strong></font></p><p>借助力扣第206号问题（<a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">反转链表</a>）来讲述如何梳理出递归函数的宏观语义以及怎么编写递归函数。</p><blockquote><p>给你<strong>单链表</strong>的头节点 <code>head</code> 请你反转链表，并返回反转后的链表<br><strong>示例一：</strong><br>输入：head = (1) -&gt; (2) -&gt; (3) -&gt; (4) -&gt; (5) -&gt; NULL<br>输出：head = (5) -&gt; (4) -&gt; (3) -&gt; (2) -&gt; (1) -&gt; NULL<br><strong>示例二：</strong><br>输入：head = (1) -&gt; (2) -&gt; NULL<br>输出：head = (2) -&gt; (1) -&gt; NULL<br><strong>示例三：</strong><br>输入：head = (1) -&gt; NULL<br>输出：head = (1) -&gt; NULL<br><strong>示例四：</strong><br>输入：head = NULL<br>输出：head = NULL</p></blockquote><p>如果一个问题已经明确了要使用递归来求解的话，我们第一步要做的就是找出这个拆解后最基本的那个问题，对于反转链表的这个问题来说，显而易见最基本的问题就是当链表为空或者是链表只有一个节点的情况。一个空链表反转过后还是一个空链表，一个只有一个节点的链表反转过后还是只有一个节点。找出最基本的问题只是递归函数中最基础的部分，如果连最基本的问题都找不出来的话，那么几乎可以断定这个问题无法使用递归求解。</p><p>完成了最基本的部分接下来才是一个如何编写一个递归函数的重头戏，<font color=blue>将递归函数单元化，也就是找出这个递归函数的宏观语义，清楚这个递归函数要表达什么。</font>将递归函数看作是一个单元之后其实就不需要再考虑我们要求解的这个问题具体是什么了，解决问题的重点就放在了怎么解决一个一个拆解出来的小问题了。</p><ul><li>这里我再啰嗦一下解释一下示例一这个例子：</li><li>反转前：<code>head</code> 的值为1，指向了值为2的节点，值为2的节点指向了值为3的节点…最终指向NULL</li><li>反转后：<code>head</code> 的值为5，指向了值为4的节点，值为4的节点指向了值为3的节点…最终指向NULL</li></ul><p>假如我们现在处于 <code>(3)</code> 这个节点，结合递归函数的宏观语义来看一下此时链表的状态。前面的 <code>(1)</code> 和 <code>(2)</code> 节点是没有变化的，因为我们现在处于 <code>(3)</code> 这个节点，还没有反转到 <code>(1)</code> 和 <code>(2)</code> 。<font color=blue>但是对于已经反转过的 <code>(4)</code> 和 <code>(5)</code> 来说，应该是 <code>NULL &lt;- (4) &lt;- (5)</code> 这个样子的。</font>而此时的 <code>(3)</code> 这个节点仍然是指向了 <code>(4)</code> 这个节点的。</p><p>好了，分析到此为止，答案已经是显而易见的了。当我们处于 <code>(3)</code> 这个节点的时候，我们只需要将 <code>(3)</code> 这个节点当作是已经反转完成的链表的下一个待反转节点再将 <code>(3)</code> 这个节点反转过来就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)  <span class="comment">// 最基本的问题</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode rev = reverseList(head.next);  <span class="comment">// 得到已经反转完成的链表</span></span><br><span class="line">        head.next.next = head;                  <span class="comment">// 将当前节点挂接在已经反转完成的链表的下一个节点，注意：head.next此时指向的是已经反转完成的链表的尾节点。</span></span><br><span class="line">        head.next = <span class="keyword">null</span>;                       <span class="comment">// 执行到这一步的时候，head已经挂载到反转完成链表的尾节点的位置了，但是链表尾节点必须指向null，所以令 head.next = null</span></span><br><span class="line">        <span class="keyword">return</span> rev;                             <span class="comment">// 返回已经反转完成的链表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的这段代码也就是力扣上第206号问题的答案，有兴趣的同学可以将代码复制到力扣上第206号问题的解答区中去验证结果。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;大家应该都听过这么一个故事：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从前有座山，山上有座庙，庙里有个老和尚和一个小和尚，老和尚在给小和尚讲一个故事，故事是什么呢？故事就是：从前有座山，山上有座庙，庙里有个老和尚和一个小和尚，老和尚在给小和尚讲一个故事，故事是什么呢？故事就是：从前有座山，山上有座庙，庙里有个老和尚和一个小和尚，老和尚在给小和尚讲一个故事，故事是什么呢？故事就是：…..&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也都应该经历过这么一个场景：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有一些理发店里面呢，会有两个镜子相对的情况，镜子A里面可以看到镜子B，镜子B里面又可以看到镜子A，镜子A跟镜子B之间互相反射的循环反反复复的无穷无尽。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我认为这可以算是现实世界中的递归现象。当然了，现实世界中类似于这样的现象并不少见。我觉得发明了递归算法的人一定也是在这其中的某一个场景或者是某一个故事下获得的灵感。&lt;/p&gt;
&lt;p&gt;&lt;font color=blue&gt;毕竟，计算机科学就是一种对于现实世界的抽象。&lt;/font&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://www.wrp.cool/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="递归" scheme="https://www.wrp.cool/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="算法" scheme="https://www.wrp.cool/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>lambda 表达式</title>
    <link href="https://www.wrp.cool/posts/47234/"/>
    <id>https://www.wrp.cool/posts/47234/</id>
    <published>2021-05-23T01:12:50.000Z</published>
    <updated>2021-05-23T13:16:06.692Z</updated>
    
    <content type="html"><![CDATA[<p>jdk1.8之后才出现了lambda表达式这个东西，这说明了lambda表达式实际上并不是编程中必须掌握的一项技能，但是既然jdk1.8之后支持了lambda表达式，那么说明lambda表达式肯定是会有其独特的用处。其实lambda表达式最重要的就是让我们写的代码更加的优雅，看起来更加的舒服。同时，使用lambda表达式也能在一定程度上少写一些代码，提高一些编程的效率。不过我还是认为lambda表达式最重要的是让代码变得更加优雅。</p><p>关于lambda表达式的一些基本的使用在网上实际上已经有了很多的博客或者教程，本文就不再赘述这些别人已经写过的东西了，主要还是想聊一下自己在学习lambda表达式过程中的一些理解。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="number">2021</span>);</span><br><span class="line">    list.add(<span class="number">0</span>);</span><br><span class="line">    list.add(<span class="number">5</span>);</span><br><span class="line">    list.add(<span class="number">23</span>);</span><br><span class="line">    list.forEach(item -&gt; System.out.print(item));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：20210523</span></span><br></pre></td></tr></table></figure><p><code>item -&gt; System.out.print(item)</code> 这就是一个最基本的lambda表达式，这实际上是一个抽象方法的实现，只不过是写成这个样子，看起来更加优雅了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">        action.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的是forEach方法的接口定义，具体的实现内容先不看，先看看forEach的参数列表中的 <code>Consumer&lt;? super T&gt; action</code> 这个东西，它叫函数式接口。</p><blockquote><p>在《Java核心技术 卷一》这本书中对函数式接口的定义是这样的：<br>对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个lambda表达式。<br>这种接口称为<strong>函数式接口</strong>（functional interface）</p><p>粗浅的理解可以是：一个接口中如果只定义了一个抽象方法的话，那么这个接口就是一个函数式接口。</p></blockquote><p>看看这个 Consumer 所谓的函数式接口中唯一定义的一个抽象方法长什么样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br></pre></td></tr></table></figure><p>上面说的 <code>item -&gt; System.out.print(item)</code> 这个东西是对一个抽象方法的实现，实际上就是对 <code>accept</code> 这个抽象方法的实现，我以我的理解来尝试复原这个实现，将它变成我们平时见到的普通的方法实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">    System.out.print(item + <span class="string">"  "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么看起来一下子清晰多了，forEach方法将这个lambda表达式解析成了它所需要的参数，也就是Consumer接口的实现，之后再调用这个方法来遍历List集合。</p><p><em>当然具体的遍历方式我们也看到了，底层还是使用的forEach循环来遍历这个集合，所以在这里顺带提一下，除非遍历集合的内容只要一行代码就可以完成，像是我上面这样子，否则使用lambda表达式来遍历集合的话就不是很必要了。因为这并不会让我们的代码变得优雅或者是提高效率，反而平白的增加的后期维护的成本，得不偿失。</em></p><blockquote><p>思考一个问题：<br><font color = blue>如果有一个方法的代码刚刚好可以实现accept这个抽象接口，能不能直接把这个方法的代码作为accept的实现传递给forEach方法呢？</font></p></blockquote><p>还是上面的这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="number">2021</span>);</span><br><span class="line">    list.add(<span class="number">0</span>);</span><br><span class="line">    list.add(<span class="number">5</span>);</span><br><span class="line">    list.add(<span class="number">23</span>);</span><br><span class="line">    list.forEach(System.out::print);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：20210523</span></span><br></pre></td></tr></table></figure><p><code>System.out::print</code> 也是一种lambda表达式，在这段代码中，这两种实现方式的效果是完全一样的。</p><blockquote><p><code>::</code>表示的是方法的引用，实际上就是将<code>System.out</code>对象中的<code>print</code>方法直接作为抽象方法<code>accept</code>的实现传到forEach中去。</p></blockquote><p>结合这两个例子来看，实际上lambda表达式中我们实际上只是传递的一个代码段，而不是接口的实现，底层的jvm会自动的根据上下文帮助我们封装成接口的实现以供方法调用，仅此而已。我认为这应该就是lambda表达式的真面目。</p><hr><p>除了传递方法的引用进去，lambda表达式还可以直接传递一个构造器。像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 声明两个函数式接口 (此处借用 java.util.function.Supplier 函数接口)*/</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Supplier1</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Supplier2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">(String str)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Main */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Main</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"执行无参构造器"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Main</span><span class="params">(String str)</span> </span>&#123; System.out.println(<span class="string">"执行有参构造器"</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Supplier1&lt;Main&gt; s1 = Main::<span class="keyword">new</span>;</span><br><span class="line">        Supplier2&lt;Main&gt; s2 = Main::<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">        s1.get();</span><br><span class="line">        s2.get(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">执行无参构造器</span></span><br><span class="line"><span class="comment">执行有参构造器</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>上面的代码就是调用了Main类中对应的构造器来构建一个Main的实例并返回，写法也非常的简单，直接双冒号调用new关键字即可。具体的调用哪一个构造器会根据上下文自动选择跟函数式接口参数对应的上的构造器。</p><p>上面的使用lambda表达式创建的Supplier1对象和Supplier2对象的方式实际上等价于下面的样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Supplier1&lt;Main&gt; s1 = <span class="keyword">new</span> Supplier1&lt;Main&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Main <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Main();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Supplier2&lt;Main&gt; s2 = <span class="keyword">new</span> Supplier2&lt;Main&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Main <span class="title">get</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Main(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>再来看看lambda表达式中this的指向问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"Test"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        r.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Runnable r = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        r.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Main main = <span class="keyword">new</span> Main();</span><br><span class="line">        main.test1();</span><br><span class="line">        main.test2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Main"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">Test</span></span><br><span class="line"><span class="comment">Main</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>先借书里的一句话来说明一下this的指向：在lambda表达式中，this的使用并没有任何特殊之处。lambda表达式的作用域嵌套在test2方法中，与出现在这个方法中的其他位置一样，lambda表达式中this的含义并没有发生变化。</p><p>对于这个实际上很好理解，lambda表达式中的this出现在任何地方都跟哪个地方本来的this是一样的，并没有因为lambda而发生不同。这实际上也从另外的角度说明了lambda表达式仅仅只是传递了一段代码过去，而没有做其他处理。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;jdk1.8之后才出现了lambda表达式这个东西，这说明了lambda表达式实际上并不是编程中必须掌握的一项技能，但是既然jdk1.8之后支持了lambda表达式，那么说明lambda表达式肯定是会有其独特的用处。其实lambda表达式最重要的就是让我们写的代码更加的优雅，看起来更加的舒服。同时，使用lambda表达式也能在一定程度上少写一些代码，提高一些编程的效率。不过我还是认为lambda表达式最重要的是让代码变得更加优雅。&lt;/p&gt;
&lt;p&gt;关于lambda表达式的一些基本的使用在网上实际上已经有了很多的博客或者教程，本文就不再赘述这些别人已经写过的东西了，主要还是想聊一下自己在学习lambda表达式过程中的一些理解。&lt;/p&gt;</summary>
    
    
    
    <category term="Java 基础" scheme="https://www.wrp.cool/categories/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="lambda" scheme="https://www.wrp.cool/tags/lambda/"/>
    
  </entry>
  
  <entry>
    <title>选择排序 &amp; 插入排序</title>
    <link href="https://www.wrp.cool/posts/21500/"/>
    <id>https://www.wrp.cool/posts/21500/</id>
    <published>2021-05-14T12:41:43.000Z</published>
    <updated>2021-05-23T01:14:27.052Z</updated>
    
    <content type="html"><![CDATA[<p>具体的选择排序和插入排序的代码我已经放<a href="https://github.com/wangruipeng-wrp/algorithm-and-data-structure/tree/master/src/Sort" target="_blank" rel="noopener">github</a>上了，本文不会针对具体的代码实现展开讨论。更多的是想聊一些在学习这两个算法过程中的自身一些心态的变化。</p><a id="more"></a><p>作为铺垫，还是简单讲一下插入排序和选择排序</p><blockquote><p><strong>选择排序：</strong><br>每次都找出一个最小的元素按照顺序排好</p></blockquote><blockquote><p><strong>插入排序：</strong><br>首先假装第一个元素是有序的，然后每次从无序的数组中拿出一个元素插入到有序的数组里面去</p></blockquote><p>我在学习这两个算法的时候是先学的选择排序，再学的插入排序。在还没有深入理解的情况下，<font color=Blue>我其实想当然的认为选择排序算法的性能就一定是要优于插入排序算法的。</font></p><p>我这么想的原因其实也非常简单，选择排序每次循环在做的事情仅仅只是比较两个元素的大小，直到最后找出最小的哪个元素，最后再交换两个元素就可以完成一轮排序，是通过一种比较的方式来实现排序这样的功能。</p><p>反过来看插入排序呢，在一开始需要保存待插入的元素，然后再往前一个个的比较，如果比较的元素比待插入的元素要大，那么就覆盖掉他后面的哪个元素。</p><p>这么粗浅的看，同样的乱序数组，插入排序和选择排序所使用的比较的次数在极端的情况下（也就是倒序数组的情况下）是相等的。</p><p>而选择排序呢，每次比较完成之后仅仅需要一次交换位置的操作即可完成本轮的排序，但是反观插入排序呢，每一次都需要有一个覆盖掉后面元素的动作，直到找到正确的位置插入了才可以完成本轮的排序。</p><p>这么一个想法出现在我脑海里之后，我几乎是断定的选择排序在性能上是要优于插入排序的。</p><p><font color=Blue>但是，如果现在是一个完全有序的数组来进行排序的呢，或者说是一个近乎有序的数组在排序呢？</font></p><p>这个时候选择排序还是必须每次都比较剩下的元素找到最小的哪一个，唯一的不同是交换元素位置的操作变少了。</p><p>再看看插入排序呢，每次都只需要比较一下前面的一个元素就好了，交换位置的操作同样变少了。但是有序的情况下，插入排序有着一个非常巨大的优势就是比较的操作也变的很少。</p><p><font color=red>于是，当对一个完全有序或者是近乎有序的数组排序时，插入排序的性能是要优于选择排序的。</font></p><p>上面是对于选择排序和插入排序在前几天学习的过程中自己对于两者性能之间的一些看法。</p><hr><p>实际上不仅仅是在这个例子中，在平时中我很多时候也总是会太果断的认为一个事情，直到举一个反例出来之后被啪啪打脸。</p><p>对于这样子的情况说的好听一些我认为是对于自己逻辑思维能力的一种莫名的自信，说的直白一些的话实际上是自己的一种无知造成了这样莫名的自信。</p><p>我认为这并不是一个好的习惯，今天在这里留下这样的一篇博客，作为一个见证：<br><font color=Blue>希望自己在今后能保持谦虚，保持好学，一点一点的变成一个厉害的人：）</font></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;具体的选择排序和插入排序的代码我已经放&lt;a href=&quot;https://github.com/wangruipeng-wrp/algorithm-and-data-structure/tree/master/src/Sort&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github&lt;/a&gt;上了，本文不会针对具体的代码实现展开讨论。更多的是想聊一些在学习这两个算法过程中的自身一些心态的变化。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://www.wrp.cool/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序算法" scheme="https://www.wrp.cool/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="选择排序" scheme="https://www.wrp.cool/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    
    <category term="插入排序" scheme="https://www.wrp.cool/tags/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>原型模式</title>
    <link href="https://www.wrp.cool/posts/54363/"/>
    <id>https://www.wrp.cool/posts/54363/</id>
    <published>2021-05-02T02:06:35.000Z</published>
    <updated>2021-05-07T13:50:01.874Z</updated>
    
    <content type="html"><![CDATA[<p>原型模式简单来说就是以一个已经创建好的对象为原型，使用二进制流的方式复制这个对象。</p><a id="more"></a><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p><strong>借《设计模式之禅》这本书中一个例子来简述一下原型模式：</strong></p><p>先来想想一个业务场景，现在有一家银行想要对它的储户发送一封广告邮件，银行的储户比较多，大概几百万上千万个储户。每个储户发送一封邮件，其中邮件的内容都是一样的，不一样的是邮件的收件人邮箱，收件人称谓等一些属性不同，其他的属性都大同小异。其中将相同的部分抽取成一个邮件模板类。</p><p><strong>模板类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Template</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String subject = <span class="string">"xxx银行国庆大酬宾！！！"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String content = <span class="string">"把你的钱全部存到我们银行，我们帮你花掉它"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>邮件类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mail</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String subject;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String addresseeAddress;</span><br><span class="line">    <span class="keyword">private</span> String addresseeName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = Template.subject;</span><br><span class="line">        <span class="keyword">this</span>.content = Template.content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mail mail = <span class="keyword">new</span> Mail();</span><br><span class="line">        <span class="comment">// 发送一百万封邮件</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1_000_000</span>; i++) &#123;</span><br><span class="line">            mail.setAddresseeAddress(randomAddresseeAddress());</span><br><span class="line">            mail.setAddresseeName(randomAddresseeName());</span><br><span class="line">            sendMail(mail);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码实际上已经能够基本的实现我们想要的功能了，当然这得要有个非常非常重要的前提，那就是这个项目的甲方是一个比较将就的甲方。</p><p>看看上面的代码有什么问题，实际上没什么问题，就是慢了点，如果遇到这种百万级别千万级别的发送邮件的场景，使用单线程慢慢发的话可能得发一天甚至还不止。像这样的业务场景是必须使用多线程来发送邮件的，但是如果跟上面一样多个线程公用同一个mail对象的话那线程就不安全了。当然你可以选择创建多个mail对象来提供给每个线程，但是这真的大可不必，<strong>原型模式</strong>就是专门为了解决这样的业务场景而生的。</p><p><strong>使用原型模式来改造一下上面邮件类的代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mail</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String subject;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String addresseeAddress;</span><br><span class="line">    <span class="keyword">private</span> String addresseeName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = Template.subject;</span><br><span class="line">        <span class="keyword">this</span>.content = Template.content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对应的客户端实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    Mail mail = <span class="keyword">new</span> Mail();</span><br><span class="line">    <span class="comment">// 发送一百万封邮件</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1_000_000</span>; i++) &#123;</span><br><span class="line">        Mail cloneMail = (Mail) mail.clone();</span><br><span class="line">        cloneMail.setAddresseeAddress(randomAddresseeAddress());</span><br><span class="line">        cloneMail.setAddresseeName(randomAddresseeName());</span><br><span class="line">        sendMail(mail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与原来的不同之处就是Mail类实现了覆盖了Object方法中的clone方法，客户端不再使用同一个对象发送邮件，而是通过clone方法获取一个新的对象。之所以不让客户端自己创建一个新对象是因为我们现在演示使用的Mail对象非常简单，如果是在真实的业务场景中，创建一个Mail邮件对象一定是一个相当复杂的过程，创建一个这样的对象对于计算机资源的开销也是非常大的。而现在我们需要创建的是百万甚至是千万级别的这样的对象，这对于资源的开销是相当巨大的。</p><p><strong>小结原型模式的适用场景：</strong></p><ul><li>类初始化需要消耗较多的资源，例如：计算资源、硬件资源等</li><li>创建对象的过程非常繁琐，需要准备较多的访问权限，或者是大量的数据</li><li>一个对象会提供给其他对象访问，而且各个调用者可能都会修改其中的值</li></ul><blockquote><p>在实际的项目开发中原型模式很少单独出现，一般是和工厂模式一起出现，通过原型模式创建一个对象再由工厂模式将这个对象提供给调用者。</p></blockquote><h1 id="浅克隆和深克隆"><a href="#浅克隆和深克隆" class="headerlink" title="浅克隆和深克隆"></a>浅克隆和深克隆</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prototype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; arrayList;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Prototype</span><span class="params">(ArrayList&lt;String&gt; arrayList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arrayList = arrayList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    arrayList.add(<span class="string">"A"</span>);</span><br><span class="line">    arrayList.add(<span class="string">"B"</span>);</span><br><span class="line"></span><br><span class="line">    Prototype prototypeTest = <span class="keyword">new</span> Prototype(arrayList);</span><br><span class="line">    Prototype cloneTest = (Prototype) prototypeTest.clone();</span><br><span class="line"></span><br><span class="line">    cloneTest.getArrayList().add(<span class="string">"C"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(prototypeTest.getArrayList());</span><br><span class="line">    System.out.println(cloneTest.getArrayList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行main方法后输出：</span><br><span class="line">[A, B, C]</span><br><span class="line">[A, B, C]</span><br></pre></td></tr></table></figure><p>通过上面的这个例子已经可以可以了解到clone方法仅仅只是克隆了对象的引用而已，而不是克隆了整个对象。通过clone方法得到的对象跟原来的对象中的引用数据类型都是指向同一片内存空间。</p><blockquote><p>clone方法相当于仅仅只是将这个对象栈内存中的数据复制一份存到一个新的引用类型的变量中而已。具体的栈内存和堆内存的关系在<a href="https://www.wrp.cool/posts/24923/">【JavaScript】数据类型</a>一文中有详细介绍。</p></blockquote><p>由于对克隆只是克隆了引用对象的地址而已，并没有深入去克隆这个对象中的引用，所以这种克隆方式称之为浅克隆。如果要实现对引用的克隆则需要修改clone方法，使其不仅克隆引用对象的地址，还能够克隆一个新的引用对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    Prototype prototype = (Prototype) <span class="keyword">super</span>.clone();</span><br><span class="line">    <span class="comment">// 克隆引用对象</span></span><br><span class="line">    prototype.arrayList = (ArrayList&lt;String&gt;) <span class="keyword">this</span>.arrayList.clone();</span><br><span class="line">    <span class="keyword">return</span> prototype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对每个需要深拷贝的对象再进行一次单独的克隆即可完成深克隆，此时原型对象和克隆对象之间分别享有两个不同的ArrayList对象，完成了对ArrayList对象的深克隆。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;原型模式简单来说就是以一个已经创建好的对象为原型，使用二进制流的方式复制这个对象。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://www.wrp.cool/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="创建型设计模式" scheme="https://www.wrp.cool/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="https://www.wrp.cool/posts/29125/"/>
    <id>https://www.wrp.cool/posts/29125/</id>
    <published>2021-04-23T13:51:13.000Z</published>
    <updated>2021-05-07T13:20:17.307Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>单例模式从名称上就很好理解：一个对象保证在内存中只有一个实例。<br>当然，如果是多线程的话也要保证多个线程在运行的过程当中这个实例只会被创建一次。</p><p>单例模式的实现也有两种，懒汉式和饿汉式。从名字上就很好区分，懒汉式就是延迟创建单例对象的一种方式，饿汉式就是即刻创建单例对象的方式。两种实现方式本文都说到。</p><a id="more"></a><h1 id="单线程中的单例模式"><a href="#单线程中的单例模式" class="headerlink" title="单线程中的单例模式"></a>单线程中的单例模式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazeSingleInstance</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LazeSingleInstance lazeSingleInstance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazeSingleInstance</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazeSingleInstance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazeSingleInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            lazeSingleInstance = <span class="keyword">new</span> LazeSingleInstance();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazeSingleInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单线程中的单例模式就只是这样子而已，非常简单。设计一个私有的构造函数是为了不让在外部创建这个类的实例，当然对外也需要提供一个可以获取类实例的方法，这也是单例模式中核心的方法，接下来也将围绕这个方法展开讨论。</p><p>这也是单例模式中最简单的实现，真正的难点在于多线程中如何保证多个线程运行过程中只创建一个实例。</p><h1 id="多线程中的单例模式"><a href="#多线程中的单例模式" class="headerlink" title="多线程中的单例模式"></a>多线程中的单例模式</h1><p>首先复现一个单例模式中可能出现的线程不安全问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazeSingleInstance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lazeSingleInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        lazeSingleInstance = <span class="keyword">new</span> LazeSingleInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lazeSingleInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>先介绍一下Java中new一个对象的过程都发生了什么事情：</strong><br>第一步：为这个对象分配内存。<br>第二步：初始化这个对象，也就是初始化对象里面的一些值。<br>第三步：将对象的地址赋值给创建这个对象的变量。</p></blockquote><p>在上面的这段代码当中，我们假设线程A执行到了第3行的第一步或者是第二步，而这时候刚刚好线程B执行到了第2行，由于线程A还没有为这个对象赋值，所以此时这个对象仍然是null的，那么线程B一样会执行到第三行代码。在这个过程当中，lazeSingleCase对象被创建了两次，违背了单例模式的设计原则。也就是发生了线程不安全的问题。</p><p>感兴趣的同学可以去实际的使用两个线程debug一下这段代码。<br>具体的多线程debug应该怎么操作可以参考<a href="https://blog.wrp.cool/posts/29198/" target="_blank" rel="noopener">【碎笔02】IDEA多线程调试</a>。</p><h2 id="第一次演进：使用-synchronized-关键字解决线程安全的问题。"><a href="#第一次演进：使用-synchronized-关键字解决线程安全的问题。" class="headerlink" title="第一次演进：使用 synchronized 关键字解决线程安全的问题。"></a>第一次演进：使用 synchronized 关键字解决线程安全的问题。</h2><p>具体的 synchronized 关键字的用法可以参考<a href="https://blog.wrp.cool/posts/10492/" target="_blank" rel="noopener">【Java并发】Synchronized关键字</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazeSingleInstance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lazeSingleInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        lazeSingleInstance = <span class="keyword">new</span> LazeSingleInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lazeSingleInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 getInstance() 方法上加了 synchronized 关键字之后保证了同一时间内只有一个线程能够执行方法内的代码，这样就解决了上述的线程不安全的问题。</p><p>但是 synchronized 关键字是加在 static 修饰的方法上的，这意味着锁住了这个类的class文件，这锁的范围太广了，消耗的资源太多。<br>这显然不是一个好的办法。</p><h2 id="第二次演进：将-synchronized-关键字移动至方法内部"><a href="#第二次演进：将-synchronized-关键字移动至方法内部" class="headerlink" title="第二次演进：将 synchronized 关键字移动至方法内部"></a>第二次演进：将 synchronized 关键字移动至方法内部</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazeSingleInstance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (LazeSingleInstance<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazeSingleInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            lazeSingleInstance = <span class="keyword">new</span> LazeSingleInstance();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lazeSingleInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以类锁的形式将创建单例对象的代码锁起来，这也保证了同一段时间内只有一个线程能够执行到创建对象的代码，也同样能够实现单例模式。<br>比起上面将 synchronized 直接加在方法上还得跟其他的加了 LazeSingleInstance.class 类锁的代码去竞争锁的情况在性能上已经是提升了很多了。</p><p><strong>思考一个问题：</strong><br>每个调用 getInstance() 方法的线程都得先等待拿到了锁才能够执行，懒汉式单例模式在仅仅只是在第一次调用这个对象时候才需要去创建这个对象，而现在每次都需要去判断对象是否存在，这显然是不合理的。</p><h2 id="第三次演进：双重检查锁"><a href="#第三次演进：双重检查锁" class="headerlink" title="第三次演进：双重检查锁"></a>第三次演进：双重检查锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazeSingleInstance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lazeSingleInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LazeSingleInstance<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lazeSingleInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                lazeSingleInstance = <span class="keyword">new</span> LazeSingleInstance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lazeSingleInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有兴趣的同学建议先自己分析一下上面的这段代码，这个也是一个比较取巧的一个设计了。</p><p>在外面加多一层 if 的判断，这样就不用每次调用 getInstance() 方法就得去等待 synchronized 锁了。<br>至此，双重检查锁也就设计完毕了。</p><blockquote><p><strong>介绍一个指令重排序的问题</strong><br>jvm 为了能够让 Java 的执行效率能够提高一些，在上面的 new 一个对象的过程，其中的第二步和第三步是有可能会颠倒过来的。也就是先为对象赋上地址值，再初始化这个对象。</p><p>看到这里的同学建议思考一个问题：双重检查锁中如果在创建对象的时候发生了指令重排序的问题，可能会导致什么情况。</p></blockquote><p><strong>答案揭晓：</strong><br>如果是在创建对象的时候先为对象赋上地址值，这个时候对象就已经不是 null 了，那么如果在还没有初始化的情况下，另外一个线程走到了第一个 if 的判断就会直接返回一个还没有初始化的对象。</p><h2 id="第四次演进：使用-volatile-关键字"><a href="#第四次演进：使用-volatile-关键字" class="headerlink" title="第四次演进：使用 volatile 关键字"></a>第四次演进：使用 volatile 关键字</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazeSingleInstance lazeSingleInstance;</span><br></pre></td></tr></table></figure><p>将这个单例对象使用 volatile 关键字去修饰即可解决指令重排序的问题。具体的 volatile 关键字的作用不久会聊到。<br>在这里先了解到 volatile 关键字可以限制在创建这个对象的时候禁止指令重排序即可。</p><h2 id="另外一种解决指令重排序的办法：使用静态内部类实现单例模式"><a href="#另外一种解决指令重排序的办法：使用静态内部类实现单例模式" class="headerlink" title="另外一种解决指令重排序的办法：使用静态内部类实现单例模式"></a>另外一种解决指令重排序的办法：使用静态内部类实现单例模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazeSingleInstance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazeSingleInstance</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> LazeSingleInstance lazeSingleInstance = <span class="keyword">new</span> LazeSingleInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazeSingleInstance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.lazeSingleInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其实也是另外的一种实现单例模式的方式。<br>由于Java中每个类对应唯一的Class文件，所以类的静态属性实际上只会随着类的加载而加载，之后就再也不会去创建这个对象了，也就实现了单例模式。<br>Java中类的加载肯定是只有唯一一次的，所以不管在创建这个类的时候有没有发生指令重排序，这个过程对外都是不可见的。也就解决了指令重排序的问题。</p><p>上面所说的单例模式都是懒汉式单例模式，可以看到单例对象都是在第一次调用的时候才会去创建的，是一个延迟加载的机制。<br>下面就来讲一下饿汉式单例模式。</p><h1 id="饿汉式单例模式"><a href="#饿汉式单例模式" class="headerlink" title="饿汉式单例模式"></a>饿汉式单例模式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstance</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> SingleInstance instance = <span class="keyword">new</span> SingleInstance();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleInstance</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleInstance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饿汉式单例模式实现起来也是比较简单，仅需要在类的初始化的时候直接创建单例对象即可。当然私有的构造函数和提供一个对外访问单例对象的接口还是必须要有的。</p><hr><p><strong>懒汉式和饿汉式的区别和各自的优缺点：</strong></p><ol><li>饿汉式中不存在线程安全问题，因为饿汉式随着类的加载而创建单例对象。</li><li>懒汉式相比与饿汉式更加能够把资源更好的利用起来，如果一个单例对象在一开始就创建出来但是长期不去使用的话，一直驻留在内存中肯定是要比使用到再去创建要耗费掉一些内存空间的。</li><li>当然相比之下我感觉使用静态内部类来实现的单例模式是一种比较好的方式。</li></ol><hr><h1 id="通过反射破坏单例模式"><a href="#通过反射破坏单例模式" class="headerlink" title="通过反射破坏单例模式"></a>通过反射破坏单例模式</h1><p>关于一些反射的知识在<a href="https://blog.wrp.cool/posts/25346/" target="_blank" rel="noopener">【Java基础】反射</a>这篇文章中已经说的很详细了，这方面不了解的同学可以再补补习。</p><blockquote><p>具体的反射如何破坏单例模式的代码这里不再去实现，只做一些原理讲解。不管是懒汉式单例模式还是饿汉式单例模式，都必须得要有一个私有的构造方法，这是为了防止从外部直接new出来单例对象。但这怎么说呢，防君子不防小人吧，如果是通过反射的话很容易能够创建一个新的单例对象出来。而懒汉式单例模式对于反射攻击则是完全没有办法防御的，饿汉式单例模式还能够通过在构造方法做一个判断去防止放射攻击。</p></blockquote><p><strong>演示一下饿汉式单例模式防止反射攻击：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstance</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingleInstance instance = <span class="keyword">new</span> SingleInstance();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"禁止使用反射创建对象！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleInstance <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的就是饿汉式防止反射攻击的一种方式，在私有构造方法中判断一下单例对象是否为空，由于饿汉式单例模式是在类加载时直接创建的单例对象，所以一旦通过反射调用私有构造方法的话肯定会抛出异常结束程序运行。</p><p>但是没有绝对安全的系统，即使是这样，单例模式还是不够安全的。</p><h1 id="使用枚举类防止防止反射攻击"><a href="#使用枚举类防止防止反射攻击" class="headerlink" title="使用枚举类防止防止反射攻击"></a>使用枚举类防止防止反射攻击</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumSingleInstance &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    EnumSingleInstance() &#123;</span><br><span class="line">        <span class="keyword">this</span>.data = <span class="keyword">new</span> Object();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object instance = EnumSingleInstance.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是通过一个Enum类来实现的单例模式，这也是《Effective Java》这本书中推荐的实现单例的方式。这种实现单例的方式可以有效的防止反射和对象的序列化和反序列化对单例模式造成的破坏。具体的原因呢，笔者现在也还是不大明白，先在这里留个坑吧，以后再补好了。</p><p>关于单例模式其实很多学习Java的同学在刚接触Java不久，大概是在学完面向对象之后，应该都会实现一下懒汉式单例模式和饿汉式单例模式。在哪个时候来看单例模式实际上是很简单的一个设计模式，但是单例模式中关于多线程的处理，还有关于Java对象序列化与反序列化的处理，以及如何防止反射破坏单例模式。这些可就一点都不简单了，也说明了越学越深入了吧。</p><p>本来还想聊一下单例模式关于Java对象的序列化与反序列化的，但是我自己暂时也还是没学到这一部分，所以呢就也是留个坑在这里吧，等着以后学到了再来补。有兴趣的同学也可以点击文末的“欢迎打扰”一起交流学习。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;单例模式从名称上就很好理解：一个对象保证在内存中只有一个实例。&lt;br&gt;当然，如果是多线程的话也要保证多个线程在运行的过程当中这个实例只会被创建一次。&lt;/p&gt;
&lt;p&gt;单例模式的实现也有两种，懒汉式和饿汉式。从名字上就很好区分，懒汉式就是延迟创建单例对象的一种方式，饿汉式就是即刻创建单例对象的方式。两种实现方式本文都说到。&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://www.wrp.cool/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="创建型设计模式" scheme="https://www.wrp.cool/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Java" scheme="https://www.wrp.cool/tags/Java/"/>
    
    <category term="设计模式" scheme="https://www.wrp.cool/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="创建型" scheme="https://www.wrp.cool/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B/"/>
    
    <category term="单例模式" scheme="https://www.wrp.cool/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="懒汉式单例模式" scheme="https://www.wrp.cool/tags/%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="饿汉式单例模式" scheme="https://www.wrp.cool/tags/%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="双重检查锁" scheme="https://www.wrp.cool/tags/%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81/"/>
    
    <category term="指令重排序" scheme="https://www.wrp.cool/tags/%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>建造者模式</title>
    <link href="https://www.wrp.cool/posts/25434/"/>
    <id>https://www.wrp.cool/posts/25434/</id>
    <published>2021-04-17T11:31:08.000Z</published>
    <updated>2021-05-07T13:17:03.713Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>首先来看一下百度百科关于建造者模式的描述。（<a href="https://baike.baidu.com/item/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/3229729?fr=aladdin" target="_blank" rel="noopener">建造者模式，百度百科</a>）</p><p><strong>实用范围：</strong><br>1、当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。<br>2、当构造过程必须允许被构造的对象有不同表示时。</p><p><strong>建造者模式中的4个角色：</strong><br>1、Builder：为创建一个产品对象的各个部件指定抽象接口。<br>2、ConcreteBuilder：实现Builder的接口以构造和装配该产品的各个部件，定义并明确它所创建的表示，并提供一个检索产品的接口。<br>3、Director：构造一个使用Builder接口的对象。<br>4、Product：表示被构造的复杂对象。ConcreteBuilder创建该产品的内部表示并定义它的装配过程，包含定义组成部件的类，包括将这些部件装配成最终产品的接口。</p><hr><blockquote><p>以上是百度百科中关于建造者模式的一些描述，下面说一些我自己的理解。</p></blockquote><a id="more"></a><p><strong>实用范围：</strong><br>1、创建对象部分的代码必须与使用到这个对象的代码解耦。<br>2、一个对象必须有多种不同的装配方式，这不仅仅是简单的参数不同。</p><p><strong>建造者模式中的4个角色：</strong><br>1、Product（产品）：要创建的对象，是一个具体的实体类。<br>2、Builder（建造者）：根据创建对象的过程实际抽象出来的接口。<br>3、ConcreteBuilder（具体建造者）：实现builder接口，实际创建对象的类。<br>4、Director（导演）：在完成上面的三个对象的工作之后交由Director类来创建对象，由此达到创建对象的过程与实际使用对象的代码解耦的目的。</p><h1 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h1><p>这里实际以创建一个手机对象为例子来用代码描述一下建造者模式</p><p><strong>手机类</strong>，对应的是Product角色：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBrand</span><span class="params">(String brand)</span> </span>&#123; <span class="keyword">this</span>.brand = brand; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNum</span><span class="params">(String num)</span> </span>&#123; <span class="keyword">this</span>.num = num; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> brand + <span class="string">"Phone&#123;name='"</span> + name + <span class="string">"', num='"</span> + num + <span class="string">"'&#125;"</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>由创建手机的过程抽象出来的抽象类</strong>，对应的是Builder角色：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">builderPhoneName</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">builderPhoneNum</span><span class="params">(String num)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Phone <span class="title">makePhone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>两个实际创建手机类的创建者</strong>，分别创建华为手机和小米手机，对应的是ConcreteBuilder角色：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HUAWEIPhoneBuilder</span> <span class="keyword">extends</span> <span class="title">PhoneBuilder</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HUAWEIPhoneBuilder</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>.phone.setBrand(<span class="string">"HUAWEI"</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">builderPhoneName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.phone.setName(name); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">builderPhoneNum</span><span class="params">(String num)</span> </span>&#123; <span class="keyword">this</span>.phone.setNum(num); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">makePhone</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.phone; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MIPhoneBuilder</span> <span class="keyword">extends</span> <span class="title">PhoneBuilder</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MIPhoneBuilder</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>.phone.setBrand(<span class="string">"MI"</span>); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">builderPhoneName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.phone.setName(name); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">builderPhoneNum</span><span class="params">(String num)</span> </span>&#123; <span class="keyword">this</span>.phone.setNum(num); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">makePhone</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.phone; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>创建手机的类</strong>，对应的是Director角色：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneDirector</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PhoneBuilder phoneBuilder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PhoneDirector</span><span class="params">(PhoneBuilder phoneBuilder)</span> </span>&#123; <span class="keyword">this</span>.phoneBuilder = phoneBuilder; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">makePhone</span><span class="params">(String name, String num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.phoneBuilder.builderPhoneName(name);</span><br><span class="line">        <span class="keyword">this</span>.phoneBuilder.builderPhoneNum(num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.phoneBuilder.makePhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>以上准备工作完成，接下来测试一下效果怎么样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PhoneDirector HUAWEIDirector = <span class="keyword">new</span> PhoneDirector(<span class="keyword">new</span> HUAWEIPhoneBuilder());</span><br><span class="line">        Phone HUAWEIPhone = HUAWEIDirector.makePhone(<span class="string">"P30"</span>, <span class="string">"135 0000 0000"</span>);</span><br><span class="line"></span><br><span class="line">        PhoneDirector MIDirector = <span class="keyword">new</span> PhoneDirector(<span class="keyword">new</span> MIPhoneBuilder());</span><br><span class="line">        Phone MIPhone = MIDirector.makePhone(<span class="string">"MI11"</span>, <span class="string">"135 1111 1111"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(HUAWEIPhone);</span><br><span class="line">        System.out.println(MIPhone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HUAWEIPhone&#123;name&#x3D;&#39;P30&#39;, num&#x3D;&#39;135 0000 0000&#39;&#125;</span><br><span class="line">MIPhone&#123;name&#x3D;&#39;MI11&#39;, num&#x3D;&#39;135 1111 1111&#39;&#125;</span><br></pre></td></tr></table></figure><p><strong>类图：</strong>（为了能够更好的看清楚这个结构，这个类图中省略了小米手机类）<br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20210418103856.png" alt="20210418103856"></p><p><strong>小结：</strong>（以下两个小点分别对应百度百科实用范围中的两个小点）</p><ol><li>测试类在使用手机对象时完全没有涉及到创建手机的过程，将创建手机过程与测试类的使用是解耦的。</li><li>如果我们需要的对象是一个其他的表示的话，比如我们需要把华为手机换成小米手机，只需要把HUAWEIPhoneBuilder换成MIPhoneBuilder即可。</li></ol><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>思考一个问题：如果实际开发中不需要将创建对象的代码与实际使用这个对象的代码分离开呢？也就是仅仅只是需要有多种不同的装配对象的方式。</p><p>还是上面的这个例子，将创建对象的逻辑与对象本身绑定在一起，仅仅只剩下一个Product角色。<br>这里假设只是需要一个华为手机。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Phone</span><span class="params">(HUAWEIPhoneBuilder huaweiPhoneBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand = huaweiPhoneBuilder.brand;</span><br><span class="line">        <span class="keyword">this</span>.name = huaweiPhoneBuilder.name;</span><br><span class="line">        <span class="keyword">this</span>.num = huaweiPhoneBuilder.num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> brand + <span class="string">"Phone&#123;name='"</span> + name + <span class="string">"', num='"</span> + num + <span class="string">"'&#125;"</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原来的 ConcreteBuilder 具体创建者角色</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HUAWEIPhoneBuilder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String brand;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> String num;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认创建的手机品牌</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HUAWEIPhoneBuilder</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>.brand = <span class="string">"HUAWEI"</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> HUAWEIPhoneBuilder <span class="title">buildName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> HUAWEIPhoneBuilder <span class="title">buildNum</span><span class="params">(String num)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.num = num;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Phone <span class="title">build</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Phone(<span class="keyword">this</span>); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone HUAWEIPhone = <span class="keyword">new</span> Phone.HUAWEIPhoneBuilder().buildName(<span class="string">"P30"</span>).buildNum(<span class="string">"135 0000 0000"</span>).build();</span><br><span class="line">        System.out.println(HUAWEIPhone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HUAWEIPhone&#123;name&#x3D;&#39;P30&#39;, num&#x3D;&#39;135 0000 0000&#39;&#125;</span><br></pre></td></tr></table></figure><p><strong>类图：</strong><br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20210418105741.png" alt="20210418105741"></p><p><strong>小结：</strong></p><ol><li>将创建对象的过程与这个对象绑定在一起，以一种链式调用的方式来解决在不同的业务场景下同一个对象的不同的装配方式。</li><li>但同时使用这个对象的代码与创建对象的代码也就耦合了。</li></ol><hr><p>上面只需创建华为手机的例子仅仅只是对于前面的一个扩展，这并不能够很好的帮助我们理解什么是对象的不同装配方式，以及如何去使用。<br>下面举一个更加形象的例子来帮助大家去理解建造者模式，比如我现在需要一个只有加法和减法的计算器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> result;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> result; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入基础操作数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Calculator</span><span class="params">(<span class="keyword">int</span> result)</span> </span>&#123; <span class="keyword">this</span>.result = result; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Calculator <span class="title">add</span><span class="params">(<span class="keyword">int</span> addNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.result += addNum;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Calculator <span class="title">sub</span><span class="params">(<span class="keyword">int</span> subNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.result -= subNum;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="keyword">new</span> Calculator(<span class="number">10</span>).add(<span class="number">10</span>).sub(<span class="number">5</span>).getResult();</span><br><span class="line">        System.out.println(<span class="string">"result："</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result：15</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;首先来看一下百度百科关于建造者模式的描述。（&lt;a href=&quot;https://baike.baidu.com/item/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/3229729?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;建造者模式，百度百科&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实用范围：&lt;/strong&gt;&lt;br&gt;1、当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。&lt;br&gt;2、当构造过程必须允许被构造的对象有不同表示时。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;建造者模式中的4个角色：&lt;/strong&gt;&lt;br&gt;1、Builder：为创建一个产品对象的各个部件指定抽象接口。&lt;br&gt;2、ConcreteBuilder：实现Builder的接口以构造和装配该产品的各个部件，定义并明确它所创建的表示，并提供一个检索产品的接口。&lt;br&gt;3、Director：构造一个使用Builder接口的对象。&lt;br&gt;4、Product：表示被构造的复杂对象。ConcreteBuilder创建该产品的内部表示并定义它的装配过程，包含定义组成部件的类，包括将这些部件装配成最终产品的接口。&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;以上是百度百科中关于建造者模式的一些描述，下面说一些我自己的理解。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://www.wrp.cool/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="创建型设计模式" scheme="https://www.wrp.cool/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Java" scheme="https://www.wrp.cool/tags/Java/"/>
    
    <category term="设计模式" scheme="https://www.wrp.cool/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="创建型" scheme="https://www.wrp.cool/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B/"/>
    
    <category term="建造者模式" scheme="https://www.wrp.cool/tags/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【Java基础】反射</title>
    <link href="https://www.wrp.cool/posts/25346/"/>
    <id>https://www.wrp.cool/posts/25346/</id>
    <published>2020-10-02T11:45:30.000Z</published>
    <updated>2021-05-23T01:16:00.414Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>首先来看一下百度百科中对于Java反射的定义，<a href="https://baike.baidu.com/item/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/6015990?fr=aladdin" target="_blank" rel="noopener">JAVA反射机制，百度百科</a></p><blockquote><p>Java的反射（reflection）机制是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制。反射被视为动态语言的关键。</p></blockquote><a id="more"></a><blockquote><p>Java反射机制主要提供了以下功能： 在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象；在运行时判断任意一个类所具有的成员变量和方法；在运行时调用任意一个对象的方法；生成动态代理。</p></blockquote><blockquote><p>有时候我们说某个语言具有很强的动态性，有时候我们会区分动态和静态的不同技术与作法。我们朗朗上口动态绑定（dynamic binding）、动态链接（dynamic linking）、动态加载（dynamic loading）等。然而“动态”一词其实没有绝对而普遍适用的严格定义，有时候甚至像面向对象当初被导入编程领域一样，一人一把号，各吹各的调。</p></blockquote><blockquote><p>一般而言，开发者社群说到动态语言，大致认同的一个定义是：“程序运行时，允许改变程序结构或变量类型，这种语言称为动态语言”。从这个观点看，Perl，Python，Ruby是动态语言，C++，Java，C#不是动态语言。</p></blockquote><blockquote><p>尽管在这样的定义与分类下Java不是动态语言，它却有着一个非常突出的动态相关机制：Reflection。这个字的意思是“反射、映象、倒影”，用在Java身上指的是我们可以于运行时加载、探知、使用编译期间完全未知的classes。换句话说，Java程序可以加载一个运行时才得知名称的class，获悉其完整构造（但不包括methods定义），并生成其对象实体、或对其fields设值、或唤起其methods。这种“看透class”的能力（the ability of the program to examine itself）被称为introspection（内省、内观、反省）。Reflection和introspection是常被并提的两个术语。</p></blockquote><p>上面这几段话出自百度百科，由此可以看出，Java反射机制的重要性。由于反射机制的存在使得Java语言变身成为一门准动态语言。很多主流框架中也是大量的使用了反射技术，像是我们说的Spring就是基于反射 + 配置 + 工厂的形式实现的。</p><h1 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h1><p>想要了解反射机制，首先来了解一个类<code>java.lang.Class</code>反射机制中最重要的一个类，Class类（描述类的类）。</p><p><strong>Java中的类：</strong>可以继承某个类，可以实现某一些接口，可以在类中定义类的属性，方法，和构造器。</p><p>由此，Class类（描述类的类）主要就是描述了类继承了哪个父类，实现了那些接口，定义了那些方法和属性，以及类中的构造器。</p><p><strong>小结：</strong>类的声明、类中的属性和方法、类的构造器是 <code>Class</code> 类主要的描述对象。</p><hr><p>既然Class类是描述类的类，那么就表明了Class类也是一个Java类，也必须遵守Java中关于类的规范，这一点不会变。</p><p>来分析一下Class类，首先看一下构造函数。<br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20200921203210.png" alt="20200921203210"><br>这是jdk1.8中Class类的构造函数，这是一个私有化的构造函数，意味着在外界是不能直接创建Class类的实例的。</p><p>实际上，Class类的实例也并不是创建出来的，Class类的实例是JVM在加载每个class字节码文件时自动生成的实例。</p><p>每个Class类对应的都是被JVM所加载的一个个class文件，相同的，每个class文件也都有一个唯一与之对应的Class实例。</p><h1 id="如何获取Class类的实例"><a href="#如何获取Class类的实例" class="headerlink" title="如何获取Class类的实例"></a>如何获取Class类的实例</h1><p>这里将通过一个User类来演示四种获取Class实例的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cool.wrp.reflex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.类名.class</span></span><br><span class="line">        Class&lt;User&gt; userClass1 = User<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.实例.getClass()</span></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        Class userClass2 = user.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.Class.forName("全限定类名")</span></span><br><span class="line">        Class userClass3 = Class.forName(<span class="string">"cool.wrp.reflex.User"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.类加载器</span></span><br><span class="line">        ClassLoader classLoader = user.getClass().getClassLoader();</span><br><span class="line">        Class userClass4  = classLoader.loadClass(<span class="string">"cool.wrp.reflex.User"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(userClass1.hashCode());</span><br><span class="line">        System.out.println(userClass2.hashCode());</span><br><span class="line">        System.out.println(userClass3.hashCode());</span><br><span class="line">        System.out.println(userClass4.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行main方法可以发现，四个Class实例的hashCode都是相同的，这证明了每个class字节码文件都有且仅有唯一一个与之对应的Class实例。</p><p>以上的四种方式，我们在实际开发中应该尽可能的使用第一种方式去获得Class类的实例，因为这种方式的效率是最高的。</p><h1 id="Class类是怎么描述类的"><a href="#Class类是怎么描述类的" class="headerlink" title="Class类是怎么描述类的"></a>Class类是怎么描述类的</h1><p style="text-indent:2em">在这里引用 <b>Java核心技术卷一 5.7.4</b> 中的内容来讲述Class类是怎么描述类的。</p><p style="text-indent:2em">在 java.lang.reflect 包中有三个类 Firld、Method 和 Construct 分别用于描述类的字段、方法和构造器。这三个类都有一个叫做 getName 的方法，用来返回字段、方法或构造器的名称。Field 类还有一个 getType 方法，用来描述字段类型的一个对象，这个对象的类型同样是Class。Method 和 Constructor 类有报告参数类型的方法，Method类还有一个报告返回类型的方法。这三个类都有一个名为 getModifiers 的方法，它将返回一个整数， 用不同 0/1 位描述所使用的修饰符，如 public 和 static。另外，还可以利用 java.lang.refkect 包中的 Modifier 类的静态方法分析 getModifiers 返回的这个整数，例如，可以使用 Modifier 类中的 isPublic、isPrivate 或 isFinal 判断方法或构造器是 public、private 还是 final。我们需要做的就是在 getModifiers 返回的整数上调用 Modifier 类中适当的方法，另外，还可以利用 Modifier.toString 方法将修饰符打印出来。</p><p style="text-indent:2em">Class 类中的 getFields、getMethods 和 getConstructors 方法将分别返回这个类支持的 <b>公共</b> 字段、方法和构造器的数组，其中包括超类的公共成员。Class 类的 getDeclareFields、getDeclareMethods 和 getDeclaredConstrors方法将分别返回类中声明的全部字段、方法和构造器的数组，其中包括私有成员、包成员和受保护成员，但不包括超类的成员。</p><hr><p><strong>来看一个书中的例子加深对这段话的理解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read class name from user input</span></span><br><span class="line">    System.out.println(<span class="string">"class name:"</span>);</span><br><span class="line">    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    String className = scanner.next();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print class name and super class name (if != Object)</span></span><br><span class="line">    Class cl = Class.forName(className);</span><br><span class="line">    Class supercl = cl.getSuperclass();</span><br><span class="line">    String modifiers = Modifier.toString(cl.getModifiers());</span><br><span class="line">    <span class="keyword">if</span> (modifiers.length() &gt; <span class="number">0</span>)</span><br><span class="line">        System.out.print(modifiers + <span class="string">" "</span>);</span><br><span class="line">    System.out.print(<span class="string">"class "</span> + className);</span><br><span class="line">    <span class="keyword">if</span> (supercl != <span class="keyword">null</span> &amp;&amp; supercl != Object<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">        System.out.print(" extends " + supercl.getName());</span><br><span class="line"></span><br><span class="line">    System.out.print(<span class="string">"\n&#123;\n"</span>);</span><br><span class="line">    printConstructors(cl);</span><br><span class="line">    System.out.println();</span><br><span class="line">    printMethods(cl);</span><br><span class="line">    System.out.println();</span><br><span class="line">    printFields(cl);</span><br><span class="line">    System.out.println(<span class="string">"\n&#125;\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单分析一下以上的代码，首先是一个接收用户在控制台的输入，通过scanner对象读取用户从控制台输入的一个全限定类名。之后通过 Class.forName 的形式去获取到用户输入类名对应的Class类对象。获取到Class对象之后再去获取父类和修饰符。</p><p>如果需要判断类使用了什么修饰符可以使用 <code>Modifier.isPublic(cl.getModifiers())</code> 来判断类是否被 public 所修饰。以此类推，判断是否被 private 所修饰则使用 <code>isPrivate</code>，是否 final 则 <code>isFinal</code>等等。</p><p>另外可以使用 <code>getInterfaces()</code> 方法去获取到一个类所实现的接口有哪些。由于Java是支持多实现的，所以该方法实际上返回的是一个泛型为Class类型的数组，用来描述类所实现的接口。</p><blockquote><p>以上是Class对象如何描述一个Java类声明的内容，接下来分析Class对象是如何去描述类的构造器、方法和属性的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Prints all constructors of a class</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cl a class</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printConstructors</span><span class="params">(Class cl)</span> </span>&#123;</span><br><span class="line">    Constructor[] constructors = cl.getDeclaredConstructors();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Constructor c : constructors) &#123;</span><br><span class="line">        String name = c.getName();</span><br><span class="line">        System.out.print(<span class="string">"\t"</span>);</span><br><span class="line">        String modifiers = Modifier.toString(c.getModifiers());</span><br><span class="line">        <span class="keyword">if</span> (modifiers.length() &gt; <span class="number">0</span>) System.out.print(modifiers + <span class="string">" "</span>);</span><br><span class="line">        System.out.print(name + <span class="string">"("</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// print parameter type</span></span><br><span class="line">        Class[] paramTypes = c.getParameterTypes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; paramTypes.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>) System.out.print(<span class="string">", "</span>);</span><br><span class="line">            System.out.print(paramTypes[j].getName());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">");"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Prints all method of a class</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cl a class</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMethods</span><span class="params">(Class cl)</span> </span>&#123;</span><br><span class="line">    Method[] methods = cl.getDeclaredMethods();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Method m : methods) &#123;</span><br><span class="line">        Class retType = m.getReturnType();</span><br><span class="line">        String name = m.getName();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"\t"</span>);</span><br><span class="line">        <span class="comment">// print modifiers, return type and method name</span></span><br><span class="line">        String modifiers = Modifier.toString(m.getModifiers());</span><br><span class="line">        <span class="keyword">if</span> (modifiers.length() &gt; <span class="number">0</span>) System.out.print(modifiers + <span class="string">" "</span>);</span><br><span class="line">        System.out.print(retType.getName() + <span class="string">" "</span> + name + <span class="string">"("</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// print parameter types</span></span><br><span class="line">        Class[] paramTypes = m.getParameterTypes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; paramTypes.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>) System.out.print(<span class="string">", "</span>);</span><br><span class="line">            System.out.print(paramTypes[j].getName());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">");"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Prints all fields of a class</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cl a class</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFields</span><span class="params">(Class cl)</span> </span>&#123;</span><br><span class="line">    Field[] fields = cl.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Field f : fields) &#123;</span><br><span class="line">        Class type = f.getType();</span><br><span class="line">        String name = f.getName();</span><br><span class="line">        System.out.print(<span class="string">"\t"</span>);</span><br><span class="line">        String modifiers = Modifier.toString(f.getModifiers());</span><br><span class="line">        <span class="keyword">if</span> (modifiers.length() &gt; <span class="number">0</span>) System.out.print(modifiers + <span class="string">" "</span>);</span><br><span class="line">        System.out.println(type.getName() + <span class="string">" "</span> + name + <span class="string">";"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有兴趣的同学可以执行一遍以上的代码，可以更清楚的展示Class对象是如何去描述一个类的。</p><hr><p>书中的这个例子已经是很详细的讲明白了Class类是如何去描述一个类的，但这里还有一点补充，就是<strong>Class类是如何去描述类中的注解的</strong>。</p><p>我们使用 <a href="https://blog.wrp.cool/posts/28807/" target="_blank" rel="noopener">【Java基础】</a> 注解一文开头的注解例子做演示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation</span>(value = <span class="string">"MyAnnotation's value"</span>, name = <span class="string">"MyAnnotation's name"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TargetClass</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mainn</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; cl = TargetClass<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取注解对象</span></span><br><span class="line">        MyAnnotation myAnnotation = cl.getAnnotation(MyAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 打印注解中的内容</span></span><br><span class="line">        System.out.println(myAnnotation.value());</span><br><span class="line">        System.out.println(myAnnotation.name());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行main方法：<br><code>MyAnnotation&#39;s value</code><br><code>MyAnnotation&#39;s name</code></p></blockquote><blockquote><p>同样的 <code>Constructor、Method、Field</code> 对象也有 <code>getAnnotation</code> 方法。</p></blockquote><h1 id="Class类是怎么操作类的"><a href="#Class类是怎么操作类的" class="headerlink" title="Class类是怎么操作类的"></a>Class类是怎么操作类的</h1><p>操作类也是分别对应着Java中对类的操作，首先是类的实例化，然后可以<strong>设置类的属性、获取类的属性、调用类的方法</strong>。而属性和方法又分为<strong>公共、私有和静态</strong></p><h3 id="类的实例化"><a href="#类的实例化" class="headerlink" title="类的实例化"></a>类的实例化</h3><p>通过反射实例化的类也是需要调用构造器的，构造方法分为有参构造器和无参构造器。</p><p>使用反射实例化一个类有两种方式，一个是调用<strong>Class对象的newInstance()方法</strong>，另一个是调用<strong>Constructor对象的newInstance()方法</strong>。</p><p><strong>实验环境</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TargetClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TargetClass</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TargetClass</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Class 对象的 newInstance() 方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TargetClass<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>()</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"main方法运行完毕"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>运行main方法抛出空指针异常</code></p><p><strong>Constructor 对象的 newInstance() 方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; cl = TargetClass<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造器</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cl.getDeclaredConstructor().newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参构造器</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cl.getDeclaredConstructor(String.class).newInstance("我是有参构造器实例化的对象");</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"main方法运行完毕"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行main方法<br><code>抛出由java.lang.NullPointerException引起的java.lang.reflect.InvocationTargetException</code><br>打印：<code>我是有参构造器实例化的对象</code><br>打印：<code>main方法运行完毕</code></p></blockquote><p><strong>小结：</strong></p><ol><li><strong>Class 对象的 newInstance() 方法</strong>无法调用有参构造函数，只能调用无参构造器</li><li><strong>Class 对象的 newInstance() 方法</strong>无法捕获构造器中的异常，而<strong>Constructor 对象的 newInstance() 方法</strong>会将构造器中的异常封装成 <code>java.lang.reflect.InvocationTargetException</code> 异常</li><li>建议使用<strong>Constructor 对象的 newInstance() 方法</strong></li></ol><hr><blockquote><p>在这里首先引入一个简单的概念，<strong>显示参数</strong>和<strong>隐式参数</strong>。在这里先简单的理解为调用属性的对象。</p></blockquote><p><strong>显示参数：</strong>在方法中明确定义的参数为显示参数</p><p><strong>隐式参数：</strong>未在方法是定义的，但的确又动态影响到程序运行的“参数”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line">        user.setName(<span class="string">"张三"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如以上代码 <code>user</code> 对象为隐式参数，实际传入的 <code>&quot;张三&quot;</code> 字符串为显示参数。</p><hr><h3 id="操作属性"><a href="#操作属性" class="headerlink" title="操作属性"></a>操作属性</h3><p><strong>实验环境</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目标类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TargetClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String pubAttr;</span><br><span class="line">    <span class="keyword">static</span> String staAttr;</span><br><span class="line">    <span class="keyword">private</span> String priAttr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; cl = TargetClass<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实例化一个对象作为隐式参数</span></span><br><span class="line">        TargetClass tc = <span class="keyword">new</span> TargetClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取属性</span></span><br><span class="line">        Field pubAttr = cl.getDeclaredField(<span class="string">"pubAttr"</span>);</span><br><span class="line">        Field staAttr = cl.getDeclaredField(<span class="string">"staAttr"</span>);</span><br><span class="line">        Field priAttr = cl.getDeclaredField(<span class="string">"priAttr"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>公共属性</strong></p><blockquote><p>实际上，Java中的非静态属性都是挂载在对应的对象上的。反射也没有例外，所以我们如果想要通过反射去操作一个属性，我们同样是需要给这个属性一个可以挂载的地方，也就是一个对象，这个对象也就是前文提到的隐式参数。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置公共属性的值</span></span><br><span class="line">pubAttr.set(tc, <span class="string">"我是公共属性"</span>);</span><br><span class="line"><span class="comment">// 获取公共属性的值</span></span><br><span class="line">System.out.println(pubAttr.get(tc));</span><br></pre></td></tr></table></figure><p><code>输出：我是公共属性</code></p><p>上面的两行代码中的tc就是对应的对象挂载的地方。在这里我将其理解为pubAttr属性的隐式参数。</p><p><strong>静态属性</strong></p><blockquote><p>刚刚说的Java中的非静态属性都是挂载在对象上的，而静态属性与Class对象一样是存储在方法区中的。所以不需要挂载的对象，在传参数的时候直接传一个null对象即可。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置静态属性的值</span></span><br><span class="line">staAttr.set(<span class="keyword">null</span>, <span class="string">"我是静态属性"</span>);</span><br><span class="line"><span class="comment">// 获取静态属性的值</span></span><br><span class="line">System.out.println(staAttr.get(<span class="keyword">null</span>));</span><br></pre></td></tr></table></figure><p><code>输出：我是静态属性</code></p><p><strong>私有属性</strong></p><blockquote><p>Java中类的私有属性是无法通过外部去设置和获取的，而反射可以改变这一点，这同时也正是反射的强大之处。只需要一行代码设置访问权限即可访问类的私有属性。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 授权访问</span></span><br><span class="line">priAttr.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 设置私有属性的值</span></span><br><span class="line">priAttr.set(tc, <span class="string">"我是私有属性"</span>);</span><br><span class="line"><span class="comment">// 获取私有属性的值</span></span><br><span class="line">System.out.println(priAttr.get(tc));</span><br></pre></td></tr></table></figure><p><code>输出：我是私有属性</code></p><h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><p>操作方法和操作属性实际上差不多，也都分共有、私有、静态方法。不同的是，在获取Method对象时需要指定参数列表，执行Method方法时也需要传入对应方法的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TargetClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pubMethod</span><span class="params">(String name)</span> </span>&#123; System.out.println(<span class="string">"我是"</span> + name); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staMethod</span><span class="params">(String name)</span> </span>&#123; System.out.println(<span class="string">"我是"</span> + name); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">priMethod</span><span class="params">(String name)</span> </span>&#123; System.out.println(<span class="string">"我是"</span> + name); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reflex</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; cl = TargetClass<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"></span><br><span class="line">        TargetClass tc = (TargetClass) cl.newInstance();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 获取公共方法</span></span><br><span class="line">        Method pubMethod = cl.getDeclaredMethod(<span class="string">"pubMethod"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 执行公共方法</span></span><br><span class="line">        pubMethod.invoke(tc, <span class="string">"公共方法"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取静态方法</span></span><br><span class="line">        Method staMethod = cl.getDeclaredMethod(<span class="string">"staMethod"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 执行静态方法</span></span><br><span class="line">        staMethod.invoke(<span class="keyword">null</span>, <span class="string">"静态方法"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取私有方法</span></span><br><span class="line">        Method priMethod = cl.getDeclaredMethod(<span class="string">"priMethod"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 私有方法授权</span></span><br><span class="line">        priMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 执行私有方法</span></span><br><span class="line">        priMethod.invoke(tc, <span class="string">"私有方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;首先来看一下百度百科中对于Java反射的定义，&lt;a href=&quot;https://baike.baidu.com/item/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/6015990?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JAVA反射机制，百度百科&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Java的反射（reflection）机制是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制。反射被视为动态语言的关键。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Java 基础" scheme="https://www.wrp.cool/categories/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="反射" scheme="https://www.wrp.cool/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>【Java基础】注解</title>
    <link href="https://www.wrp.cool/posts/28807/"/>
    <id>https://www.wrp.cool/posts/28807/</id>
    <published>2020-09-13T03:11:52.000Z</published>
    <updated>2021-05-23T01:16:05.051Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "我的注解"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> "name"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是Java自定义注解的格式，其中的四个注解就是元注解，也就是我们接下注解部分来的重点。</p><a id="more"></a><h1 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h1><p>普通的注解就是用来修饰例如变量、方法和类的。而元注解是用来修饰注解的，是修饰注解的注解。下面的四个注解就是元注解。</p><p><strong>@Target</strong><br>目标的意思，表示的是注解可以修饰的目标。参数是一个<code>java.lang.annotation.ElementType</code>类型的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;</span><br><span class="line">        ElementType.TYPE,               <span class="comment">// 类、接口、枚举类</span></span><br><span class="line">        ElementType.FIELD,              <span class="comment">// 成员变量、枚举常量</span></span><br><span class="line">        ElementType.METHOD,             <span class="comment">// 成员方法</span></span><br><span class="line">        ElementType.PARAMETER,          <span class="comment">// 方法参数</span></span><br><span class="line">        ElementType.CONSTRUCTOR,        <span class="comment">// 构造方法</span></span><br><span class="line">        ElementType.LOCAL_VARIABLE,     <span class="comment">// 局部变量</span></span><br><span class="line">        ElementType.ANNOTATION_TYPE,    <span class="comment">// 注解类</span></span><br><span class="line">        ElementType.PACKAGE,            <span class="comment">// 包</span></span><br><span class="line">        ElementType.TYPE_PARAMETER,     <span class="comment">// 类型参数，jdk1.8新增</span></span><br><span class="line">        ElementType.TYPE_USE            <span class="comment">// 使用类型的任何地方，jdk1.8新增</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@Retention</strong><br>有点类似于生命周期的意思，表示的是注解在程序中作用的范围，参数是<code>java.lang.annotation.RetentionPolicy</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)      <span class="comment">// 源文件保留</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.CLASS)       <span class="comment">// 编译后保留</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)     <span class="comment">// 运行时保留</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@Inherited</strong><br>Inherited注解的作用是：使被它修饰的注解具有继承性（如果某个类使用了被@Inherited修饰的注解，则其子类将自动具有该注解）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyInheritedAnnotation &#123; </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyInheritedAnnotation</span>(name=<span class="string">"parent"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Class&lt;Child&gt; child = Child<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">MyInheritedAnnotation annotation = child.getAnnotation(MyInheritedAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(annotation.name());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行main方法打印结果：<code>parent</code></p><p><strong>@Documented</strong><br>Documented注解的作用是：描述在使用 javadoc 工具为类生成帮助文档时是否要保留其注解信息。</p><blockquote><p>以上内容参考：<a href="https://blog.csdn.net/pengjunlee/article/details/79683621#meta-annotation%EF%BC%88%E5%85%83%E6%B3%A8%E8%A7%A3%EF%BC%89" target="_blank" rel="noopener">JAVA核心知识点–元注解详解</a></p></blockquote><p><strong>彩蛋：</strong><br>将名称定义成value的值在使用时是可以省略value属性不写的。<br>例如上面定义的<code>MyAnnotation</code>注解，在设置值时<code>value</code>属性是可以省略属性名称的，而<code>name</code>属性则不可以省略属性名称。</p><p><code>@MyAnnotation(&quot;value&quot;)</code> 表示指定了value的值<br><code>@MyAnnotation(name = &quot;name&quot;)</code> 表示指定了name的值<br><code>@MyAnnotation(value = &quot;value&quot;, name = &quot;name&quot;)</code> 表示指定了value和name的值，如果指定了多个值则属性名不可以省略</p>]]></content>
    
    
    <summary type="html">&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Target&lt;/span&gt;(ElementType.TYPE)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Retention&lt;/span&gt;(RetentionPolicy.RUNTIME)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Documented&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Inherited&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;@interface&lt;/span&gt; MyAnnotation &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;String &lt;span class=&quot;title&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &quot;我的注解&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;String &lt;span class=&quot;title&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &quot;name&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上就是Java自定义注解的格式，其中的四个注解就是元注解，也就是我们接下注解部分来的重点。&lt;/p&gt;</summary>
    
    
    
    <category term="Java 基础" scheme="https://www.wrp.cool/categories/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="注解" scheme="https://www.wrp.cool/tags/%E6%B3%A8%E8%A7%A3/"/>
    
    <category term="元注解" scheme="https://www.wrp.cool/tags/%E5%85%83%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【Spring】依赖注入</title>
    <link href="https://www.wrp.cool/posts/47506/"/>
    <id>https://www.wrp.cool/posts/47506/</id>
    <published>2020-09-08T12:11:02.000Z</published>
    <updated>2021-05-07T13:19:13.099Z</updated>
    
    <content type="html"><![CDATA[<p><em>依赖注入（Dependency Injection简称DI）</em><br><strong>依赖：</strong>指Bean对象的创建依赖于IOC容器，Bean对象的依赖资源。<br><strong>注入：</strong>指Bean对象所依赖的资源，由容器来设置和装配。</p><a id="more"></a><h3 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h3><p>构造器注入这里与上文<a href="http://blog.wrp.cool/posts/17371/" target="_blank" rel="noopener">【Spring】创建对象</a> 中「通过构造方法创建对象」相同，这里不再赘述。</p><h3 id="set方法注入"><a href="#set方法注入" class="headerlink" title="set方法注入"></a>set方法注入</h3><h4 id="基本数据类型和字符串注入"><a href="#基本数据类型和字符串注入" class="headerlink" title="基本数据类型和字符串注入"></a>基本数据类型和字符串注入</h4><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20200831232348.png" alt="20200831232348"></p><h4 id="java-util-Properties类注入"><a href="#java-util-Properties类注入" class="headerlink" title="java.util.Properties类注入"></a>java.util.Properties类注入</h4><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20200831232859.png" alt="20200831232859"></p><h4 id="注入Bean"><a href="#注入Bean" class="headerlink" title="注入Bean"></a>注入Bean</h4><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20200901203712.png" alt="20200901203712"></p><blockquote><p>注意上面加了颜色的这句话<code>但是销毁回调允许它参与请求作用域的生命周期。</code><br>这句话的意思是，当Bean被销毁时，这个Bean所注入的其他的Bean并不会被一同销毁，也就是会继续驻留在内存中。如果我们要销毁这个Bean，需要进一步的销毁操作。差不多就像是闭包的意思。</p></blockquote><h4 id="集合类型的注入"><a href="#集合类型的注入" class="headerlink" title="集合类型的注入"></a>集合类型的注入</h4><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20200901205115.png" alt="20200901205115"></p><h4 id="注入空字符串"><a href="#注入空字符串" class="headerlink" title="注入空字符串"></a>注入空字符串</h4><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20200901214249.png" alt="20200901214249"></p><h4 id="注入null"><a href="#注入null" class="headerlink" title="注入null"></a>注入null</h4><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20200901214315.png" alt="20200901214315"></p><h3 id="p名称空间注入"><a href="#p名称空间注入" class="headerlink" title="p名称空间注入"></a>p名称空间注入</h3><h4 id="普通属性"><a href="#普通属性" class="headerlink" title="普通属性"></a>普通属性</h4><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20200901214537.png" alt="20200901214537"></p><h4 id="其他bean引用"><a href="#其他bean引用" class="headerlink" title="其他bean引用"></a>其他bean引用</h4><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20200901214554.png" alt="20200901214554"></p><h3 id="c名称空间注入"><a href="#c名称空间注入" class="headerlink" title="c名称空间注入"></a>c名称空间注入</h3><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20200901214656.png" alt="20200901214656"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;em&gt;依赖注入（Dependency Injection简称DI）&lt;/em&gt;&lt;br&gt;&lt;strong&gt;依赖：&lt;/strong&gt;指Bean对象的创建依赖于IOC容器，Bean对象的依赖资源。&lt;br&gt;&lt;strong&gt;注入：&lt;/strong&gt;指Bean对象所依赖的资源，由容器来设置和装配。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="https://www.wrp.cool/categories/Spring/"/>
    
    
    <category term="Spring" scheme="https://www.wrp.cool/tags/Spring/"/>
    
    <category term="DI" scheme="https://www.wrp.cool/tags/DI/"/>
    
    <category term="依赖注入" scheme="https://www.wrp.cool/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>【Spring】创建对象</title>
    <link href="https://www.wrp.cool/posts/17371/"/>
    <id>https://www.wrp.cool/posts/17371/</id>
    <published>2020-09-07T15:34:39.000Z</published>
    <updated>2021-05-07T13:19:09.344Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章 <a href="http://blog.wrp.cool/posts/5741/" target="_blank" rel="noopener">【Spring】IOC推导</a> 讲到了Spring会帮我们创建好对象存在IOC容器中，当需要使用的时候只需要去IOC容器中取即可。<br>这篇文章就说一下Spring中创建对象的几种方式。</p><a id="more"></a><h1 id="通过构造方法创建对象"><a href="#通过构造方法创建对象" class="headerlink" title="通过构造方法创建对象"></a>通过构造方法创建对象</h1><p>通过构造方法创建对象是Spring中最普通的一种创建对象的方式了，通过调用类的构造方法去创建这个对象。这种方式创建对象只需要在配置文件中配置即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 默认调用无参构造 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user1"</span> <span class="attr">class</span>=<span class="string">"cool.wrp.ioc.User"</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 下标的形式调用有参构造 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user2"</span> <span class="attr">class</span>=<span class="string">"cool.wrp.ioc.User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"user2"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 参数类型调用有参构造 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user3"</span> <span class="attr">class</span>=<span class="string">"cool.wrp.ioc.User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"user3"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 参数名调用有参构造 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user4"</span> <span class="attr">class</span>=<span class="string">"cool.wrp.ioc.User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"user4"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="通过静态工厂方法创建对象"><a href="#通过静态工厂方法创建对象" class="headerlink" title="通过静态工厂方法创建对象"></a>通过静态工厂方法创建对象</h1><p>自己编写一个创造类的静态工厂类，然后将这个静态工厂类注册到Spring中去，再告诉Spring要通过这其中的哪个静态方法去创建我们想要的对象，这样子Spring就可以根据我们想要的方式去创建对象了。<br>这样一来是以自己定义的工厂去创建我们想要的类，我们可以在这个类创建类的方法中自由控制创建流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 教师类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 此处由于篇幅限制省略全参构造方法和toString方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学生类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 此处由于篇幅限制省略全参构造方法和toString方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工厂类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Teacher类的静态方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Teacher <span class="title">getTeacherInstance</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 针对创建Teacher类的扩展</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Teacher(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Student类的静态方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">getStudentInstance</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 针对创建Student类的扩展</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Student(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 教师类的工厂 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"teacherFactory"</span> <span class="attr">class</span>=<span class="string">"cool.wrp.createObject.PersonFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getTeacherInstance"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"张三"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"18"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 学生类的工厂 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"studentFactory"</span> <span class="attr">class</span>=<span class="string">"cool.wrp.createObject.PersonFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getStudentInstance"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"李四"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"18"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">        <span class="comment">// 通过静态工厂创建Teacher类</span></span><br><span class="line">        Teacher teacher = context.getBean(<span class="string">"teacherFactory"</span>, Teacher<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(teacher);</span><br><span class="line">        <span class="comment">// 通过静态工厂创建Student类</span></span><br><span class="line">        Student student = context.getBean(<span class="string">"studentFactory"</span>, Student<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(student);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>运行测试类，成功输出</code></p><h1 id="使用实例工厂方法实例化"><a href="#使用实例工厂方法实例化" class="headerlink" title="使用实例工厂方法实例化"></a>使用实例工厂方法实例化</h1><p>实例工厂相比起静态工厂就是工厂类中创建对象的方法不是静态的，只是普通的成员方法。这样子不能直接调用创建类的静态方法，就必须要在配置文件中注册一下工厂类然后再通过工厂类去调用工厂创建对象的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 教师类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 此处由于篇幅限制省略全参构造方法和toString方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学生类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 此处由于篇幅限制省略全参构造方法和toString方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工厂类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Teacher类的静态方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Teacher <span class="title">getTeacherInstance</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Teacher(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Student类的静态方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">getStudentInstance</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Student(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 教师类的工厂 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"teacherFactory"</span> <span class="attr">factory-bean</span>=<span class="string">"personFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getTeacherInstance"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"张三"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"18"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 学生类的工厂 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"studentFactory"</span> <span class="attr">factory-bean</span>=<span class="string">"personFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getStudentInstance"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"李四"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"18"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注册工厂类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"personFactory"</span> <span class="attr">class</span>=<span class="string">"cool.wrp.createObject.PersonFactory"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">        <span class="comment">// 通过静态工厂创建Teacher类</span></span><br><span class="line">        Teacher teacher = context.getBean(<span class="string">"teacherFactory"</span>, Teacher<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(teacher);</span><br><span class="line">        <span class="comment">// 通过静态工厂创建Student类</span></span><br><span class="line">        Student student = context.getBean(<span class="string">"studentFactory"</span>, Student<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(student);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>运行测试类，成功输出</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一篇文章 &lt;a href=&quot;http://blog.wrp.cool/posts/5741/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;【Spring】IOC推导&lt;/a&gt; 讲到了Spring会帮我们创建好对象存在IOC容器中，当需要使用的时候只需要去IOC容器中取即可。&lt;br&gt;这篇文章就说一下Spring中创建对象的几种方式。&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="https://www.wrp.cool/categories/Spring/"/>
    
    
    <category term="Spring" scheme="https://www.wrp.cool/tags/Spring/"/>
    
    <category term="IOC" scheme="https://www.wrp.cool/tags/IOC/"/>
    
    <category term="创建对象" scheme="https://www.wrp.cool/tags/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>【Spring】Bean的自动装配</title>
    <link href="https://www.wrp.cool/posts/43228/"/>
    <id>https://www.wrp.cool/posts/43228/</id>
    <published>2020-09-03T12:20:58.000Z</published>
    <updated>2021-05-07T13:19:24.198Z</updated>
    
    <content type="html"><![CDATA[<p>自动装配是使用spring满足bean依赖的一种方法<br>spring会在应用上下文中为某个bean寻找其依赖的bean。<br><em>以上内容出自b站（<a href="https://www.bilibili.com/video/BV1WE411d7Dv?p=3" target="_blank" rel="noopener">狂神说Java</a>）</em></p><a id="more"></a><p><strong>实验环境搭建</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 宠物猫和宠物狗类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"吃鱼"</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"吃骨头"</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person类，拥有Cat和Dog</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cat <span class="title">getCat</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> cat; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCat</span><span class="params">(Cat cat)</span> </span>&#123; <span class="keyword">this</span>.cat = cat; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dog <span class="title">getDog</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> dog; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDog</span><span class="params">(Dog dog)</span> </span>&#123; <span class="keyword">this</span>.dog = dog; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">        Person person = context.getBean(<span class="string">"person"</span>, Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        person.getCat().eat();</span><br><span class="line">        person.getDog().eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="配置文件方式自动装配"><a href="#配置文件方式自动装配" class="headerlink" title="配置文件方式自动装配"></a>配置文件方式自动装配</h1><h4 id="byName"><a href="#byName" class="headerlink" title="byName"></a>byName</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置文件 --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cat"</span> <span class="attr">class</span>=<span class="string">"spring.Cat"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dog"</span> <span class="attr">class</span>=<span class="string">"spring.Dog"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 此处使用byName方式自动注入依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"spring.Person"</span> <span class="attr">autowire</span>=<span class="string">"byName"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>运行测试类成功输出</code></p><p><strong>小结：</strong></p><ol><li>将查找其类中所有的set方法名，例如setCat，获得将set去掉并且首字母小写的字符串，即cat。</li><li>去spring容器中寻找是否有此字符串名称id或者是此字符串名称name的对象，自动注入到该属性中。</li></ol><h4 id="byType"><a href="#byType" class="headerlink" title="byType"></a>byType</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置文件 --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"spring.Cat"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"spring.Dog"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 此处使用byType方式自动注入属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"spring.Person"</span> <span class="attr">autowire</span>=<span class="string">"byType"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>运行测试类成功输出</code></p><p><strong>小结：</strong></p><ol><li>自动匹配set方法的参数类型，并自动注入。</li><li>如果set方法中存在多个参数，则无法注入。</li></ol><h1 id="注解方式自动装配"><a href="#注解方式自动装配" class="headerlink" title="注解方式自动装配"></a>注解方式自动装配</h1><p>Spring官网开启注解支持的方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启注解支持 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        扩展：另外的开启注解支持的方式</span></span><br><span class="line"><span class="comment">        &lt;bean class ="org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor"/&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cat"</span> <span class="attr">name</span>=<span class="string">"cat"</span> <span class="attr">class</span>=<span class="string">"spring.Cat"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dog"</span> <span class="attr">name</span>=<span class="string">"dog"</span> <span class="attr">class</span>=<span class="string">"spring.Dog"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"spring.Person"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h4><blockquote><p><code>@Autowired</code>默认使用的注解方式是ByType方式进行注入，如果需要根据名称进行注入的话需要搭配<code>@Qualifier</code>注解一起使用。<code>@Autowired</code>注解其中还有一个布尔值的属性<code>required</code>可以指定是否必须注入。默认值是true必须注入，如果置为false则表示可以非必须注入：<code>(required = false)</code></p></blockquote><p>将<code>@Autowired</code>注解写在类的成员变量、set方法或者构造器上即可实现自动注入。<br>演示怎么将<code>@Autowired</code>注解在成员变量、set方法、构造器上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 构造器 */</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Cat cat, Dog dog)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cat = cat;</span><br><span class="line">    <span class="keyword">this</span>.dog = dog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 成员变量 */</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* set方法 */</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCat</span><span class="params">(Dog dog)</span> </span>&#123; <span class="keyword">this</span>.dog = dog; &#125;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDog</span><span class="params">(Cat cat)</span> </span>&#123; <span class="keyword">this</span>.cat = cat; &#125;</span><br></pre></td></tr></table></figure><p><code>以上三种方式运行测试类均可成功输入</code></p><p><strong>实际上，Spring官方建议我们使用构造器的方式注入依赖，而不是成员变量注入。</strong></p><ol><li><p><strong>成员变量注入的方式不能为final修饰的成员变量注入依赖。</strong></p></li><li><p><strong>IOC容器的解耦。</strong><br>当我们使用IOC容器创建对象时意味着我们把创建对象的这个操作交给了IOC容器，也就是所谓的控制反转。<br>但是如果我们需要脱离IOC容器来创建这个对象呢？<br>答案是如果使用的是成员变量注入的方式则脱离IOC容器之后我们无法创建这个对象。<br>由于是成员变量注入，而成员变量对外又是不可见的，只能通过IOC容器去利用反射机制将依赖注入，所以一旦脱离了IOC容器之后这个类几乎不可用，这直接导致了类与IOC容器的高度耦合。</p></li><li><p><strong>使用构造器注入的方式能够更好的帮助我们遵守单一职责原则。</strong><br>如果一个类中的依赖过于庞大，那么使用构造器注入的方式参数也会变得很多，而参数变多则是一个很明显的提示，我们需要考虑优化这个类了。</p></li></ol><p>而使用set方法注入依赖的话则是一个可选的依赖注入，如果需要这个依赖则注入进来。不需要就不要管它。这种注入方式是一种非必须注入的方式，相对的构造器注入则是一种强制注入的方式了。</p><p><strong>总结：</strong></p><ol><li>尽量不要使用成员变量的方式注入依赖。</li><li>根据具体的业务场景选择构造器注入或是set方法方式的注入</li></ol><h4 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h4><p>注意：上文提到的另外开启注解的方式不支持@Resource注解。</p><ol><li>@Resource如有指定的name属性，先按name属性以byName方式查找装配</li><li>其次再使用默认的byName方式进行装配</li><li>如果以上都不成功，则按byType的方式自动装配</li><li>都不成功，则报异常</li></ol><p><code>@Resource</code>注解也是可以应用在成员变量、构造器、set方法上的，相比起<code>@Autowired</code>注解，是jdk自带的注解而不是Spring提供的，这其中的一个好处是使得程序在依赖注入方面与Spring框架解耦，但我个人觉得并不是很必要。另外一个就是上面提到的注入方式的不同，<code>@Autowired</code>是byType方式而<code>@Resource</code>是先使用byName方式，byName方式注入失败再使用byType方式。还有新版本的jdk已经不再支持<code>@Resource</code>注解了，故了解即可。</p><h4 id="Component、-Repository、-Service、-Controller"><a href="#Component、-Repository、-Service、-Controller" class="headerlink" title="@Component、@Repository、@Service、@Controller"></a>@Component、@Repository、@Service、@Controller</h4><p>这些注解是为了让我们更加进一步的简化xml文件中的配置而存在的，将这些注解应用在类上，则可以将该类交由IOC容器去管理。相当于在xml文件中定义了这个类的bean节点。<br>默认使用的id是类名的小驼峰写法，自定义id则只需要指定value属性即可。四个注解的功能都是相同的，之所以有四个只是为了区分开各个类的层级。<code>@Repository</code>、<code>@Service</code>、<code>@Controller</code>这三个注解分别对应MVC三层设计中的<code>dao</code>、<code>service</code>、<code>controller</code>，另外的<code>@Component</code>注解则是使用在一些其他的类中，例如工具类。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;自动装配是使用spring满足bean依赖的一种方法&lt;br&gt;spring会在应用上下文中为某个bean寻找其依赖的bean。&lt;br&gt;&lt;em&gt;以上内容出自b站（&lt;a href=&quot;https://www.bilibili.com/video/BV1WE411d7Dv?p=3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;狂神说Java&lt;/a&gt;）&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="https://www.wrp.cool/categories/Spring/"/>
    
    
    <category term="Spring" scheme="https://www.wrp.cool/tags/Spring/"/>
    
    <category term="Bean" scheme="https://www.wrp.cool/tags/Bean/"/>
    
    <category term="自动装配" scheme="https://www.wrp.cool/tags/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/"/>
    
    <category term="注解开发" scheme="https://www.wrp.cool/tags/%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>【Spring】IOC理论推导</title>
    <link href="https://www.wrp.cool/posts/5741/"/>
    <id>https://www.wrp.cool/posts/5741/</id>
    <published>2020-08-22T20:18:18.000Z</published>
    <updated>2021-05-07T13:19:30.072Z</updated>
    
    <content type="html"><![CDATA[<p>控制反转IOC（Inversion of Control)，是一种设计思想，DI（依赖注入）是实现IOC的一种方法，也有人认为DI只是IOC的另一种说法。没有IOC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。<br><em>以上内容出自b站（<a href="https://www.bilibili.com/video/BV1WE411d7Dv?p=3" target="_blank" rel="noopener">狂神说Java</a>）</em></p><a id="more"></a><hr><p><strong>演示传统开发模式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserDao</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MysqlUserDaoImpl</span> <span class="keyword">implements</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"从MySQL数据库中取出的User对象"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OracleUserDaoImpl</span> <span class="keyword">implements</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"从Oracle数据库中取出来的User对象"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * service </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserService</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">IUserService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IUserDao userDao = <span class="keyword">new</span> MysqlUserDaoImpl();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        userDao.getUser(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IUserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        userService.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>小结：</strong><br>传统的开发模式中，各个类之间的耦合度过高，如果在service层中要调用dao层的接口，必须在代码中new一个dao层接口的实现类才可以使用。<br>但是以这样的方式去编写代码一旦需要切换dao层的实现则必须去修改service层的代码，去修改接口的实现类才可以。<br>如果现在需要修改一个dao层的实现类，但是这个实现类在service层中很多地方都去new了的话，修改就会变得非常麻烦。不符合开闭原则的设计思想，也大大提高了代码之间的耦合度。</p><blockquote><p>此处其实可以使用在上一篇博客 <a href="http://blog.wrp.cool/posts/34268/" target="_blank" rel="noopener">【创建型设计模式】工厂模式</a> 中所讲述的工厂模式解决，但本文重点在于IOC，关于工厂模式的内容则不详细展开。</p></blockquote><hr><p><strong>演示IOC开发模式</strong> <em>（此处dao层模式使用传统开发模式中的dao层）</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * service</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">IUserService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IUserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(IUserDao userDao)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.userDao = userDao; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         userDao.getUser(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IUserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        userService.setUserDao(<span class="keyword">new</span> MysqlUserDaoImpl());</span><br><span class="line">        userService.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>小结：</strong><br>IOC开发模式已经从根本上去解决了传统开发模式中的问题，传统开发模式中任何对象都是依赖于程序去控制创建，但是使用了IOC模式进行开发之后，依赖的对象不再需要程序去创建，而是交由用户去自定义。换句话说，service只是提供一个调用处理逻辑的接口出去给用户，而具体要处理的对象则交由用户去创建，从根本上解耦了。</p><hr><h1 id="Spring中的IOC"><a href="#Spring中的IOC" class="headerlink" title="Spring中的IOC"></a>Spring中的IOC</h1><p>前文已经说过IOC是一种思想而不是一种具体的实现，Spring就是一种IOC的具体实现。</p><p><strong>演示Spring IOC</strong> <em>（此处dao层模式使用传统开发模式中的dao层）</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注册UserDao --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"cool.wrp.ioc.OracleUserDaoImpl"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * service</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">IUserService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建spring上下文对象</span></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">        IUserDao userDao = (IUserDao) context.getBean(<span class="string">"userDao"</span>);</span><br><span class="line">        userDao.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IUserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        userService.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上演示的就是一个简单的Spring应用。</p><p>Spring是以一种配置加工厂方式来实现IOC，这在Spring中有一个专业的名词叫做IOC容器。Spring的IOC容器通过配置文件去读取要创建的bean。之后通过上下文对象的<code>getBean()</code>方法去获取到我们想要的bean对象。实际上应该将Spring理解为一个巨大的工厂。<br>以上将对象的创建完全交由Spring负责，在客户端中也不需要去传入实际的对象。所谓的控制反转就是将创建对象的这一步动作交给第三方去完成。不需要在程序中去创建对象，也不需要用户去创建对象，而是通过Spring的工厂创建完成之后我们自己根据需要去取出对象来使用。控制就是控制对象的创建，反转就是将控制对象的创建这一步骤反转给Spring。</p><h1 id="Bnan的作用域"><a href="#Bnan的作用域" class="headerlink" title="Bnan的作用域"></a>Bnan的作用域</h1><p>Spring官网对Bean作用域的描述<br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20200901215755.png" alt="20200901215755"></p><blockquote><p>这里我们来聊聊singleton和prototype，单例和原型。另外的几种作用域等以后有用到再研究</p></blockquote><p>Spring中Bean默认的作用域范围就是单例的，也就是在整个IOC容器中只有一个Bean实例存在，相对应的原型模式就是在IOC容器中存在多个Bean实例的。单例的Bean在创建上下文时就创建了，然后每次去获取的时候都是获取的同一个，而原型的Bean则是当需要用到再去创建，每次需要都会去创建一个新的Bean。</p><p><strong>演示单例和原型</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"singletonStu"</span> <span class="attr">class</span>=<span class="string">"cool.wrp.createObject.Student"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"prototypeStu"</span> <span class="attr">class</span>=<span class="string">"cool.wrp.createObject.Student"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);<span class="comment">// 创建singletonStu</span></span><br><span class="line">        <span class="comment">// 演示单例</span></span><br><span class="line">        Student stu1 = context.getBean(<span class="string">"singletonStu"</span>, Student<span class="class">.<span class="keyword">class</span>)</span>;<span class="comment">// 取出singletonStu</span></span><br><span class="line">        Student stu2 = context.getBean(<span class="string">"singletonStu"</span>, Student<span class="class">.<span class="keyword">class</span>)</span>;<span class="comment">// 取出singletonStu</span></span><br><span class="line">        System.out.println(stu1 == stu2);<span class="comment">// true</span></span><br><span class="line">        <span class="comment">// 演示原型</span></span><br><span class="line">        Student stu3 = context.getBean(<span class="string">"prototypeStu"</span>, Student<span class="class">.<span class="keyword">class</span>)</span>;<span class="comment">// 创建singletonStu</span></span><br><span class="line">        Student stu4 = context.getBean(<span class="string">"prototypeStu"</span>, Student<span class="class">.<span class="keyword">class</span>)</span>;<span class="comment">// 创建singletonStu</span></span><br><span class="line">        System.out.println(stu3 == stu4);<span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;控制反转IOC（Inversion of Control)，是一种设计思想，DI（依赖注入）是实现IOC的一种方法，也有人认为DI只是IOC的另一种说法。没有IOC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。&lt;br&gt;&lt;em&gt;以上内容出自b站（&lt;a href=&quot;https://www.bilibili.com/video/BV1WE411d7Dv?p=3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;狂神说Java&lt;/a&gt;）&lt;/em&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Spring" scheme="https://www.wrp.cool/categories/Spring/"/>
    
    
    <category term="Spring" scheme="https://www.wrp.cool/tags/Spring/"/>
    
    <category term="IOC" scheme="https://www.wrp.cool/tags/IOC/"/>
    
    <category term="控制反转" scheme="https://www.wrp.cool/tags/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/"/>
    
    <category term="Bean的作用域" scheme="https://www.wrp.cool/tags/Bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式</title>
    <link href="https://www.wrp.cool/posts/34268/"/>
    <id>https://www.wrp.cool/posts/34268/</id>
    <published>2020-08-09T13:18:59.000Z</published>
    <updated>2021-05-07T13:20:39.692Z</updated>
    
    <content type="html"><![CDATA[<p><strong>百度百科中对创建型模式的定义：</strong><br>创建型模式旨在将系统与它的对象创建、结合、表示的方式分离。这些设计模式在对象创建的类型、主体、方式、时间等方面提高了系统的灵活性。（<a href="https://baike.baidu.com/item/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/22912595?fr=aladdin" target="_blank" rel="noopener">百度百科</a>）</p><p><strong>个人理解：</strong><br>某些业务场景中，需要重复的创建相同对象去完成业务逻辑。一旦需要切换成另外的对象的话则需要修改大量代码。而使用创建型设计模式（例如工厂模式）则仅需要修改一处即可。即工厂中创建对象的地方。</p><p><strong>本文将讲述的创建型的设计模式有：</strong><br>简单工厂模式、工厂方法模式、抽象工厂模式</p><a id="more"></a><h1 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h1><p>定义：由一个工厂对象决定创建出哪一种产品的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手机类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"使用苹果手机打电话"</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MI</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"使用小米手机打电话"</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手机工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Phone <span class="title">getPhone</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"apple"</span>.equalsIgnoreCase(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Apple();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"mi"</span>.equalsIgnoreCase(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MI();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>客户端不使用工厂类时创建对应的手机</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone apple = <span class="keyword">new</span> Apple();</span><br><span class="line">        apple.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类图：<br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20200814233625.png" alt="20200814233625"></p><p> <strong>小结：</strong><br> 客户端如果在很多地方需要使用到手机类，那么每个地方都必须去new对应的手机类。如果有一天业务逻辑发生变化，需要换一款手机，那么就得在很多地方都去重新new新的手机类。这将会变得非常麻烦，不符合低耦合的设计思想</p></li><li><p><strong>客户端使用手机工厂类创建对应的手机</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone apple = PhoneFactory.getPhone(<span class="string">"apple"</span>);</span><br><span class="line">        <span class="keyword">if</span> (apple != <span class="keyword">null</span>) &#123;</span><br><span class="line">            apple.create();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类图：<br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20200814233841.png" alt="20200814233841"></p><p> <strong>小结：</strong><br> 使用工厂模式可以直接在工厂类中去修改对应的实例，而不需要在每个创建实例的地方都去修改。如果需要修改对应的手机实例则只需要在工厂类中去替换掉对应的实例即可。</p><p> <strong>举例：</strong><br> 需求：将原来的苹果手机换成最新的苹果手机。使用工厂模式之后只需要去创建一个最新的苹果手机类继承手机类，再去修改手机工厂类中的实例即可。</p></li></ul><p><strong>缺点：</strong>工厂类职责过于繁重，一旦创建新的手机则需要修改工厂类。违反了开闭原则</p><p><strong>改进：</strong>在工厂类中使用反射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手机工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Phone <span class="title">getPhone</span><span class="params">(Class c)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Phone = (Phone) Class.forName(c.getName()).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone = PhoneFactory.getPhone(Apple<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (phone != <span class="keyword">null</span>) &#123;</span><br><span class="line">            phone.call();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>暂停一会，介绍两个简单的概念。产品等级和产品家族</p><blockquote><p><strong>产品等级：</strong>产品等级指的是相同类型的产品。<br>比如，我们使用的手机有小米手机、华为手机、苹果手机这些都是同一产品等级。<br><strong>产品家族：</strong>产品家族指的是不同产品等级构成的一组产品。<br>比如，上面的这些手机厂商不仅生产手机还生产电脑，那么小米手机和小米电脑构成一个产品家族，华为手机和华为电脑构成一个产品家族，苹果手机和苹果电脑构成一个产品家族</p></blockquote><hr><h1 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h1><p>定义：工厂方法模式（FACTORY METHOD）是一种常用的类创建型设计模式，此模式的核心精神是封装类中变化的部分，提取其中个性化善变的部分为独立类，通过依赖注入以达到解耦、复用和方便后期维护拓展的目的。它的核心结构有四个角色，分别是抽象工厂；具体工厂；抽象产品；具体产品。（<a href="https://baike.baidu.com/item/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/2361103?fr=aladdin" target="_blank" rel="noopener">百度百科</a>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象手机类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 手机具体实现类 - 完成手机具体功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"使用苹果手机打电话"</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MI</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"使用小米手机打电话"</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Phone <span class="title">getPhone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象工厂实现类 - 创建具体的手机对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span> <span class="keyword">extends</span> <span class="title">PhoneFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">getPhone</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Apple(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MIFactory</span> <span class="keyword">extends</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">getPhone</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> MI(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PhoneFactory phoneFactory = <span class="keyword">new</span> AppleFactory();</span><br><span class="line">        Phone phone = phoneFactory.getPhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类图：<br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20200814235206.png" alt="20200814235206"></p><p><strong>小结：</strong></p><ol><li>如果是需要切换具体的实例时只需要在客户端中修改具体的工厂的实例 <code>PhoneFactory phoneFactory = new AppleFactory();</code> 也就是这行代码，修改实现的 <code>AppleFactory()</code> 为新的工厂。</li><li>工厂方法模式可以很容易实现对产品等级的扩展，比如现在要新增一个华为手机，只要创建一个华为手机类继承<code>Phone</code>由这个类来实现具体的华为手机功能，再创建一个华为手机的工厂类继承<code>PhoneFactory</code>，实现具体的创建华为手机的工作。扩展产品等级只需要这两步就可以完成了。</li><li>如果引入的产品等级过多，则会产生大量的类，不便于阅读代码。</li></ol><blockquote><p>需求：创建一款新的手机HUAWEI，并将原有的苹果手机换成华为手机</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 华为手机类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HUAWEI</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"使用华为手机打电话"</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 华为手机的工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HUAWEIFactory</span> <span class="keyword">extends</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">getPhone</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> HUAWEI(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PhoneFactory phoneFactory = <span class="keyword">new</span> HUAWEIFactory();</span><br><span class="line">        Phone phone = phoneFactory.getPhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h1><p>定义：抽象工厂是一种常见的设计模式。此模式为一个产品家族提供了统一的创建接口。当需要这个产品家族的某一系列的时候，可以从抽象工厂中选出相对系的系列来创建一个具体的工厂类别。（<a href="https://baike.baidu.com/item/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/5686668?fr=aladdin" target="_blank" rel="noopener">百度百科</a>）</p><blockquote><p>需求：引入一个新的产品等级（电脑）与原有的手机组合成产品家族，实现对产品家族的扩展</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 产品家族中的各个产品等级抽象类和实现 //</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 电脑抽象类 - 产品等级为电脑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">calculation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 手机抽象类 - 产品等级为手机</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 华为实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HUAWEIComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculation</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"使用华为电脑计算"</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HUAWEIPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"使用华为手机打电话"</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 小米实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MIComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculation</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"使用小米电脑计算"</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MIPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"使用小米手机打电话"</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶层电子产品抽象工厂 - 将以下产品家族统称为电子产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ElectronicProductFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Phone <span class="title">getPhone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Computer <span class="title">getComputer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体的实现工厂 - 实现的是产品家族工厂（比如：华为产品家族、小米产品家族）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HUAWEIFactory</span> <span class="keyword">extends</span> <span class="title">ElectronicProductFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">getPhone</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> HUAWEIPhone(); &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">getComputer</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> HUAWEIComputer(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MIFactory</span> <span class="keyword">extends</span> <span class="title">ElectronicProductFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">getPhone</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> MIPhone(); &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">getComputer</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> MIComputer(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ElectronicProductFactory electronicProductFactory = <span class="keyword">new</span> MIFactory();</span><br><span class="line">        Phone miPhone = electronicProductFactory.getPhone();</span><br><span class="line">        Computer miComputer = electronicProductFactory.getComputer();</span><br><span class="line">        miPhone.call();</span><br><span class="line">        miComputer.calculation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类图：<br><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/20200815223416.png" alt="20200815223416"></p><blockquote><p>需求：引入新的苹果产品家族，将客户端的小米产品更换为苹果产品</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 苹果工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span> <span class="keyword">extends</span> <span class="title">ElectronicProductFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">getPhone</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ApplePhone(); &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">getComputer</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> AppleComputer(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 苹果产品等级实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculation</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"使用苹果电脑计算"</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplePhone</span> <span class="keyword">extends</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"使用苹果手机打电话"</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ElectronicProductFactory electronicProductFactory = <span class="keyword">new</span> AppleFactory();</span><br><span class="line">        Phone miPhone = electronicProductFactory.getPhone();</span><br><span class="line">        Computer miComputer = electronicProductFactory.getComputer();</span><br><span class="line">        miPhone.call();</span><br><span class="line">        miComputer.calculation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>小结：</strong></p><ol><li>抽象工厂针对于共产方法的扩展更方便了产品家族的扩展，如果是在工厂方法中将产品等级组合成产品家族的话需要修改大量的代码，有兴趣的同学可以试试使用工厂方法去将产品等级组合成产品家族。而使用抽象工厂扩展产品家族的话就变得很方便，新增新的产品家族和产品家族工厂即可。</li><li>如果在抽象工厂内部的产品家族中要实现对产品等级的扩展则会非常麻烦，需要修改大量的代码，而使用工厂方法去扩展产品等级则非常简单。</li></ol><p>总结：<br>针对产品等级和产品家族，工厂方法和抽象工厂各有各的优点和缺点，在真实的开发中需要根据实际的业务场景去选择适合的设计模式去完成相应的需求，切记不要为了使用某一种设计模式而过度的设计自己的代码。<br><u>刚刚好的才是最美</u>，代码如此，人生亦是如此。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;百度百科中对创建型模式的定义：&lt;/strong&gt;&lt;br&gt;创建型模式旨在将系统与它的对象创建、结合、表示的方式分离。这些设计模式在对象创建的类型、主体、方式、时间等方面提高了系统的灵活性。（&lt;a href=&quot;https://baike.baidu.com/item/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/22912595?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;百度百科&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人理解：&lt;/strong&gt;&lt;br&gt;某些业务场景中，需要重复的创建相同对象去完成业务逻辑。一旦需要切换成另外的对象的话则需要修改大量代码。而使用创建型设计模式（例如工厂模式）则仅需要修改一处即可。即工厂中创建对象的地方。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文将讲述的创建型的设计模式有：&lt;/strong&gt;&lt;br&gt;简单工厂模式、工厂方法模式、抽象工厂模式&lt;/p&gt;</summary>
    
    
    
    <category term="设计模式" scheme="https://www.wrp.cool/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="创建型设计模式" scheme="https://www.wrp.cool/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Java" scheme="https://www.wrp.cool/tags/Java/"/>
    
    <category term="设计模式" scheme="https://www.wrp.cool/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="创建型" scheme="https://www.wrp.cool/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B/"/>
    
    <category term="简单工厂" scheme="https://www.wrp.cool/tags/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/"/>
    
    <category term="工厂方法" scheme="https://www.wrp.cool/tags/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/"/>
    
    <category term="抽象工厂" scheme="https://www.wrp.cool/tags/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/"/>
    
    <category term="产品家族" scheme="https://www.wrp.cool/tags/%E4%BA%A7%E5%93%81%E5%AE%B6%E6%97%8F/"/>
    
    <category term="产品等级" scheme="https://www.wrp.cool/tags/%E4%BA%A7%E5%93%81%E7%AD%89%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构】链表</title>
    <link href="https://www.wrp.cool/posts/29990/"/>
    <id>https://www.wrp.cool/posts/29990/</id>
    <published>2020-08-02T06:45:27.000Z</published>
    <updated>2021-05-07T13:16:11.078Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>如果上一篇文章实现的动态数组，由于底层任然是使用的静态数组，而不是真正意义上的<strong>动态数据结构</strong>的话。那么本文的链表则肯定是一个真真正正意义上的动态的数据结构了。</p><a id="more"></a><p>我还记得在读书时老师曾经给我们举过一个非常好的例子用于演示链表和数组在增删改查种各自的优缺点。在这里我把它分享出来给大家</p><blockquote><p>一个班级假设有50个学生，现在使用数组和链表来分别承载这50个学生。<br>然后模拟两种场景来分别对比这两种数据结构的优缺点<br><strong>数组：</strong>将这50个学生按照顺序排号，从0开始到49（这里模拟的是数组的下标）<br><strong><em>像这样 [0, 1, 2, 3, …, 49]</em></strong><br><strong>链表：</strong>将50个学生叫到操场排好队，每个学生去记住自己后面一个学生，记录排第一的同学（链表头）。<br><strong><em>像这样 (0) -&gt; (1) -&gt; (2) -&gt; (3) -&gt; … -&gt; (49)</em></strong><br>原谅我懒得画图。。。</p></blockquote><p><strong>场景一：</strong>老师在办公室想要叫某个学生到办公室去（模拟数据的查询）<br><strong>数组：</strong>直接在班级表种去查这个学生对应的序号，根据序号就可以很快速的找到这个学生。<br><strong>链表：</strong>由于没有序号，需要一个个学生去查找，首先找到链表头同学，比较是不是老师叫的学生，如果是则去办公室找老师。如果不是，则去找链表头同学所记住的后面一个同学，再进行对比。如果还不是则再去寻找这个同学记忆的下一个同学之后再进行比对，直到找到这个同学为止。</p><p><strong>场景二：</strong>班上来了一个新的插班生，插班生必须安排在班级的第一个位置（模拟数据的添加和删除）<br><strong>数组：</strong>由于每个学生的序号都是按照顺序排好的，所以不能直接插入在第一个学生之前，必须是要占用第一个学生的位置。所以要将全部的学生重新排号，插班生排0号，剩下的学生按照原来的号码依次加1往后排序。<br><strong>链表：</strong>让这个插班生去记住第一个同学也就是原理啊的链表头，再成为新的链表头。其他的学生完全不受影响。</p><p>通过以上两个场景的展现可以很清晰的看出来链表和数组各自的优缺点在哪里。链表增删快，而数组查询快。</p><h1 id="设计节点类"><a href="#设计节点类" class="headerlink" title="设计节点类"></a>设计节点类</h1><p>链表中的数据实际上是一个个的节点，在Java中使用一个节点类（Node）来表示。在节点类中有两个变量，一个是当前节点的值，另一个是指向下一个节点的指针。<br>由此每个节点中都有一个指向下一个节点的指针，最后一个节点指向下一个节点的指针就置为空。以此一节一节的链接起来，也就成了链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 节点本身的值（支持泛型）</span></span><br><span class="line">    <span class="keyword">public</span> E e;</span><br><span class="line">    <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e, Node next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.e = e;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e)</span> </span>&#123; <span class="keyword">this</span>(e, <span class="keyword">null</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">null</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> e.toString(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="设计链表的成员变量和构造方法"><a href="#设计链表的成员变量和构造方法" class="headerlink" title="设计链表的成员变量和构造方法"></a>设计链表的成员变量和构造方法</h1><p>我们先来考虑一下怎么去设计链表类中的成员变量再来看看怎么设计构造函数</p><p>首先我们需要一个变量可以表示当前链表中共有多少个节点，也就是链表的大小。size变量是没跑了。<br>另外回顾一下刚刚的例子，在哪个班级中如果老师需要找到一个班级中的某个确定的学生时，第一个找的其实是链表头同学，根据链表头去一个个找下去直到找到为止。<br>所以在我们设计的链表类中需要一个头节点的指针，定义一个<strong>Node变量</strong>作为指针。</p><p>刚刚的例子中场景二来一个插班生我们将插班生插在了第一个位置。直接让插班生去记住原来的链表头再将链表头指向插班生。设想一下，如果是插入在链表的中间呢？<br>比如插入在第二个学生的位置。需要插班生去记住原来的第二个同学，再让原来的第一个同学把记忆的第二个同学换成插班生同学。也就是说如果是插入在中间的元素要多一步让前面的同学去记插班生同学，而插入在第一个则不需要。</p><p>针对上面的情况我们可以设置一个虚拟的头节点来解决这个问题。这个虚拟的节点来指向我们链表中真正的第一个节点，对外呢，屏蔽这个节点的存在。故此我们将上面决定要定义的<strong>Node变量</strong>改成<strong>dummyHead</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">private</span> Node dummyHead; <span class="comment">// 虚拟头节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dummyHead = <span class="keyword">new</span> Node(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方便用户传入一个数组将其转换成链表的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(E[] arrayE)</span> </span>&#123;</span><br><span class="line">    dummyHead = <span class="keyword">new</span> Node(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    size = arrayE.length;</span><br><span class="line"></span><br><span class="line">    Node cur = dummyHead;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arrayE.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        cur.next = <span class="keyword">new</span> Node(arrayE[i], cur.next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设计两个方便使用的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> size == <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure><h1 id="链表中插入元素"><a href="#链表中插入元素" class="headerlink" title="链表中插入元素"></a>链表中插入元素</h1><p>我们来研究一下前面的例子是怎么在一个班级中插入插班生的。</p><blockquote><p>首先，得要有一个插班生，这个不用想肯定是必须的，好了，插入功能核心代码的<strong>第一步</strong>也就出来了。<br>然后我们得要去找到插班生要插入的位置，在这里呢我们虚拟一个index（下标）的概念出来，方便用户指定要插入的位置，核心功能的<strong>第二步</strong>也就出来了。<br>找到位置也有插班生之后的问题就是要把插班生插入到班级里面去啦，这个事情要怎么做呢。<br>比方说我现在是要插入到第二个位置去，那么我需要先让插班生去记忆原来的第二个位置的同学，这也是<strong>第三步</strong>。<br>然后让第一个同学不要去记原来的第二个同学了，换成是插班生同学，<strong>第四步</strong>。<br>到此为止，这个插入的动作就完成了。</p></blockquote><p>将上面的各个步骤以程序的方式重新梳理一遍<br>第一步：创建一个新的节点 <code>new Node()</code><br>第二步：使用一个for循环找到要插入位置的前一个节点和后一个节点<br>第三步：将第一步创建出来的节点的<code>next</code>指针指向第二步找出来的后一个节点<br>第四步：将第二步找出来的前一个节点的<code>next</code>指针指向第一步创建的节点</p><p>将上面的逻辑组织一下换成Java语言</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下标的校验，不属于插入的核心代码</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"index "</span> + index + <span class="string">" 不合法, 当前size = "</span> + size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一步</span></span><br><span class="line">    Node node= <span class="keyword">new</span> Node(e);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步：</span></span><br><span class="line">    <span class="comment">// 使用一个prev变量去作为一个中间量去寻找要插入的节点位置</span></span><br><span class="line">    <span class="comment">// 这里的prev就是前一个节点，由于还没有插入，所以prev.next就是要插入的后一个节点</span></span><br><span class="line">    Node prev = dummyHead;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        prev = prev.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三步</span></span><br><span class="line">    node.next = prev.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第四步</span></span><br><span class="line">    prev.next = node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护一下size变量</span></span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上便是添加操作的方法，但这还不是最好。</p><p>上面的代码虽说是完成了这个添加动作的逻辑，也能够顺顺利利的运行起来，但这还不够优雅。<br>实际上我们可以将第一步、第三步和第四步合并成一行代码<br>创建一个新的节点直接将<code>prev.next</code>赋值给新节点的<code>next</code>，再直接赋值给<code>prev.next</code>。<br>像下面这个样子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"index "</span> + index + <span class="string">" 不合法, 当前size = "</span> + size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node prev = dummyHead;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        prev = prev.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原来的第一步、第二步和第四步</span></span><br><span class="line">    prev.next = <span class="keyword">new</span> Node(e, prev.next);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>插一句题外话<br>其实编写程序，就是像上面这样子一步一步去考虑出这个程序核心代码的步骤。<br>然后再把这个简单的按照程序逻辑梳理一遍，再开始实际编码。也恰恰是这两步才是最关键的，而不是编码，有了梳理完的逻辑实际编码起来码随心动倒还是个挺舒服的过程。<br>最后再审视一遍自己写出来的代码，看看有没有地方可以改进，可以写的更加的优雅一些</p></blockquote><hr><h1 id="删除链表中的元素"><a href="#删除链表中的元素" class="headerlink" title="删除链表中的元素"></a>删除链表中的元素</h1><p>我们来换个方式写删除操作，在前面的添加操作中我们设置了一个虚拟的index表示的是下标，作用是方便用户操作。在删除的这一小节我们不使用这个index我们假设用户能够直到自己要删除的元素，直接传入待删除元素，然后程序将其删除即可。</p><p>删除元素实际上就是添加元素的逆向操作，找到待删除节点的前一个节点，将这个节点直接指向待删除元素的后一个节点即可删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到要删除元素的前一个元素</span></span><br><span class="line">    Node prev = dummyHead;</span><br><span class="line">    <span class="keyword">while</span>(!prev.next.e.equals(e)) &#123;</span><br><span class="line">        prev = prev.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将要删除元素前一个元素的指针直接指向要删除元素的后一个元素</span></span><br><span class="line">    prev.next = prev.next.next;</span><br><span class="line"></span><br><span class="line">    size--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上面的代码使用递归的方式写出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    remove(e, dummyHead);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.next.e.equlas(e)) &#123;</span><br><span class="line">        node.next = node.next.next;</span><br><span class="line">        size --;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    remove(e, node.next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上链表这样的数据结构天然的适合递归，在很多场合都可以使用递归去操作一个链表。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;如果上一篇文章实现的动态数组，由于底层任然是使用的静态数组，而不是真正意义上的&lt;strong&gt;动态数据结构&lt;/strong&gt;的话。那么本文的链表则肯定是一个真真正正意义上的动态的数据结构了。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="https://www.wrp.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="Java" scheme="https://www.wrp.cool/tags/Java/"/>
    
    <category term="数据结构" scheme="https://www.wrp.cool/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="链表" scheme="https://www.wrp.cool/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【数据结构】动态数组</title>
    <link href="https://www.wrp.cool/posts/714/"/>
    <id>https://www.wrp.cool/posts/714/</id>
    <published>2020-07-31T13:31:50.000Z</published>
    <updated>2021-06-25T14:59:12.969Z</updated>
    
    <content type="html"><![CDATA[<p>本文将讲述一个动态数组的实现过程，由于动态数组其实是一种比较简单的数据结构。所以本文将会以代码展示为主，当然，难点也是会重点讲述。</p><a id="more"></a><h1 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h1><blockquote><p>将要实现一个Array类来承载动态数组这种数据结构。动态数组的底层也是使用Java中的静态数组去实现的，之所以动态是因为这其中可以自动的扩容和扩容和缩容的操作。</p></blockquote><ol><li>准备一个静态的数组和一个记录动态数组大小的变量<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> E[] data;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure></li><li>准备构造方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Array</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    data = (E[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Array</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>设计一些方便用户的方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取数组中元素的个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数组的容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回数组是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>准备工作结束。</li></ol><h1 id="二、设计扩容和缩容的方法"><a href="#二、设计扩容和缩容的方法" class="headerlink" title="二、设计扩容和缩容的方法"></a>二、设计扩容和缩容的方法</h1><p>Java中的数组一旦被初始化之后就再也无法改变它的容量了，所以我们只能够是通过创建一个新的数组，在新数组中开辟出我们想要的空间，然后再将原来的数组全部搬到这个新数组中，以此来实现动态数组。严谨一些的话这并不是真正意义上的动态数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现动态的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity 新数组的容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建新数组</span></span><br><span class="line">    E[] newData = (E[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将元素复制到新数组中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        newData[i] = data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将data指向新数组</span></span><br><span class="line">    data = newData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、添加元素"><a href="#三、添加元素" class="headerlink" title="三、添加元素"></a>三、添加元素</h1><p>向数组中的任意位置添加元素，需要将这个位置之后的所有元素都往后挪动一个位置，来腾出这个位置以供新的元素添加进来。<br>重点就是在于这个「挪」的实现，我们需要从最后一个元素开始一个个的往后挪一位，这样才不会覆盖到原有的元素。</p><blockquote><p>注意：在添加元素的时候我们是有可能会超出现有数组的边界的，不进行处理的话就会抛出下标越界的异常。<br>动态数组就是为了解决这个问题而存在的，自动的判断是否需要扩容操作，为用户屏蔽掉下标越界的问题，用户只管插入而不需要担心容量问题。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向数组中的任意位置添加元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 任意位置的下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 要添加的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"数组下标 "</span> + index + <span class="string">" 不合法, 当前size = "</span> + size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否需要进行扩容操作</span></span><br><span class="line">    <span class="keyword">if</span> (size == data.length) </span><br><span class="line">        resize(data.length * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挪动元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size; i &gt; index; i--) </span><br><span class="line">        data[i] = data[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素，维护size变量</span></span><br><span class="line">    data[index] = e;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设计两个方便用户操作的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向所有元素后添加一个新元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123; add(size, e); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向所有元素前添加一个新元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123; add(<span class="number">0</span>, e); &#125;</span><br></pre></td></tr></table></figure><h1 id="四、删除元素"><a href="#四、删除元素" class="headerlink" title="四、删除元素"></a>四、删除元素</h1><p>这其实跟添加元素是一样的，只是反过来而已。删除数组中任意位置的元素，需要将这个位置之后的所有元素都往前挪动一个位置。一个个的覆盖掉前面的元素。<br>在这里需要从要删除元素的后一位开始挪，一直往后挪到最后一位元素。</p><blockquote><p>注意：在删除元素时，如果数组中剩下的空间太多了，这时我们需要触发缩容操作，以免造成太多内存的浪费。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除数组中的任意元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index 要删除元素的下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> E 删除的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"数组下标 "</span> + index + <span class="string">" 不合法, 当前size = "</span> + size);</span><br><span class="line">    </span><br><span class="line">    E removeE = data[index];</span><br><span class="line">    <span class="comment">// 挪动元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        data[i] = data[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">// 判断是否缩容</span></span><br><span class="line">    <span class="keyword">if</span> (size == data.length / <span class="number">4</span> &amp;&amp; data.length / <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        resize(data.length / <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> removeE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在扩容的时候是扩容成原来数组的两倍的大小，但是缩容时确实缩容成数组的四分之一大小。<br>这是为了防止用户在添加删除元素时刚好是在原来数组容量大小的附近进行的，则不断的会去触发扩容和缩容的操作，而这会更多的消耗资源。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于动态数组，以上的几个方法就是其中最主要的方法了，其他的一些例如查询元素和修改元素相对而言比较简单，也没什么好说的，本文也就省略不提。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将讲述一个动态数组的实现过程，由于动态数组其实是一种比较简单的数据结构。所以本文将会以代码展示为主，当然，难点也是会重点讲述。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="https://www.wrp.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="Java" scheme="https://www.wrp.cool/tags/Java/"/>
    
    <category term="数据结构" scheme="https://www.wrp.cool/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="动态数组" scheme="https://www.wrp.cool/tags/%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84/"/>
    
    <category term="数组" scheme="https://www.wrp.cool/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【Java并发】多线程异常处理器</title>
    <link href="https://www.wrp.cool/posts/29598/"/>
    <id>https://www.wrp.cool/posts/29598/</id>
    <published>2020-07-23T13:31:05.000Z</published>
    <updated>2021-05-07T13:17:33.526Z</updated>
    
    <content type="html"><![CDATA[<p>我们平时在处理异常的时候，如果是主线程抛出了一个未处理的异常，那么我们可以轻松的使用 <code>try-catch</code> 捕获这个异常。但是如果这个异常是在子线程中抛出的，那么主线程实际上对于子线程的异常是不敏感的，虽然可以正常的抛出，但是却很难去发现。就算是在主线程中使用 <code>try-catch</code> 去捕获子线程的异常那也是没用的，因为 <code>try-catch</code> 只会捕获本线程中的异常。</p><a id="more"></a><p>简单对比一下主线程和子线程之间抛异常的不同之处：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"我是子线程抛出来的异常"</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">5000</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"我是主线程抛出来的异常"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上面的代码就可以清晰的展现这个问题。我们使用一个for循环来模拟程序的正常执行过程，这其中，子线程的异常大概是在控制台打印到500的时候抛出来，但这完全不会影响到主线程的正常执行，但是主线程的异常却每次都准确的在程序打印到5000的时候去抛出来，然后程序终止运行。如果是在真实的开发环境中，子线程抛出来的异常并不会被主线程捕获并处理，而在茫茫的日志文件中，我们想要去发现子线程的异常，简直是大海捞针。今天的主题就是要来说一说如何去处理子线程中的异常。</p><p>演示「主线程」<strong>无法捕获</strong>「子线程」中的异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test(),<span class="string">"线程1"</span>).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test(),<span class="string">"线程2"</span>).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test(),<span class="string">"线程3"</span>).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test(),<span class="string">"线程4"</span>).start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"捕获了异常"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"子线程抛出的异常"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面演示的在主线程中使用 <code>try-catch</code> 去捕获异常也是无法处理的，但是把 <code>try-catch</code> 放到子线程中去就可以处理这个异常了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"我是子线程抛出来的异常"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeExeception e) &#123;</span><br><span class="line">            <span class="comment">// 处理异常逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">5000</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"我是主线程抛出来的异常"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像上面这样在子线程中使用 <code>try-catch</code> 去捕获异常这是解决问题的办法之一。这也不可避免的带来一个弊端，那就是我们需要在每个run方法中都手动的去编写 <code>try-catch</code> 来处理异常，而且我们也不知道具体可能出现什么类型的异常。我们有更好的办法——UncaughtExceptionHandler</p><h1 id="Thread类中的接口UncaughtExceptionHandler"><a href="#Thread类中的接口UncaughtExceptionHandler" class="headerlink" title="Thread类中的接口UncaughtExceptionHandler"></a>Thread类中的接口UncaughtExceptionHandler</h1><p>java.lang 包中有一个ThreadGroup的类实现了这个接口，这里就简单的称之为线程的异常处理器。我们来看看这处理了什么内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口中仅定义了这一个方法，以下是实现类</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    通过接口的参数我们大致可以猜出，当子线程中抛出异常时，将会通过某种方式（个人猜测是反射）回调这个方法</span></span><br><span class="line"><span class="comment">    也清晰明了的告诉了我们是哪个线程抛出的哪个异常</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        parent 的定义：private final ThreadGroup parent;</span></span><br><span class="line"><span class="comment">        首先检查是否存在一个父线程的这个异常处理器，如果存在则调用父线程的异常处理器进行处理，这里是一个递归的操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        parent.uncaughtException(t, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            当调用完毕发现并没有一个可以处理异常的处理器之后</span></span><br><span class="line"><span class="comment">            尝试获取全局的异常处理器“这里的 ueh”</span></span><br><span class="line"><span class="comment">            如果存在一个全局的异常处理器，则使用这个处理器处理异常</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Thread.UncaughtExceptionHandler ueh =</span><br><span class="line">            Thread.getDefaultUncaughtExceptionHandler();</span><br><span class="line">        <span class="keyword">if</span> (ueh != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ueh.uncaughtException(t, e);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(e <span class="keyword">instanceof</span> ThreadDeath)) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                不存在的情况，直接将异常的堆栈信息打印出来</span></span><br><span class="line"><span class="comment">                也就是本文开头子线程中抛出的“我是子线程抛出来的异常”</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            System.err.print(<span class="string">"Exception in thread \""</span></span><br><span class="line">                            + t.getName() + <span class="string">"\" "</span>);</span><br><span class="line">            e.printStackTrace(System.err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看完这个线程处理器之后来看看要如何实现这个线程处理器</p><ul><li><p>首先我们需要编写一个类实现 Thread.UncaughtExceptionHandler 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyUncaughtExceptionHandler</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyUncaughtExceptionHandler</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">"已经成功捕获了异常。抛出异常的线程是："</span> + t.getName() + <span class="string">"。抛出的异常是："</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>其次我们需要将自己编写的异常处理器织入到主线程中，让它自动去处理子线程的异常。（这里使用开篇中「演示主线程中无法捕获子线程中的异常」的例子并作对比）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> MyUncaughtExceptionHandler(<span class="string">"线程异常处理器"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test(),<span class="string">"线程1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test(),<span class="string">"线程2"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test(),<span class="string">"线程3"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test(),<span class="string">"线程4"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"子线程抛出的异常"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main方法执行结果</span></span><br><span class="line">线程异常处理器已经成功捕获了异常。抛出异常的线程是：线程<span class="number">1</span>。抛出的异常是：java.lang.RuntimeException: 子线程抛出的异常</span><br><span class="line">线程异常处理器已经成功捕获了异常。抛出异常的线程是：线程<span class="number">2</span>。抛出的异常是：java.lang.RuntimeException: 子线程抛出的异常</span><br><span class="line">线程异常处理器已经成功捕获了异常。抛出异常的线程是：线程<span class="number">3</span>。抛出的异常是：java.lang.RuntimeException: 子线程抛出的异常</span><br><span class="line">线程异常处理器已经成功捕获了异常。抛出异常的线程是：线程<span class="number">4</span>。抛出的异常是：java.lang.RuntimeException: 子线程抛出的异常</span><br></pre></td></tr></table></figure><p>  至此，多线程异常处理器介绍完毕。</p></li></ul><hr><blockquote><p>插一句题外话，我认为本文的例子中很形象的向我们展示了线程的工作过程。线程在执行期间是互相不打扰的，各自干着各自的事情，这期间并不会互相影响。就像是一个团队在协同工作一样，每个人都是一个独立的线程，各自在完成自己的工作，并不会互相打扰。每个线程领取到自己的任务（run方法）之后，等待开始执行（调用start方法）。之后便是一直闷头干下去，直到把工作做完（run方法执行完毕）</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们平时在处理异常的时候，如果是主线程抛出了一个未处理的异常，那么我们可以轻松的使用 &lt;code&gt;try-catch&lt;/code&gt; 捕获这个异常。但是如果这个异常是在子线程中抛出的，那么主线程实际上对于子线程的异常是不敏感的，虽然可以正常的抛出，但是却很难去发现。就算是在主线程中使用 &lt;code&gt;try-catch&lt;/code&gt; 去捕获子线程的异常那也是没用的，因为 &lt;code&gt;try-catch&lt;/code&gt; 只会捕获本线程中的异常。&lt;/p&gt;</summary>
    
    
    
    <category term="并发" scheme="https://www.wrp.cool/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="Java" scheme="https://www.wrp.cool/tags/Java/"/>
    
    <category term="并发" scheme="https://www.wrp.cool/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="线程" scheme="https://www.wrp.cool/tags/%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="异常" scheme="https://www.wrp.cool/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>【Java并发】join()方法</title>
    <link href="https://www.wrp.cool/posts/50308/"/>
    <id>https://www.wrp.cool/posts/50308/</id>
    <published>2020-07-19T12:47:27.000Z</published>
    <updated>2021-05-07T13:18:03.001Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>join方法的主要作用是同步。在主线程中去创建并启动一个线程，再调用这个线程的join方法之后，会使得两个线程原本是并行关系变成串行关系，也就是主线程将会等待子线程执行完毕之后再继续执行。</p></blockquote><a id="more"></a><p>注意：join方法可以传入一个long类型的参数，表示过了多少毫秒之后两个线程将由串行关系再次转变成并行关系。但如果传入的参数是0的话，表示的是永久等待，也就是主线程将会等待直到子线程执行完毕之后再次执行，相当于不传参数的join方法。</p><p><strong>代码演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子线程"</span> + Thread.currentThread().getName() + <span class="string">"开始执行"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"子线程"</span> + Thread.currentThread().getName() + <span class="string">"执行完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test());</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Test());</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(<span class="string">"所有子线程执行完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main方法执行结果</span></span><br><span class="line">子线程Thread-<span class="number">1</span>执行完毕</span><br><span class="line">子线程Thread-<span class="number">0</span>执行完毕</span><br><span class="line">所有子线程执行完毕</span><br></pre></td></tr></table></figure><p>上面的代码如果将两个线程执行join方法的那行代码注释掉，则执行结果为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">所有子线程执行完毕</span><br><span class="line">子线程Thread-<span class="number">0</span>执行完毕</span><br><span class="line">子线程Thread-<span class="number">1</span>执行完毕</span><br></pre></td></tr></table></figure><p>很明显，join方法的调用会使得主线程去等待子线程执行完毕之后再重新执行代码。</p><h1 id="join期间被中断"><a href="#join期间被中断" class="headerlink" title="join期间被中断"></a>join期间被中断</h1><p>一个有意思的问题：</p><blockquote><p>如果主线程调用子线程的join方法后，在子线程执行的期间，有interrupt通知进入了，怎么办？</p></blockquote><p>针对上面的问题，我再重申一下本文开篇关于join方法作用的介绍。「<strong>主线程将会等待调用了join方法的子线程执行完毕后再继续执行</strong>」<br>实际上，是主线程在等待子线程执行完毕，也就是说陷入阻塞状态的是主线程而不是子线程。<br>所以关于上面的问题如果有interrupt通知进入了主线程将会抛出一个InterruptedException来响应这个interrupt通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Thread mainThread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        mainThread.interrupt();</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        thread.join();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"线程被中断了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main方法执行结果</span></span><br><span class="line">main线程被中断了</span><br></pre></td></tr></table></figure><p>启动一个子线程并调用join方法，这时主线程就在等待子线程的执行完毕，然后子线程去中断了主线程。也就是中断了一个正在<strong>因join方法陷入阻塞</strong>的线程，那么此时我们中断的是这个陷入阻塞的线程，而不是正在执行的子线程。</p><h1 id="join期间的线程状态"><a href="#join期间的线程状态" class="headerlink" title="join期间的线程状态"></a>join期间的线程状态</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Thread mainThread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(mainThread.getState());</span><br><span class="line">        System.out.println(Thread.currentThread().getState());</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">    thread.join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main方法执行结果</span></span><br><span class="line">WAITING</span><br><span class="line">RUNNABLE</span><br></pre></td></tr></table></figure><p>在子线程中去打印主线程和子线程各自的状态，明显调用了join方法的主线程被阻塞了是WAITING状态，而正在运行的子线程则是RUNNABLE状态。</p><h1 id="join方法分析"><a href="#join方法分析" class="headerlink" title="join方法分析"></a>join方法分析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面是Thread类中的join方法源码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    join(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可知，join方法实际上还是调用了wait方法的。如果没有传入时间参数，则是调用了<code>wait(0)</code>这个方法，代表永久等待，直到被唤醒。<br>有意思的是这其中并没有看到notify或者是notifyAll方法，也就是并没有线程去唤醒这个等待子线程执行完毕的主线程，但是当子线程执行完毕之后，这确确实实被唤醒了。<br>我们知道，主线程被唤醒的条件是子线程执行完毕，又知道线程执行完毕只有两种情况，一是run方法运行结束，二是抛出了运行时异常。<br>至此，答案水落石出，当线程执行完毕时，将会去执行notifyAll方法唤醒其他的线程。</p><blockquote><p>注意：我们并不提倡使用Thread类的实例作为synchronized的锁对象原因也是在此，因为这可能会破坏原有的wait-notify结构。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;join方法的主要作用是同步。在主线程中去创建并启动一个线程，再调用这个线程的join方法之后，会使得两个线程原本是并行关系变成串行关系，也就是主线程将会等待子线程执行完毕之后再继续执行。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
