<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>知更</title>
  
  <subtitle>知道要更新，知道要进步</subtitle>
  <link href="https://www.wrp.cool/atom.xml" rel="self"/>
  
  <link href="https://www.wrp.cool/"/>
  <updated>2022-11-16T12:38:21.112Z</updated>
  <id>https://www.wrp.cool/</id>
  
  <author>
    <name>码小瑞</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM 垃圾回收</title>
    <link href="https://www.wrp.cool/posts/23073/"/>
    <id>https://www.wrp.cool/posts/23073/</id>
    <published>2022-11-04T17:11:10.000Z</published>
    <updated>2022-11-16T12:38:21.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对象已死？"><a href="#对象已死？" class="headerlink" title="对象已死？"></a>对象已死？</h1><p>在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”（“死去”即不可能再被任何途径使用的对象）了。</p><h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><p>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</p><p><strong>优点：</strong>原理简单，判断效率高。<br><strong>缺点：</strong>无法解决循环引用问题。</p><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E5%88%A9%E7%94%A8%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E5%9B%9E%E6%94%B6.png" alt="利用可达性分析算法判断对象是否可回收"></p><h3 id="GC-Roots-对象"><a href="#GC-Roots-对象" class="headerlink" title="GC Roots 对象"></a>GC Roots 对象</h3><p><strong>固定对象：</strong></p><ul><li>栈帧中的本地变量表中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</li><li>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。</li><li>在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。</li><li>在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</li><li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</li><li>所有被同步锁（synchronized关键字）持有的对象。</li><li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li></ul><p><strong>临时性对象：</strong></p><p>如果只针对 Java 堆中的某一块区域发起垃圾回收，必须考虑到内存区域并不是封闭独立的所以某个区域里的对象完全有可能被位于堆中其他区域的对象所引用，这时候就需要将这些关联区域的对象也一并加入GC Roots集合中去，才能保证可达性分析的正确性。</p><h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h3><p>可以用来做外部资源回收的工作，但是 try-finally 可以做的更好，并且 finalize() 方法执行效率低、执行成本高、不确定性大，所以一般不推荐使用，仅作了解。</p><p>真正宣告一个对象死亡，要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。</p><p>这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。这样做的原因是，如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。</p><p>如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 此代码演示了两点：</span></span><br><span class="line"><span class="comment">* 1.对象可以在被GC时自我拯救。</span></span><br><span class="line"><span class="comment">* 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalizeEscapeGC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">FinalizeEscapeGC</span> <span class="variable">SAVE_HOOK</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">isAlive</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;yes, I am still alive :)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;finalize method executed!&quot;</span>);</span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> <span class="title class_">FinalizeEscapeGC</span>();</span><br><span class="line">        <span class="comment">//对象第一次成功拯救自己</span></span><br><span class="line">        SAVE_HOOK = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="literal">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;no, I am dead :(&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下面这段代码与上面的完全相同，但是这次自救却失败了</span></span><br><span class="line">        SAVE_HOOK = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="literal">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;no, I am dead :(&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四大引用类型"><a href="#四大引用类型" class="headerlink" title="四大引用类型"></a>四大引用类型</h2><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似 <code>Object obj=new Object()</code> 这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></table></figure><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">// 使对象只被弱引用关联</span></span><br></pre></td></tr></table></figure><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;Object&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">// 使对象只被虚引用关联</span></span><br></pre></td></tr></table></figure><h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。</p><p><strong>缺点：</strong></p><ol><li>效率不稳定，效率随着需要被回收的对象的增多而降低。</li><li>内存空间碎片化，会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li></ol><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E2%80%9C%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E2%80%9D%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="“标记-清除”算法示意图"></p><h2 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h2><p>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p><p><strong>优点：</strong>对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。</p><p><strong>缺点：</strong>将可用内存缩小为了原来的一半。</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="标记-复制算法示意图"></p><p>现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。</p><p>HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。</p><h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>标记过程与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E2%80%9C%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E2%80%9D%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="“标记-整理”算法示意图"></p><p><code>标记-清除</code>算法与<code>标记-整理</code>算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策：</p><ul><li><strong>移动：</strong>移动操作必须全程暂停用户应用程序才能进行</li><li><strong>不移动：</strong>存活对象所导致的内存碎片化问题</li></ul><p>是否移动对象都存在弊端，移动则内存回收时会更复杂，不移动则内存分配时会更复杂</p><blockquote><p>有一种“和稀泥式”解决方案可以不在内存分配和访问上增加太大额外负担，做法是让虚拟机平时多数时间都采用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经大到影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间。</p></blockquote><h1 id="经典垃圾收集器"><a href="#经典垃圾收集器" class="headerlink" title="经典垃圾收集器"></a>经典垃圾收集器</h1><h2 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h2><p>“分代收集”（Generational Collection）的理论建立在两个分代假说之上：</p><ul><li>弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。</li><li>强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。</li></ul><p><em>分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则。</em></p><p>这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：<strong>收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。</strong></p><blockquote><p>显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间；如果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。</p></blockquote><p>设计者一般至少会把Java堆划分为新生代（Young Generation）和老年代（Old Generation）两个区域。顾名思义，在新生代中，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。</p><p>但是分代收集并非只是简单划分一下内存区域那么容易，它至少存在一个明显的困难：<strong>对象不是孤立的，对象之间会存在跨代引用。</strong>为了解决这个问题，就需要对分代收集理论添加第三条经验法则：</p><ul><li>跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。</li></ul><p>依据这条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构（该结构被称为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GCRoots进行扫描。虽然这种方法需要在对象改变引用关系（如将自己或者某个属性赋值）时维护记录数据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。</p><h2 id="垃圾收集器图示"><a href="#垃圾收集器图示" class="headerlink" title="垃圾收集器图示"></a>垃圾收集器图示</h2><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="HotSpot虚拟机的垃圾收集器"></p><p>图展示了七种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用，图中收集器所处的区域，则表示它是属于新生代收集器抑或是老年代收集器。</p><h2 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h2><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/SerialSerialOld%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="SerialSerial Old收集器运行示意图"></p><p>这个收集器是一个单线程工作的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。</p><p><strong>优点：</strong>简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。<br><strong>缺点：</strong>在进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。</p><p><strong>适用场景：</strong>对于内存资源受限的环境，它是所有收集器里额外内存消耗（Memory Footprint）最小的；对于单核处理器或处理器核心数较少的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p><h2 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h2><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/ParNewSerialOld%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="ParNewSerial Old收集器运行示意图"></p><p>它是 Serial 收集器的多线程版本。</p><p>是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。</p><p>默认开启的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。</p><h2 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h2><p>Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）</p><p>Parallel Scavenge收集器ᨀ供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX：MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX：GCTimeRatio参数。</p><p><strong>-XX：MaxGCPauseMillis：</strong>参数允许的值是一个大于0的毫秒数，收集器将尽力保证内存回收花费的时间不超过用户设定值。但垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的。</p><p><strong>-XX：GCTimeRatio：</strong>参数的值则应当是一个大于0小于100的整数，也就是垃圾收集时间占总时间的比率，相当于吞吐量的倒数。譬如把此参数设置为19，那允许的最大垃圾收集时间就占总时间的5%（即1&#x2F;(1+19)），默认值为99，即允许最大1%（即1&#x2F;(1+99)）的垃圾收集时间。</p><h2 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h2><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/SerialSerialOld%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="SerialSerial Old收集器运行示意图"></p><p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。在服务端模式下有两大用途：</p><ol><li>在 JDK 1.5 以及之前版本(Parallel Old 诞生以前)中与 Parallel Scavenge 收集器搭配使用。</li><li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li></ol><h2 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h2><p>Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/ParallelScavengeParallelOld%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Parallel ScavengeParallel Old收集器运行示意图"></p><h2 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h2><blockquote><p>CMS（Concurrent Mark Sweep）收集器是一种基于<strong>标记-清除</strong>算法实现的，以获取<strong>最短回收停顿时间</strong>为目标的收集器。<strong>优点：</strong>并发收集、低停顿。</p></blockquote><p><strong>整个运作过程分为四步：</strong></p><ol><li><strong>初始标记：</strong>仅仅只是标记一下GC Roots能直接关联到的对象，速度很快</li><li><strong>并发标记：</strong>从GC Roots的直接关联对象开始遍历整个对象图，耗时较长但是不需要停顿用户线程</li><li><strong>重新标记：</strong>修正在并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</li><li><strong>并发清除：</strong>使用标记-清除算法清理删除掉标记阶段判断的已经死亡的对象，不需要移动存活对象</li></ol><p>由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一起工作，所以从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/ConcurrentMarkSweep%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="ConcurrentMarkSweep收集器运行示意图"></p><p><strong>四个缺点：</strong></p><ol><li>与用户线程并发执行期间，会占用一部分线程而导致应用程序变慢而降低总吞吐量</li><li>款基于“标记-清除”算法实现，收集结束时可能会有大量空间碎片产生</li><li>无法清理浮动垃圾：在CMS的并发标记和并发清理阶段，用户线程是还在继续运行，会有新的垃圾对象产生。这部分垃圾就称为“浮动垃圾”，只能等下一次垃圾清楚再回收</li><li>需要预留空间：由于在垃圾收集阶段用户线程还需要持续运行，那就还需要预留足够内存空间提供给用户线程使用，因此CMS收集器必须预留一部分空间供并发收集时的程序运作使用</li></ol><hr><blockquote><p><strong>巨人的肩膀：</strong></p><ul><li>《深入理解Java虚拟机》</li></ul></blockquote>]]></content>
    
    
    <summary type="html">在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Java对象内存结构</title>
    <link href="https://www.wrp.cool/posts/4996/"/>
    <id>https://www.wrp.cool/posts/4996/</id>
    <published>2022-11-03T10:17:11.000Z</published>
    <updated>2022-11-03T11:43:44.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h1><p>当 new 一个新的对象时，首先检查这个对象所属的类是否已经被加载、解析和初始化。如果没有那必须先执行类加载过程。接下来虚拟机将为新生对象分配内存，为对象分配空间的任务实际上便等同于把一块确定大小的内存块（类加载完毕后对象大小也被确定）从 Java 堆中划分出来。</p><h2 id="对象内存空间分配"><a href="#对象内存空间分配" class="headerlink" title="对象内存空间分配"></a>对象内存空间分配</h2><p>分配空间有两种方式：指针碰撞和空闲列表。</p><p><strong>指针碰撞：</strong>假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”（Bump The Pointer）。</p><p><strong>空闲列表：</strong>但如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”（Free List）。</p><blockquote><p>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理（Compact）的能力决定。因此，当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用CMS这种基于清（Sweep）算法的收集器时，“理论上”就只能采用较为复杂的空闲列表来分配内存。<em>（CMS的实现里面，为了能在多数情况下分配得更快，设计了一个叫作Linear Allocation Buffer的分配缓冲区，通过空闲列表拿到一大块分配缓冲区之后，在它里面仍然可以使用指针碰撞方式来分配。）</em></p></blockquote><h2 id="指向新对象"><a href="#指向新对象" class="headerlink" title="指向新对象"></a>指向新对象</h2><p>对象创建在虚拟机中是非常频繁的行为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题关键是为对象内存分配这个动作提供原子性保证，有两种可选方案：CAS和线程隔离。</p><p><strong>CAS：</strong>对分配内存空间的动作进行同步处理，CAS配上失败重试的方式保证更新操作的原子性</p><p><strong>线程隔离：</strong>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。是否使用TLAB，可以通过-XX：+&#x2F;-UseTLAB参数来设定。</p><h2 id="初始化新对象"><a href="#初始化新对象" class="headerlink" title="初始化新对象"></a>初始化新对象</h2><p><strong>内存空间初始化：</strong>内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值，如果使用了TLAB的话，这一项工作也可以ᨀ前至TLAB分配时顺便进行。这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。</p><p><strong>对象头初始化：</strong>接下来，Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（懒加载）、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><h1 id="堆内存中的对象"><a href="#堆内存中的对象" class="headerlink" title="堆内存中的对象"></a>堆内存中的对象</h1><p>对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p><h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>HotSpot虚拟机对象的对象头部分包括两类信息：一类是用于存储对象自身的运行时数据，另一类是类型指针。</p><p><strong>对象自身的运行时数据：</strong>哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。</p><p><strong>类型指针：</strong>即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。</p><p>此外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据。</p><h2 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h2><p>实例数据部分是对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。</p><p>HotSpot虚拟机默认的分配顺序为longs&#x2F;doubles、ints、shorts&#x2F;chars、bytes&#x2F;booleans、oops（Ordinary Object Pointers，oops）</p><h2 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h2><p>对象的第三部分是对齐填充，这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是任何对象的大小都必须是8字节的整数倍。对象头部分已经被精心设计成正好是8字节的倍数（1倍或者2倍），因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p><h1 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h1><p>Java程序会通过栈上的reference数据来操作堆上的具体对象，主流的访问方式有两种：句柄、直接指针。</p><p><strong>句柄：</strong>使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。</p><p>使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E9%80%9A%E8%BF%87%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png" alt="通过句柄访问对象"></p><p><strong>直接指针：</strong>使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。</p><p>使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本。</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E9%80%9A%E8%BF%87%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png" alt="通过直接指针访问对象"></p><hr><blockquote><p><strong>巨人的肩膀：</strong></p><ul><li>《深入理解Java虚拟机》</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;对象的创建&quot;&gt;&lt;a href=&quot;#对象的创建&quot; class=&quot;headerlink&quot; title=&quot;对象的创建&quot;&gt;&lt;/a&gt;对象的创建&lt;/h1&gt;&lt;p&gt;当 new 一个新的对象时，首先检查这个对象所属的类是否已经被加载、解析和初始化。如果没有那必须先执行类加载过程。接</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>线程基础（下）</title>
    <link href="https://www.wrp.cool/posts/32328/"/>
    <id>https://www.wrp.cool/posts/32328/</id>
    <published>2022-11-01T13:42:40.000Z</published>
    <updated>2022-11-01T16:24:59.060Z</updated>
    
    <content type="html"><![CDATA[<p>承接上文，本文将介绍：线程的生命周期、如何捕获线程异常、以及可以让并行变串行的join()方法</p><h1 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h1><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4800715d63964fe28eaaebac61c364c4~tplv-k3u1fbpfcp-watermark.image" alt="线程的6个状态.png"></p><blockquote><p>在这张图片中，包含了线程的所有状态以及每种状态之间的互相转换过程。其中箭头的指向是固定的，单箭头的指向则表明了两个线程的状态是不可逆的，一旦从一端到另一端之后就无法再回去原来的状态。</p></blockquote><h2 id="NEW、RUNNABLE、TERMINATED"><a href="#NEW、RUNNABLE、TERMINATED" class="headerlink" title="NEW、RUNNABLE、TERMINATED"></a>NEW、RUNNABLE、TERMINATED</h2><ol><li><p><em>新创建（NEW）</em><br>线程一经创建，也就是去 new 了一个 Thread 类之后，未调用 start 方法之前，这时的线程就是「新创建」的状态</p></li><li><p><em>可运行（RUNNABLE）</em><br>有些地方可能将「可运行」状态称之为「就绪」状态，这两者其实都是「RUNNABLE」状态</p><p> 调用 start 方法开始，直到 run 方法中的代码执行完毕之前，如果没有其他的操作使得线程状态跑到上图右边的三种状态中去的话，线程将会一直处于「可运行」状态。</p><p> 注意：线程并没有一个「运行」的状态，就算是正在执行 run() 方法的线程状态也是「可运行」状态。</p></li><li><p><em>已终止（TERMINATED）</em><br>当 run 方法的代码执行完毕或者是抛出未处理的异常的时，线程就会处于「已终止」状态中。这个状态也是线程的最终状态，线程一旦进入了这个状态将无法再回到其他的状态中。</p><p> NEW、RUNNABLE、TERMINATED 这三种状态都是单向的，是无法返回的。NEW –&gt; RUNNABLE –&gt; TERMINATED</p></li><li><p><em>代码演示</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">500</span>)</span><br><span class="line">                <span class="comment">// run() 方法执行中</span></span><br><span class="line">                System.out.println(<span class="string">&quot;thread.state = &quot;</span> + Thread.currentThread().getState());  <span class="comment">// RUNNABLE</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;thread.state = &quot;</span> + thread.getState());  <span class="comment">// NEW</span></span><br><span class="line"></span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(<span class="string">&quot;thread.state = &quot;</span> + thread.getState());  <span class="comment">// RUNNABLE</span></span><br><span class="line"></span><br><span class="line">    thread.join();</span><br><span class="line">    System.out.println(<span class="string">&quot;thread.state = &quot;</span> + thread.getState());  <span class="comment">// TERMINATED</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="BLOCKED、WAITING、TIMED-WAITING"><a href="#BLOCKED、WAITING、TIMED-WAITING" class="headerlink" title="BLOCKED、WAITING、TIMED_WAITING"></a>BLOCKED、WAITING、TIMED_WAITING</h2><ol><li><p><em>被阻塞（BLOCKED）</em><br>如果线程执行了一个被 synchronize 关键字修饰的代码块，并且这个代码块还处于其他线程的执行之中，这时调用的线程就会处于阻塞的状态，等待其他线程执行完毕后再执行。<br>等待的这个线程在等待的时间内就是处于 <em>BLOCKED</em> 状态。</p><blockquote><p>习惯上来说 BLOCKED、WAITING、TIMED_WAITING 都称之为阻塞状态，而不仅仅是 BLOCKED。</p></blockquote></li><li><p><em>等待(WAITING)</em> 和 <em>计时等待(TIMED_WAITING)</em><br>当线程阻塞时就会进入等待的状态。其中等待和计时等待非常好理解，有带 time 参数的等待就是计时等待，反之则是等待。</p></li><li><p><em>代码演示</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">5</span>); <span class="comment">// 让 t1 和 t2 先跑一会</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;t1 sleep(50) t1.state = &quot;</span>+t1.getState()); <span class="comment">// TIMED_WAITING</span></span><br><span class="line">        System.out.println(<span class="string">&quot;t1 get LOCK，t2 be BLOCKED t2.state = &quot;</span> + t2.getState()); <span class="comment">// BLOCKED</span></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">100</span>); <span class="comment">// 进入 wait() 中</span></span><br><span class="line">        System.out.println(<span class="string">&quot;t1 wait(), t1.state = &quot;</span> + t1.getState()); <span class="comment">// WAITING</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="捕获线程异常"><a href="#捕获线程异常" class="headerlink" title="捕获线程异常"></a>捕获线程异常</h1><p>由于 Runnable 和 Thread 之间的解耦设计，导致 Thread 在运行 Runnable 时其实是无法感知到 Runnable 内部的运行逻辑的，Thread 无法知道这个线程执行完了是否需要处理返回值，是否会抛出什么异常等等</p><p>例如线程池，线程池中的 Thread 根本不知道会传进来一个什么样的 Runnable，对于 Thread 而言，只关注执行上的逻辑，而不关注 Runnable 内部的逻辑。</p><p>毫无疑问这样的设计是优秀的，但如果线程在执行的过程当中发生了异常，那处理起来就不是很方便了。针对这种情况可以利用 Thread.UncaughtExceptionHandler 捕获异常。</p><p>如果主线程抛出一个异常，可以直接使用 <code>try-catch</code> 捕获处理这个异常。如果异常是子线程中抛出的，那么主线程对这个异常并不敏感，无法直接捕获处理这个异常。虽然在控制台能看到异常信息，但是这个异常信息是子线程输出的，主线程并无法感知到这个异常，之所以能在控制台看到异常信息，是因为主线程与子线程共用了同一个控制台。</p><p>如果还不是很理解上面这段话，你可以跑一下这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;我是子线程抛出来的异常&quot;</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">5000</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;我是主线程抛出来的异常&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                System.out.println(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于主线程的异常，可以直接使用 <code>try-catch</code> 来捕获处理。对于子线程的异常，每次抛出异常的时机都不相同，主线程无法知道什么时候子线程会抛出异常，更无法捕获处理子线程中的异常。</p><p>其实这个例子也很形象的向我们展示了线程的工作过程：每个线程在执行期间是互不打扰的，自己干自己的事情。每个线程在领取到自己的任务（run方法）之后，等待被分配资源开始执行（start方法）之后便是一直闷头干下去，直到把工作做完（run方法执行完毕）</p><p>这样就要求子线程必须能够自行处理异常，也就是在子线程内部使用 <code>try-catch</code> 来处理异常。但子线程不一定能够处理自己的异常，有些异常需要向外通知父线程，让父线程去执行对应的处理逻辑。</p><p>这样看来，子线程更像是父线程的一个方法，异常可以在方法中使用 <code>try-catch</code> 自行处理，也可以标记在方法签名上向外抛出。</p><p>针对需要通知父线程处理的异常，可以使用 <em>Thread.UncaughtExceptionHandler</em> 这个接口来接收并处理异常。</p><p>这个接口的使用方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义的线程异常处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MyUncaughtExceptionHandler</span> <span class="keyword">implements</span> <span class="title class_">Thread</span>.UncaughtExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyUncaughtExceptionHandler</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;：成功捕获了异常。抛出异常的线程是：&quot;</span> + t.getName() + <span class="string">&quot;。抛出的异常是：&quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 方式一：设置为默认异常处理器</span></span><br><span class="line">    <span class="comment">// MyUncaughtExceptionHandler --&gt; Thread.defaultUncaughtExceptionHandler</span></span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> <span class="title class_">MyUncaughtExceptionHandler</span>(<span class="string">&quot;默认的线程异常处理器&quot;</span>));</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>()).start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式二：设置为线程专用的异常处理器</span></span><br><span class="line">    <span class="comment">// MyUncaughtExceptionHandler --&gt; t.uncaughtExceptionHandler</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>(), <span class="string">&quot;Thread-0&quot;</span>);</span><br><span class="line">    t.setUncaughtExceptionHandler(<span class="keyword">new</span> <span class="title class_">MyUncaughtExceptionHandler</span>(<span class="string">&quot;为 Thread-0 专门设置的异常处理器&quot;</span>));</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Task 抛出的异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先创建一个类实现 <code>Thread.UncaughtExceptionHandler</code> 作为自定义的线程异常处理器，再根据需要设置为默认的异常处理器，或者是为每个线程单独设置的异常处理器。</p><p>如果没有单独设置异常处理器也没有设置默认的异常处理器，那么调用 <code>ThreadGroup</code> 类对异常做处理，该类实现了 <code>Thread.UncaughtExceptionHandler</code> 接口，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 首先检查是否存在父线程组，如果存在则调用父线程组的异常处理器进行处理，这里是一个递归的操作</span></span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">        parent.uncaughtException(t, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取全局异常处理器</span></span><br><span class="line">        Thread.<span class="type">UncaughtExceptionHandler</span> <span class="variable">ueh</span> <span class="operator">=</span> Thread.getDefaultUncaughtExceptionHandler();</span><br><span class="line">        <span class="comment">// 尝试使用全局异常处理器处理</span></span><br><span class="line">        <span class="keyword">if</span> (ueh != <span class="literal">null</span>) &#123;</span><br><span class="line">            ueh.uncaughtException(t, e);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(e <span class="keyword">instanceof</span> ThreadDeath)) &#123;</span><br><span class="line">            <span class="comment">// 不存在全局异常处理器，直接将异常的堆栈信息打印出来</span></span><br><span class="line">            System.err.print(<span class="string">&quot;Exception in thread \&quot;&quot;</span> + t.getName() + <span class="string">&quot;\&quot; &quot;</span>);</span><br><span class="line">            e.printStackTrace(System.err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="并行变串行，join"><a href="#并行变串行，join" class="headerlink" title="并行变串行，join()"></a>并行变串行，join()</h1><blockquote><p>join方法的作用是同步。在主线程中去创建并启动一个线程，再调用这个线程的join方法之后，会使得两个线程原本是并行关系变成串行关系，也就是主线程将会等待子线程执行完毕之后再继续执行。</p></blockquote><p>注意：join方法可以传入一个long类型的参数，表示过了多少毫秒之后两个线程将由串行关系再次转变成并行关系。但如果传入的参数是0的话，表示的是永久等待，也就是主线程将会等待直到子线程执行完毕之后再次执行，相当于不传参数的join方法。</p><p><strong>代码演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;开始执行&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;子线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Test</span>());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Test</span>());</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(<span class="string">&quot;所有子线程执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main方法执行结果</span></span><br><span class="line"><span class="comment">// 子线程Thread-0开始执行</span></span><br><span class="line"><span class="comment">// 子线程Thread-1开始执行</span></span><br><span class="line"><span class="comment">// 子线程Thread-0执行完毕</span></span><br><span class="line"><span class="comment">// 子线程Thread-1执行完毕</span></span><br><span class="line"><span class="comment">// 所有子线程执行完毕</span></span><br></pre></td></tr></table></figure><p>上面的代码如果将两个线程执行join方法的那行代码注释掉，则执行结果为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">所有子线程执行完毕</span><br><span class="line">子线程Thread-<span class="number">0</span>开始执行</span><br><span class="line">子线程Thread-<span class="number">1</span>开始执行</span><br><span class="line">子线程Thread-<span class="number">1</span>执行完毕</span><br><span class="line">子线程Thread-<span class="number">0</span>执行完毕</span><br></pre></td></tr></table></figure><p>很明显，join方法的调用会使得主线程去等待子线程执行完毕之后再重新执行代码。</p><h2 id="join期间被中断"><a href="#join期间被中断" class="headerlink" title="join期间被中断"></a>join期间被中断</h2><blockquote><p>如果主线程调用子线程的 join() 方法后，在子线程执行的期间，有 interrupt 通知进入了，怎么办？</p></blockquote><p>针对上面的问题，我再重申一下关于 join() 方法作用的介绍。<strong>主线程将会等待调用了join方法的子线程执行完毕后再继续执行</strong></p><p>实际上，是主线程在等待子线程执行完毕，也就是说陷入阻塞状态的是主线程而不是子线程。所以关于上面的问题如果有 interrupt 通知进入了主线程将会抛出一个 InterruptedException 来响应这个 interrupt 通知。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">mainThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        mainThread.interrupt();</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        thread.join();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;线程被中断了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main方法执行结果</span></span><br><span class="line">main线程被中断了</span><br></pre></td></tr></table></figure><p>启动一个子线程并调用join方法，这时主线程就在等待子线程的执行完毕，然后子线程去中断了主线程。也就是中断了一个正在<strong>因join方法陷入阻塞</strong>的线程，那么此时我们中断的是这个陷入阻塞的线程，而不是正在执行的子线程。</p><h2 id="join期间的线程状态"><a href="#join期间的线程状态" class="headerlink" title="join期间的线程状态"></a>join期间的线程状态</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">Thread</span> <span class="variable">mainThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(mainThread.getState());</span><br><span class="line">        System.out.println(Thread.currentThread().getState());</span><br><span class="line">    &#125;);</span><br><span class="line">    thread.start();</span><br><span class="line">    thread.join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main方法执行结果</span></span><br><span class="line"><span class="comment">// WAITING</span></span><br><span class="line"><span class="comment">// RUNNABLE</span></span><br></pre></td></tr></table></figure><p>在子线程中去打印主线程和子线程各自的状态，明显调用了join方法的主线程被阻塞了是WAITING状态，而正在运行的子线程则是RUNNABLE状态。</p><h2 id="join-方法分析"><a href="#join-方法分析" class="headerlink" title="join() 方法分析"></a>join() 方法分析</h2><p><strong>join() 方法源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    join(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可知，join() 方法实际上还是调用了 wait() 方法的。如果没有传入时间参数，则是调用了 wait(0) 这个方法，代表永久等待，直到被唤醒。<br>有意思的是这其中并没有看到 notify() 或者是 notifyAll() 方法，也就是并没有线程去唤醒这个等待子线程执行完毕的主线程，但是当子线程执行完毕之后，这确确实实被唤醒了。</p><p>我们知道，主线程被唤醒的条件是子线程执行完毕，又知道线程执行完毕只有两种情况，一是 run() 方法运行结束，二是抛出了运行时异常。至此，答案水落石出，当线程执行完毕时，将会去执行 notifyAll() 方法唤醒其他的线程。</p><blockquote><p>注意：我们并不提倡使用 Thread 类的实例作为 synchronized 的锁对象原因也是在此，因为这可能会破坏原有的 wait-notify 结构。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;承接上文，本文将介绍：线程的生命周期、如何捕获线程异常、以及可以让并行变串行的join()方法&lt;/p&gt;
&lt;h1 id=&quot;线程生命周期&quot;&gt;&lt;a href=&quot;#线程生命周期&quot; class=&quot;headerlink&quot; title=&quot;线程生命周期&quot;&gt;&lt;/a&gt;线程生命周期&lt;/h1&gt;&lt;p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>拿到 synchronized 锁之后，先释放再等等</title>
    <link href="https://www.wrp.cool/posts/11150/"/>
    <id>https://www.wrp.cool/posts/11150/</id>
    <published>2022-11-01T13:00:34.000Z</published>
    <updated>2022-11-02T07:32:15.276Z</updated>
    
    <content type="html"><![CDATA[<p>在 synchronized 的使用中，如果继续往下执行代码的条件不被满足的话需要先释放当前持有的锁对象再等等，等到执行条件被满足后再接着往下执行。</p><blockquote><p>就像平时去医院排队看病一样，轮到我们了在医生问诊的过程中，可能会先让你先去做某一项检查，等检查完拿到检查结果之后再重新排队等待医生叫号。<br>排队看病的例子中，当我们在被医生问诊的时候，我们就独占了医生这把锁；需要做某一项检查的时候就是往下继续问诊的流程继续不了了；拿到检查结果后我们也要重新排队等待医生继续问诊。</p></blockquote><p>在程序的世界里，我们使用 synchronized 锁来保护医生对象，一个医生同一时刻只能给一个病人问诊；调用 wait() 方法先去做检查；当问诊结束了调用 notify() 方法去通知下一位病人问诊。</p><h1 id="wait-方法介绍"><a href="#wait-方法介绍" class="headerlink" title="wait() 方法介绍"></a>wait() 方法介绍</h1><p><strong>wait() 方法的使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">    object.wait();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (Object.class) &#123;</span><br><span class="line">    Object.class.wait();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="built_in">this</span>.wait();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Object.class.wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>wait() 方法的重载：</strong></p><ul><li>wait(long timeout)：在 timeout 毫秒内如果没有被 notify 唤醒则自行唤醒。</li><li>wait(long timeout, int nanos)：在 1,000,000*timeout+nanos 纳米内如果没有被 notify 唤醒则自行唤醒。</li></ul><h1 id="notify-方法介绍"><a href="#notify-方法介绍" class="headerlink" title="notify() 方法介绍"></a>notify() 方法介绍</h1><p>调用 wait() 方法当前线程会放弃 synchronized 锁，相对应的调用 notify() 方法之后原来放弃 synchronized 锁的线程就会重新去竞争 synchronized 锁，竞争到锁的线程可以继续执行。</p><p>notify() 方法还有一个兄弟方法叫做 notifyAll()，notify() 方法只会唤醒被 wait() 阻塞的线程之一；而 notifyAll() 会唤醒全部被 wait() 阻塞的线程。</p><p>被 wait() 方法阻塞的线程想要被唤醒必须是另外的一个线程去调用了 notiify() 并且轮到本线程被唤醒，或者是直接调用 notifyAll()。</p><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Demo</span><span class="params">(<span class="type">int</span> num)</span> &#123; <span class="built_in">this</span>.num = num; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Integer&gt; waitList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">50</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Integer&gt; notifyList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                waitList.add(num);</span><br><span class="line">                LOCK.wait();</span><br><span class="line">                notifyList.add(num);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Demo</span>(i)).start();</span><br><span class="line">            Thread.sleep(<span class="number">10</span>); <span class="comment">// 一个个去睡觉</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// notifyDemo();</span></span><br><span class="line">        <span class="comment">// notifyAllDemo();</span></span><br><span class="line">        System.out.println(waitList);</span><br><span class="line">        System.out.println(notifyList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">notifyDemo</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">                LOCK.notify();</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>); <span class="comment">// 一个个来唤醒</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">notifyAllDemo</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">            LOCK.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">50</span>); <span class="comment">// 等待全部唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 main() 方法中调用 notify() 方法的执行结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure><p>在 main() 方法中调用 notifyAll() 方法的执行结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span><br></pre></td></tr></table></figure><p>很明显，notify() 是顺序唤醒线程的，而 notifyAll() 是倒序唤醒线程的。如果想要深究这部分原因，进入到 Object 类中看到 wait()、notify()、notifyAll() 这三个方法都是被 native 修饰的方法。再深入就是 jvm 的 C++ 实现了，包括还得看 synchronized 的实现等等。这部分内容暂时道行还不够，就先不做介绍了，暂时就先记住这么个现象吧。</p><p>如果业务上需要对线程的唤醒顺序有要求的话，可以分用多个锁来指定唤醒对应线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                LOCK.wait();</span><br><span class="line">                System.out.println(<span class="string">&quot;被唤醒。&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">            LOCK.notify();</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            str.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                str.append(i + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">9</span>)</span><br><span class="line">                    str.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            str.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看上面这段代码，输出结果是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line">被唤醒。</span><br></pre></td></tr></table></figure><p>显然对于 notify() 和 wait() 之间的执行顺序，调用 notify() 或者 notifyAll() 之后并不会马上释放本线程的 monitor 锁，而是等待被线程执行完毕之后再释放 monitor 锁给被 wait() 阻塞的线程去竞争。</p><h1 id="问诊案例"><a href="#问诊案例" class="headerlink" title="问诊案例"></a>问诊案例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeeDoctor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Doctor</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Doctor</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(LOCK) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello doctor.&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (needDoCheck()) &#123;</span><br><span class="line">                LOCK.notifyAll();</span><br><span class="line">                LOCK.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;You&#x27;re healthy&quot;</span>);</span><br><span class="line">            LOCK.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">needDoCheck</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (checkIsDone()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isChecking()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;is checking...&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;wait a minute&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是问诊案例的大概流程，有三个地方需要注意：</p><ol><li><p>判断是否需要等待应该使用 while 循环判断，因为很可能被唤醒的线程检查结果还没出来，还是需要继续等待。</p></li><li><p>尽量使用 notifyAll() 方法唤醒，因为不能确定被唤醒线程能否往下继续执行。如果被唤醒线程因条件不满足继续等待，那还有其他线程可以继续抢锁，而 notify() 在这种情况下会导致所有线程都陷入等待无法唤醒。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 synchronized 的使用中，如果继续往下执行代码的条件不被满足的话需要先释放当前持有的锁对象再等等，等到执行条件被满足后再接着往下执行。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;就像平时去医院排队看病一样，轮到我们了在医生问诊的过程中，可能会先让你先去做某一项检</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>synchronized 关键字是怎样保证线程安全的</title>
    <link href="https://www.wrp.cool/posts/11150/"/>
    <id>https://www.wrp.cool/posts/11150/</id>
    <published>2022-11-01T13:00:34.000Z</published>
    <updated>2022-11-01T15:14:52.512Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一句话说明 synchronized 关键字的作用：</strong></p><blockquote><p>保证在 <strong>「同一时刻」</strong> 最多只有 <strong>「一个」</strong> 线程执行该段代码，以达到保证 <strong>「并发安全」</strong> 的效果</p></blockquote><p>上一篇文章讲述的线程不安全的例子，现在就给出解决办法：synchronized。</p><h1 id="synchronized-关键字的使用方式"><a href="#synchronized-关键字的使用方式" class="headerlink" title="synchronized 关键字的使用方式"></a>synchronized 关键字的使用方式</h1><p>为了阅读方便，把前一篇文章中的示例代码再放到这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共享变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 对共享变量的修改</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100_000</span>; i++) &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123; &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;num = &quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以理解为是一个锁的作用，用来保护需要同步执行的代码，只有拿到锁的线程才能执行被保护的代码。如果使用 synchronized 来保护 <code>num++</code> 这行代码 ，那就可以保证 num 变量的线程安全。因为这样同一个时刻就只有一个线程能执行 <code>num++</code> 了。被保护代码也称为临界区代码。</p><p>synchronized 既然是一把锁，那肯定就需要一个对象来充当这个锁对象，这个对象可以是类对象或者是实例对象。由此就有了两个锁的概念：类锁、对象锁。</p><p>再根据使用方式的不同，类锁可以分为：</p><ul><li>静态方法加锁</li><li>代码块直接指定类锁</li></ul><p>对象锁可以分为：</p><ul><li>普通方法加锁</li><li>代码块直接指定对象锁</li></ul><p>由于 Java 中的类是全局唯一的对象，而对象则可以存在多个。于是，类锁是全局唯一的，被类锁保护的代码在同一时刻肯定只有唯一一个线程能执行该代码；对象锁在全局可以同时存在多个，被对象锁保护的代码在同一时刻可能会被多个线程同时执行，但这些线程肯定持有不同的对象锁。</p><h2 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a>类锁</h2><p>由于类锁在全局的唯一性，所以使用类锁保护的代码可以保证在整个 JVM 实例中同一时刻只有一个线程能执行该方法。</p><h3 id="静态方法加锁"><a href="#静态方法加锁" class="headerlink" title="静态方法加锁"></a>静态方法加锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 synchronized 关键字添加在静态方法签名上，以 Task.class 类对象为锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码块指定类锁"><a href="#代码块指定类锁" class="headerlink" title="代码块指定类锁"></a>代码块指定类锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Task.class) &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h2><p>被 new 出来或者反射加载的对象，在内存中可以存在多份。所以被对象锁保护的代码同一时刻可能会被多个线程执行，但是这些线程持有的实例对象肯定不同。</p><h3 id="普通方法加锁"><a href="#普通方法加锁" class="headerlink" title="普通方法加锁"></a>普通方法加锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 synchronized 关键字添加在方法签名上，以 this 对象为锁</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码块指定对象锁"><a href="#代码块指定对象锁" class="headerlink" title="代码块指定对象锁"></a>代码块指定对象锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类锁和对象锁的使用场景"><a href="#类锁和对象锁的使用场景" class="headerlink" title="类锁和对象锁的使用场景"></a>类锁和对象锁的使用场景</h2><p>类锁的经典使用场景有单例模式的双重检查锁（DCL）实现，由于类锁限制的范围太广泛了，在整个 JVM 实例同一时刻只有一个线程能执行被保护代码，也就是完全放弃了并行带来的性能提升，在使用类锁的时候这一点是需要认真考量的。DCL 的外层判断也是为了降低锁的粒度，基于性能的考量而加的。</p><p>对象锁的使用场景就比较多了，早期的并发容器当中使用的都是对象锁来保护并发安全，例如 Vector 和 Hashtable。早期并发容器中对象锁的使用也可以做为一个参考，一个对象内部的资源需要被保护时，可以以这个对象为锁来使用 synchronized 关键字。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;一句话说明 synchronized 关键字的作用：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;保证在 &lt;strong&gt;「同一时刻」&lt;/strong&gt; 最多只有 &lt;strong&gt;「一个」&lt;/strong&gt; 线程执行该段代码，以达到保证 &lt;st</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java运行时数据区域</title>
    <link href="https://www.wrp.cool/posts/26815/"/>
    <id>https://www.wrp.cool/posts/26815/</id>
    <published>2022-11-01T10:51:45.000Z</published>
    <updated>2022-11-05T14:36:25.189Z</updated>
    
    <content type="html"><![CDATA[<p>Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。分别有：</p><ul><li><strong>程序计数器</strong>（Program Counter Register）</li><li><strong>虚拟机栈</strong>（VM Stack）</li><li><strong>本地方法栈</strong>（Native Method Stack）</li><li><strong>方法区</strong>（Method Area）</li><li><strong>堆</strong>（Heap）</li></ul><p>其中，程序计数器、虚拟机栈、本地方法栈这三个区域是线程隔离的区域，每个线程都有自己的程序计数器、虚拟机栈、本地方法栈，所以这三个区域内的变量是线程安全的。我们称这类内存区域为“线程私有”的内存，他们的生命周期与线程相同。</p><p>方法区和堆则是所有线程共享的区域，存放在这里面的数据需要注意线程安全问题。</p><h1 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h1><p>程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的<br>字节码的行号指示器。它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。</p><p>此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何 OutOfMemoryError 情况的区域。</p><h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1><p>虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><p><strong>局部变量表：</strong>局部变量表（Local Variables Table）是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。如果执行的是实例方法（没有被static修饰的方法），那局部变量表中第0位索引的变量槽默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问到这个隐含的参数</p><p><strong>操作数栈：</strong>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和读取内容，也就是出栈和入栈操作。譬如在做算术运算的时候是通过将运算涉及的操作数栈压入栈顶后调用运算指令来进行的，又譬如在调用其他方法的时候是通过操作数栈来进行方法参数的传递。举个例子，例如整数加法的字节码指令iadd，这条指令在运行的时候要求操作数栈中最接近栈顶的两个元素已经存入了两个int型的数值，当执行这个指令时，会把这两个int值出栈并相加，然后将相加的结果重新入栈。</p><p><strong>动态连接：</strong>Java 多态的基石，在运行时动态指定调用方法。</p><p><strong>方法出口：</strong>当一个方法开始执行后，只有两种方式退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者；第二种退出方式是在方法执行的过程中遇到了异常，并且这个异常没有在方法体内得到妥善处理，一个方法使用异常完成出口的方式退出，是不会给它的上层调用者提供任何返回值的。</p><blockquote><p>注：《Java虚拟机规范》明确允许Java虚拟机实现自行选择是否支持栈的动态扩展，而HotSpot虚拟机的选择是不支持扩展，所以除非在创建线程申请内存时就因无法获得足够内存而出现OutOfMemoryError异常，否则在线程运行时是不会因为扩展而导致内存溢出的，只会因为栈容量无法容纳新的栈帧而导致StackOverflowError异常。</p></blockquote><h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。</p><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>此内存区域的唯一目的就是存放对象实例，Java世界里“几乎”所有的对象实例都在这里分配内存。</p><p>根据《Java虚拟机规范》的规定，Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。但对于大对象（典型的如数组对象），多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的内存空间。</p><p>Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。</p><h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。</p><p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p><h2 id="String-字符串常量池"><a href="#String-字符串常量池" class="headerlink" title="String 字符串常量池"></a>String 字符串常量池</h2><p>JDK7 以前 String 字符串常量池是存放在永久代空间中的，自 JDK7 移除永久代之后将 String 字符串常量池移动至堆内存。所以关于 String::intern() 方法在 JDK7 之后会有些不一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;计算机&quot;</span>).append(<span class="string">&quot;软件&quot;</span>).toString();</span><br><span class="line">    System.out.println(str1.intern() == str1);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;ja&quot;</span>).append(<span class="string">&quot;va&quot;</span>).toString();</span><br><span class="line">    System.out.println(str2.intern() == str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码在 JDK6 中运行，会得到两个false。原因是：在JDK 6中，intern()方法会把<strong>首次遇到</strong>的字符串实例复制到永久代的字符串常量池中存储，返回的也是永久代里面这个字符串实例的引用，而由StringBuilder创建的字符串对象实例在Java堆上，所以必然不可能是同一个引用，结果将返回false。</p><p>在 JDK7 中运行，会得到一个 true 一个 false，原因是：JDK7 的intern()方法实现不需要再拷贝字符串的实例到永久代了，<strong>因为字符串常量池已经移到Java堆中，那只需要在常量池里记录一下首次出现的实例引用即可</strong>，因此intern()返回的引用和由StringBuilder创建的那个字符串实例就是同一个。而对str2比较返回false，这是因为“java”这个字符串在执行String-Builder.toString()之前就已经出现过了，字符串常量池中已经有它的引用，<strong>不符合intern()方法要求“首次遇到”的原则</strong>，“计算机软件”这个字符串则是首次出现的，因此结果返回true。</p><h1 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h1><p>在JDK 1.4中新加入了NIO（New Input&#x2F;Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I&#x2F;O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著ᨀ高性能，因为避免了在Java堆和Native堆中来回复制数据。</p><p>显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。</p><hr><blockquote><p><strong>巨人的肩膀：</strong></p><ul><li>《深入理解Java虚拟机》</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。分别有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;程序计数器&lt;/strong&gt;（Program Counter Register）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;虚拟机栈&lt;/s</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis 对象结构和数据类型</title>
    <link href="https://www.wrp.cool/posts/35006/"/>
    <id>https://www.wrp.cool/posts/35006/</id>
    <published>2022-09-14T08:41:33.000Z</published>
    <updated>2022-10-17T12:01:18.869Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://xiaolincoding.com/redis/data_struct/command.html">小林Coding-Redis 常见数据类型和应用场景</a></p></blockquote><p>Redis 是一个键值对数据库，它的键值对中的 key 就是字符串对象，value 可以是字符串对象也可以是其他的集合数据类型对象，比如：List、Hash、Set、Zset 等。</p><p>Redis 中常见的数据类型有五种：String（字符串）、Hash（哈希）、List（列表）、Set（集合）、Zset（有序集合）。</p><p>随着 Redis 版本更新，后面又支持了四种：BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）。</p><h1 id="Redis-对象结构"><a href="#Redis-对象结构" class="headerlink" title="Redis 对象结构"></a>Redis 对象结构</h1><p>Redis 是使用了一个<strong>哈希表</strong>保存所有键值对，哈希表的最大好处就是让我们可以用 O(1) 的时间复杂度来快速查找到键值对。哈希表其实就是一个数组，数组中的元素叫做哈希桶。</p><p>哈希桶存放的是指向键值对数据的指针，这样通过指针就能找到键值对数据。因为键值对的 value 可以是字符串对象或者集合对象，所以键值对中并不直接保存值本身，而是保存了 <code>void * key</code> 和 <code>void * value</code> 指针，分别指向了实际的键对象和值对象，这样一来，即使值是集合数据，也可以通过 value 指针找到。</p><p><strong>Redis对象结构示意图：</strong></p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/Redis%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="Redis对象结构示意图"></p><p>以上三个属性是 Redis 对象中重要的三个属性，Redis 对象还有其他的一些属性，这里就先不展开。</p><ul><li><strong>type</strong>：标识该对象是什么类型的对象（String、List、Hash、Set、Zset）</li><li><strong>encoding</strong>：标识该对象使用了哪种底层的数据结构</li><li><strong>ptr</strong>：指向底层数据结构的指针</li></ul><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>String 是最基本的 key-value 结构，key 是唯一标识，value 是具体的值，value其实不仅是字符串， 也可以是数字（整数或浮点数），value 最多可以容纳的数据长度是 <strong>512M</strong>。底层数据结构是 int 和 SDS（简单动态字符串）。</p><p>SDS 是 Redis 内部实现的字符串对象，并没有采用 C语言 的字符串表示。由 Redis 内部实现的 SDS 优势如下：</p><ol><li>SDS 可以保存二进制数据，因为 SDS 采用 len 属性的值来表示字符串是否结束。</li><li>SDS 获取字符串长度的时间复杂度是 O(1)，因为 SDS 采用 len 属性记录字符串长度</li><li>SDS 拼接字符串不会造成缓冲区溢出，是安全的，因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，空间不够会自动扩容，所以不会导致缓冲区溢出的问题。</li></ol><p>字符串对象的内部编码（encoding）有 3 种 ：<strong>int、embstr 和 raw</strong>。</p><ul><li><p><strong>int</strong>：如果保存的是可以用 long 类型表示的整数值，那么直接将值保存在 ptr 属性里面即可，编码设置为 int。</p></li><li><p><strong>embstr 和 raw</strong>：保存的是字符串，底层的数据结构都是 SDS，如果是较短的字符串那么将编码设置为 embstr，如果是较长的字符串那么将编码设置为 raw。</p></li></ul><p>embstr 和 raw 的边界在不同的 Redis 版本中是不相同的。embstr 会通过一次内存分配函数来分配一块连续的内存空间来保存 redisObject 和 SDS，而 raw 编码会通过调用两次内存分配函数来分别分配两块空间来保存redisObject 和 SDS。Redis 这样做会有很多好处：</p><ul><li>embstr 编码在创建和释放对象时只需要调用一次内存函数。</li><li>embstr 所有的数据都保存在一块连续的内存，可以更好的利用 CPU 缓存提高性能。</li></ul><p>但 embstr 也是有缺点的，如果需要重新分配字符串内存时，整个 redisObject 和 SDS 都需要重新分配空间，<strong>所以 embstr 编码的字符串对象是只读的</strong>，我们对 embstr 编码的字符串对象执行的任何修改，程序都会先将对象的编码从 embstr 转换成 raw，然后再执行修改。</p><p><strong>String 类型的使用场景：</strong>缓存对象、常规计数、分布式锁、分布式服务之间共享 Session 信息</p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>List 列表是简单的字符串列表，按照插入顺序排序，可以从头部或尾部向 List 列表添加元素。列表的最大长度为 <code>2^32 - 1</code>，也即每个列表支持超过 40 亿个元素。在 Redis 3.2 版本之后，List 数据类型底层数据结构只由 quicklist 实现，替代了双向链表和压缩列表。</p><p><strong>List 类型的使用场景：</strong>消息队列</p><p>消息队列在存取消息时，必须要满足三个需求，分别是：<strong>消息保序、处理重复的消息和保证消息可靠性</strong>。</p><div class="note default flat"><p><strong>如何满足消息保序需求？</strong></p></div><p>List 本身就是按先进先出的顺序对数据进行存取的，所以，如果使用 List 作为消息队列保存消息的话，就已经能满足消息保序的需求了。</p><p>List 可以使用 LPUSH + RPOP （或者反过来，RPUSH + LPOP）命令实现消息队列。不过这种方式在消费者读取数据时，有一个潜在的性能风险点：</p><p>生产者往 List 中写入消息时并不会通知消费者去消费消息，消费者只能不断的尝试从 List 中去取消息，这会导致消费者的 CPU 一直消耗在 RPOP 命令上，带来不必要的性能损失。</p><p>为了解决这个问题，Redis提供了 BRPOP 命令。<strong>BRPOP命令也称为阻塞式读取</strong>，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据。和消费者程序自己不停地调用RPOP命令相比，这种方式能节省CPU开销。</p><div class="note default flat"><p><strong>如何处理重复的消息？</strong></p></div><p>需要为每一条消息生成一个 ID 号，消费者记录自己消费过的 ID，取出消息时先判断自己是否消费过此消息，如果消费过则不再处理。</p><div class="note default flat"><p><strong>如何保证消息可靠性？</strong></p></div><p>当消费者程序从 List 中读取一条消息后，List 就不会再留存这条消息了。所以，如果消费者程序在处理消息的过程出现了故障或宕机，就会导致消息没有处理完成，那么，消费者程序再次启动后，就没法再次从 List 中读取消息了。</p><p>为了留存消息，List 类型提供了 <code>BRPOPLPUSH</code> 命令，BRPOPLPUSH 命令从列表中取出最后一个元素，并插入到另外一个列表的头部；如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</p><blockquote><p>BRPOPLPUSH 命令：<code>BRPOPLPUSH L1 L2 10</code>，从 L1 取出一条消息返回并存入 L2 中，阻塞时间为 10s。</p></blockquote><p>使用 BRPOPLPUSH 命令后，如果消费者程序读了消息但没能正常处理，等它重启后，就可以从备份 List 中重新读取消息并进行处理了。</p><h1 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h1><p>Hash 是一个键值对（key - value）集合，特别适合用于存储对象。其中 value 的形式如：<code>value=[&#123;field1, value1&#125;,...&#123;fieldN, valueN&#125;]</code>。在 Redis7.0 以后底层的数据结构改为 listpack，不再使用压缩列表或哈希表。</p><p><strong>应用场景：</strong>缓存对象、购物车（以 用户ID 为 key，商品ID 为 field，商品数量为 value）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 缓存 UID:1 对象</span></span><br><span class="line">&gt; HSET UID:1 name admin age 18</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 UID:1 对象的姓名、年龄等属性值</span></span><br><span class="line">&gt; HGET UID:1 name</span><br><span class="line"><span class="string">&quot;admin&quot;</span></span><br><span class="line">&gt; HGET UID:1 age</span><br><span class="line"><span class="string">&quot;18&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建购物车</span></span><br><span class="line">&gt; HSET SHOPPINGCART:UID:01 1001 1 1002 2 1003 10</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取购物车信息</span></span><br><span class="line">&gt; HGETALL SHOPPINGCART:UID:01</span><br><span class="line">1) <span class="string">&quot;1001&quot;</span></span><br><span class="line">2) <span class="string">&quot;1&quot;</span></span><br><span class="line">3) <span class="string">&quot;1002&quot;</span></span><br><span class="line">4) <span class="string">&quot;2&quot;</span></span><br><span class="line">5) <span class="string">&quot;1003&quot;</span></span><br><span class="line">6) <span class="string">&quot;10&quot;</span></span><br></pre></td></tr></table></figure><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>Set 类型是一个无序并唯一的集合，它的存储顺序不会按照插入的先后顺序进行存储。</p><p>一个集合最多可以存储 <code>2^32-1</code> 个元素。概念和数学中个的集合基本类似，可以交集，并集，差集等等，所以 Set 类型除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集。</p><p>但是 Set 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，可能会导致 Redis 实例阻塞。</p><p>在主从集群中，为了避免主库因为 Set 做聚合计算（交集、差集、并集）时导致主库被阻塞，我们可以选择一个从库完成聚合统计，或者把数据返回给客户端，由客户端来完成聚合统计。</p><div class="note primary flat"><p><strong>Set 集合运算操作</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 交集运算</span></span><br><span class="line">SINTER key [key ...]</span><br><span class="line"><span class="comment"># 将交集结果存入新集合destination中</span></span><br><span class="line">SINTERSTORE destination key [key ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 并集运算</span></span><br><span class="line">SUNION key [key ...]</span><br><span class="line"><span class="comment"># 将并集结果存入新集合destination中</span></span><br><span class="line">SUNIONSTORE destination key [key ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 差集运算</span></span><br><span class="line">SDIFF key [key ...]</span><br><span class="line"><span class="comment"># 将差集结果存入新集合destination中</span></span><br><span class="line">SDIFFSTORE destination key [key ...]</span><br></pre></td></tr></table></figure><p><strong>应用场景：</strong>点赞、共同关注、抽奖活动。</p><div class="note default flat"><p><strong>点赞</strong></p></div><p>Set 集合可以保证一个用户只能点一个赞，这里举例子一个场景，key 是文章ID，value 是用户ID。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># uid:1 用户对文章 article:1 点赞</span></span><br><span class="line">&gt; SADD article:1 uid:1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># uid:2 用户对文章 article:1 点赞</span></span><br><span class="line">&gt; SADD article:1 uid:2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># uid:3 用户对文章 article:1 点赞</span></span><br><span class="line">&gt; SADD article:1 uid:3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># uid:1 取消了对 article:1 文章点赞</span></span><br><span class="line">&gt; SREM article:1 uid:1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 article:1 文章所有点赞用户</span></span><br><span class="line">&gt; SMEMBERS article:1</span><br><span class="line">1) <span class="string">&quot;uid:3&quot;</span></span><br><span class="line">2) <span class="string">&quot;uid:2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 article:1 文章的点赞用户数量</span></span><br><span class="line">&gt; SCARD article:1</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断用户 uid:1 是否对文章 article:1 点赞了</span></span><br><span class="line">&gt; SISMEMBER article:1 uid:1</span><br><span class="line">(<span class="built_in">integer</span>) 0  <span class="comment"># 返回0说明没点赞，返回1则说明点赞了</span></span><br></pre></td></tr></table></figure><div class="note default flat"><p><strong>共同关注</strong></p></div><p>Set 类型支持交集运算，所以可以用来计算共同关注的好友、公众号等。key 可以是用户id，value 则是已关注的公众号的id。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># uid:1 用户关注公众号 id 为 5、6、7、8、9</span></span><br><span class="line">&gt; SADD uid:1 5 6 7 8 9</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"><span class="comment"># uid:2  用户关注公众号 id 为 7、8、9、10、11</span></span><br><span class="line">&gt; SADD uid:2 7 8 9 10 11</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># uid:1 和 uid:2 共同关注的公众号</span></span><br><span class="line">&gt; SINTER uid:1 uid:2</span><br><span class="line">1) <span class="string">&quot;7&quot;</span></span><br><span class="line">2) <span class="string">&quot;8&quot;</span></span><br><span class="line">3) <span class="string">&quot;9&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给 uid:2 推荐 uid:1 关注的公众号</span></span><br><span class="line">&gt; SDIFF uid:1 uid:2</span><br><span class="line">1) <span class="string">&quot;5&quot;</span></span><br><span class="line">2) <span class="string">&quot;6&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给 uid:1 推荐 uid:2 关注的公众号</span></span><br><span class="line">&gt; SDIFF uid:2 uid:1</span><br><span class="line">1) <span class="string">&quot;10&quot;</span></span><br><span class="line">2) <span class="string">&quot;11&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证某个公众号是否被 uid:1 或 uid:2 关注</span></span><br><span class="line">&gt; SISMEMBER uid:1 5</span><br><span class="line">(<span class="built_in">integer</span>) 1 <span class="comment"># 返回1，说明关注了</span></span><br><span class="line">&gt; SISMEMBER uid:2 5</span><br><span class="line">(<span class="built_in">integer</span>) 0 <span class="comment"># 返回0，说明没关注</span></span><br></pre></td></tr></table></figure><div class="note default flat"><p><strong>抽奖活动</strong></p></div><p>存储某活动中中奖的用户名 ，Set 类型因为有去重功能，可以保证同一个用户不会中奖两次。</p><p>如果允许重复中奖，使用 SRANDMEMBER 命令。如果不允许重复中奖，使用 SPOP 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从集合key中随机选出count个元素，元素不从key中删除</span></span><br><span class="line">SRANDMEMBER key [count]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从集合key中随机选出count个元素，元素从key中删除</span></span><br><span class="line">SPOP key [count]</span><br></pre></td></tr></table></figure><h1 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h1><p>Zset 有序集合相比于 Set 集合多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序集合的元素值，一个是元素排序值。</p><p>有序集合保留了集合不能有重复成员的特性（分值可以重复），但不同的是，有序集合中的元素可以排序。</p><p>在 Redis 7.0 中，Zset 有序集合的底层数据结构就交由 listpack 数据结构来实现了，压缩列表数据结构就被废弃了。</p><div class="note primary flat"><p><strong>常用命令</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 往有序集合key中加入带分值元素</span></span><br><span class="line">ZADD key score member [[score member]...]   </span><br><span class="line"><span class="comment"># 往有序集合key中删除元素</span></span><br><span class="line">ZREM key member [member...]                 </span><br><span class="line"><span class="comment"># 返回有序集合key中元素member的分值</span></span><br><span class="line">ZSCORE key member</span><br><span class="line"><span class="comment"># 返回有序集合key中元素个数</span></span><br><span class="line">ZCARD key </span><br><span class="line"></span><br><span class="line"><span class="comment"># 为有序集合key中元素member的分值加上increment</span></span><br><span class="line">ZINCRBY key increment member</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正序获取有序集合key从start下标到stop下标的元素</span></span><br><span class="line">ZRANGE key start stop [WITHSCORES]</span><br><span class="line"><span class="comment"># 倒序获取有序集合key从start下标到stop下标的元素</span></span><br><span class="line">ZREVRANGE key start stop [WITHSCORES]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回有序集合中指定分数区间内的成员，分数由低到高排序。</span></span><br><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回指定成员区间内的成员，按字典正序排列, 分数必须相同。</span></span><br><span class="line">ZRANGEBYLEX key min max [LIMIT offset count]</span><br><span class="line"><span class="comment"># 返回指定成员区间内的成员，按字典倒序排列, 分数必须相同</span></span><br><span class="line">ZREVRANGEBYLEX key max min [LIMIT offset count]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 并集计算(相同元素分值相加)，numberkeys一共多少个key，结果保存至destkey集合</span></span><br><span class="line">ZUNIONSTORE destkey numberkeys key [key...] </span><br><span class="line"><span class="comment"># 交集计算(相同元素分值相加)，numberkeys一共多少个key，结果保存至destkey集合</span></span><br><span class="line">ZINTERSTORE destkey numberkeys key [key...]</span><br></pre></td></tr></table></figure><p><strong>应用场景：</strong>排行榜、电话或者姓名等排序</p><div class="note default flat"><p><strong>排行榜</strong></p></div><p>以文章点赞数排行榜为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># arcticle:1 文章获得了200个赞</span></span><br><span class="line">&gt; ZADD user:1:ranking 200 arcticle:1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># arcticle:2 文章获得了40个赞</span></span><br><span class="line">&gt; ZADD user:1:ranking 40 arcticle:2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># arcticle:3 文章获得了100个赞</span></span><br><span class="line">&gt; ZADD user:1:ranking 100 arcticle:3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># arcticle:4 文章获得了50个赞</span></span><br><span class="line">&gt; ZADD user:1:ranking 50 arcticle:4</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># arcticle:5 文章获得了150个赞</span></span><br><span class="line">&gt; ZADD user:1:ranking 150 arcticle:5</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><div class="note default flat"><p><strong>电话排序</strong></p></div><p>使用有序集合的 ZRANGEBYLEX 或 ZREVRANGEBYLEX 可以帮助我们实现电话号码或姓名的排序，我们以 ZRANGEBYLEX （返回指定成员区间内的成员，按 key 正序排列，分数必须相同）为例。</p><p>注意：不要在分数不一致的 SortSet 集合中去使用 ZRANGEBYLEX和 ZREVRANGEBYLEX 指令，因为获取的结果会不准确。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt; ZADD phone 0 13100111100 0 13110114300 0 13132110901 </span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">&gt; ZADD phone 0 13200111100 0 13210414300 0 13252110901 </span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">&gt; ZADD phone 0 13300111100 0 13310414300 0 13352110901 </span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有电话号码</span></span><br><span class="line">&gt; ZRANGEBYLEX phone - +</span><br><span class="line">1) <span class="string">&quot;13100111100&quot;</span></span><br><span class="line">2) <span class="string">&quot;13110114300&quot;</span></span><br><span class="line">3) <span class="string">&quot;13132110901&quot;</span></span><br><span class="line">4) <span class="string">&quot;13200111100&quot;</span></span><br><span class="line">5) <span class="string">&quot;13210414300&quot;</span></span><br><span class="line">6) <span class="string">&quot;13252110901&quot;</span></span><br><span class="line">7) <span class="string">&quot;13300111100&quot;</span></span><br><span class="line">8) <span class="string">&quot;13310414300&quot;</span></span><br><span class="line">9) <span class="string">&quot;13352110901&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 132 号段的号码</span></span><br><span class="line">&gt; ZRANGEBYLEX phone [132 (133</span><br><span class="line">1) <span class="string">&quot;13200111100&quot;</span></span><br><span class="line">2) <span class="string">&quot;13210414300&quot;</span></span><br><span class="line">3) <span class="string">&quot;13252110901&quot;</span></span><br></pre></td></tr></table></figure><h1 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h1><p>Bitmap，即位图，是一串连续的二进制数组（0和1），可以通过偏移量（offset）定位元素。BitMap 通过最小的单位bit来进行 <code>0|1</code> 的设置，表示某个元素的值或者状态，时间复杂度为 O(1)。使用它进行储存将非常节省空间，特别适合一些数据量大且使用二值统计的场景。</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/BitMap%E5%AD%98%E5%82%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="BitMap存储示意图"></p><p>Bitmap 本身是用 String 类型作为底层数据结构实现的一种统计二值状态的数据类型。</p><p>String 类型是会保存为二进制的字节数组，所以，Redis 就把字节数组的每个 bit 位利用起来，用来表示一个元素的二值状态，你可以把 Bitmap 看作是一个 bit 数组。</p><div class="note primary flat"><p><strong>常用命令</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置值，其中value只能是 0 和 1</span></span><br><span class="line">SETBIT key offset value</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取值</span></span><br><span class="line">GETBIT key offset</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取指定范围内值为 1 的个数</span></span><br><span class="line"><span class="comment"># start 和 end 以字节为单位</span></span><br><span class="line">BITCOUNT key start end</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># BitMap间的运算</span><br><span class="line"># operations 位移操作符，枚举值</span><br><span class="line">#   AND 与运算 &amp;</span><br><span class="line">#   OR 或运算 |</span><br><span class="line">#   XOR 异或 ^</span><br><span class="line">#   NOT 取反 ~</span><br><span class="line"># result 计算的结果，会存储在该key中</span><br><span class="line"># key1 … keyn 参与运算的key，可以有多个，空格分割，NOT 运算只能一个key</span><br><span class="line"># 当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 <span class="number">0</span>。</span><br><span class="line"># 返回值是保存到 destkey 的字符串的长度（以字节<span class="type">byte</span>为单位），和输入 key 中最长的字符串长度相等。</span><br><span class="line">BITOP [operations] [result] [key1] [keyn…]</span><br><span class="line"></span><br><span class="line"># 返回指定key中第一次出现指定value(<span class="number">0</span>/<span class="number">1</span>)的位置</span><br><span class="line">BITPOS [key] [value]</span><br></pre></td></tr></table></figure><p><strong>应用场景：</strong>签到统计、判断用户登录状态、连续签到用户统计</p><div class="note default flat"><p><strong>连续签到用户统计</strong></p></div><p>以统计七天连续签到打卡的用户为例：</p><p>把每天的日期作为 Bitmap 的 key，userId 作为 offset，若是打卡则将 offset 位置的 bit 设置成 1。key 对应的集合的每个 bit 位的数据则是一个用户在该日期的打卡记录。</p><p>一共有 7 个这样的 Bitmap，如果我们能对这 7 个 Bitmap 的对应的 bit 位做 『与』运算。同样的 UserID offset 都是一样的，当一个 userID 在 7 个 Bitmap 对应对应的 offset 位置的 bit &#x3D; 1 就说明该用户 7 天连续打卡。</p><p>结果保存到一个新 Bitmap 中，我们再通过 BITCOUNT 统计 bit &#x3D; 1 的个数便得到了连续打卡 7 天的用户总数了。</p><h1 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h1><p>HyperLogLog 是一个用来做基数估计的数据类型，什么是基数估计呢？</p><p>比如现有数据集：{1, 3, 5, 7, 5, 7, 8}，其中构成这个集合的基本元素是：{1, 3, 5, 7, 8}，总共有 5 个，那么基数就是 5。基数估计就是在可接受的误差范围内，快速计算基数。</p><p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 <code>2^64</code> 个不同元素的基数，和元素越多就越耗费内存的 Set 和 Hash 类型相比，HyperLogLog 就非常节省空间。</p><p>不过，有一点需要你注意一下，HyperLogLog 的统计规则是基于概率完成的，所以它给出的统计结果是有一定误差的，标准误算率是 0.81%。</p><div class="note primary flat"><p><strong>HyperLogLog 使用命令：</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加指定元素到 HyperLogLog 中</span></span><br><span class="line">PFADD key element [element ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回给定 HyperLogLog 的基数估算值。</span></span><br><span class="line">PFCOUNT key [key ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将多个 HyperLogLog 合并为一个 HyperLogLog</span></span><br><span class="line">PFMERGE destkey sourcekey [sourcekey ...]</span><br></pre></td></tr></table></figure><p><strong>应用场景：</strong>百万级网页 UV 计数</p><p>在统计 UV 时，你可以用 PFADD 命令（用于向 HyperLogLog 中添加新元素）把访问页面的每个用户都添加到 HyperLogLog 中。</p><p>接下来，就可以用 PFCOUNT 命令直接获得 page1 的 UV 值了，这个命令的作用就是返回 HyperLogLog 的统计结果。</p><h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><p>Stream 是 Redis 5.0 版本新增加的数据类型，是 Redis 专门为消息队列设计的数据类型。在 Redis 5.0 Stream 没出来之前，消息队列的实现方式都有着各自的缺陷，例如：</p><ul><li>发布订阅模式，不能持久化也就无法可靠的保存消息，并且对于离线重连的客户端不能读取历史消息的缺陷；</li><li>List 实现消息队列的方式不能重复消费，一个消息消费完就会被删除，而且生产者需要自行实现全局唯一 ID。</li></ul><p>基于以上问题，Redis 5.0 便推出了 Stream 用于完美地实现消息队列，它支持消息的持久化、支持自动生成全局唯一 ID、支持 ack 确认消息的模式、支持消费组模式等，让消息队列更加的稳定和可靠。</p><div class="note default flat"><p><strong>基本操作：生产和消费</strong></p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># * 表示让 Redis 为插入的数据自动生成一个全局唯一的 ID</span></span><br><span class="line"><span class="comment"># 往名称为 mymq 的消息队列中插入一条消息，消息的键是 name，值是 zhangsan</span></span><br><span class="line">&gt; XADD mymq * name zhangsan</span><br><span class="line"><span class="string">&quot;1663241868161-0&quot;</span></span><br></pre></td></tr></table></figure><p>插入成功后会返回全局唯一的 ID：”1663241868161-0”。消息的全局唯一 ID 由两部分组成：</p><ul><li>第一部分“1663241868161”是数据插入时，以毫秒为单位计算的当前服务器时间；</li><li>第二部分表示插入消息在当前毫秒内的消息序号，这是从 0 开始编号的。例如，“1663241868161-0”就表示在“1663241868161”毫秒内的第 1 条消息。</li></ul><p>消费者通过 XREAD 命令从消息队列中读取消息时，可以指定一个消息 ID，并从这个消息 ID 的下一条消息开始进行读取（注意是输入消息 ID 的下一条信息开始读取，不读取输入ID的消息）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里输入的毫秒时间戳是刚才生成的ID的前一毫秒</span></span><br><span class="line">&gt; XREAD STREAMS mymq 1663241868160-0</span><br><span class="line">1) 1) <span class="string">&quot;mymq&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1663241868161-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;zhangsan&quot;</span></span><br></pre></td></tr></table></figure><p>如果想要实现阻塞读（当没有数据时，阻塞住），可以调用 XRAED 时设定 BLOCK 配置项，实现类似于 BRPOP 的阻塞读取操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 10000 = 10s，命令最后的“$”符号表示读取最新的消息</span></span><br><span class="line">&gt; XREAD BLOCK 10000 STREAMS mymq $</span><br><span class="line">(nil)</span><br><span class="line">(10.00s)</span><br></pre></td></tr></table></figure><div class="note default flat"><p><strong>消费组</strong></p></div><p>Stream 可以以使用 XGROUP 创建消费组，创建消费组之后，Stream 可以使用 XREADGROUP 命令让消费组内的消费者读取消息。</p><p>创建两个消费组，这两个消费组消费的消息队列是 mymq，都指定从第一条消息开始读取：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个名为 group1 的消费组，0-0 表示从第一条消息开始读取。</span></span><br><span class="line">&gt; XGROUP CREATE mymq group1 0-0</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 创建一个名为 group2 的消费组，0-0 表示从第一条消息开始读取。</span></span><br><span class="line">&gt; XGROUP CREATE mymq group2 0-0</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>消费组 group1 内的消费者 consumer1 从 mymq 消息队列中读取所有消息的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令最后的参数“&gt;”，表示从第一条尚未被消费的消息开始读取。</span></span><br><span class="line">&gt; XREADGROUP GROUP group1 consumer1 STREAMS mymq &gt;</span><br><span class="line">1) 1) <span class="string">&quot;mymq&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1654254953808-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;xiaolin&quot;</span></span><br></pre></td></tr></table></figure><p>消息队列中的消息一旦被消费组里的一个消费者读取了，就不能再被该消费组内的其他消费者读取了，即同一个消费组里的消费者不能消费同一条消息。</p><p>不同消费组的消费者可以消费同一条消息（但是有前提条件，创建消息组的时候，不同消费组指定了相同位置开始读取消息）</p><p>使用消费组的目的是让组内的多个消费者共同分担读取消息，所以，我们通常会让每个消费者读取部分消息，从而实现消息读取负载在多个消费者间是均衡分布的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 让 group2 中的 consumer1 从 mymq 消息队列中消费一条消息</span></span><br><span class="line">&gt; XREADGROUP GROUP group2 consumer1 COUNT 1 STREAMS mymq &gt;</span><br><span class="line">1) 1) <span class="string">&quot;mymq&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1663243059501-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="comment"># 让 group2 中的 consumer2 从 mymq 消息队列中消费一条消息</span></span><br><span class="line">&gt; XREADGROUP GROUP group2 consumer2 COUNT 1 STREAMS mymq &gt;</span><br><span class="line">1) 1) <span class="string">&quot;mymq&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1663243061599-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="comment"># 让 group2 中的 consumer3 从 mymq 消息队列中消费一条消息</span></span><br><span class="line">&gt; XREADGROUP GROUP group2 consumer3 COUNT 1 STREAMS mymq &gt;</span><br><span class="line">1) 1) <span class="string">&quot;mymq&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;1663243062597-0&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;3&quot;</span></span><br></pre></td></tr></table></figure><div class="note default flat"><p><strong>消息确认</strong></p></div><p>Streams 会自动使用内部队列（也称为 PENDING List）留存消费组里每个消费者读取的消息，直到消费者使用 XACK 命令通知 Streams “消息已经处理完成”。</p><p>消费确认增加了消息的可靠性，一般在业务处理完成之后，需要执行 XACK 命令确认消息已经被消费完成，整个流程的执行如下图所示：</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/Stream%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="Stream消息确认流程图"></p><p>如果消费者没有成功处理消息，它就不会给 Streams 发送 XACK 命令，消息仍然会留存。此时，消费者可以在重启后，用 XPENDING 命令查看已读取、但尚未确认处理完成的消息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; XPENDING mymq group1</span><br><span class="line">1) (<span class="built_in">integer</span>) 3</span><br><span class="line">2) <span class="string">&quot;1663245004996-0&quot;</span> <span class="comment"># 表示 group1 中所有消费者读取的消息最小 ID</span></span><br><span class="line">3) <span class="string">&quot;1663245010578-0&quot;</span> <span class="comment"># 表示 group1 中所有消费者读取的消息最大 ID</span></span><br><span class="line">4) 1) 1) <span class="string">&quot;consumer1&quot;</span></span><br><span class="line">      2) <span class="string">&quot;1&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;consumer2&quot;</span></span><br><span class="line">      2) <span class="string">&quot;1&quot;</span></span><br><span class="line">   3) 1) <span class="string">&quot;consumer3&quot;</span></span><br><span class="line">      2) <span class="string">&quot;1&quot;</span></span><br></pre></td></tr></table></figure><p>如果想查看某个消费者具体读取了哪些数据，可以执行下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看 group1 里 consumer2 从 mymq 消息队列中读取未确认哪些消息</span></span><br><span class="line">&gt; XPENDING mymq group1 - + 10 consumer2</span><br><span class="line">1) 1) <span class="string">&quot;1663245009507-0&quot;</span></span><br><span class="line">   2) <span class="string">&quot;consumer2&quot;</span></span><br><span class="line">   3) (<span class="built_in">integer</span>) 276418</span><br><span class="line">   4) (<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><p>group1 里 consumer2 应答 1663245009507-0：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 应答</span></span><br><span class="line">&gt; XACK mymq GROUP1 1663245009507-0</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应答成功后没有未确认消息了</span></span><br><span class="line">&gt; XPENDING mymq GROUP1 - + 10 consumer2</span><br><span class="line">(empty array)</span><br></pre></td></tr></table></figure><div class="note default flat"><p><strong>对于 MQ 来说，为什么 Redis 显得不专业？</strong></p></div><ol><li><p>Redis 在以下 2 个场景下，可能会导致数据丢失：</p><ul><li>AOF 持久化配置为每秒写盘，但这个写盘过程是异步的，Redis 宕机时会存在数据丢失的可能</li><li>主从复制也是异步的，主从切换时，也存在丢失数据的可能 (opens new window)。</li></ul></li><li><p>Redis Stream 消息不可堆积</p><ul><li>Redis 的数据都存储在内存中，这就意味着一旦发生消息积压，则会导致 Redis 的内存持续增长，如果超过机器内存上限，就会面临被 OOM 的风险。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;a href=&quot;https://xiaolincoding.com/redis/data_struct/command.html&quot;&gt;小林Coding-Redis 常见数据类型和应用场景&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p</summary>
      
    
    
    
    <category term="Redis" scheme="https://www.wrp.cool/categories/Redis/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker 基础概念和基本用法</title>
    <link href="https://www.wrp.cool/posts/24100/"/>
    <id>https://www.wrp.cool/posts/24100/</id>
    <published>2022-09-13T08:15:21.000Z</published>
    <updated>2022-10-17T14:16:10.403Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要记录一些 Docker 中的基本概念，以及一些常用命令，主要是为了理清楚 <code>镜像</code>、<code>容器</code>、<code>网络</code>、<code>数据卷</code> 这几个概念、作用、操作。当然能够帮到大家就更好了。</p><h1 id="Docker-介绍"><a href="#Docker-介绍" class="headerlink" title="Docker 介绍"></a>Docker 介绍</h1><p><strong>Docker 的四大组成对象：</strong></p><ul><li>Docker 镜像：相当于软件的安装包</li><li>Docker 容器：相当于安装完正在运行的软件</li><li>Docker 网络：负责软件之间的相互通信</li><li>Docker 数据卷：将软件内外的数据相互映射，提供容器内外数据交互功能</li></ul><p>Docker 是以 服务端&#x2F;客户端 的形式对外提供服务的，服务端是 docker daemon，客户端是 docker CLI。所有的镜像模块、容器模块、网络模块、数据卷模块都是实现在 docker daemon 之中的。</p><p>docker daemon 暴露了一套 RESTFul API 接口以对外提供服务，我们可以在控制台通过编写 http 请求来控制 docker daemon，但是这样太繁琐了。所以，Docker 提供了 docker CLI 可以在控制台更方便的控制 docker daemon。</p><h1 id="搭建-Docker-运行环境"><a href="#搭建-Docker-运行环境" class="headerlink" title="搭建 Docker 运行环境"></a>搭建 Docker 运行环境</h1><p>Docker 主要是运行在 Linux 系统中的，也有提供运行在 Windows、Mac 系统上的桌面软件，运行在 Windows、Mac 系统上的 Docker 也是搭了一层 Linux 的隔离。Windows 和 Mac 操作系统的 Docker 环境下载连接如下：</p><ul><li><a href="https://docs.docker.com/desktop/install/windows-install/">Windows 安装环境下载</a></li><li><a href="https://docs.docker.com/desktop/install/mac-install/">Mac 安装环境下载</a></li></ul><p><strong>CentOS 安装如下：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"></span><br><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line">sudo yum install docker-ce</span><br><span class="line"></span><br><span class="line">sudo systemctl enable docker  # 开机自启动</span><br><span class="line">sudo systemctl start docker   # 启动 Docker 服务</span><br></pre></td></tr></table></figure><p>安装完成，启动成功之后可以运行两条命令查看 Docker 的一些基本信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker version  # Docker 版本信息（包含客户端和服务端的版本信息）</span><br><span class="line">docker info     # Docker 详细信息（包含镜像、容器状态等）</span><br></pre></td></tr></table></figure><p><strong>配置国内镜像源：</strong></p><p>修改 <code>/etc/docker/daemon.json</code> 文件（如果不存在，直接创建即可）添加以下内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;https://registry.docker-cn.com&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>修改完成，重启 Docker 以生效：<code>systemctl restart docker</code></p><p>运行 <code>docker info</code> 看看是否已经生效，大概在倒数两三行的位置可以看到 Registry Mirrors 信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Registry Mirrors:</span><br><span class="line"> https://registry.docker-cn.com/</span><br></pre></td></tr></table></figure><h1 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h1><p>在 <a href="https://hub.docker.com/">dockerhub</a> 中搜索想要下载的镜像直接下载即可，有标注 <code>DOCKER OFFICIAL IMAGE</code> 字样的镜像为官方维护的镜像。也可以在控制台查看 dockerhub 的镜像信息：<code>docker search image-name</code></p><p>下载命令：<code>docker pull image-name</code></p><p><strong>镜像命名规则：</strong> <code>username</code>&#x2F;<code>repository</code>:<code>tag</code></p><ul><li><strong>username：</strong> 上传该镜像的用户，由官方维护的镜像无此信息</li><li><strong>repository：</strong> 镜像名称，通常是软件名</li><li><strong>tag：</strong> 镜像标签，通常是版本信息，也可以是环境需求、构建方式等信息</li></ul><p>当我们在下载镜像时如果没有明确给出 <code>tag</code> 时，Docker 会默认使用 <code>latest</code> 作为 <code>tag</code>，也就是默认下载最新版本的镜像。</p><p><strong>常用命令：</strong></p><table><thead><tr><th align="left">操作</th><th align="left">命令</th></tr></thead><tbody><tr><td align="left">查看本地镜像信息</td><td align="left"><code>docker images</code></td></tr><tr><td align="left">查看本地镜像的详细信息</td><td align="left"><code>docker inspect image-name</code></td></tr><tr><td align="left">删除镜像</td><td align="left"><code>docker rmi image-name</code></td></tr></tbody></table><p><strong>创建镜像：</strong></p><p>提交容器修改保存成镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker commit -m &quot;message&quot; container-name your-image-name</span><br></pre></td></tr></table></figure><p>创建镜像之后可以使用 <code>docker images</code> 命令查看镜像信息。创建时如果忘了指定镜像名称可以通过 <code>docker tag</code> 重新命名镜像。</p><p><strong>镜像导入导出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 将镜像保存导出</span><br><span class="line">docker save -o save-path/save-name1.tar your-image-name1 your-image-name2</span><br><span class="line"># 将导出的镜像导入</span><br><span class="line">docker load -i image-path/image-name.tar</span><br></pre></td></tr></table></figure><p><strong>容器导入导出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 导出容器（一次只能导出一个）</span><br><span class="line">docker export -o save-name.tar your-container-name</span><br><span class="line"># 导入容器（导入之后是镜像）</span><br><span class="line">docker import save-name.tar your-image-name</span><br></pre></td></tr></table></figure><h1 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h1><p>Docker 镜像运行起来就是 Docker 容器了，也就是一个个运行起来的软件。</p><p><strong>Docker 容器的生命周期：</strong></p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/docker%E5%AE%B9%E5%99%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="docker容器生命周期"></p><p>Docker 容器的生命周期分为五种状态，分别为：</p><ul><li><strong>Created：</strong>容器已经被创建，容器所需的相关资源已经准备就绪，但容器中的程序还未处于运行状态。</li><li><strong>Running：</strong>容器正在运行，也就是容器中的应用正在运行。</li><li><strong>Paused：</strong>容器已暂停，表示容器中的所有程序都处于暂停 ( 不是停止 ) 状态。</li><li><strong>Stopped：</strong>容器处于停止状态，占用的资源和沙盒环境都依然存在，只是容器中的应用程序均已停止。</li><li><strong>Deleted：</strong>容器已删除，相关占用的资源及存储在 Docker 中的管理信息也都已释放和移除。</li></ul><p><strong>常用命令：</strong></p><table><thead><tr><th align="left">操作</th><th align="left">命令</th><th align="left">常用参数</th></tr></thead><tbody><tr><td align="left">创建容器</td><td align="left"><code>docker create image-name</code></td><td align="left"><code>--name</code>（指定容器名称）</td></tr><tr><td align="left">启动容器</td><td align="left"><code>docker start container-name</code></td><td align="left"></td></tr><tr><td align="left">创建并启动容器</td><td align="left"><code>docker run image-name</code></td><td align="left"><code>--name</code>、<code>-d</code>（后台运行）<br> <code>--rm</code>（停止后删除）、<code>-e</code>（设置环境）</td></tr><tr><td align="left">停止容器</td><td align="left"><code>docker stop container-name</code></td><td align="left"></td></tr><tr><td align="left">删除容器</td><td align="left"><code>docker rm container-name</code></td><td align="left"><code>-v</code>（删除相关联的数据卷）</td></tr><tr><td align="left">查看容器状态</td><td align="left"><code>docker ps</code></td><td align="left"><code>-a</code>（查看全部容器）</td></tr><tr><td align="left">进入容器</td><td align="left"><code>docker exec container-name</code></td><td align="left"><code>-it</code>（当前控制台输入输出）<br> <code>bash</code>&#x2F;<code>sh</code>（以哪种方式启动）</td></tr></tbody></table><p><strong>写时复制：</strong></p><p>在通过镜像运行容器时，并不是马上就把镜像里的所有内容拷贝到容器所运行的沙盒文件系统中，而是利用 UnionFS 将镜像以只读的方式挂载到沙盒文件系统中。只有在容器中发生对文件的修改时，修改才会体现到沙盒环境上。</p><p>容器是基于镜像启动的，在启动容器的时候并不是直接创建一个容器，而是利用镜像直接启动，当发生修改时再利用写时复制机制去修改。这样可以大幅提高容器启动速度，做到秒启动。</p><h1 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h1><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/docker%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.png" alt="docker容器网络模型"></p><p>在 Docker 网络中，有三个比较核心的概念，也就是：<code>沙盒（Sandbox）</code>、<code>网络（Network）</code>、<code>端点（Endpoint）</code>。这三者形成了 Docker 网络的核心模型，也就是容器网络模型 ( Container Network Model )。</p><ul><li><strong>沙盒：</strong>每个容器完全独立的网络环境，隔离了容器网络与宿主机网络。</li><li><strong>网络：</strong>Docker 内部的虚拟子网，网络内的参与者相互可见并能够进行通讯。</li><li><strong>端点：</strong>可控封闭网络环境的出入口，当端口相互配对后，就能进行数据传输了。</li></ul><p>目前 Docker 官方为我们提供了五种 Docker 网络驱动，分别是：<strong>Bridge Driver（默认，网桥模式）</strong>、Host Driver、Overlay Driver、MacLan Driver、None Driver。docker daemon 中默认维护了一个 bridge 的网络，所有的容器默认都是加入到此网络中。</p><h2 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h2><p>要让一个容器连接到另外一个容器，可以在容器通过 <code>docker create</code> 或 <code>docker run</code> 创建时通过 <code>--link</code> 选项进行配置，同时也可以为连接指定一个别名，这样在代码中可以直接使用别名进行连接。如下就是创建 mysql 容器和 webapp 容器，让 webapp 容器连接至 mysql 容器中，并且在 webapp 容器中为 mysql 容器取别名为 database。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name mysql -e MYSQL_ROOT_PASSWORD=root mysql</span><br><span class="line">docker run -d --name webapp --link mysql:database webapp</span><br></pre></td></tr></table></figure><p>这样在 webapp 中如果需要连接 mysql 可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://database:3306/database-name&quot;</span>;</span><br></pre></td></tr></table></figure><p>如果不是连接默认端口，那么需要在启动时通过 <code>--expose</code> 参数告诉容器暴露对应端口，使用如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name mysql --expose=3307 -e MYSQL_ROOT_PASSWORD=root mysql</span><br></pre></td></tr></table></figure><p>可通过 <code>docker ps</code> 命令查看容器对外暴露了哪些端口。</p><h2 id="创建网络"><a href="#创建网络" class="headerlink" title="创建网络"></a>创建网络</h2><p>我们也可以自定义网络，形成虚拟子网的目的，<strong>只有在同一网络之中的容器才可以互联</strong>。</p><ul><li>创建网络：<code>docker network create -d bridge network-name</code>，<code>-d</code> 指定网络类型</li><li>查看网络：<code>docker network ls</code></li><li>删除网络：<code>docker network rm network-name</code></li></ul><p>创建容器时指定网络：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name your-container-name --network=network-name container-name</span><br></pre></td></tr></table></figure><h2 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h2><p>将容器中的端口映射至宿主机的端口。如下：</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/docker%E7%BD%91%E7%BB%9C%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E6%A8%A1%E5%9E%8B.png" alt="docker网络端口映射模型"></p><p>要映射端口，我们可以在创建容器时使用 <code>-p</code> 或者是 <code>--publish</code> 参数。</p><p>使用方式：<code>-p &lt;host-port&gt;:&lt;container-port&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nginx -p 80:80 nginx</span><br></pre></td></tr></table></figure><p>可通过 <code>docker ps</code> 查看端口映射情况</p><h1 id="Docker-数据卷"><a href="#Docker-数据卷" class="headerlink" title="Docker 数据卷"></a>Docker 数据卷</h1><p>数据管理使用挂载的方式，通过数据卷可以方便管理挂载的目录</p><h2 id="容器数据管理"><a href="#容器数据管理" class="headerlink" title="容器数据管理"></a>容器数据管理</h2><p>容器内的文件系统是随着容器的生命周期而创建和移除的，容器内部的数据无法被持久化存储。由于容器隔离，操作容器内部文件也变得很麻烦。Docker 解决这一问题的方式是文件挂载，将宿主操作系统中的文件挂载到容器内部，便可以让容器内外都共享这个文件。通过这种方式可以互通容器内外的文件，那么文件数据持久化以及操作容器内部文件的问题也就得到了解决。</p><p>Docker 提供了三种文件挂载的方式：Bind Mount、Volume 和 Tmpfs Mount。</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/docker%E6%96%87%E4%BB%B6%E6%8C%82%E8%BD%BD.png" alt="docker文件挂载"></p><ul><li><p><strong>Bind Mount：</strong> 直接将宿主操作系统中的目录和文件挂载到容器内的文件系统中，形成挂载映射关系，在容器内外对文件的读写都相互可见。</p><blockquote><p>使用 <code>-v</code> 参数设置，示例：<code>-v &lt;host-path&gt;:&lt;container-path&gt;:ro</code>，ro（可选）表示容器内只读。为避免混淆，此处强制使用绝对路径。</p></blockquote></li><li><p><strong>Volume（数据卷）：</strong> 仅指定容器内的目录，宿主操作系统挂载的目录由 Docker 进行管理，不需要关心具体挂载到了宿主操作系统中的哪里。</p><blockquote><p>Bind Mount 模式为指定 <code>&lt;host-path&gt;</code> 则为 Volume。此种方式生成的数据在路径上会有 Docker 生成的 ID，所以能够自己命名：<code>-v name:&lt;container-path&gt;</code></p></blockquote></li><li><p><strong>Tmpfs Mount：</strong> 挂载系统内存中的一部分到容器的文件系统里，不过由于内存和容器的特征，它的存储并不是持久的，其中的内容会随着容器的停止而消失。</p><blockquote><p>使用 <code>--tmpfs</code> 参数挂载，<code>--tmpfs &lt;host-path&gt;</code></p></blockquote></li></ul><p>以上创建出来的数据挂载信息，或者是数据卷信息可以通过 <code>docker inspect</code> 命令查看。</p><h2 id="数据卷管理"><a href="#数据卷管理" class="headerlink" title="数据卷管理"></a>数据卷管理</h2><p>上面对数据卷的操作都是基于容器的，多少有点不方便，Docker 提供了独立操作数据卷的方式。</p><p><strong>数据卷使用命令：</strong></p><table><thead><tr><th align="left">操作</th><th align="left">命令</th></tr></thead><tbody><tr><td align="left">创建数据卷</td><td align="left"><code>docker volume create volume-name</code></td></tr><tr><td align="left">查看数据卷</td><td align="left"><code>docker volume ls</code></td></tr><tr><td align="left">删除数据卷</td><td align="left"><code>docker volume rm volume-name</code></td></tr><tr><td align="left">删除没有被引用且未命名的数据卷</td><td align="left"><code>docker volume prune -f</code></td></tr></tbody></table><p><strong>数据卷容器：</strong></p><p>创建数据卷容器的方式很简单，由于不需要容器本身运行，因而我们找个简单的系统镜像都可以完成创建。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker create --name appdata -v /webapp/storage ubuntu</span><br></pre></td></tr></table></figure><p>在使用数据卷容器时，我们不建议再定义数据卷的名称，因为我们可以通过对数据卷容器的引用来完成数据卷的引用。之前我们提到，Docker 的 Network 是容器间的网络桥梁，如果做类比，数据卷容器就可以算是容器间的文件系统桥梁。我们可以像加入网络一样引用数据卷容器，只需要在创建新容器时使用专门的 <code>--volumes-from</code> 选项即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nginx --volumes-from appdata nginx</span><br></pre></td></tr></table></figure><p>引用数据卷容器时，不需要再定义数据卷挂载到容器中的位置，Docker 会以数据卷容器中的挂载定义将数据卷挂载到引用的容器中。</p><p>使用数据卷容器看起来与使用原始数据卷的方式差不多，但是数据卷容器主要是在迁移数据卷时提供方便。如果迁移数据卷至其他目录，不用修改引用容器中的数据卷，数据卷容器相当于对数据卷的路径做了一层包装或者是取了个别名的意思。</p><hr><blockquote><p><strong>巨人的肩膀：</strong></p><ul><li>掘金小册-开发者必备的 Docker 实践指南</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文主要记录一些 Docker 中的基本概念，以及一些常用命令，主要是为了理清楚 &lt;code&gt;镜像&lt;/code&gt;、&lt;code&gt;容器&lt;/code&gt;、&lt;code&gt;网络&lt;/code&gt;、&lt;code&gt;数据卷&lt;/code&gt; 这几个概念、作用、操作。当然能够帮到大家就更好了。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="分布式" scheme="https://www.wrp.cool/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring Security</title>
    <link href="https://www.wrp.cool/posts/28582/"/>
    <id>https://www.wrp.cool/posts/28582/</id>
    <published>2022-09-06T03:38:08.000Z</published>
    <updated>2022-10-11T06:00:41.678Z</updated>
    
    <content type="html"><![CDATA[<p>关于 Spring Security 的文章网上有很多，B站也有很多教程，我都看过一些，但感觉对这部分的知识还不是很牢固。网上的大部分文章主要都是从后端的用户认证开始讲起的，一上来就是这些比较偏向实用部分的内容我觉得不是很好理解，还有很多巨长的类名方法名等等，这并不是在说网上的这些文章写的不好，毕竟本文也是一篇前人栽树，后人乘凉的文章。但是写这篇文章的初衷是想要从一个简单的小例子入手，解释清楚那些巨长的类名方法名都是干嘛的，应该怎么使用。</p><p>Spring Security 的一些介绍就不多说了，直接一个小 demo 走起，这个 demo 力争简洁，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入账号：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入密码：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> sc.next();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 开始认证    </span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">AuthenticationManager</span> <span class="variable">am</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SampleAuthenticationManager</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1、封装一个 UsernamePasswordAuthenticationToken 对象</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Authentication</span> <span class="variable">unAuth</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(username, password);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2、经过 AuthenticationManager 的认证，如果认证失败会抛出一个 AuthenticationException 错误</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Authentication</span> <span class="variable">auth</span> <span class="operator">=</span> am.authenticate(unAuth);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3、将这个认证过的 Authentication 填入 SecurityContext 里面</span></span><br><span class="line">            SecurityContextHolder.getContext().setAuthentication(auth);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;认证失败：&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 SecurityContext 中取出 Authentication</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Authentication</span> <span class="variable">auth</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        System.out.println(<span class="string">&quot;认证成功！&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;输入的账号：&quot;</span> + auth.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;输入的密码：&quot;</span> + auth.getCredentials());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现一个简单 AuthenticationManager 用于认证</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SampleAuthenticationManager</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键认证部分</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Authentication <span class="title function_">authenticate</span><span class="params">(Authentication auth)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> auth.getName();</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> (String) auth.getCredentials(); <span class="comment">// getCredentials 返回的是密码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (username == <span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(username))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadCredentialsException</span>(<span class="string">&quot;账号不能为空&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (password == <span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(password))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadCredentialsException</span>(<span class="string">&quot;密码不能为空&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 认证成功，创建认证成功对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(auth.getName(), auth.getCredentials());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring Security 主要的两个功能是认证和鉴权。这两个功能组合起来就能完成用户登录的需求，也就是一个系统中最基础最重要的模块。根据不同系统的需求，用户认证的工作可能会很繁琐。具体的认证步骤由程序员自行编写，Spring Security 的策略是把每个认证步骤串联起来成为一整个认证流程。上面的这个 demo 仅仅是一个简单的账号密码判空操作而已。主要是说明了怎么编写认证步骤。</p><h1 id="重要组件"><a href="#重要组件" class="headerlink" title="重要组件"></a>重要组件</h1><ul><li>Authentication：认证对象接口，定义了认证对象的数据形式。</li><li>AuthenticationManager：认证工作的上层接口，用于校验 <code>Authentication</code>，返回一个认证完成后的 <code>Authentication</code> 对象。</li><li>SecurityContext：上下文对象，<code>Authentication</code> 对象会放在里面。</li><li>SecurityContextHolder：用于拿到上下文对象的静态工具类。</li></ul><h2 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h2><p>Authentication 只是定义了一种在 Spring Security 进行认证过的数据的数据形式应该是怎么样的，要有权限，要有密码，要有身份信息，要有额外信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Authentication</span> <span class="keyword">extends</span> <span class="title class_">Principal</span>, Serializable &#123;</span><br><span class="line">    <span class="comment">// 获取用户权限列表</span></span><br><span class="line">    Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities();</span><br><span class="line">    <span class="comment">// 获取证明用户认证的信息，通常情况下获取到的是密码等信息。</span></span><br><span class="line">    Object <span class="title function_">getCredentials</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 获取用户的额外信息，（这部分信息可以是我们的用户表中的信息）。</span></span><br><span class="line">    Object <span class="title function_">getDetails</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 获取用户身份信息，在未认证的情况下获取到的是用户名，在已认证的情况下获取到的是 UserDetails。</span></span><br><span class="line">    Object <span class="title function_">getPrincipal</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 获取当前 Authentication 是否已认证。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAuthenticated</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 设置当前 Authentication 是否已认证（true or false）。</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setAuthenticated</span><span class="params">(<span class="type">boolean</span> var1)</span> <span class="keyword">throws</span> IllegalArgumentException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AuthenticationManager"><a href="#AuthenticationManager" class="headerlink" title="AuthenticationManager"></a>AuthenticationManager</h2><p><code>AuthenticationManager</code> 定义了一个认证方法，它将一个未认证的 <code>Authentication</code> 传入，返回一个已认证的 <code>Authentication</code>，默认使用的实现类为：<code>ProviderManager</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AuthenticationManager</span> &#123;</span><br><span class="line">    <span class="comment">// 认证方法</span></span><br><span class="line">    Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span> </span><br><span class="line">        <span class="keyword">throws</span> AuthenticationException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SecurityContext"><a href="#SecurityContext" class="headerlink" title="SecurityContext"></a>SecurityContext</h2><p>上下文对象，认证后的数据就放在这里面，这个接口里面只有两个方法，其主要作用就是 get or set <code>Authentication</code>。接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SecurityContext</span> <span class="keyword">extends</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    Authentication <span class="title function_">getAuthentication</span><span class="params">()</span>; <span class="comment">// 获取Authentication对象</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setAuthentication</span><span class="params">(Authentication authentication)</span>; <span class="comment">// 放入Authentication对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SecurityContextHolder"><a href="#SecurityContextHolder" class="headerlink" title="SecurityContextHolder"></a>SecurityContextHolder</h2><p>可以说是 <code>SecurityContext</code> 的工具类，用于 get or set or clear <code>SecurityContext</code>，默认会把数据都存储到当前线程中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityContextHolder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clearContext</span><span class="params">()</span> &#123;</span><br><span class="line">        strategy.clearContext(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SecurityContext <span class="title function_">getContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> strategy.getContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setContext</span><span class="params">(SecurityContext context)</span> &#123;</span><br><span class="line">        strategy.setContext(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>由这四个组件组成的认证流程就是：</p><ol><li>将登录请求的身份信息封装成未认证的 <code>Authentication</code></li><li>将未认证的 <code>Authentication</code> 交由 <code>AuthenticationManager</code> 实行认证</li><li><code>AuthenticationManager</code> 认证完成返回认证后的 <code>Authentication</code></li><li>将认证过的 <code>Authentication</code> 放入 <code>SecurityContext</code></li></ol><p>上面的这四个组件就是 Spring Security 当中最重要的几个组件，Spring Security 其他的内容也是围绕这几个组件展开的。</p><h1 id="ProviderManager"><a href="#ProviderManager" class="headerlink" title="ProviderManager"></a>ProviderManager</h1><p>ProviderManager 是 AuthenticationManager 的默认实现类，由它衍生出来了 AuthenticationProvider 接口。</p><p>原来的一个 AuthenticationManager 只做一次认证工作，但是 ProviderManager 把多个认证工作放在一个集合中，遍历取出每个认证对象一次次做认证工作，只要有一次通过了，就认为这次认证是成功的。在 ProviderManager 中把认证工作封装成了 AuthenticationProvider。</p><div class="note default flat"><p><strong>AuthenticationProvider：</strong></p></div><p>认证提供者，服务于 ProviderManager 类，由实现了这个接口的对象组成一个集合，在 ProviderManager 中遍历取出认证 Authentication。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AuthenticationProvider</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 认证</span></span><br><span class="line">    Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span></span><br><span class="line">            <span class="keyword">throws</span> AuthenticationException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否支持当前的 Authentication 对象</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class&lt;?&gt; authentication)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProviderManager 这个类的代码比较复杂，摘一些跟它认证流程有关的代码出来看看，以下代码在源码的基础上有做改动，主要是为了方便看一些</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 构造方法之一，传入一个个的 AuthenticationProvider 对象</span></span><br><span class="line"><span class="comment"> * 待会就拿这些对象来认证。</span></span><br><span class="line"><span class="comment"> * parent 对象传入 null，parent 相当于是一个兜底的 AuthenticationManager，</span></span><br><span class="line"><span class="comment"> * 如果所有的 AuthenticationProvider 认证都没通过，则使用 parent 做一次认证。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ProviderManager</span><span class="params">(AuthenticationProvider... providers)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(Arrays.asList(providers), (AuthenticationManager)<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Authentication</span>&gt; toTest = authentication.getClass();</span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">parentResult</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依次取出 provider 认证 authentication</span></span><br><span class="line">    <span class="keyword">for</span>(AuthenticationProvider provider : <span class="built_in">this</span>.getProviders()) &#123;</span><br><span class="line">        <span class="comment">// provider 不能支持 authentication，直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> (!provider.supports(toTest))  <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用 provider 进行认证</span></span><br><span class="line">            result = provider.authenticate(authentication);</span><br><span class="line">            <span class="comment">// 认证通过</span></span><br><span class="line">            <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.copyDetails(authentication, result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InternalAuthenticationServiceException | AccountStatusException | AuthenticationException e) &#123;</span><br><span class="line">            <span class="comment">// 某次异常处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// providers 认证失败，尝试使用 parent 认证</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.parent != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = parentResult = <span class="built_in">this</span>.parent.authenticate(authentication);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ProviderNotFoundException | AuthenticationException e) &#123;</span><br><span class="line">            <span class="comment">// 异常处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 认证成功，擦除密码信息</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.eraseCredentialsAfterAuthentication &amp;&amp; result <span class="keyword">instanceof</span> CredentialsContainer) &#123;</span><br><span class="line">            ((CredentialsContainer)result).eraseCredentials();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发布认证成功事件</span></span><br><span class="line">        <span class="keyword">if</span> (parentResult == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.eventPublisher.publishAuthenticationSuccess(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// 执行至此，说明 providers 和 parent 都没认证成功，包装异常信息抛出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码如果觉得比较复杂也可以不看，只需知道 ProviderManager 类的认证流程即可。</p><h1 id="DaoAuthenticationProvider"><a href="#DaoAuthenticationProvider" class="headerlink" title="DaoAuthenticationProvider"></a>DaoAuthenticationProvider</h1><p>DaoAuthenticationProvider 就是 AuthenticationProvider 的最常实现类，顾名思义，Dao 正是数据访问层的缩写，也暗示了这个身份认证器的实现思路。</p><p>按照我们最直观的思路，怎么去认证一个用户呢？</p><p>用户前台提交了用户名和密码，而数据库中保存了用户名和密码，认证便是负责比对同一个用户名，提交的密码和保存的密码是否相同便是了。</p><p>在 Spring Security 中。提交的用户名和密码，被封装成了 UsernamePasswordAuthenticationToken，而根据用户名加载用户的任务则是交给了 UserDetailsService。</p><h2 id="UserDetailsService"><a href="#UserDetailsService" class="headerlink" title="UserDetailsService"></a>UserDetailsService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line">    <span class="comment">// 查询用户，去哪里查询自己实现，一般是数据库。</span></span><br><span class="line">    UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要我们自己编写一个类实现 UserDetailsService 接口，在数据库中查询出登录的用户，将其包装成 UserDetails 对象返回。</p><p>这个接口的实现类写完需要在 Spring Security 配置中注册我们自己写的实现类，否则 Spring Security 是不知道你实现了这个接口的。</p><h2 id="UserDetails"><a href="#UserDetails" class="headerlink" title="UserDetails"></a>UserDetails</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDetails</span> <span class="keyword">extends</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// 当前认证用户的权限列表</span></span><br><span class="line">    Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities();</span><br><span class="line">    <span class="comment">// 当前认证用户密码</span></span><br><span class="line">    String <span class="title function_">getPassword</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 当前认证用户用户名</span></span><br><span class="line">    String <span class="title function_">getUsername</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 账户是否没过期</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 账户是否没被锁定（可以用来做黑名单）</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 账户凭据是否没过期</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 账户是否启用</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是一个接口，用来包装对应的数据库查出来的我们自己的 User 对象，包装完之后交给 Spring Security 去判断当前认证的用户账号情况。</p><h2 id="DaoAuthenticationProvider-比对密码"><a href="#DaoAuthenticationProvider-比对密码" class="headerlink" title="DaoAuthenticationProvider 比对密码"></a>DaoAuthenticationProvider 比对密码</h2><p>以下代码从源码中来，又跟源码不大一样，为了好看一些，有做删减。</p><p><strong>先从数据库加载用户：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> UserDetails <span class="title function_">retrieveUser</span><span class="params">(String username, UsernamePasswordAuthenticationToken authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">loadedUser</span> <span class="operator">=</span> <span class="built_in">this</span>.getUserDetailsService().loadUserByUsername(username);</span><br><span class="line">        <span class="keyword">if</span> (loadedUser == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 找不到直接报错，</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> loadedUser;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UsernameNotFoundException | InternalAuthenticationServiceException | Exception e) &#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>比对密码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">additionalAuthenticationChecks</span><span class="params">(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    <span class="keyword">if</span> (authentication.getCredentials() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 前台没传密码，直接报错</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">presentedPassword</span> <span class="operator">=</span> authentication.getCredentials().toString();</span><br><span class="line">        <span class="comment">// 比对密码，passwordEncoder 是需要注册的密码器。</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.passwordEncoder.matches(presentedPassword, userDetails.getPassword())) &#123;</span><br><span class="line">            <span class="comment">// 密码不匹配，直接报错</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PasswordEncoder：</strong>是一个接口，用来定义一些密码器的，Spring Security 提供了多种不同的密码策略，需要选择一种密码策略，在配置文件中注册。通常使用 BCryptPasswordEncoder。</p><div class="note default flat"><p><strong>小结：</strong></p></div><ol><li>顶层接口，一切的开始：AuthenticationManager，用于管理认证的每一个环节。</li><li>Authentication：认证对象，所有的一切都是为它服务的，放在 SecurityContext 中传来传去的。每一个认证环节的开始和结束都是它。</li><li>ProviderManager：AuthenticationManager 最重要的实现类，那也就是最重要的一个认证环节。</li><li>ProviderManager 把自己的认证工作委托给了多个 AuthenticationProvider，只要有一个认证成功了就认为是成功的。</li><li>AuthenticationManager 和 ProviderManager 的职责是不同的，主要就是它们的认证策略不同。</li><li>具体的登录密码比对工作交给了 DaoAuthenticationProvider，这也是 ProviderManager 最重要的一个 AuthenticationProvider。</li><li>通常需要实现 UserDetailsService 和 UserDetails，DaoAuthenticationProvider 根据这两个对象来校验密码。</li></ol><p>写这篇文章的目的主要是学习 Spring Security 的过程中有很多的不理解的地方，很多类名都特别长，长的又差不多，感觉很难理解。所以想要写一篇文章来帮助自己巩固这部分的知识，这篇文章的一些内容也是在网上其他文章中出现过的。</p><p>推荐一个 GitHub 上的一个 Spring Security 的仓库，写的真的不错：<a href="https://github.com/rookie-ricardo/spring-boot-learning-demo">向大佬学习</a></p><hr><p>本来鉴权部分应该是要单独的写一篇文章来总结的，但是看了看 Spring Security 的动态鉴权，看是看的明白个大概，就是道行太浅还用不上这么高级的东西。这里就先简单的介绍一下简单的鉴权方案吧。</p><p>有需要动态鉴权的同学也可以先看看这两篇文章，顺带一提，大佬写的文章真的不错。</p><ul><li><a href="https://zhuanlan.zhihu.com/p/365515214">Spring Security 鉴权流程</a></li><li><a href="https://juejin.cn/post/6847902222668431368">SpringSecurity动态鉴权流程解析</a></li></ul><p><strong>鉴权策略：</strong></p><ol><li>在 SecurityConfig 配置文件中手动开启 <code>@EnableGlobalMethodSecurity(prePostEnabled = true)</code></li><li>在 UserDetailService.loadUserByUsername 方法中查询出用户所具有的全部权限</li><li>将权限封装在 UserDetail.getAuthorities() 方法中供 Spring Security 获取</li><li>在每个需要授权的 API 上加上 <code>@PreAuthorize(&quot;hasAuthority(&#39;权限值&#39;)&quot;)</code> 注解</li><li>如果用户权限列表有该接口对应权限值就能访问对应接口</li></ol><hr><blockquote><p><strong>前人栽树：</strong></p><ul><li><a href="https://zhuanlan.zhihu.com/p/365513384">Spring Security 认证流程</a></li><li><a href="https://juejin.cn/post/6846687598442708999">SpringSecurity+JWT认证流程解析</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于 Spring Security 的文章网上有很多，B站也有很多教程，我都看过一些，但感觉对这部分的知识还不是很牢固。网上的大部分文章主要都是从后端的用户认证开始讲起的，一上来就是这些比较偏向实用部分的内容我觉得不是很好理解，还有很多巨长的类名方法名等等，这并不是在说网</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JWT 工具类封装</title>
    <link href="https://www.wrp.cool/posts/64951/"/>
    <id>https://www.wrp.cool/posts/64951/</id>
    <published>2022-09-05T11:04:10.000Z</published>
    <updated>2022-10-17T12:03:00.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1><p>JWT（Json Web Token）是一种用于用户认证的技术，前端携带 JWT 访问后端服务器，后端服务器可以解析 JWT 判断是否由本服务器签发，以及解析出一些简单的数据后可以拿到本次请求的用户。引入 JWT 主要为了解决传统 session 验证的弊端，session 认证的弊端：</p><ol><li>Session 保存在服务器中，用户数增加对服务器开销造成一定压力。</li><li>Session 保存在服务器物理内存中，对分布式不友好。</li><li>依赖 Cookie，对于非浏览器的客户端、手机移动端等不适用。</li><li>客户端 Cookie 泄漏会导致服务器不安全。</li><li>由于依赖 Cookie，所以无法跨域。</li></ol><p>JWT 的优势：</p><ol><li>简洁、数据量小、传输速度快</li><li>存储在客户端，原则上是跨语言的，支持任何 web 形式。</li><li>不依赖 Cookie 和 Session，对分布式友好。</li><li>容易跨域，对单点登录友好。</li><li>对手机移动端适用。</li></ol><p>JWT 认证流程图：</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/JWT%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B.png" alt="JWT认证流程"></p><h2 id="JWT-结构"><a href="#JWT-结构" class="headerlink" title="JWT 结构"></a>JWT 结构</h2><p>JWT 分成三个部分，每个部分都是一个字符串，中间由 <code>.</code> 隔开。</p><ul><li>Header：头部，标记加密的算法</li><li>Payload：负载，存放具体数据</li><li>Signature：签名，由 “Header + Payload + 服务器本地密钥” 经 MD5 加密后的值。</li></ul><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>Header 是一个描述 JWT 元数据的 JSON 对象，alg 属性表示签名使用的算法，默认为 HMAC SHA256（写为HS256）；typ 属性表示令牌的类型，JWT 令牌统一写为 JWT。最后，使用 Base64 URL 算法将上述 JSON 对象转换为字符串保存。一般是下面这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h3><p>有效载荷部分，是 JWT 的主体内容部分，也是一个 JSON 对象，包含需要传递的数据，可以存放自定义数据。JWT 指定七个默认字段供选择</p><ol><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ol><p>注意：此部分内容未加密，不能存放敏感信息。</p><h3 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h3><p>signature 是签证信息，该签证信息是通过 <code>header</code> 和 <code>payload</code>，加上 <code>secret</code>，通过算法加密生成。</p><h1 id="JWTUtil"><a href="#JWTUtil" class="headerlink" title="JWTUtil"></a>JWTUtil</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入 JWT 依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.auth0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>java-jwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.auth0.jwt.JWT;</span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.JWTCreator;</span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.algorithms.Algorithm;</span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.exceptions.JWTDecodeException;</span><br><span class="line"><span class="keyword">import</span> com.auth0.jwt.interfaces.DecodedJWT;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JWTUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可从 application.yml 中获取</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">SECRET</span> <span class="operator">=</span> <span class="string">&quot;maxiaorui&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成用户 Token</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map     存放在 token 的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expires 过期时间（单位：秒）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generateUserToken</span><span class="params">(Map&lt;String, String&gt; map, Integer expires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> JWTCreator.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> JWT.create();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// payload</span></span><br><span class="line">        map.forEach(builder::withClaim);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定过期时间</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">expiresAt</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        expiresAt.add(Calendar.SECOND, expires);</span><br><span class="line">        builder.withExpiresAt(expiresAt.getTime());</span><br><span class="line"></span><br><span class="line"><span class="comment">//        builder.withIssuer(&quot;issuer&quot;);                       // 签发人</span></span><br><span class="line"><span class="comment">//        builder.withSubject(&quot;subject&quot;);                     // 主题</span></span><br><span class="line"><span class="comment">//        builder.withAudience(&quot;audience1&quot;, &quot;audience2&quot;);     // 受众</span></span><br><span class="line"><span class="comment">//        builder.withNotBefore(new Date());                  // 生效时间</span></span><br><span class="line"><span class="comment">//        builder.withIssuedAt(new Date());                   // 签发时间</span></span><br><span class="line"><span class="comment">//        builder.withJWTId(&quot;jti&quot;);                           // 编号</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成原始 Token，此处可对 payload 数据做混淆</span></span><br><span class="line">        <span class="keyword">return</span> builder.sign(Algorithm.HMAC256(SECRET));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验用户 Token</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token 用户 Token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> DecodedJWT</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DecodedJWT <span class="title function_">verify</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (token == <span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(token))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">JWTDecodeException</span>(<span class="string">&quot;Token 无效&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果在生成 Token 的时候做了混淆此处应该解析混淆</span></span><br><span class="line">        <span class="keyword">return</span> JWT.require(Algorithm.HMAC256(SECRET)).build().verify(token);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 DecodedJWT 中解析 payload：<code>DecodedJWT.getClaims();</code></p><p>解析可能出现的异常：</p><ul><li>JWTDecodeException：header、payload 被修改会出现的异常</li><li>SignatureVerificationException：签名不匹配异常</li><li>TokenExpiredException：令牌过期异常</li><li>AlgorithmMismatchException：算法不匹配异常</li></ul><hr><p>说句题外话，有没有发现 JWT 的前面总是会加 <code>Bearer</code> 这个单词？？？</p><p>那么加了能干嘛呢，不加行不行呢？？</p><p>别问，问就是规范，至于什么规范？<a href="https://www.google.com/">谷歌</a>、<a href="https://www.bing.com/">必应</a>、<a href="https://www.baidu.com/">百度</a></p><blockquote><p><strong>前人栽树：</strong></p><ul><li><a href="https://cnodejs.org/topic/5b0c4a7b8a4f51e140d942fc">一篇文章告诉你JWT的实现原理</a></li><li><a href="https://www.cnblogs.com/johnvwan/p/15557287.html">JWT分布式场景应用解析 </a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">关于 JWT 的介绍包括简介、原理、使用场景等网上有很多文章写的都非常好，本文不会过多赘述，主要记录 JWT 工具类的封装。</summary>
    
    
    
    <category term="代码段记录" scheme="https://www.wrp.cool/categories/%E4%BB%A3%E7%A0%81%E6%AE%B5%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发：volatile</title>
    <link href="https://www.wrp.cool/posts/63338/"/>
    <id>https://www.wrp.cool/posts/63338/</id>
    <published>2022-08-25T07:26:42.000Z</published>
    <updated>2022-10-17T11:18:36.227Z</updated>
    
    <content type="html"><![CDATA[<h1 id="volatile-的特性"><a href="#volatile-的特性" class="headerlink" title="volatile 的特性"></a>volatile 的特性</h1><p>当我们声明共享变量为 volatile 后，对这个变量的读&#x2F;写将会很特别。理解 volatile特性的一个好方法是把对 volatile 变量的单个读&#x2F;写，看成是使用同一个锁对这些单个读&#x2F;写操作做了同步。下面我们通过具体的示例来说明，请看下面的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileFeaturesExample</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> <span class="variable">vl</span> <span class="operator">=</span> <span class="number">0L</span>; <span class="comment">//使用 volatile 声明 64 位的 long 型变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">long</span> l)</span> &#123;</span><br><span class="line">        vl = l; <span class="comment">//单个 volatile 变量的写</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getAndIncrement</span> <span class="params">()</span> &#123;</span><br><span class="line">        vl++; <span class="comment">//复合（多个）volatile 变量的读/写</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vl; <span class="comment">//单个 volatile 变量的读</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设有多个线程分别调用上面程序的三个方法，这个程序在语义上和下面程序等价：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileFeaturesExample</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">vl</span> <span class="operator">=</span> <span class="number">0L</span>; <span class="comment">// 64 位的 long 型普通变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">long</span> l)</span> &#123; <span class="comment">//对单个的普通变量的写用同一个锁同步</span></span><br><span class="line">        vl = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getAndIncrement</span> <span class="params">()</span> &#123; <span class="comment">//普通方法调用</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> get(); <span class="comment">//调用已同步的读方法</span></span><br><span class="line">        temp += <span class="number">1L</span>; <span class="comment">//普通写操作</span></span><br><span class="line">        set(temp); <span class="comment">//调用已同步的写方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">get</span><span class="params">()</span> &#123; <span class="comment">//对单个的普通变量的读用同一个锁同步</span></span><br><span class="line">        <span class="keyword">return</span> vl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面示例程序所示，对一个 volatile 变量的单个读&#x2F;写操作，与对一个普通变量的读&#x2F;写操作使用同一个锁来同步，它们之间的执行效果相同。</p><p>锁的 happens-before 规则保证释放锁和获取锁的两个线程之间的内存可见性，这意味着对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入。</p><p>锁的语义决定了临界区代码的执行具有原子性。这意味着即使是 64 位的 long 型和 double 型变量，只要它是 volatile 变量，对该变量的读写就将具有原子性。如果是多个 volatile 操作或类似于 volatile++ 这种复合操作，这些操作整体上不具有原子性。</p><p>简而言之，volatile 变量自身具有下列特性：</p><ul><li>可见性。对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入。</li><li>原子性：对任意单个 volatile 变量的读&#x2F;写具有原子性，但类似于 volatile++ 这种复合操作不具有原子性。</li></ul><h1 id="volatile-写-读建立的-happens-before-关系"><a href="#volatile-写-读建立的-happens-before-关系" class="headerlink" title="volatile 写-读建立的 happens before 关系"></a>volatile 写-读建立的 happens before 关系</h1><p>上面讲的是 volatile 变量自身的特性，对程序员来说，volatile 对线程的内存可见性的影响比 volatile 自身的特性更为重要，也更需要我们去关注。</p><p>从内存语义的角度来说，volatile 的写-读与锁的释放-获取有相同的内存效果：volatile 写和锁的释放有相同的内存语义；volatile 读与锁的获取有相同的内存语义。</p><p>请看下面使用 volatile 变量的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileExample</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">        a = <span class="number">1</span>;          <span class="comment">//1</span></span><br><span class="line">        flag = <span class="literal">true</span>;    <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;     <span class="comment">//3</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a;  <span class="comment">//4</span></span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设线程 A 执行 writer()方法之后，线程 B 执行 reader()方法。根据 happens before 规则，这个过程建立的 happens before 关系可以分为两类：</p><ol><li>根据程序次序规则，1 happens before 2; 3 happens before 4。</li><li>根据 volatile 规则，2 happens before 3。</li><li>根据 happens before 的传递性规则，1 happens before 4。</li></ol><p>上述 happens before 关系的图形化表现形式如下：</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/volatile-1.png" alt="volatile-1"></p><p>在上图中，每一个箭头链接的两个节点，代表了一个 happens before 关系。黑色箭头表示程序顺序规则；橙色箭头表示 volatile 规则；蓝色箭头表示组合这些规则后提供的 happens before 保证。</p><p>这里 A 线程写一个 volatile 变量后，B 线程读同一个 volatile 变量。A 线程在写volatile 变量之前所有可见的共享变量，在 B 线程读同一个 volatile 变量后，将立即变得对 B 线程可见。</p><h1 id="volatile-写的内存语义"><a href="#volatile-写的内存语义" class="headerlink" title="volatile 写的内存语义"></a>volatile 写的内存语义</h1><blockquote><p>当写一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量值刷新到主内存。</p></blockquote><p>以上面示例程序 VolatileExample 为例，假设线程 A 首先执行 writer()方法，随后线程 B 执行 reader()方法，初始时两个线程的本地内存中的 flag 和 a 都是初始状态。下图是线程 A 执行 volatile 写后，共享变量的状态示意图：</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/volatile-2.png" alt="volatile-2"></p><p>如上图所示，线程 A 在写 flag 变量后，本地内存 A 中被线程 A 更新过的两个共享变量的值被刷新到主内存中。此时，本地内存 A 和主内存中的共享变量的值是一致的。</p><h1 id="volatile-读的内存语义"><a href="#volatile-读的内存语义" class="headerlink" title="volatile 读的内存语义"></a>volatile 读的内存语义</h1><blockquote><p>当读一个 volatile 变量时，JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</p></blockquote><p>当读一个 volatile 变量时，JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</p><p>下面是线程 B 读同一个 volatile 变量后，共享变量的状态示意图：</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/volatile-3.png" alt="volatile-3"></p><p>如上图所示，在读 flag 变量后，本地内存 B 包含的值已经被置为无效。此时，线程 B 必须从主内存中读取共享变量。线程 B 的读取操作将导致本地内存 B 与主内存中的共享变量的值也变成一致的了。</p><p>如果我们把 volatile 写和 volatile 读这两个步骤综合起来看的话，在读线程 B 读一个 volatile 变量后，写线程 A 在写这个 volatile 变量之前所有可见的共享变量的值都将立即变得对读线程 B 可见。</p><div class="note default flat"><p><strong>volatile 读写内存语义总结：</strong></p></div><ul><li>线程 A 写一个 volatile 变量，实质上是线程 A 向接下来将要读这个 volatile 变量的某个线程发出了（其对共享变量所在修改的）消息。</li><li>线程 B 读一个 volatile 变量，实质上是线程 B 接收了之前某个线程发出的（在写这个 volatile 变量之前对共享变量所做修改的）消息。</li><li>线程 A 写一个 volatile 变量，随后线程 B 读这个 volatile 变量，这个过程实质上是线程 A 通过主内存向线程 B 发送消息。</li></ul><hr><blockquote><p><strong>巨人的肩膀：</strong></p><ul><li><a href="https://www.infoq.cn/minibook/java_memory_model">深入理解Java内存模型</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">volatile 读：直接从主内存读；volatile 写：立即刷新到主内存。</summary>
    
    
    
    <category term="Java" scheme="https://www.wrp.cool/categories/Java/"/>
    
    <category term="并发" scheme="https://www.wrp.cool/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发：重排序规则</title>
    <link href="https://www.wrp.cool/posts/41133/"/>
    <id>https://www.wrp.cool/posts/41133/</id>
    <published>2022-08-25T02:17:57.000Z</published>
    <updated>2022-10-17T11:18:04.817Z</updated>
    
    <content type="html"><![CDATA[<p>关于重排序的一些概念性问题在<a href="https://www.wrp.cool/posts/41498/#%E6%9C%89%E5%BA%8F%E6%80%A7%E6%98%AF%E6%80%8E%E4%B9%88%E4%BA%A7%E7%94%9F%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E7%9A%84">Java 内存模型（JMM）</a>中 <em>「有序性是怎么产生并发问题的」</em> 一节有详细介绍。</p><p>程序最终的执行顺序是由 CPU 处理的，做为 Java 程序员更应该关心的是重排序的结果，而不是重排序的过程。</p><p>具体的在什么情况下会发生重排序，又是按照一个什么样的规则去重排序，这些问题应该交给 CPU 去处理，我们应该关心的是我们写的程序被重排序后是怎么样的。</p><h1 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h1><p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分下列三种类型：</p><table><thead><tr><th align="left">名称</th><th align="left">代码示例</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">写后读</td><td align="left">a &#x3D; 1;b &#x3D; a;</td><td align="left">写一个变量之后，再读这个位置。</td></tr><tr><td align="left">写后写</td><td align="left">a &#x3D; 1;a &#x3D; 2;</td><td align="left">写一个变量之后，再写这个变量。</td></tr><tr><td align="left">读后写</td><td align="left">a &#x3D; b;b &#x3D; 1;</td><td align="left">读一个变量之后，再写这个变量。</td></tr></tbody></table><p>上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。</p><p>前面提到过，编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。</p><blockquote><p>注意：这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</p></blockquote><h1 id="as-if-serial-语义"><a href="#as-if-serial-语义" class="headerlink" title="as-if-serial 语义"></a>as-if-serial 语义</h1><p>as-if-serial 语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。</p><p>为了遵守 as-if-serial 语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。为了具体说明，请看下面计算圆面积的代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">pi</span>   <span class="operator">=</span> <span class="number">3.14</span>;         <span class="comment">//A</span></span><br><span class="line"><span class="type">double</span> <span class="variable">r</span>    <span class="operator">=</span> <span class="number">1.0</span>;          <span class="comment">//B</span></span><br><span class="line"><span class="type">double</span> <span class="variable">area</span> <span class="operator">=</span> pi * r * r;   <span class="comment">//C</span></span><br></pre></td></tr></table></figure><p>上面三个操作的数据依赖关系如下图所示：</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E9%87%8D%E6%8E%92%E5%BA%8F%E6%95%B0%E6%8D%AE%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB.png" alt="重排序数据依赖关系"></p><p>如上图所示，A 和 C 之间存在数据依赖关系，同时 B 和 C 之间也存在数据依赖关系。因此在最终执行的指令序列中，C 不能被重排序到 A 和 B 的前面（C 排到 A 和 B 的前面，程序的结果将会被改变）。但 A 和 B 之间没有数据依赖关系，编译器和处理器可以重排序 A 和 B 之间的执行顺序。下图是该程序的两种执行顺序：</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E9%87%8D%E6%8E%92%E5%BA%8F%E5%90%8E%E5%8F%AF%E8%83%BD%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB.png" alt="重排序后可能的依赖关系"></p><p>as-if-serial 语义把单线程程序保护了起来，遵守 as-if-serial 语义的编译器，runtime 和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。as-if-serial 语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。</p><h1 id="程序顺序规则"><a href="#程序顺序规则" class="headerlink" title="程序顺序规则"></a>程序顺序规则</h1><p>根据 happens- before 的程序顺序规则，上面计算圆的面积的示例代码存在三个 happens- before 关系：</p><ul><li>A happens- before B；</li><li>B happens- before C；</li><li>A happens- before C；</li></ul><p>这里的第 3 个 happens- before 关系，是根据 happens- before 的传递性推导出来的。</p><p>这里 A happens-before B，但实际执行时 B 却可以排在 A 之前执行（看上面的重排序后的执行顺序）。实际上如果 A happens-before B，JMM 并不要求 A 一定要在 B 之前执行。JMM 仅仅要求前一个操作（执行的结果）对后一个操作可见。这里操作 A 的执行结果不需要对操作 B 可见；而且重排序操作 A 和操作 B 后的执行结果，与操作 A 和操作 B 按 happens-before 顺序执行的结果一致。在这种情况下，JMM 会认为这种重排序并不非法（not illegal），JMM 允许这种重排序。</p><p>在计算机中，软件技术和硬件技术有一个共同的目标：在不改变程序执行结果的前提下，尽可能的开发并行度。编译器和处理器遵从这一目标，从 happens- before 的定义我们可以看出，JMM 同样遵从这一目标。</p><h1 id="重排序对多线程的影响"><a href="#重排序对多线程的影响" class="headerlink" title="重排序对多线程的影响"></a>重排序对多线程的影响</h1><p>现在让我们来看看，重排序是否会改变多线程程序的执行结果。请看下面的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReorderExample</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">        a = <span class="number">1</span>;                   <span class="comment">//1</span></span><br><span class="line">        flag = <span class="literal">true</span>;             <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;                <span class="comment">//3</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>  a * a;        <span class="comment">//4</span></span><br><span class="line">            ……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flag 变量是个标记，用来标识变量 a 是否已被写入。这里假设有两个线程 A 和 B，A 首先执行 writer() 方法，随后 B 线程接着执行 reader() 方法。线程 B 在执行操作 4 时，能否看到线程 A 在操作 1 对共享变量 a 的写入？</p><p>答案是：不一定能看到。</p><p>由于操作 1 和操作 2 没有数据依赖关系，编译器和处理器可以对这两个操作重排序；同样，操作 3 和操作 4 没有数据依赖关系，编译器和处理器也可以对这两个操作重排序。让我们先来看看，当操作 1 和操作 2 重排序时，可能会产生什么效果? 请看下面的程序执行时序图：</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/java-jmm-8.png" alt="java-jmm-8"></p><p>如上图所示，操作 1 和操作 2 做了重排序。程序执行时，线程 A 首先写标记变量 flag，随后线程 B 读这个变量。由于条件判断为真，线程 B 将读取变量 a。此时，变量 a 还根本没有被线程 A 写入，在这里多线程程序的语义被重排序破坏了！</p><p>下面再让我们看看，当操作 3 和操作 4 重排序时会产生什么效果（借助这个重排序，可以顺便说明控制依赖性）。下面是操作 3 和操作 4 重排序后，程序的执行时序图：</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/java-jmm-9.png" alt="java-jmm-9"></p><p>在程序中，操作 3 和操作 4 存在控制依赖关系。当代码中存在控制依赖性时，会影响指令序列执行的并行度。为此，编译器和处理器会采用猜测（Speculation）执行来克服控制相关性对并行度的影响。以处理器的猜测执行为例，执行线程 B 的处理器可以提前读取并计算 a*a，然后把计算结果临时保存到一个名为重排序缓冲（reorder buffer ROB）的硬件缓存中。当接下来操作 3 的条件判断为真时，就把该计算结果写入变量 i 中。</p><p>从图中我们可以看出，猜测执行实质上对操作 3 和 4 做了重排序。重排序在这里破坏了多线程程序的语义！</p><p>在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是 as-if-serial 语义允许对存在控制依赖的操作做重排序的原因）；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。</p><blockquote><p>虽然重排序的一些具体的发生过程并不是我们关心的重点，但作为程序员，求知好学也是应该的不是吗。下面的部分不感兴趣的同学跳过即可。</p></blockquote><h1 id="为什么会发生重排序"><a href="#为什么会发生重排序" class="headerlink" title="为什么会发生重排序"></a>为什么会发生重排序</h1><p>重排序分为真重排序和伪重排序，真重排序就像是在<a href="https://www.wrp.cool/posts/41498/">Java 内存模型（JMM）</a>中的 <em>「有序性是怎么产生并发问题的」</em> 所介绍的：<strong>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。</strong>伪重排序正是接下来所要介绍的：</p><blockquote><p>由于现代的处理器使用写缓冲区来临时保存向内存写入的数据，这对内存操作的执行顺序产生重要的影响。</p></blockquote><p><strong>写缓冲区的优点：</strong></p><ul><li>保证指令流水线持续运行，可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟</li><li>通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用</li></ul><p><strong>写缓冲区的缺点：</strong>每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读&#x2F;写操作的执行顺序，不一定与内存实际发生的读&#x2F;写操作顺序一致！请看下面示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Processor A</span></span><br><span class="line">a = <span class="number">1</span>; <span class="comment">//A1  </span></span><br><span class="line">x = b; <span class="comment">//A2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Processor B</span></span><br><span class="line">b = <span class="number">2</span>; <span class="comment">//B1  </span></span><br><span class="line">y = a; <span class="comment">//B2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始状态：a = b = 0；处理器允许执行后得到结果：x = y = 0</span></span><br></pre></td></tr></table></figure><p>假设处理器 A 和处理器 B 按程序的顺序并行执行内存访问，最终却可能得到 x &#x3D; y &#x3D; 0 的结果。具体的原因如下图所示：</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E4%BC%AA%E9%87%8D%E6%8E%92%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="伪重排序执行时序图"></p><p>以下面的这种时序执行时，程序就会得到 x &#x3D; y &#x3D; 0 的结果：</p><ol><li>处理器 A 和处理器 B 同时把共享变量写入自己的写缓冲区（A1，B1）</li><li>处理器 A 和处理器 B 同时从内存中读取另一个共享变量（A2，B2）</li><li>处理器 A 和处理器 B 刷自己写缓冲区中的脏数据到内存中（A3，B3）</li></ol><p>从内存操作实际发生的顺序来看，直到处理器 A 执行 A3 来刷新自己的写缓存区，写操作 A1 才算真正执行了。虽然处理器 A 执行内存操作的顺序为：A1-&gt;A2，但内存操作实际发生的顺序却是：A2-&gt;A1。此时，处理器 A 的内存操作顺序被重排序了（处理器 B 的情况和处理器 A 一样，这里就不赘述了）。</p><p>这里的关键是，由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。</p><p>为了保证内存可见性，java 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM 把内存屏障指令分为下列四类：</p><table><thead><tr><th align="left">屏障类型</th><th align="left">指令示例</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">LoadLoad Barriers</td><td align="left">Load1; LoadLoad; Load2</td><td align="left">确保 Load1 数据装载，之前于 Load2 及所有后续装载指令的装载。</td></tr><tr><td align="left">StoreStore Barriers</td><td align="left">Store1; StoreStore; Store2</td><td align="left">确保 Store1 数据对其他处理器可见（刷新到内存），之前于 Store2 及所有后续存储指令的存储。</td></tr><tr><td align="left">LoadStore Barriers</td><td align="left">Load1; LoadStore; Store2</td><td align="left">确保 Load1 数据装载，之前于 Store2 及所有后续的存储指令刷新到内存。</td></tr><tr><td align="left">StoreLoad Barriers</td><td align="left">Store1; StoreLoad; Load2</td><td align="left">确保 Store1 数据对其他处理器可见（刷新到内存），之前于 Load2 及所有后续装载指令的装载。</td></tr></tbody></table><p>StoreLoad Barriers 会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。</p><p>StoreLoad Barriers 是一个“全能型”的屏障，它同时具有其他三个屏障的效果。现代的多处理器大都支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中（buffer fully flush）。</p><hr><blockquote><p><strong>巨人的肩膀：</strong></p><ul><li><a href="https://www.infoq.cn/minibook/java_memory_model">深入理解Java内存模型</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">程序最终的执行顺序是由 CPU 处理的，做为 Java 程序员更应该关心的是重排序的结果，而不是重排序的过程。</summary>
    
    
    
    <category term="Java" scheme="https://www.wrp.cool/categories/Java/"/>
    
    <category term="并发" scheme="https://www.wrp.cool/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发：线程的执行结果和异常</title>
    <link href="https://www.wrp.cool/posts/62788/"/>
    <id>https://www.wrp.cool/posts/62788/</id>
    <published>2022-08-06T17:54:46.000Z</published>
    <updated>2022-10-17T11:17:42.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="利用-Future-获取线程执行结果和处理异常"><a href="#利用-Future-获取线程执行结果和处理异常" class="headerlink" title="利用 Future 获取线程执行结果和处理异常"></a>利用 Future 获取线程执行结果和处理异常</h1><p><strong>简介：</strong></p><p>如果当前任务需要另外的某一个任务执行完毕获取到返回值后才能继续执行，但是这个另外的任务又比较耗时，那么可以使用 Future 类将这个任务的返回结果包装起来，然后当前线程先去做点其他的事情，等到 Future 拿到结果之后再执行那部分的逻辑。这个被包装的对象就是 <code>Callable</code>。</p><p><strong>简而言之：</strong>如果有个很耗时的方法的需要执行，那么先开个线程让它执行，当前线程先做点其他的事情，不要一直在哪里傻等</p><p><strong>Callable 介绍：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Callable 是一个接口，跟 Runnable 一样用来包装要执行的任务，不同的是 Callable 接口可以拥有返回值和向外抛出异常。</p><div class="note modern primary no-icon flat"><p><strong>Future 的使用：</strong></p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">final</span> Future&lt;Integer&gt; future = service.submit(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get 方法的行为取决于 Callable 任务的状态，只有以下五种情况：</p><ol><li>任务正常完成：gei 方法会立即返回结果</li><li>任务尚未完成（可能是还没开始或执行中）：get将阻塞直到任务完成并返回结果</li><li>任务执行过程中抛出 Exception：get方法会抛出 ExecutionException<br>这里的异常是 call 方法产生的异常，不管 call 方法抛出了什么样的异常都会被 get 方法接收到，但是 get 方法只会抛出 ExecutionException 异常。</li><li>任务被取消：get 方法会抛出 CancellationException</li><li>任务超时：get 方法有一个重载方法，可以传入延迟时间，如果时间到了还没有获得结果，get方法就会抛出 TimeOutException。</li></ol><p><strong>Future 的其他方法介绍：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 尝试取消任务，如果任务已经完成、已取消或其他原因无法取消，则失败。 </span></span><br><span class="line"><span class="comment">     * 1、如果任务还没开始执行，则该任务不应该运行 </span></span><br><span class="line"><span class="comment">     * 2、如果任务已经开始执行，由参数mayInterruptIfRunning来决定执行该任务的线程是否应该被中断，这只是终止任务的一种尝试。</span></span><br><span class="line"><span class="comment">          若mayInterruptIfRunning为true，则会立即中断执行任务的线程并返回true</span></span><br><span class="line"><span class="comment">          若mayInterruptIfRunning为false，则会返回true且不会中断任务执行线程。</span></span><br><span class="line"><span class="comment">     * 3、调用这个方法后，以后对isDone方法调用都返回true。 </span></span><br><span class="line"><span class="comment">     * 4、如果这个方法返回true,以后对isCancelled返回true。 </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 判断任务是否被取消了，如果调用了cancel()则返回true </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 如果任务完成，则返回ture </span></span><br><span class="line"><span class="comment">     * 任务完成包含正常终止、异常、取消任务。在这些情况下都返回true </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note modern primary no-icon flat"><p><strong>FutureTask 的使用：</strong></p></div><p>上面的例子使用的是线程池的 submit 方法创建 Future 对象，现在介绍一种由普通线程创建的 Future 对象：FutureTask。</p><p>Thread 类是只能传入 Runnable 方法去执行的，而现在又需要一个 Future 对象，显而易见的我们需要一个类同时实现 Future 和 Runnable 对象。</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/FutureTask%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="FutureTask类关系图"></p><p>这个类的使用方式也很简单，需要 Runnable 对象的时候就把它当 Runnable 去用，需要 Future 的时候就把它当 Future 去用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>巨人的肩膀：</strong></p><p><a href="https://www.51cto.com/article/633900.html">并发编程之Future&amp;FutureTask深入解析</a></p>]]></content>
    
    
    <summary type="html">处理线程执行过程中抛出的异常以及返回的结果。</summary>
    
    
    
    <category term="Java" scheme="https://www.wrp.cool/categories/Java/"/>
    
    <category term="并发" scheme="https://www.wrp.cool/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发：AQS</title>
    <link href="https://www.wrp.cool/posts/38839/"/>
    <id>https://www.wrp.cool/posts/38839/</id>
    <published>2022-08-06T13:54:00.000Z</published>
    <updated>2022-10-17T11:18:08.709Z</updated>
    
    <content type="html"><![CDATA[<p>AQS 的全称是：AbstractQueuedSynchronizer（抽象队列同步器）j.u.c 包下所提供的一系列同步器，也是在 AQS 的帮助下实现的，比如 CountDownLatch、ReentrantLock、Semaphore、CyclicBarrier 等。</p><p>同步器都会有一个内部类继承自 AQS 并且重写 AQS 中的一些方法以定制化一些更具特征的功能，一般这个内部类被命名为 Sync。以 Sync 为工具对外提供一些操纵的接口，以此实现自定义同步器。</p><p>同步器都拥有让线程陷入阻塞以及唤醒阻塞线程继续执行的能力，之间的区别只是阻塞、唤醒线程的时机、方法、形式不同而已。也正是这些同步器提供了 Java 强大的并发能力。</p><p>所以其实这些同步器都必须具备共同的能力：<strong>阻塞、唤醒线程的能力。这项能力由 LockSupport 类提供。</strong></p><h1 id="LockSupport-的-park-和-unpark"><a href="#LockSupport-的-park-和-unpark" class="headerlink" title="LockSupport 的 park 和 unpark"></a>LockSupport 的 park 和 unpark</h1><p>LockSupport 类位于 <code>java.util.concurrent.locks</code> 包下，这个类中包含了 park 和 unpark 方法。park 方法可以阻塞当前线程一直到 unpark 方法被调用，unpark 方法也可以提前被调用。但是 unpark 方法是没有被计数的，也就是说提前调用多次 unpark 只会解除后续的一次 park 操作。另外 LockSupport 类是作用在线程上而不是同步器上的，一个线程在新的同步器上调用 park 操作可能会直接返回，因为在此之前可能还有剩余的 unpark 操作。</p><p><strong>使用示例，先 park 再 unpark</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;卧槽，我阻塞了。。。&quot;</span>);</span><br><span class="line">        LockSupport.park();</span><br><span class="line">        System.out.println(<span class="string">&quot;还好醒过来了。。吓死我了md&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">1</span>); <span class="comment">// 让 t1 跑一会</span></span><br><span class="line">    System.out.println(<span class="string">&quot;没事，我来将你唤醒。&quot;</span>);</span><br><span class="line">    LockSupport.unpark(t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用示例，先 unpark 再 park</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;这次我先将你唤醒！&quot;</span>);</span><br><span class="line">    LockSupport.unpark(Thread.currentThread());</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;先唤醒再阻塞。&quot;</span>);</span><br><span class="line">    LockSupport.park();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;醒过来了。。&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LockSupport 类中其他阻塞线程的方法：</strong></p><ul><li>void park(Object blocker)</li><li>void parkNanos(long nanos)</li><li>void parkNanos(Object blocker, long nanos)</li><li>void parkUntil(long deadline)</li><li>void parkUntil(Object blocker, long deadline)</li><li>blocker：记录导致线程阻塞的对象，方便故障排查</li><li>nanos：阻塞当前线程，最长不超过 nanos 纳秒，或者被 unpark 唤醒</li><li>deadline：阻塞当前线程直到 deadline 之前，或者被 unpark 唤醒</li></ul><h1 id="AQS-概述"><a href="#AQS-概述" class="headerlink" title="AQS 概述"></a>AQS 概述</h1><p>开头提到的同步器都必须实现以下两个功能：</p><ul><li>同步资源的管理（例如：CountDownLatch 的倒数、锁的获取和释放），以及同步资源的更新和检查操作。</li><li>至少有一个方法导致调用线程在同步状态已经被获取时阻塞，以及在其他线程改变这个同步状态时解除阻塞等。</li></ul><p>实现这两个功能需要两个操作：acquire（申请同步资源）、release（释放同步资源），AQS 提供了这两个方法。</p><ul><li><strong>acquire：</strong>尝试申请同步资源，失败阻塞调用的线程，直到同步资源允许其继续执行。例如：ReentrantLock.lock()、CountDownLatch.await() 等方法</li><li><strong>release：</strong>释放当前线程所持有的同步资源，使得一或多个被 acquire 阻塞的线程继续执行。例如：ReentrantLock.unlock()、CountDownLatch.countDown() 等方法。</li></ul><p>AQS 并没有对自定义同步器的同步方法做统一的定义，因此在不同的同步器中 acquire 和 release 的名称可能有所不同，例如：Lock.lock、Semaphore.acquire、CountDownLatch.await、FutureTask.get 他们都是 acquire 方法的体现，而比如 Lock.unlock 则是 release 的体现了。</p><p>AQS 背后的基本思想其实很简单，acquire 操作如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (拿不到同步资源) &#123;</span><br><span class="line">    进入阻塞队列排队;</span><br><span class="line">    或者不排队，直接返回;</span><br><span class="line">&#125;</span><br><span class="line">拿到同步资源了，退出排队;</span><br></pre></td></tr></table></figure><p>release 操作如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">释放同步资源;</span><br><span class="line"><span class="keyword">if</span> (同步资源充足，允许被阻塞的线程获取)</span><br><span class="line">    唤醒能获取同步资源的线程;</span><br></pre></td></tr></table></figure><p>为了实现 acquire 和 release 操作，需要以下的三个基本组件的相互协作：</p><ul><li>同步状态的原子性管理</li><li>线程的阻塞与唤醒被阻塞的线程</li><li>线程排队的队列管理</li></ul><p>同时实现这三个功能是可以做到的，但是无法应对各种各样的同步需求，比如在互斥锁中同一时刻只允许有一个线程持有锁，而共享锁则允许同一时刻有多个线程持有锁、以及各种同步器之间的特性无法同时实现。AQS 实际上是将这些组件共同的部分（例如：acquire 和 release）提取出来了，而其他的同步器继承 AQS 来做一些个性化实现。</p><blockquote><p>这也是 Java 继承的一种应用，将公共部分提取出来作为父类，再由子类继承父类去做一些个性化定制。只是在自定义同步器中对 AQS 的继承跟常规继承还有点区别。这里的继承更像是一种组合的操作，而不是对 AQS 的扩展。</p></blockquote><h1 id="同步资源"><a href="#同步资源" class="headerlink" title="同步资源"></a>同步资源</h1><p><strong>概述：</strong>同步资源表示的是当前线程是否满足继续执行条件。这个条件更像是一个许可证，拿到执行许可证才能继续执行。所以你可以把同步资源理解为执行许可证。</p><p><strong>表示：</strong>AQS 使用 state 属性（int 32位）来设置同步资源，并暴露出 <code>getState</code>、<code>setState</code> 以及 <code>compareAndSet</code> 操作来读取和更新这个属性，这些方法都依赖于 j.u.c.atomic 包的支持。</p><p>AQS 并不维护同步资源的值，仅为其提供维护方法，具体如何对同步资源调配将有继承自 AQS 的同步器自行处理。同步器仅需实现对同步资源的获取与释放方法即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等）AQS 在顶层已经实现好了，同步器主要实现也仅能实现以下的几种方法：</p><ul><li><strong>isHeldExclusively()：</strong>该线程是否正在独占资源。只有用到condition才需要去实现它。</li><li><strong>tryAcquire(int)：</strong>独占方式。尝试获取资源，成功则返回true，失败则返回false。</li><li><strong>tryRelease(int)：</strong>独占方式。尝试释放资源，成功则返回true，失败则返回false。</li><li><strong>tryAcquireShared(int)：</strong>共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li><strong>tryReleaseShared(int)：</strong>共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li></ul><p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现 tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared 中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如 ReentrantReadWriteLock。</p><h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><p>整个框架的关键就是如何管理被阻塞的线程的队列，该队列是严格的 FIFO 队列，因此，框架不支持基于优先级的同步。</p><p>其实这里称之为队列我认为不是很准确，从数据结构的角度它更像是一个双端链表，可能从 FIFO 的特性来说它才更像是一个队列吧。</p><p>既然是双向链表，那么就只需要关注其节点的数据结构以及如何组织节点即可。</p><p>先看一下节点的数据结构，至于如何组织节点将在分析 acquire、release 的时候做具体介绍，其实也就是介绍节点的创建时机、以及怎样入队出队的时机。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">// 标识节点当前是共享模式还是独占模式</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// waitStatus 字段的值，下面会介绍</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程等待状态，取值在上面</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line">    <span class="comment">// 前驱节点的引用</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="comment">// 后继节点的引用</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="comment">// 这个就是线程本尊</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 Node 节点类很明显就是一个标准双端链表的节点类，有 prev、next 指向前驱和后继节点，thread 当然就是具体的线程，waitStatus 当然就是线程在队列中的状态了。</p><blockquote><ul><li><strong>CANCELLED：</strong>表示当前结点已取消调度。当 timeout 或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。</li><li><strong>SIGNAL：</strong>表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为 SIGNAL。</li><li><strong>CONDITION：</strong>表示结点等待在 Condition 上，当其他线程调用了 Condition 的 signal() 方法后，CONDITION 状态的结点将从等待队列转移到同步队列中，等待获取同步锁。</li><li><strong>PROPAGATE：</strong>共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。</li><li><strong>0：</strong>新结点入队时的默认状态。</li></ul></blockquote><p>注意：负值表示结点处于有效等待状态，而正值表示结点已被取消。所以源码中很多地方用 <code>&gt;0</code>、<code>&lt;0</code> 来判断结点的状态是否正常。</p><h1 id="AQS-结构"><a href="#AQS-结构" class="headerlink" title="AQS 结构"></a>AQS 结构</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头结点，你直接把它当做 当前持有锁的线程 可能是最好理解的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个链表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步资源状态，这个字段将由继承 AQS 的自定义同步器维护</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表当前持有独占锁的线程，继承自 AbstractOwnableSynchronizer</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br></pre></td></tr></table></figure><p>整个 AQS 维护了一个 state（同步资源）和一个阻塞队列，当多线程竞争同步资源被阻塞的线程会进入此队列排队。他们之间的关系如下：</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/AQS-1.png" alt="AQS-1"></p><hr><blockquote><p><strong>小结：</strong></p><p>AQS 是被抽象出来作为各个同步器最重要的工具 Sync 类的父类而存在的。AQS 定义了同步资源 state 属性，并且为其提供维护方法。同步器通过维护同步资源来调用 AQS 中对线程的阻塞入队&#x2F;唤醒出队等操作。</p></blockquote><p>关于 AQS 的概念性介绍就到这里，关于最重要的 acquire 和 release 方法会再单独开一篇文章做详解。</p><hr><blockquote><p><strong>巨人的肩膀：</strong></p><ul><li><a href="https://www.cnblogs.com/dennyzhangdd/p/7218510.html">《The java.util.concurrent Synchronizer Framework》 JUC同步器框架（AQS框架）原文翻译</a></li><li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer">一行一行源码分析清楚AbstractQueuedSynchronizer</a></li><li><a href="https://www.cnblogs.com/waterystone/p/4920797.html">Java并发之AQS详解</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">Java 并发之魂：AQS。地位不用多说，各种并发同步工具背后都是基于 AQS 实现的，比如 CountDownLatch、ReentrantLock、Semaphore、CyclicBarrier 等。</summary>
    
    
    
    <category term="Java" scheme="https://www.wrp.cool/categories/Java/"/>
    
    <category term="并发" scheme="https://www.wrp.cool/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发：同步工具类</title>
    <link href="https://www.wrp.cool/posts/30379/"/>
    <id>https://www.wrp.cool/posts/30379/</id>
    <published>2022-08-04T14:02:10.000Z</published>
    <updated>2022-11-01T12:46:38.449Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲述控制并发流程的工具类，包括：CountDownLatch、Semaphore、CyclicBarrier、Condition。这些工具类的作用就是帮助程序员更容易控制线程之间的合作，让线程互相配合，以满足业务逻辑，比如让线程A等待线程B执行完毕后再执行的排队策略、或者是让多个线程等待到某个时刻再同时从某个阶段开始执行的合作策略。</p><h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><blockquote><p>中文名：倒计时门栓，举个例子可以类比成一个门锁，一旦门打开了，门外面等待的人就会一拥而入。而 CountDownLatch 就是用一个倒计时做为门锁，一旦计数到0，就把门锁打开，等待执行的线程就会在此时刻一起开始执行。</p></blockquote><p><strong>构造方法：</strong></p><ul><li><code>public CountDownLatch(int count)</code> 参数 count 为要倒数的值</li></ul><p><strong>重要方法：</strong></p><ul><li><code>public void await() throws InterruptedException</code><ul><li>等待，线程调用此方法后被挂起，等待直到 count 值为0才开始执行</li></ul></li><li><code>public boolean await(long timeout, TimeUnit unit)</code><ul><li>超时等待，线程调用此方法后会被挂起，在设置的最长等待时间之前如果倒计时结束则返回 true 并在倒计时结束时刻开始执行后续代码，到达最长等待时间之后则返回 false 并开始执行后续代码</li></ul></li><li><code>public void countDown()</code><ul><li>将 count 值减1，直到为0时，等待的线程才会被唤醒。</li></ul></li></ul><p><strong>CountDownLatch 使用示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(Math.abs(r.nextInt() % <span class="number">1000</span>));</span><br><span class="line">                latch.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;门锁打开了，开始执行，此刻时间是：&quot;</span> + System.currentTimeMillis());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    latch.countDown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 十个线程的开始执行时间都是相同的</span></span><br></pre></td></tr></table></figure><h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><blockquote><p>可以理解为：运行许可证。拿到 Semaphore 资源的线程才可以往下运行，运行完毕之后必须归还 Semaphore 资源。可以用来保护一些比较稀缺的资源，保证了同一时刻最多只有有限个线程在使用这些稀缺资源。</p></blockquote><p><strong>构造方法：</strong></p><ul><li><code>public Semaphore(int permits, boolean fair)</code><ul><li>permits：运行许可证数量</li><li>fair：是否使用公平锁策略</li></ul></li></ul><p><strong>重要方法：</strong></p><ul><li><code>public void acquire() throws InterruptedException</code><ul><li>申请许可证，如果暂时没许可证则陷入阻塞。</li></ul></li><li><code>public boolean tryAcquire()</code><ul><li>尝试申请许可证，看看现在有没有空闲的许可证，如果有的话直接获取，没有则去做别的事情。</li></ul></li><li><code>public void release()</code><ul><li>释放许可证，将用完的许可证放回去。必须在 finally 代码块中调用</li></ul></li></ul><p>以上摘抄了几个比较重要的方法出来说明，Semaphore 类中还有一些其他的方法能更灵活使用，包括设置阻塞超时、一次性获取多个许可证、一次性释放多个许可证等。</p><p><strong>Semaphore 使用示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Semaphore</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                s.acquire();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 申请到了许可证，往下执行&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;释放许可证&quot;</span>);</span><br><span class="line">                s.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Thread-&quot;</span> + i).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><blockquote><p>可以类比为春游时候的大巴车，等待人满发车。就是约定好一个数字（<em>大巴车的载客数</em>），先到的线程等待后到的线程（<em>先上车的同学等待后上车的同学</em>），等到线程数满足约定数量之后（<em>全部同学到齐</em>）全部开始执行（<em>发车</em>）。</p></blockquote><p><strong>构造方法：</strong></p><ul><li><code>public CyclicBarrier(int parties, Runnable barrierAction)</code><ul><li>parties：提前约定好等待线程的数量</li><li>barrierAction：等待所有线程到齐后执行的线程</li></ul></li></ul><p><strong>重要方法：</strong></p><ul><li><code>public int await() throws InterruptedException, BrokenBarrierException</code><ul><li>先到的线程开始等待后面的线程来了之后一起执行</li></ul></li><li><code>public int await(long timeout, TimeUnit unit) throws InterruptedException, BrokenBarrierException, TimeoutException</code><ul><li>设置超时的等待，超时抛出 TimeoutException</li></ul></li><li><code>public void reset()</code><ul><li>放弃正在等待中的线程，开始新一轮等待</li></ul></li></ul><div class="note primary modern no-icon flat"><p><strong>抛出 BrokenBarrierException 的3种情况：</strong></p></div><ol><li>其他等待的线程被中断</li><li>其他等待的线程超时</li><li>其他线程调用 CyclicBarrier.reset() 方法</li></ol><p><strong>CyclicBarrier 使用示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">CyclicBarrier</span> <span class="variable">cb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">5</span>, () -&gt; System.out.println(<span class="string">&quot;大巴发车&quot;</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>(i, cb), <span class="string">&quot;Thread-&quot;</span> + i).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier cb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Task</span><span class="params">(<span class="type">int</span> id, CyclicBarrier cb)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.cb = cb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread-&quot;</span> + id + <span class="string">&quot; 准备前往大巴车&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(Math.abs(r.nextInt() % <span class="number">10000</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread-&quot;</span> + id + <span class="string">&quot; 已经上大巴车了，开始等待其他同学到达&quot;</span>);</span><br><span class="line">            cb.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread-&quot;</span> + id + <span class="string">&quot;所乘坐的大巴车出发！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p><strong>CountDownLatch 和 CyclicBarrier 的区别：</strong></p><ol><li><strong>可重用性不同：</strong>CountDownLatch 在倒数到0并出发门栓打开后，就不能再次使用了，只能创建新的实例；而 CyclicBarrier 可以重复使用。</li><li><strong>作用不同：</strong>CyclicBarrier 要等到固定数量的线程都到达了栅栏位置才能继续执行，而 CountDownLatch 只需要等待计数器倒数至0。</li><li>CyclicBarrier 是线程之间的交互行为，重点在协作的线程；<br>CountDownLatch 是倒数事件的行为，重点在倒数的事件。</li></ol></blockquote><p><strong>CountDownLatch 的应用场景：</strong>有一个任务想要往下执行，但必须要等到其他的任务执行完毕后才可以继续往下执行。假如我们这个想要继续往下执行的任务调用一个CountDownLatch对象的await()方法，其他的任务执行完自己的任务后调用同一个CountDownLatch对象上的countDown()方法，这个调用await()方法的任务将一直阻塞等待，直到这个CountDownLatch对象的计数值减到0为止。</p><p><strong>CyclicBarrier 的应用场景：</strong>CyclicBarrier 可以构造一个栅栏，当某一个线程执行到栅栏前，它就会开始等待，直到所有线程都到达栅栏前，那么该栅栏就会打开，所有线程再统一出发，继续执行剩下的任务。</p><h1 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h1><blockquote><p>条件对象。是 Object 中的 wait()、notify()、notifyAll() 这几个方法的升级版（避免了 synchronized 的使用），不同的是这里的锁使用的是 ReentrantLock，而不是 monitor 锁。<br>关于 Object 中的 wait()、notify()、notifyAll() 这几个方法具体可以查看<a href="https://www.wrp.cool/posts/29010/">这里</a></p></blockquote><p><strong>创建 Condition 对象：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">c</span> <span class="operator">=</span> lock.newCondition();</span><br></pre></td></tr></table></figure><div class="note info modern no-icon flat"><p><strong>Condition 中与 Object 三个方法的对应：</strong></p></div><table><thead><tr><th align="left">Object</th><th align="left">Condition</th></tr></thead><tbody><tr><td align="left">wait()</td><td align="left">await()</td></tr><tr><td align="left">notify()</td><td align="left">signal()</td></tr><tr><td align="left">notifyAll()</td><td align="left">signalAll()</td></tr></tbody></table><p><strong>Condition 使用的示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个线程交替打印 1-100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (count &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                c.signal();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;输出：&quot;</span> + String.format(<span class="string">&quot;%03d&quot;</span>, count++));</span><br><span class="line">                <span class="keyword">if</span> (count &lt;= <span class="number">100</span>)</span><br><span class="line">                    c.awaitUninterruptibly();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;奇数线程&quot;</span>).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;偶数线程&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的这个交替打印 1-100 的例子，还可以使用 synchronized 来实现，只是效率上较差了一些。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> count;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 打印奇数的线程</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (count &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + count++);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;奇数&quot;</span>).start();</span><br><span class="line">    <span class="comment">// 打印偶数的线程</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (count &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + count++);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;偶数&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个场景下使用 synchronized 的效率较差的原因是：竞争到锁的线程将判断是否满足打印条件，如果满足则打印，否则直接跳出，紧接着同步代码块执行完毕释放锁，两个线程重新进入竞争锁的步骤，如果在这个时候其中一个线程接连多次竞争到锁，但是却因为不满足打印条件而再次直接释放锁，这就是无意义的浪费</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文讲述控制并发流程的工具类，包括：CountDownLatch、Semaphore、CyclicBarrier、Condition。这些工具类的作用就是帮助程序员更容易控制线程之间的合作，让线程互相配合，以满足业务逻辑，比如让线程A等待线程B执行完毕后再执行的排队策略、或</summary>
      
    
    
    
    <category term="Java" scheme="https://www.wrp.cool/categories/Java/"/>
    
    <category term="并发" scheme="https://www.wrp.cool/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发：并发容器</title>
    <link href="https://www.wrp.cool/posts/3103/"/>
    <id>https://www.wrp.cool/posts/3103/</id>
    <published>2022-08-04T13:50:58.000Z</published>
    <updated>2022-10-17T11:16:01.201Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>看并发容器的发展历史其实也反映了一个软件的发展历史，很明显大多数软件在研发的初期都是比较粗糙的，这也是由市场的性质所决定的，前期如果投入了过多的时间跟精力，那么一旦这款软件不被市场所接受，那全都白费了。并发容器的发展历程跟这如出一辙。</p></blockquote><p>早期的 jdk 中的并发容器只有 Vector 和 Hashtable，初期的设计这两种并发容器的效率并不理想，这两个并发容器的实现和早期的 ArrayList 和 HashMap 几乎一样，只是在其中的一些可能会导致并发不安全的方法上加了 synchronized 关键字用来同步。将 synchronized 加在方法上等于是锁住了整个实例对象。这样的设计是方便了开发人员，几乎是最少的成本实现了并发容器的功能，但是效率上就堪忧了。</p><p>再到后来的 Collections 提供的同步工具类：<code>Collections.synchronizedList(new ArrayList&lt;&gt;())</code>。这种方式来创建并发容器，实际上也只是把 synchronized 从方法签名上转移到了方法内部。锁的粒度更细了一些，但也不是那么优秀。</p><p>这两种方式虽然都不是很优秀，但也是一个发展的过程。接下来才是正文。</p><div class="note default flat"><p><strong>为什么普通容器不安全</strong></p></div><p>普通容器没有对写操作和扩容做同步操作，如果多个线程同时写到了同一个位置或者扩容的话，只有一个线程的修改能被保存下来。原理就像是不安全的 <code>i++</code> 一样。</p><p>甚至在 HashMap 中多线程同时扩容还会造成 <code>自己.next = 自己</code> 造成 CPU100% 的情况。具体情况可以参考<a href="https://coolshell.cn/articles/9606.html">这篇文章</a></p><h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><p>Java8 中 的 ConcurrentHashMap 数据结构示意图：</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8-1.png" alt="并发容器-1"></p><p>第一排被框起来的一个个小方块就是 Node 节点类，这里要跟 Java7 的 Segment 区分好，jdk1.7 的 Segment 通过继承 ReentrantLock 来加锁，也就是每次锁住的是一个 Segment 实例，相当于是所有的 Segment 加起来才是完整的 ConcurrentHashMap，在一定程度上提高了并发度。一开始我认为 Java8 的 Node 跟 Java7 的 Segment 一样是不可扩容的，但这里的 Node 是可以扩容的，要区分开。</p><p>正常来说数据都是存放在 Node 数组里面的，如果发生了 hash 冲突，那会从 Node 往后再拉一个链表出来，把冲突的数据放在后面。当这个链表的长度达到 8 并且 Node 数组的长度超过 64，那么就会把链表转换成红黑树来存储冲突数据。</p><p>概括一下 ConcurrentHashMap 中的数据结构为：<code>数组 + 链表 + 红黑树</code></p><h2 id="put-方法流程"><a href="#put-方法流程" class="headerlink" title="put() 方法流程"></a>put() 方法流程</h2><p>方法定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来要分析的内容，onlyIfAbsent：元素是否可重复</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先就是一些常规流程，比如判空、获取新元素 hash 值、以及记录链表长度用于后面判断是否需要链表转红黑树操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line"><span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>根据前面的 ConcurrentHashMap 的数据结构，put() 方法添加的新元素可能会：</p><ul><li>落在 Node 节点上；</li><li>落在 Node 拉出来的链表上；</li><li>落在由链表转换的红黑树上。</li></ul><h3 id="新元素落在-Node-上"><a href="#新元素落在-Node-上" class="headerlink" title="新元素落在 Node 上"></a>新元素落在 Node 上</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自旋，确保肯定能插入成功</span></span><br><span class="line"><span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">    Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">    <span class="comment">// 找到 hash 对应位置的 Node 发现为 null，于是此次 put() 操作应该创建新 Node</span></span><br><span class="line">    <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// CAS 把新 Node 放进去</span></span><br><span class="line">        <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 数据落在链表或者红黑树上的情况，下面的分析将从此处开始</span></span><br><span class="line">        <span class="comment">// 数据落地后判断是否将链表转换成红黑树，该部分分析从此处开始</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h3 id="新元素落在链表上"><a href="#新元素落在链表上" class="headerlink" title="新元素落在链表上"></a>新元素落在链表上</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从此处开始才锁起来，锁的对象是被操作的整个 Node 节点</span></span><br><span class="line"><span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">    <span class="comment">/* 因为刚刚没有锁起来，在这里可能刚刚拿到的 f 节点已经被改了</span></span><br><span class="line"><span class="comment">     * 再做一次判断看看有没有被改，如果被改了那就自旋重来一次 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 关于这里的这个 if 说一点点点我自己的想法吧，</span></span><br><span class="line"><span class="comment">     * 如果是我写这个 if 我会这么写：if (tabAt(tab, i) != f) continue;</span></span><br><span class="line"><span class="comment">     * 首先这么写可以少一层缩进，代码上看起来会舒服一些</span></span><br><span class="line"><span class="comment">     * 另外下面还有一个判断是否要转换成红黑树的操作，直接 continue 的话可以少一次判断，</span></span><br><span class="line"><span class="comment">     * 少这一次判断不是为了省这一点点的判断的性能，而是此时如果其他线程增加了节点导致需要转换红黑树，</span></span><br><span class="line"><span class="comment">     * 那么哪个判断就进去了，虽然 treeifyBin() 方法也是线程安全的，但本来这不该是当前线程去做的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">        <span class="comment">// fh：头节点的 hash 值，大于 0 说明是链表</span></span><br><span class="line">        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            binCount = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 循环找到链表最后一个位置</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                K ek;</span><br><span class="line">                <span class="comment">// 找到了重复的键，判断是否覆盖</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                    oldVal = e.val;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                        e.val = value;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                <span class="comment">// 走到了链表尾，将新元素挂在链表尾部。</span></span><br><span class="line">                <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数据落在红黑树的情况，下面的分析将从此处开始</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="新元素落在红黑树上"><a href="#新元素落在红黑树上" class="headerlink" title="新元素落在红黑树上"></a>新元素落在红黑树上</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头节点是红黑树节点</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">    Node&lt;K,V&gt; p;</span><br><span class="line">    binCount = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 调用红黑树的插值方法插入新节点</span></span><br><span class="line">    <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        oldVal = p.val;</span><br><span class="line">        <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">            p.val = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="是否链转红"><a href="#是否链转红" class="headerlink" title="是否链转红"></a>是否链转红</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表长度超过8转换成红黑树</span></span><br><span class="line"><span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">        <span class="comment">// 走到这里还不一定会转换成红黑树</span></span><br><span class="line">        <span class="comment">// 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树</span></span><br><span class="line">        treeifyBin(tab, i);</span><br><span class="line">    <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> oldVal;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note default flat"><p><strong>为什么链表转红黑树的阈值是8？</strong></p></div><p>根据泊松分布，如果 hash 函数的设计没问题的话，链表长度超过8的概率还不足千万分之一，已经是及其小的概率了。千万不要觉得8这个数字不是那么大就觉得 ConcurrentHashMap 会经常发生链表转红黑树的情况。</p><h3 id="put-流程小结"><a href="#put-流程小结" class="headerlink" title="put() 流程小结"></a>put() 流程小结</h3><ol><li>准备工作：判断 key value 不为空、计算 hash 值等。</li><li>如果：新元素落在新节点上。那么：CAS 新增节点。</li><li>如果：新元素落在链表上。那么：遍历链表插入新元素。</li><li>如果：新元素落在红黑树上。那么：调用红黑树方法插入新节点。</li><li>判断是否需要将链表转换为红黑树</li></ol><p>关于整个 put() 方法的工作流程这里还只是很表面的分析，这里还有几个重量级问题：第一个是初始化，第二个是扩容，第三个是帮助数据迁移。</p><h2 id="get-方法流程"><a href="#get-方法流程" class="headerlink" title="get() 方法流程"></a>get() 方法流程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 ConcurrentHashMap 是否已经初始化完毕，以及对应位置的元素是否已经添加</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 头节点是不是我们想要的节点</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果头结点的 hash 小于 0，说明 正在扩容，或者该位置是红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// find 方法根据 e 的具体实现（ForwardingNode 或 TreeBin）而调用对应方法</span></span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 不是红黑树也不是头节点，那肯定是链表，遍历取出即可</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>get() 流程小结：</strong></p><ol><li>计算 hash 值</li><li>如果：值在 Node 节点中。那么：直接返回。</li><li>如果：正在扩容或者值在红黑树中。那么：调用对应方法找到 val 返回</li><li>如果：都不是。那么：肯定是链表，遍历返回 val</li><li>找不到，返回 null</li></ol><h1 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h1><p>先简单介绍一下 Cpoy On Write 思想吧。Cpoy On Write 就是一种写时复制的操作，字面上意思也很明确：写操作复制。执行写入操作时先复制一份副本，在副本上写入，再将指针指向被修改的副本。优点是在读取的时候不需要加锁，并且读写冲突不会抢锁，仅在写写冲突的时候会抢锁。缺点也很明显，多线程同时写的话会对内存造成比较大的压力；并且保证不了数据的实施一致性，只能保证数据的最终一致性，因为读操作拿到的数据可能不是最新的数据。</p><p>其多线程并发安全由内部数据不可变保证，不可变指的是每次修改都是在副本上修改，所以读取的数据永远不会改变。</p><div class="note default flat"><p><strong>Cpoy On Write 在迭代中的应用：</strong></p></div><p>一些没有 Cpoy On Write 能力的集合（ArrayList）在迭代的时候会发生什么事情：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">    <span class="keyword">for</span> (Integer i : list) </span><br><span class="line">        list.add(<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 方法抛出异常：</span></span><br><span class="line"><span class="comment">// java.util.ConcurrentModificationException</span></span><br></pre></td></tr></table></figure><p>抛出异常的原因也很简单，ArrayList 不允许在迭代的过程中新增或者删除元素。为什么不允许呢？</p><p>因为迭代的过程中新增或删除元素会导致迭代访问元素顺序错乱或者死循环跟下标越界问题。比如：访问到第5个元素的时候把第1个元素删了，此时所有元素往前移了一个位置，那原来的第六个元素的访问就被跳过了。</p><p>foreach 循环依赖了由 ArrayList 提供的 Iterator 对象。Iterator 对象维护了一个 expectedModCount 变量，这个变量记录了 Iterator 对象初始化时 ArrayList 发生了多少次增加或删除元素的操作，ArrayList 每次增加或删除元素都会维护 modCount 变量。于是每次迭代调用 iterator.next() 时都会检查 expectedModCount 与 modCount 是否相等，不相等则抛出 java.util.ConcurrentModificationException 异常。</p><p>上面的代码如果使用 CopyOnWriteArrayList 实现就不会抛出此异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">    <span class="keyword">for</span> (Integer i : list) &#123;</span><br><span class="line">        list.add(<span class="number">6</span>);</span><br><span class="line">        System.out.print(i + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(<span class="string">&quot;\n&quot;</span> + list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 方法输出：</span></span><br><span class="line"><span class="comment">// 1  2  3  4  5  </span></span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6, 6, 6, 6, 6]</span></span><br></pre></td></tr></table></figure><p>结果也是很明显，符合 Copy On Write 原则。新增元素时在副本上增加，不会影响到正在迭代的数据，指针切换后仍然遍历的是旧数据。</p><h1 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h1><p>阻塞队列（BlockingQueue）通常用于一个线程生产对象，而另外一个线程消费这些对象的场景。下图是对这个原理的阐述：</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="阻塞队列示意图"></p><p>在这个示意图中，<code>Thread 1</code> 代表生产线程，<code>Thread 2</code> 代表了消费线程。</p><p>生产线程将会持续生产新对象放到阻塞队列中，直到队列达到它所能容纳的临界点。达到临界点再往队列插入新对象时会发生阻塞，直到消费线程从队列中拿走一个对象。消费线程会一直在阻塞队列中拿出对象，如果队列为空的话，消费线程会发生阻塞，直到一个生产线程往队列中插入一个新对象。</p><p>每当有新对象入队时就会唤醒一个消费者线程；每当有一个对象出队时就会唤醒一个生产者线程。</p><div class="note default flat"><p><strong>使用示例：ArrayBlockingQueue</strong></p></div><p>ArrayBlockingQueue 是一个有界的阻塞队列，也是一个 FIFO 队列，其底层由一个不可扩容的数组实现，意味着同一时间能够存储元素数量是有上限的，数组容易在初始化时设定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(BlockingQueue&lt;Integer&gt; queue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.put(<span class="number">1</span>);</span><br><span class="line">            queue.put(<span class="number">2</span>);</span><br><span class="line">            queue.put(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(BlockingQueue&lt;Integer&gt; queue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(queue.take());</span><br><span class="line">            System.out.println(queue.take());</span><br><span class="line">            System.out.println(queue.take());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(queue);</span><br><span class="line">    <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(queue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(producer).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(consumer).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一些其他阻塞队列在实际开发中应当视情况选择合适的队列使用比如：延迟队列 DelayQueue、链阻塞队列 LinkedBlockingQueue、具有优先级的阻塞队列 PriorityBlockingQueue、同步队列 SynchronousQueue 等等。</p><hr><blockquote><p><strong>巨人的肩膀：</strong></p><ul><li><a href="https://www.javadoop.com/post/hashmap">Java7&#x2F;8 中的 HashMap 和 ConcurrentHashMap 全解析</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">从并发容器的发展历史开始，优秀如 ConcurrentHashMap 这样的代码绝不是一朝一夕就可以完成的。</summary>
    
    
    
    <category term="Java" scheme="https://www.wrp.cool/categories/Java/"/>
    
    <category term="并发" scheme="https://www.wrp.cool/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发：final</title>
    <link href="https://www.wrp.cool/posts/38583/"/>
    <id>https://www.wrp.cool/posts/38583/</id>
    <published>2022-08-04T13:50:40.000Z</published>
    <updated>2022-10-17T11:18:19.125Z</updated>
    
    <content type="html"><![CDATA[<p>final 是一个在 Java 基础阶段就会学到的关键字，首先回顾一下 final 的基本用法，再进一步深入了解 final 在并发中的应用。</p><h1 id="final-基本用法"><a href="#final-基本用法" class="headerlink" title="final 基本用法"></a>final 基本用法</h1><h2 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a>修饰类</h2><p>当某个类的整体定义为 final 时，就表明了你不能打算继承该类，而且也不允许别人这么做。即这个类是不能有子类的。</p><p>注意：final 类中的所有方法都隐式为 final，因为无法覆盖他们，所以在 final 类中给任何方法添加 final 关键字是没有任何意义的。</p><div class="note default flat"><p><strong>那么怎么扩展 final 类呢？</strong></p></div><p>设计模式中最重要的两种关系，一种是继承&#x2F;实现；另外一种是组合关系。所以当遇到不能用继承的（final 修饰的类），应该考虑用组合，如下代码大概写个组合实现的意思：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String innerString;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...init &amp; other methods</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 支持老的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> innerString.length(); <span class="comment">// 通过innerString调用老的方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加新方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toMyString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h2><p>final 修饰的方法不能被重写，不过重写的前提是继承，如果 final 修饰的方法同时又是 private 的将会导致子类无法重写此方法，子类可以定义相同的方法名和参数，该方法将成为子类的新方法，而不是继承自父类的方法。</p><p>final 方法虽然不能被重写，但是可以被重载的，如下代码是正确的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">finalFunction</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">finalFunction</span><span class="params">(String name)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类中所有的 private 方法都是隐式 final 的，由于子类看不到父类的 private 方法，所以也就不能重写它。在代码中仍然能够对 private 方法添加 final 修饰符，但是这并没有什么用处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;func from A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;func from B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        a.func(); <span class="comment">// 编译错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修饰参数"><a href="#修饰参数" class="headerlink" title="修饰参数"></a>修饰参数</h2><p>final 修饰的参数不能被改变，被 final 修饰的基本数据类型的参数其值不能被改变，被 final 修饰的引用数据类型的参数其地址不能被改变，但对象内部的数据可以被改变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finalDemo</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> i, <span class="keyword">final</span> User user)</span> &#123;</span><br><span class="line">    user.name = <span class="string">&quot;zhangsan&quot;</span>; <span class="comment">// 正确</span></span><br><span class="line">    i = <span class="number">10</span>;                 <span class="comment">// 错误</span></span><br><span class="line">    user = <span class="keyword">new</span> <span class="title class_">User</span>();      <span class="comment">// 错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h2><p><strong>被 final 修饰的属性不一定都是编译器常量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">//编译期常量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">J</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非编译期常量</span></span><br><span class="line">    <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> r.nextInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>k</code> 的值由随机数对象决定，所以不是所有的 final 修饰的字段都是编译期常量，只是 <code>k</code> 的值在被初始化后无法被更改。</p><p><strong>static final 变量</strong></p><p>一个既是static又是final 的字段只占据一段不能改变的存储空间，它必须在定义的时候进行赋值，否则编译器将不予通过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> r.nextInt(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">k2</span> <span class="operator">=</span> r.nextInt(<span class="number">10</span>); </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;k=&quot;</span>+t1.k+<span class="string">&quot; k2=&quot;</span>+t1.k2);</span><br><span class="line">        <span class="type">Test</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;k=&quot;</span>+t2.k+<span class="string">&quot; k2=&quot;</span>+t2.k2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码某次输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k=6 k2=5</span><br><span class="line">k=1 k2=5</span><br></pre></td></tr></table></figure><p>对于不同的对象<code>k</code>的值是不同的，但是<code>k2</code>的值却是相同的，这是为什么呢？<br>因为 static 关键字所修饰的字段并不属于一个对象，而是属于这个类的。也可简单的理解为 static final 所修饰的字段仅占据内存的一个一份空间，一旦被初始化之后便不会被更改。</p><hr><p>对于 final 的基本用法就介绍到这里，接下来介绍 final 在并发中的应用：</p><h1 id="final-域的重排序规则"><a href="#final-域的重排序规则" class="headerlink" title="final 域的重排序规则"></a>final 域的重排序规则</h1><ol><li>在构造函数内对一个 final 域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li><li>初次读一个包含 final 域的对象的引用，与随后初次读这个 final 域，这两个操作之间不能重排序。</li></ol><p><strong>写 final 域的重排序规则：</strong></p><ul><li>JMM 禁止编译器把 final 域的写重排序到构造函数之外。</li><li>编译器会在 final 域的写之后，构造函数 return 之前，插入一个 StoreStore 屏障。这个屏障禁止处理器把 final 域的写重排序到构造函数之外。</li></ul><p><strong>读 final 域的重排序规则：</strong></p><ul><li>在一个线程中，初次读对象引用与初次读该对象包含的 final 域，JMM 禁止处<br>理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读 final 域操作的前面插入一个 LoadLoad 屏障。</li></ul><blockquote><p><strong>巨人的肩膀：</strong></p><ul><li><a href="https://www.infoq.cn/minibook/java_memory_model">深入理解Java内存模型</a></li><li><a href="https://pdai.tech/md/java/thread/java-thread-x-key-final.html">关键字: final详解</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">final 是一个在 Java 基础阶段就会学到的关键字，首先回顾一下 final 的基本用法，再进一步深入了解 final 在并发中的应用。</summary>
    
    
    
    <category term="Java" scheme="https://www.wrp.cool/categories/Java/"/>
    
    <category term="并发" scheme="https://www.wrp.cool/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发：Unsafe、CAS和原子类</title>
    <link href="https://www.wrp.cool/posts/61146/"/>
    <id>https://www.wrp.cool/posts/61146/</id>
    <published>2022-08-04T13:50:18.000Z</published>
    <updated>2022-10-17T11:18:15.172Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我在网上看到一些文章写着：CAS 是一种自旋锁。这是一种错误的观念，CAS 跟自旋其实没什么关系，只是当 CAS 失败的时候通常会使用自旋补偿罢了。换句话说，自旋是 CAS 的一种常见的补偿操作，二者并无直接关系。</p></blockquote><p>我个人认为程序员对于 CAS 这样的一种工具其实不应该是仅仅当作工具去看待，更多的是要掌握 CAS 这种思想，并且运用到实际开发中。比如在商品下单的库存校验部分就可以用到 CAS 思想。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">set</span> reserve <span class="operator">=</span> reserve <span class="operator">-</span> #&#123;buyCount&#125; <span class="keyword">from</span> goods <span class="keyword">where</span> reserve <span class="operator">&gt;=</span> #&#123;buyCount&#125;</span><br></pre></td></tr></table></figure><p>由于单条 SQL 执行的时候具有原子性，就算是秒杀的时候也不会导致库存不足的情况出现，这也是 CAS 的一种体现。</p><p>这也印证了 CAS 和自旋并无直接关系，此处的 CAS 失败应该直接通知用户库存不足，而不是做自旋等待。</p><hr><p>Java 中 CAS 由 Unsafe 类实现，原子类是对 CAS 的包装，对外屏蔽了 Unsafe 类，以及提供一些方便的操作。</p><p>CAS 的全称为 Compare-And-Swap ，直译就是对比交换。是一条 CPU 的原子指令（cmpxchg 指令），其作用是让 CPU 先进行比较两个值是否相等，然后原子地更新某个位置的值。就是说 CAS 是靠硬件实现的，JVM 只是封装了汇编调用，那些 java.util.concurrent.atomic.* 类便是使用了这些封装后的接口，这些接口的提供者就是 Unsafe。</p><p>CAS 操作需要输入两个数值，一个旧值（期望操作前的值）和一个新值，在操作期间先比较下在旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。CAS 操作是原子性的，所以多线程并发使用 CAS 更新数据时，可以不使用锁。JDK 中大量使用了 CAS 来更新数据而防止加锁（synchronized 重量级锁）来保持原子更新。</p><h1 id="Unsafe-类"><a href="#Unsafe-类" class="headerlink" title="Unsafe 类"></a>Unsafe 类</h1><p>Unsafe 是位于 sun.misc 包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升 Java 运行效率、增强 Java 语言底层资源操作能力方面起到了很大的作用。但由于 Unsafe 类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用 Unsafe 类会使得程序出错的概率变大，使得 Java 这种安全的语言变得不再“安全”，因此对 Unsafe 的使用一定要慎重。</p><p>Unsafe 类的设计者并不希望 Unsafe 被轻易的使用，尽管 Unsafe 里面的方法都是 public 的，但是并没有办法使用它们，JDK API 文档也没有提供任何关于这个类的方法的解释。总而言之，对于 Unsafe 类的使用都是受限制的，只有授信的代码才能获得该类的实例，当然 JDK 库里面的类是可以随意使用的。</p><p>Unsafe 类是单例实现的，提供静态方法 getUnsafe 获取 Unsafe 实例，当且仅当调用 getUnsafe 方法的类为引导类加载器所加载时才合法，否则抛出 SecurityException 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Unsafe</span> &#123;</span><br><span class="line">    <span class="comment">// 单例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe theUnsafe;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Unsafe</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">var0</span> <span class="operator">=</span> Reflection.getCallerClass();</span><br><span class="line">        <span class="comment">// 仅在引导类加载器`BootstrapClassLoader`加载时才合法</span></span><br><span class="line">        <span class="keyword">if</span>(!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;    </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(<span class="string">&quot;Unsafe&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> theUnsafe;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要获取 Unsafe 类实例有以下两种实现方案：</p><p>通过反射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Unsafe <span class="title function_">reflectGetUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> (Unsafe) field.get(<span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">        log.error(e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从getUnsafe方法的使用限制条件出发，通过Java命令行命令-Xbootclasspath&#x2F;a把调用Unsafe相关方法的类A所在jar包路径追加到默认的bootstrap路径中，使得A被引导类加载器加载，从而通过Unsafe.getUnsafe方法安全的获取Unsafe实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xbootclasspath/a: $&#123;path&#125; // path 为调用 Unsafe 相关方法的类所在 jar 包路径 </span><br></pre></td></tr></table></figure><h1 id="Unsafe-对-CAS-的实现"><a href="#Unsafe-对-CAS-的实现" class="headerlink" title="Unsafe 对 CAS 的实现"></a>Unsafe 对 CAS 的实现</h1><p>Unsafe 类中只有三个跟 CAS 有关的方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CAS 实现</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o             包含要修改字段的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> offset        要修改字段在该对象中的内存偏移量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expected      期望值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> update        更新值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>              更新成功 ? true : false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapObject</span><span class="params">(Object o, <span class="type">long</span> offset, Object expected, Object update)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> expected, <span class="type">int</span> update)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapLong</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">long</span> expected, <span class="type">long</span> update)</span>;</span><br></pre></td></tr></table></figure><p>写一个小例子演示怎么使用 Unsafe 的 CAS 操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException &#123;</span><br><span class="line">    <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> reflectGetUnsafe();</span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    u.setId(<span class="number">1001L</span>);</span><br><span class="line">    u.setName(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    u.setAge(<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Field</span> <span class="variable">id</span> <span class="operator">=</span> User.class.getDeclaredField(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">    <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> User.class.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="type">Field</span> <span class="variable">age</span> <span class="operator">=</span> User.class.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">idOffset</span> <span class="operator">=</span> unsafe.objectFieldOffset(id);</span><br><span class="line">    <span class="type">long</span> <span class="variable">nameOffset</span> <span class="operator">=</span> unsafe.objectFieldOffset(name);</span><br><span class="line">    <span class="type">long</span> <span class="variable">ageOffset</span> <span class="operator">=</span> unsafe.objectFieldOffset(age);</span><br><span class="line"></span><br><span class="line">    unsafe.compareAndSwapLong(u, idOffset, <span class="number">1001L</span>, <span class="number">1002L</span>);</span><br><span class="line">    unsafe.compareAndSwapObject(u, nameOffset, <span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">    unsafe.compareAndSwapInt(u, ageOffset, <span class="number">18</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// User&#123;id=1002, name=&#x27;lisi&#x27;, age=20&#125;</span></span><br></pre></td></tr></table></figure><div class="note default flat"><p><strong>CAS 存在的问题：</strong></p></div><ol><li><p><strong>ABA 问题</strong><br>因为 CAS 需要在操作值的时候，检查值有没有发生变化，比如没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用 CAS 进行检查时则会发现它的值没有发生变化，但是实际上却变化了。</p><p>ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么 A-&gt;B-&gt;A 就会变成 1A-&gt;2B-&gt;3A。</p></li><li><p><strong>自旋开销过大</strong><br> 自旋CAS如果长时间不成功，会给 CPU 带来非常大的执行开销。</p></li><li><p><strong>只能够保证一个变量的原子操作</strong><br>当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁。</p><p>从 Java 1.5 开始，JDK 提供了 AtomicReference 类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行 CAS 操作。</p></li></ol><h1 id="原子类对-CAS-的包装"><a href="#原子类对-CAS-的包装" class="headerlink" title="原子类对 CAS 的包装"></a>原子类对 CAS 的包装</h1><p>原子类是 JUC 为我们提供的方便程序员使用 CAS 的工具类，位于 java.util.concurrent.atomic 包，该包下的所有类都是原子类。</p><p>接下来将把该包下的原子类分为：</p><ul><li>基本数据类型原子类，以 <code>AtomicInteger</code> 为代表</li><li>数组类型原子类，以 <code>AtomicIntegerArray</code> 为代表</li><li>引用类型原子类，以 <code>AtomicReference</code> 为代表</li><li>原子更新字段类，以 <code>AtomicIntegerFieldUpdater</code> 为代表</li></ul><p>以及解决了 ABA 问题的原子类：<code>AtomicStampedReference</code>，还有 JDK8 新增的 Adder 和 Accumulator</p><h2 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h2><p>AtomicInteger 的构造过程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unsafe 类实例，Unsafe CAS 所需要的偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态加载 value 字段相对当前对象的“起始地址”的偏移量</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset(AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被包装的 int 值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AtomicInteger</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AtomicInteger</span><span class="params">(<span class="type">int</span> initialValue)</span> &#123; value = initialValue; &#125;</span><br></pre></td></tr></table></figure><p><strong>常用 API：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> <span class="comment">// 获取当前的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> <span class="comment">// CAS 更新，expect：预期值，update：更新值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span> <span class="comment">// 获取当前的值，并设置新的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> <span class="comment">// 获取当前的值，并自增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">()</span> <span class="comment">// 获取当前的值，并自减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span> <span class="comment">// 获取当前的值，并加上预期的值</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">lazySet</span><span class="params">(<span class="type">int</span> newValue)</span> <span class="comment">// 最终会设置成 newValue,使用 lazySet 设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span><br></pre></td></tr></table></figure><p>常用 API 具体的使用方法这里就不展开了，JDK API 文档里面都有，其实现原理也比较好理解。</p><h2 id="AtomicIntegerArray"><a href="#AtomicIntegerArray" class="headerlink" title="AtomicIntegerArray"></a>AtomicIntegerArray</h2><blockquote><p>数组中的每个元素都具备原子性。</p></blockquote><p><strong>常用方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> expect, <span class="type">int</span> update)</span> <span class="comment">// CAS 更新，i：数组下标</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">// 获取下标i的元素</span></span><br></pre></td></tr></table></figure><p><strong>常用方法演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AtomicIntegerArray</span> <span class="variable">array</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;);</span><br><span class="line">    array.compareAndSet(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    System.out.println(array.get(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h2 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h2><blockquote><p>使对象具备原子性的修改</p></blockquote><p><strong>常用方法：</strong>compareAndSet(V expect, V update)，与前文相同。</p><p><strong>常用方法演示：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line">    AtomicReference&lt;User&gt; atomicUser = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(u1);</span><br><span class="line">    System.out.println(atomicUser.get());</span><br><span class="line">    atomicUser.compareAndSet(u1, u2);</span><br><span class="line">    System.out.println(atomicUser.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// User&#123;name=&#x27;zhangsan&#x27;&#125;</span></span><br><span class="line"><span class="comment">// User&#123;name=&#x27;lisi&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p><strong>两个注意点：</strong></p><ol><li>AtomicArray 能够使数组中的每个元素都具有原子性，AtomicReference 可不是让对象里面的每个属性都具有原子性，仅仅是这个对象在修改的时候具有原子性。</li><li>对于 AtomicReference 的使用，可能这里会有一个误区，认为 AtomicReference 对于一个对象的包装好像没什么用处。看完上面的例子之后可能认为不使用 AtomicReference 而直接让 <code>u1 = u2</code> 好像也能达到同样的效果，针对上面的这个例子这确实没错。<strong>但是 <code>u1 = u2</code> 这不是一个原子操作！</strong>具体原因在<a href="https://www.wrp.cool/posts/41498/">Java 内存模型（JMM）</a>的 <em>「JMM 怎么解决原子性问题」</em> 小节中有具体介绍。</li></ol><p>在开篇的时候提到了 CAS 常常会采用自旋来做为失败补偿机制，在这里演示一个 CAS 自旋锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CASSpinLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; casSpinLock = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="keyword">while</span> (!casSpinLock.compareAndSet(<span class="literal">null</span>, current)) &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        sign.compareAndSet(current, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AtomicIntegerFieldUpdater"><a href="#AtomicIntegerFieldUpdater" class="headerlink" title="AtomicIntegerFieldUpdater"></a>AtomicIntegerFieldUpdater</h2><blockquote><p>将一个对象中的某个属性升级为具有原子能力的属性</p></blockquote><p><strong>使用场景：</strong></p><ol><li>在特定场景下才需要某个字段具有原子能力，如果一开始将该对象设计为原子对象，会给内存一定的压力。</li><li>为做不到线程安全的类设置原子能力。</li></ol><p>原子更新字段类的使用与前面的其他原子类有一些不同，主要就是在创建实例对象的时候不同，使用方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    AtomicIntegerFieldUpdater&lt;Data&gt; atomicDataI = AtomicIntegerFieldUpdater.newUpdater(Data.class, <span class="string">&quot;i&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>(<span class="number">0</span>);</span><br><span class="line">    atomicDataI.compareAndSet(data, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    System.out.println(atomicDataI.get(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Data</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意点：</strong></p><ol><li>原子更新字段类是将该字段升级为原子字段，这并不是针对某个对象的升级，而是针对于类的升级，被升级类的全部实例对象都可以使用该原子字段。</li><li>创建后与一般的原子类使用无异。</li></ol><h2 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h2><blockquote><p>需要手动为每次 CAS 更新操作维护一个版本号，以此来解决 ABA 问题。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line">    AtomicStampedReference&lt;User&gt; atomicUser = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(u1, <span class="number">1</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        atomicUser.compareAndSet(u1, u2, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        atomicUser.compareAndSet(u2, u1, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">    t.join();</span><br><span class="line"></span><br><span class="line">    System.out.println(atomicUser.compareAndSet(u1, u2, <span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    System.out.println(atomicUser.compareAndSet(u1, u2, <span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p><code>AtomicStampedFieldUpdater</code> 网上看到很多文章都提到这个类说是啥带版本号原子更新字段啥的，但是在 oracle 文档却没有找到该类，可能是灵异事件吧。</p></blockquote><h2 id="Adder-和-Accumulator"><a href="#Adder-和-Accumulator" class="headerlink" title="Adder 和 Accumulator"></a>Adder 和 Accumulator</h2><p><code>LongAdder</code>、<code>LongAccumulator</code>、<code>DoubleAdder</code>、<code>DoubleAccumulator</code>，这四个类是在 JDK8 中新增的，接下来将主要分析 LongAdder 这个类，其他的几个类都差不多。引入 LongAdder 主要是为了优化 AtomicLong 在多线程并发情况下的效率，其背后的原理也是空间换时间。</p><p>AtomicLong 相对于 LongAdder 的缺点：速度慢，在多线程的情况下竞争同一个变量 <code>value</code> 导致出现大量线程自旋的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">LongAdder</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAdder</span>();</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        service.submit(<span class="keyword">new</span> <span class="title class_">Task</span>(counter));</span><br><span class="line">    &#125;</span><br><span class="line">    service.shutdown();</span><br><span class="line">    <span class="keyword">while</span> (!service.isTerminated()) &#123; &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    System.out.println(counter.sum());</span><br><span class="line">    System.out.println(<span class="string">&quot;LongAdder耗时：&quot;</span> + (end - start));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LongAdder counter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Task</span><span class="params">(LongAdder counter)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.counter = counter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            counter.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我的电脑上这段代码耗时大概是在 100ms 左右。同样的代码如果使用 AtomicLong 实现大概需要 1000ms 左右。二者在多线程的情况下差距十分明显。</p><p>LongAdder 的原理是：在最初无竞争时，只更新 base 的值，当有多线程竞争时通过分段的思想，让不同的线程更新不同的段，最后把这些段相加就得到了完整的 LongAdder 存储的值。</p><div class="note modern default no-icon flat"><p><strong>LongAdder 重要方法：</strong></p></div><p><strong>add(long x) 方法：</strong>使用它可以使LongAdder中存储的值增加x，x可为正可为负。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">long</span> x)</span> &#123;</span><br><span class="line">    <span class="comment">// as是Striped64中的cells属性</span></span><br><span class="line">    <span class="comment">// b是Striped64中的base属性</span></span><br><span class="line">    <span class="comment">// v是当前线程hash到的Cell中存储的值</span></span><br><span class="line">    <span class="comment">// m是cells的长度减1，hash时作为掩码使用</span></span><br><span class="line">    <span class="comment">// a是当前线程hash到的Cell</span></span><br><span class="line">    Cell[] as; <span class="type">long</span> b, v; <span class="type">int</span> m; Cell a;</span><br><span class="line">    <span class="comment">// 条件1：cells不为空，说明出现过竞争，cells已经创建</span></span><br><span class="line">    <span class="comment">// 条件2：cas操作base失败，说明其它线程先一步修改了base，正在出现竞争</span></span><br><span class="line">    <span class="keyword">if</span> ((as = cells) != <span class="literal">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">        <span class="comment">// true表示当前竞争还不激烈</span></span><br><span class="line">        <span class="comment">// false表示竞争激烈，多个线程hash到同一个Cell，可能要扩容</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">uncontended</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 条件1：cells为空，说明正在出现竞争，上面是从条件2过来的</span></span><br><span class="line">        <span class="comment">// 条件2：应该不会出现</span></span><br><span class="line">        <span class="comment">// 条件3：当前线程所在的Cell为空，说明当前线程还没有更新过Cell，应初始化一个Cell</span></span><br><span class="line">        <span class="comment">// 条件4：更新当前线程所在的Cell失败，说明现在竞争很激烈，多个线程hash到了同一个Cell，应扩容</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="literal">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            <span class="comment">// getProbe()方法返回的是线程中的threadLocalRandomProbe字段</span></span><br><span class="line">            <span class="comment">// 它是通过随机数生成的一个值，对于一个确定的线程这个值是固定的</span></span><br><span class="line">            <span class="comment">// 除非刻意修改它</span></span><br><span class="line">            (a = as[getProbe() &amp; m]) == <span class="literal">null</span> ||</span><br><span class="line">            !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line">            <span class="comment">// 调用Striped64中的方法处理</span></span><br><span class="line">            longAccumulate(x, <span class="literal">null</span>, uncontended);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>最初无竞争时只更新base</li><li>直到更新base失败时，创建cells数组</li><li>当多个线程竞争同一个Cell比较激烈时，可能要扩容</li></ol><blockquote><p>请注意，这里的 casBase() 方法失败后，采用的是数组缓解多线程竞争的策略，再一次印证了自旋跟 CAS 没啥必须的关系。</p></blockquote><blockquote><p>具体的 longAccumulate 方法分析可以转至 <a href="https://zhuanlan.zhihu.com/p/65520633">死磕 java并发包之LongAdder源码分析</a> 进行具体了解。大佬写的很好，是我道行不够，看不明白。</p></blockquote><p><strong>sum()方法：</strong>获取LongAdder中真正存储的值的大小，通过把base和所有段相加得到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">()</span> &#123;</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    <span class="comment">// sum初始等于base</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> base;</span><br><span class="line">    <span class="comment">// 如果cells不为空</span></span><br><span class="line">    <span class="keyword">if</span> (as != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历所有的Cell</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="comment">// 如果所在的Cell不为空，就把它的value累加到sum中</span></span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="literal">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回sum</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 sum() 方法是把base和所有段的值相加得到，那么，这里有一个问题，如果前面已经累加到 sum 上的 Cell 的 value 有修改，不是就没法计算到了么？</p><p>答案确实如此，所以 LongAdder 可以说不是强一致性的，它是最终一致性的。</p><hr><blockquote><p><strong>巨人的肩膀：</strong></p><ul><li><a href="https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html">Java魔法类：Unsafe应用解析</a></li><li><a href="https://pdai.tech/md/java/thread/java-thread-x-juc-AtomicInteger.html">JUC原子类：CAS, Unsafe和原子类详解</a></li><li><a href="https://zhuanlan.zhihu.com/p/65520633">死磕 java并发包之LongAdder源码分析</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">Java 中 CAS 由 Unsafe 类实现，原子类是对 CAS 的包装，对外屏蔽了 Unsafe 类，以及提供一些方便的操作。</summary>
    
    
    
    <category term="Java" scheme="https://www.wrp.cool/categories/Java/"/>
    
    <category term="并发" scheme="https://www.wrp.cool/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发：内存模型（JMM）</title>
    <link href="https://www.wrp.cool/posts/41498/"/>
    <id>https://www.wrp.cool/posts/41498/</id>
    <published>2022-07-26T16:49:31.000Z</published>
    <updated>2022-10-24T12:06:59.920Z</updated>
    
    <content type="html"><![CDATA[<p>并发问题产生的三大根源是「原子性」「可见性」「有序性」，引入 Java 内存模型就是为了解决这三个问题。</p><h1 id="并发问题是怎么产生的"><a href="#并发问题是怎么产生的" class="headerlink" title="并发问题是怎么产生的"></a>并发问题是怎么产生的</h1><div class="note default flat"><p><strong>为什么需要多线程？</strong></p></div><p>众所周知，CPU、内存、I&#x2F;O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为：</p><ul><li>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I&#x2F;O 设备的速度差异；&#x2F;&#x2F; 导致 <code>原子性</code> 问题 </li><li>CPU 增加了缓存，以均衡与内存的速度差异；&#x2F;&#x2F; 导致 <code>可见性</code> 问题</li><li>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用；&#x2F;&#x2F; 导致 <code>有序性</code> 问题</li></ul><h2 id="原子性是怎么产生并发问题的"><a href="#原子性是怎么产生并发问题的" class="headerlink" title="原子性是怎么产生并发问题的"></a>原子性是怎么产生并发问题的</h2><blockquote><p>原子性问题由分时复用引起</p></blockquote><p>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程1执行</span></span><br><span class="line">i += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程2执行</span></span><br><span class="line">i += <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这里需要注意的是：<code>i += 1</code> 需要三条 CPU 指令 </p><ol><li>将变量 i 从内存读取到 CPU寄存器； </li><li>在CPU寄存器中执行 i + 1 操作；</li><li>将最后的结果i写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。</li></ol><p>由于CPU分时复用（线程切换）的存在，线程1执行了第一条指令后，就切换到线程2执行，假如线程2执行了这三条指令后，再切换会线程1执行后续两条指令，将造成最后写到内存中的i值是2而不是3。</p><h2 id="可见性是怎么产生并发问题的"><a href="#可见性是怎么产生并发问题的" class="headerlink" title="可见性是怎么产生并发问题的"></a>可见性是怎么产生并发问题的</h2><blockquote><p>可见性问题由 CPU 缓存引起</p></blockquote><p>可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1执行的代码</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">i = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2执行的代码</span></span><br><span class="line">j = i;</span><br></pre></td></tr></table></figure><p>假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i &#x3D;10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。</p><p>此时线程2执行 j &#x3D; i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10。</p><p>这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p><h2 id="有序性是怎么产生并发问题的"><a href="#有序性是怎么产生并发问题的" class="headerlink" title="有序性是怎么产生并发问题的"></a>有序性是怎么产生并发问题的</h2><blockquote><p>有序性问题由重排序引起</p></blockquote><p>有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">i = <span class="number">1</span>;        <span class="comment">//语句1  </span></span><br><span class="line">flag = <span class="literal">true</span>;  <span class="comment">//语句2</span></span><br></pre></td></tr></table></figure><p>上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗? 不一定，为什么呢? 这里可能会发生指令重排序（Instruction Reorder）。</p><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：</p><ul><li>编译器优化的重排序。编译器在不改变单线程程序语义（as-if-serial 语义）的前提下，可以重新安排语句的执行顺序。</li><li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li>内存系统的重排序。由于处理器使用缓存和读 &#x2F; 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ul><p>从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E9%87%8D%E6%8E%92%E5%BA%8F%E4%BB%8E%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%B0%E6%8C%87%E4%BB%A4%E5%BA%8F%E5%88%97%E6%89%80%E7%BB%8F%E5%8E%86%E6%AD%A5%E9%AA%A4.png" alt="重排序从源代码到指令序列所经历步骤"></p><p>上述的 1 属于编译器重排序，2 和 3 属于处理器重排序，这些重排序都可能会导致多线程程序出现内存可见性问题。</p><ul><li>对于编译器重排序，JMM 的编译器重排序规则会禁止特定类型的编译器重排序。</li><li>对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序。</li></ul><blockquote><p>不管是编译器重排序还是处理器重排序都可以帮助提升程序性能，只是这样的重排序在特定的情况下可能会让代码变得不可靠，所以 JMM 要求在特定情况下是禁止重排序的，此处并非一昧禁止重排序。</p></blockquote><p>同样的，JMM 也不是一昧允许重排序，那么：<strong>重排序的规则是什么？</strong><br>由于篇幅问题此处不做展开，感兴趣的同学请移步：<a href="https://www.wrp.cool/posts/41133/">重排序所遵循的规则</a></p><h1 id="JMM-是怎么解决并发问题的"><a href="#JMM-是怎么解决并发问题的" class="headerlink" title="JMM 是怎么解决并发问题的"></a>JMM 是怎么解决并发问题的</h1><ul><li><strong>JMM 为我们提供了什么工具来解决并发问题？</strong></li><li>JMM 为我们提供了 synchronized、final、volatile、Lock锁、Happens-Before 规则。利用好这些工具能帮我们解决并发问题。</li></ul><h2 id="JMM-怎么解决原子性问题"><a href="#JMM-怎么解决原子性问题" class="headerlink" title="JMM 怎么解决原子性问题"></a>JMM 怎么解决原子性问题</h2><blockquote><p>JMM 要求对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。 </p></blockquote><p>请分析以下哪些操作是原子性操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span>;     <span class="comment">// 语句1：直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中</span></span><br><span class="line">y = x;      <span class="comment">// 语句2：包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</span></span><br><span class="line">x++;        <span class="comment">// 语句3：x++包括3个操作：读取x的值，进行加1操作，写入新的值。</span></span><br><span class="line">x = x + <span class="number">1</span>;  <span class="comment">// 语句4：同语句3</span></span><br></pre></td></tr></table></figure><p>上面4个语句只有语句1的操作具备原子性。</p><p>也就是说，只有简单的读取、赋值（必须是将数字赋值给某个变量）才是原子操作。变量之间的相互赋值不是原子操作。</p><blockquote><p>从上面可以看出，JMM 只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过 synchronized 和 Lock 来实现。由于 synchronized 和 Lock 能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p></blockquote><h2 id="JMM-怎么解决可见性问题"><a href="#JMM-怎么解决可见性问题" class="headerlink" title="JMM 怎么解决可见性问题"></a>JMM 怎么解决可见性问题</h2><p>JMM 提供了 volatile 关键字来保证可见性。</p><p>当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p><p>由于篇幅问题此处不对 volatile 做展开，感兴趣的同学请移步<a href="https://www.wrp.cool/posts/63338/">Java并发：volatile</a></p><p>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p><blockquote><p>另外，synchronized 和 Lock 也能够保证可见性，synchronized 和 Lock 能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p></blockquote><h2 id="JMM-怎么解决有序性问题"><a href="#JMM-怎么解决有序性问题" class="headerlink" title="JMM 怎么解决有序性问题"></a>JMM 怎么解决有序性问题</h2><p>JMM 提供了 Happens-Before 规则在一定程度上保证了有序性</p><p>一个 happens-before 规则通常对应于多个编译器重排序规则和处理器重排序规则。对于 java 程序员来说，happens-before 规则简单易懂，它避免程序员为了理解 JMM 提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现。 </p><div class="note simple default no-icon flat"><p><strong>规则一：程序顺序规则</strong><br>在一个线程中，按照代码的顺序，前面的操作 Happens-Before 于后面的任意操作。</p></div><p>在这条规则下可能会有一个疑问：<strong>既然指令可以重排序又怎么保证程序顺序规则？</strong></p><blockquote><p>以 Happens-Before 的角度回答这个问题：</p></blockquote><p>JMM 通过 Happens-Before 关系向开发人员提供<strong>跨越线程</strong>的内存可见性保证。</p><p>如果一个操作的执行结果对另外一个操作可见，那么这两个操作之间必然存在 Happens-Before 管理。</p><p>其次，Happens-Before 关系只是描述结果的可见性，并不表示指令执行的先后顺序，也就是说只要不对结果产生影响，仍然允许指令的重排序。</p><blockquote><p>以重排序的角度回答这个问题：</p></blockquote><p>在程序顺序规则下，JMM 并不是不允许重排序，JMM 仅仅要求前一个操作（执行的结果）对后一个操作可见。</p><p>假设根据程序顺序规则有 A Happens-Before B 如果操作A的结果不需要对操作B可见，并且操作A和操作B重排序前后的执行结果一致；</p><p>在这种情况下 JMM 会认为这种重排序并不非法，JMM 允许这种重排序。</p><div class="note simple default no-icon flat"><p><strong>规则二：volatile变量规则</strong><br>对一个 volatile 变量的写操作，Happens-Before 于后续对这个变量的读操作。</p></div><p>也就是说对一个 volatile 变量而言，肯定不会发生可见性问题。</p><p>因为 volatile 写完会被立即刷回主内存中，而读操作发生在这之后，那么每次读取都会读取到最新值。</p><div class="note simple default no-icon flat"><p><strong>规则三：传递规则</strong><br>如果A Happens-Before B，并且B Happens-Before C，则A Happens-Before C。</p></div><p>这个规则比较简单，此处不做展开。</p><div class="note simple default no-icon flat"><p><strong>规则四：锁定规则</strong><br>对一个锁的解锁操作 Happens-Before 于后续对这个锁的加锁操作。</p></div><p>这个很好理解，同一把锁的情况下，肯定是要先解锁才能再次上锁。已经锁了的情况下总不能再锁一次吧。</p><div class="note simple default no-icon flat"><p><strong>规则五：线程启动规则</strong><br>如果线程A调用线程B的 start() 方法来启动线程B，则 start() 操作 Happens-Before 于线程B中的任意操作。</p></div><p>我们也可以这样理解线程启动规则：线程A启动线程B之后，线程B能够看到线程A在启动线程B之前的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在线程A中初始化线程B</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="comment">//此处的变量x的值是多少呢？答案是100</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//线程A在启动线程B之前将共享变量x的值修改为100</span></span><br><span class="line">x = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//启动线程B</span></span><br><span class="line">threadB.start();</span><br></pre></td></tr></table></figure><p>上述代码是在线程A中执行的一个代码片段，根据线程启动规则，线程A启动线程B之后，线程B能够看到线程A在启动线程B之前的操作，在线程B中访问到的x变量的值为100。</p><div class="note simple default no-icon flat"><p><strong>规则六：线程终结规则</strong><br>线程A等待线程B完成（在线程A中调用线程B的 join() 方法实现），当线程B完成后（线程A调用线程B的 join() 方法返回），则线程A能够访问到线程B对共享变量的操作。</p></div><p>我们也可以这样理解线程终结规则：线程A的 join() 方法返回之后，线程A能看到线程B的所有操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//在线程B中，将共享变量x的值修改为100</span></span><br><span class="line">        x = <span class="number">100</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//在线程A中启动线程B</span></span><br><span class="line">    t.start();</span><br><span class="line">    <span class="comment">//在线程A中等待线程B执行完成</span></span><br><span class="line">    t.join();</span><br><span class="line">    <span class="comment">//此处访问共享变量x的值为100</span></span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note simple default no-icon flat"><p><strong>规则七：线程中断规则</strong><br>对线程 interrupt() 方法的调用 Happens-Before 于被中断线程的代码检测到中断事件的发生。</p></div><p>我们也可以这样理解线程中断规则：在 InterruptedException 的 catch 代码块中能够看到调用 interrupt() 方法之前的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在线程A中将x变量的值初始化为0</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//在线程A中初始化线程B</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="comment">//线程B检测自己是否被中断</span></span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted())&#123; &#125;</span><br><span class="line">        <span class="comment">//如果线程B被中断，则此时X的值为100</span></span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//在线程A中启动线程B</span></span><br><span class="line">    threadB.start();</span><br><span class="line">    <span class="comment">//在线程A中将共享变量X的值修改为100</span></span><br><span class="line">    x = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//在线程A中中断线程B</span></span><br><span class="line">    threadB.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note simple default no-icon flat"><p><strong>规则八：对象终结规则</strong><br>一个对象的初始化完成 Happens-Before 于它的 finalize() 方法的开始。</p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">TestThread</span><span class="params">()</span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;构造方法&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对象销毁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">TestThread</span>();</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p><strong>巨人的肩膀：</strong></p><ul><li><a href="https://pdai.tech/md/java/thread/java-thread-x-theorty.html">Java 并发 - 理论基础</a></li><li><a href="https://www.infoq.cn/minibook/java_memory_model">深入理解Java内存模型</a></li><li><a href="https://cloud.tencent.com/developer/article/1734515">何为Happens-Before原则？这次彻底懂了！</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">并发问题产生的三大根源是「原子性」「可见性」「有序性」，引入 Java 内存模型就是为了解决这三个问题。</summary>
    
    
    
    <category term="Java" scheme="https://www.wrp.cool/categories/Java/"/>
    
    <category term="并发" scheme="https://www.wrp.cool/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发：锁分类和介绍</title>
    <link href="https://www.wrp.cool/posts/40896/"/>
    <id>https://www.wrp.cool/posts/40896/</id>
    <published>2022-07-18T12:04:39.000Z</published>
    <updated>2022-10-17T11:16:22.927Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lock-接口"><a href="#Lock-接口" class="headerlink" title="Lock 接口"></a>Lock 接口</h1><p>Lock 并不是用于替代 synchronized 的，而是当使用 synchronized 不合适或者不满足要求的时候，为业务提供高级功能的。</p><div class="note info simple no-icon flat"><p><strong>synchronized 的缺点：</strong></p></div><ul><li><strong>效率低：</strong>锁的释放情况比较少、试图获取锁不能设定超时、不能中断一个正在试图获取锁的线程</li><li><strong>不够灵活：</strong>加锁和释放锁的时机单一、每个锁仅有单一的对象</li><li><strong>无法知道是否成功获取到锁：</strong>如果拿到锁了，我们也不知道，拿不到锁只能阻塞</li></ul><div class="note info simple no-icon flat"><p><strong>Lock 接口中的重要方法：</strong></p></div><ul><li><strong>void lock();</strong><ul><li>获取锁，如果拿不到锁，就阻塞</li><li>不会像 synchronized 一样在异常的时候自动释放锁</li><li>必须在 finally 中释放锁，以保证异常时锁一定被释放</li><li>阻塞不能被中断，一旦陷入死锁，就会永久等待</li></ul></li><li><strong>void lockInterruptibly() throws InterruptedException;</strong><ul><li>与 lock() 一样，但在等待锁的过程中可被中断</li></ul></li><li><strong>boolean tryLock();</strong><ul><li>尝试获取锁，获取成功返回 true，获取失败返回 false</li><li>该方法立即返回，不会阻塞</li></ul></li><li><strong>boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</strong><ul><li>与 tryLock() 相同，但可以设置超时时间，在超时时间阻塞</li></ul></li><li><strong>void unlock();</strong><ul><li>释放锁</li></ul></li></ul><div class="note primary modern"><p><strong>锁的分类思维导图：</strong></p></div><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/Java%E9%94%81%E5%88%86%E7%B1%BB%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.png" alt="Java锁分类思维导图"></p><h1 id="悲观锁-VS-乐观锁"><a href="#悲观锁-VS-乐观锁" class="headerlink" title="悲观锁 VS 乐观锁"></a>悲观锁 VS 乐观锁</h1><p>乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。</p><div class="note primary simple no-icon flat"><p><strong>为什么会出现乐观锁：</strong></p></div><ol><li>悲观锁的阻塞和唤醒带来的性能损耗</li><li>悲观锁可能会出现死锁</li><li>悲观锁可能会出现线程优先级反转，优先级低的线程拿到锁之后不释放，优先级高的线程反而需要等待优先级低的线程释放锁</li></ol><div class="note primary simple no-icon flat"><p>针对同一个数据的并发操作，<strong>悲观锁与乐观锁有以下不同：</strong></p></div><ul><li><strong>悲观锁：</strong>悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。</li><li><strong>乐观锁：</strong>乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。</li></ul><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81.png" alt="乐观锁和悲观锁"></p><ul><li>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。</li><li>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</li></ul><h1 id="公平锁-VS-非公平锁"><a href="#公平锁-VS-非公平锁" class="headerlink" title="公平锁 VS 非公平锁"></a>公平锁 VS 非公平锁</h1><blockquote><p><strong>为什么会出现非公平锁？</strong><br>避免唤醒线程带来的 CPU 开销，以及避免了线程唤醒期间带来的无线程持有锁导致的资源浪费。</p><ul><li><strong>例如：</strong></li><li>线程A 释放锁 线程B 准备获取锁</li><li>CPU 开始唤醒 线程B</li><li>线程C 申请获取锁</li><li>将锁先给 线程C，线程C 执行完之后再将锁还给 线程B</li></ul><p>线程B 可能会稍微等待一会，但是在此期间保证锁一直都有线程使用，没有浪费。并且 CPU 不必唤醒 线程C，节省了一次线程唤醒带来的开销。</p></blockquote><ul><li><p><strong>公平锁：</strong></p><ul><li>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。</li><li>优点：等待锁的线程不会饿死。</li><li>缺点：整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</li></ul></li><li><p><strong>非公平锁：</strong></p><ul><li>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。</li><li>优点：可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。</li><li>缺点：是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</li></ul></li></ul><blockquote><p>假设有一口水井，有管理员看守，管理员有一把锁，只有拿到锁的人才能够打水，打完水要把锁还给管理员。每个过来打水的人都要管理员的允许并拿到锁之后才能去打水，如果前面有人正在打水，那么这个想要打水的人就必须排队。管理员会查看下一个要去打水的人是不是队伍里排最前面的人，如果是的话，才会给你锁让你去打水；如果你不是排第一的人，就必须去队尾排队，这就是公平锁。</p></blockquote><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E5%85%AC%E5%B9%B3%E9%94%81%E6%BC%94%E7%A4%BA.png" alt="公平锁演示"></p><blockquote><p>对于非公平锁，管理员对打水的人没有要求。即使等待队伍里有排队等待的人，但如果在上一个人刚打完水把锁还给管理员而且管理员还没有允许等待队伍里下一个人去打水时，刚好来了一个插队的人，这个插队的人是可以直接从管理员那里拿到锁去打水，不需要排队，原本排队等待的人只能继续等待。</p></blockquote><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E6%BC%94%E7%A4%BA.png" alt="非公平锁演示"></p><h1 id="共享锁-VS-独占锁"><a href="#共享锁-VS-独占锁" class="headerlink" title="共享锁 VS 独占锁"></a>共享锁 VS 独占锁</h1><p>共享锁也成为读锁，指的是该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。顾名思义共享锁在各个线程之间是共享的，只要是读请求的线程都能够同时持有这把锁。</p><p>独享锁也叫排他锁、写锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是独享锁。</p><p>共享锁和独占锁在 Java 中经典的应用就是在 ReentrantReadWriteLock 这个类中了，深入到这个类的源码中发现这个类还实现了公平锁与非公平锁，在非公平锁的情况下就会有一个问题：<strong>想要获取写锁的线程可能会被饿死。</strong></p><blockquote><p><strong>为什么？</strong><br>非公平锁是可以插队的，如果当前有一个线程持有了读锁，一个需要写锁的线程正在排队；此时又来了一个需要读锁的线程，那么该线程可以直接持有读锁；但是哪个需要写锁的线程获取锁的时间就又要等待第二个持有读锁的线程执释放锁才能获取到锁；如果后面源源不断的出现需要读锁的线程，这些线程都能够直接持有读锁，那么哪个需要写锁的线程就会被饿死。长时间得不到执行。</p></blockquote><p>为了保证非公平锁的效率和避免出现写锁线程被饿死的情况，在非公平情况下肯定要对获取读锁做出一些限制。</p><div class="note modern primary flat"><p><strong>ReentrantReadWriteLock 非公平锁源码：</strong></p></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">8159625535654395037L</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">writerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 写锁在任何情况下都可以插队</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">readerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/* 为了避免需要写锁的线程被饿死的情况</span></span><br><span class="line"><span class="comment">         * 仅当等待队列头的线程是等待写锁的线程，阻塞当前读线程</span></span><br><span class="line"><span class="comment">         * 有一定的概率出现这种情况，因为如果队首线程是等待读锁的线程</span></span><br><span class="line"><span class="comment">         * 而等待写锁的线程排在后面一点，当队首的读线程还没拿到锁的情况下</span></span><br><span class="line"><span class="comment">         * 新来的读锁线程还是可以插队的</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="可重入锁-VS-不可重入锁"><a href="#可重入锁-VS-不可重入锁" class="headerlink" title="可重入锁 VS 不可重入锁"></a>可重入锁 VS 不可重入锁</h1><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。下面用示例代码来进行分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法1执行...&quot;</span>);</span><br><span class="line">        doOthers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doOthers</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法2执行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，类中的两个方法都是被内置锁 synchronized 修饰的，doSomething() 方法中调用 doOthers() 方法。因为内置锁是可重入的，所以同一个线程在调用 doOthers() 时可以直接获得当前对象的锁，进入 doOthers() 进行操作。</p><p>如果是一个不可重入锁，那么当前线程在调用 doOthers() 之前需要将执行 doSomething() 时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。</p><div class="note primary simple no-icon flat"><p><strong>可重入举例：</strong></p></div><p>有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E5%8F%AF%E9%87%8D%E5%85%A5%E6%BC%94%E7%A4%BA.png" alt="可重入演示"></p><div class="note primary simple no-icon flat"><p><strong>可重入举例：</strong></p></div><p>管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。</p><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E6%BC%94%E7%A4%BA.png" alt="不可重入演示"></p><h1 id="自旋锁-VS-适应性自旋锁"><a href="#自旋锁-VS-适应性自旋锁" class="headerlink" title="自旋锁 VS 适应性自旋锁"></a>自旋锁 VS 适应性自旋锁</h1><blockquote><p><strong>自旋锁：</strong></p><p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p><p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p><p>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p></blockquote><p><img src="https://wrp-blog-image.oss-cn-beijing.aliyuncs.com/blog-images/%E8%87%AA%E6%97%8B%E9%94%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="自旋锁工作流程图"></p><p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。</p><p>自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">    <span class="type">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>巨人的肩膀：</strong></p><ul><li><a href="https://tech.meituan.com/2018/11/15/java-lock.html">不可不说的Java“锁”事</a></li></ul></blockquote>]]></content>
    
    
    <summary type="html">锁是一种工具，用于控制对共享资源的访问。</summary>
    
    
    
    <category term="Java" scheme="https://www.wrp.cool/categories/Java/"/>
    
    <category term="并发" scheme="https://www.wrp.cool/categories/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
  </entry>
  
</feed>
